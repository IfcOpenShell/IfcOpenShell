/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC2X3_TC1.exp. Do not make modifications  *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifndef USE_IFC4

#include "../ifcparse/Ifc2x3.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"

#include <map>

using namespace Ifc2x3;
using namespace IfcParse;
using namespace IfcWrite;

IfcUtil::IfcBaseClass* Ifc2x3::SchemaEntity(IfcEntityInstanceData* e) {
    switch(e->type()) {
        case Type::IfcAbsorbedDoseMeasure: return new IfcAbsorbedDoseMeasure(e); break;
        case Type::IfcAccelerationMeasure: return new IfcAccelerationMeasure(e); break;
        case Type::IfcAmountOfSubstanceMeasure: return new IfcAmountOfSubstanceMeasure(e); break;
        case Type::IfcAngularVelocityMeasure: return new IfcAngularVelocityMeasure(e); break;
        case Type::IfcAreaMeasure: return new IfcAreaMeasure(e); break;
        case Type::IfcBoolean: return new IfcBoolean(e); break;
        case Type::IfcBoxAlignment: return new IfcBoxAlignment(e); break;
        case Type::IfcComplexNumber: return new IfcComplexNumber(e); break;
        case Type::IfcCompoundPlaneAngleMeasure: return new IfcCompoundPlaneAngleMeasure(e); break;
        case Type::IfcContextDependentMeasure: return new IfcContextDependentMeasure(e); break;
        case Type::IfcCountMeasure: return new IfcCountMeasure(e); break;
        case Type::IfcCurvatureMeasure: return new IfcCurvatureMeasure(e); break;
        case Type::IfcDayInMonthNumber: return new IfcDayInMonthNumber(e); break;
        case Type::IfcDaylightSavingHour: return new IfcDaylightSavingHour(e); break;
        case Type::IfcDescriptiveMeasure: return new IfcDescriptiveMeasure(e); break;
        case Type::IfcDimensionCount: return new IfcDimensionCount(e); break;
        case Type::IfcDoseEquivalentMeasure: return new IfcDoseEquivalentMeasure(e); break;
        case Type::IfcDynamicViscosityMeasure: return new IfcDynamicViscosityMeasure(e); break;
        case Type::IfcElectricCapacitanceMeasure: return new IfcElectricCapacitanceMeasure(e); break;
        case Type::IfcElectricChargeMeasure: return new IfcElectricChargeMeasure(e); break;
        case Type::IfcElectricConductanceMeasure: return new IfcElectricConductanceMeasure(e); break;
        case Type::IfcElectricCurrentMeasure: return new IfcElectricCurrentMeasure(e); break;
        case Type::IfcElectricResistanceMeasure: return new IfcElectricResistanceMeasure(e); break;
        case Type::IfcElectricVoltageMeasure: return new IfcElectricVoltageMeasure(e); break;
        case Type::IfcEnergyMeasure: return new IfcEnergyMeasure(e); break;
        case Type::IfcFontStyle: return new IfcFontStyle(e); break;
        case Type::IfcFontVariant: return new IfcFontVariant(e); break;
        case Type::IfcFontWeight: return new IfcFontWeight(e); break;
        case Type::IfcForceMeasure: return new IfcForceMeasure(e); break;
        case Type::IfcFrequencyMeasure: return new IfcFrequencyMeasure(e); break;
        case Type::IfcGloballyUniqueId: return new IfcGloballyUniqueId(e); break;
        case Type::IfcHeatFluxDensityMeasure: return new IfcHeatFluxDensityMeasure(e); break;
        case Type::IfcHeatingValueMeasure: return new IfcHeatingValueMeasure(e); break;
        case Type::IfcHourInDay: return new IfcHourInDay(e); break;
        case Type::IfcIdentifier: return new IfcIdentifier(e); break;
        case Type::IfcIlluminanceMeasure: return new IfcIlluminanceMeasure(e); break;
        case Type::IfcInductanceMeasure: return new IfcInductanceMeasure(e); break;
        case Type::IfcInteger: return new IfcInteger(e); break;
        case Type::IfcIntegerCountRateMeasure: return new IfcIntegerCountRateMeasure(e); break;
        case Type::IfcIonConcentrationMeasure: return new IfcIonConcentrationMeasure(e); break;
        case Type::IfcIsothermalMoistureCapacityMeasure: return new IfcIsothermalMoistureCapacityMeasure(e); break;
        case Type::IfcKinematicViscosityMeasure: return new IfcKinematicViscosityMeasure(e); break;
        case Type::IfcLabel: return new IfcLabel(e); break;
        case Type::IfcLengthMeasure: return new IfcLengthMeasure(e); break;
        case Type::IfcLinearForceMeasure: return new IfcLinearForceMeasure(e); break;
        case Type::IfcLinearMomentMeasure: return new IfcLinearMomentMeasure(e); break;
        case Type::IfcLinearStiffnessMeasure: return new IfcLinearStiffnessMeasure(e); break;
        case Type::IfcLinearVelocityMeasure: return new IfcLinearVelocityMeasure(e); break;
        case Type::IfcLogical: return new IfcLogical(e); break;
        case Type::IfcLuminousFluxMeasure: return new IfcLuminousFluxMeasure(e); break;
        case Type::IfcLuminousIntensityDistributionMeasure: return new IfcLuminousIntensityDistributionMeasure(e); break;
        case Type::IfcLuminousIntensityMeasure: return new IfcLuminousIntensityMeasure(e); break;
        case Type::IfcMagneticFluxDensityMeasure: return new IfcMagneticFluxDensityMeasure(e); break;
        case Type::IfcMagneticFluxMeasure: return new IfcMagneticFluxMeasure(e); break;
        case Type::IfcMassDensityMeasure: return new IfcMassDensityMeasure(e); break;
        case Type::IfcMassFlowRateMeasure: return new IfcMassFlowRateMeasure(e); break;
        case Type::IfcMassMeasure: return new IfcMassMeasure(e); break;
        case Type::IfcMassPerLengthMeasure: return new IfcMassPerLengthMeasure(e); break;
        case Type::IfcMinuteInHour: return new IfcMinuteInHour(e); break;
        case Type::IfcModulusOfElasticityMeasure: return new IfcModulusOfElasticityMeasure(e); break;
        case Type::IfcModulusOfLinearSubgradeReactionMeasure: return new IfcModulusOfLinearSubgradeReactionMeasure(e); break;
        case Type::IfcModulusOfRotationalSubgradeReactionMeasure: return new IfcModulusOfRotationalSubgradeReactionMeasure(e); break;
        case Type::IfcModulusOfSubgradeReactionMeasure: return new IfcModulusOfSubgradeReactionMeasure(e); break;
        case Type::IfcMoistureDiffusivityMeasure: return new IfcMoistureDiffusivityMeasure(e); break;
        case Type::IfcMolecularWeightMeasure: return new IfcMolecularWeightMeasure(e); break;
        case Type::IfcMomentOfInertiaMeasure: return new IfcMomentOfInertiaMeasure(e); break;
        case Type::IfcMonetaryMeasure: return new IfcMonetaryMeasure(e); break;
        case Type::IfcMonthInYearNumber: return new IfcMonthInYearNumber(e); break;
        case Type::IfcNormalisedRatioMeasure: return new IfcNormalisedRatioMeasure(e); break;
        case Type::IfcNumericMeasure: return new IfcNumericMeasure(e); break;
        case Type::IfcPHMeasure: return new IfcPHMeasure(e); break;
        case Type::IfcParameterValue: return new IfcParameterValue(e); break;
        case Type::IfcPlanarForceMeasure: return new IfcPlanarForceMeasure(e); break;
        case Type::IfcPlaneAngleMeasure: return new IfcPlaneAngleMeasure(e); break;
        case Type::IfcPositiveLengthMeasure: return new IfcPositiveLengthMeasure(e); break;
        case Type::IfcPositivePlaneAngleMeasure: return new IfcPositivePlaneAngleMeasure(e); break;
        case Type::IfcPositiveRatioMeasure: return new IfcPositiveRatioMeasure(e); break;
        case Type::IfcPowerMeasure: return new IfcPowerMeasure(e); break;
        case Type::IfcPresentableText: return new IfcPresentableText(e); break;
        case Type::IfcPressureMeasure: return new IfcPressureMeasure(e); break;
        case Type::IfcRadioActivityMeasure: return new IfcRadioActivityMeasure(e); break;
        case Type::IfcRatioMeasure: return new IfcRatioMeasure(e); break;
        case Type::IfcReal: return new IfcReal(e); break;
        case Type::IfcRotationalFrequencyMeasure: return new IfcRotationalFrequencyMeasure(e); break;
        case Type::IfcRotationalMassMeasure: return new IfcRotationalMassMeasure(e); break;
        case Type::IfcRotationalStiffnessMeasure: return new IfcRotationalStiffnessMeasure(e); break;
        case Type::IfcSecondInMinute: return new IfcSecondInMinute(e); break;
        case Type::IfcSectionModulusMeasure: return new IfcSectionModulusMeasure(e); break;
        case Type::IfcSectionalAreaIntegralMeasure: return new IfcSectionalAreaIntegralMeasure(e); break;
        case Type::IfcShearModulusMeasure: return new IfcShearModulusMeasure(e); break;
        case Type::IfcSolidAngleMeasure: return new IfcSolidAngleMeasure(e); break;
        case Type::IfcSoundPowerMeasure: return new IfcSoundPowerMeasure(e); break;
        case Type::IfcSoundPressureMeasure: return new IfcSoundPressureMeasure(e); break;
        case Type::IfcSpecificHeatCapacityMeasure: return new IfcSpecificHeatCapacityMeasure(e); break;
        case Type::IfcSpecularExponent: return new IfcSpecularExponent(e); break;
        case Type::IfcSpecularRoughness: return new IfcSpecularRoughness(e); break;
        case Type::IfcTemperatureGradientMeasure: return new IfcTemperatureGradientMeasure(e); break;
        case Type::IfcText: return new IfcText(e); break;
        case Type::IfcTextAlignment: return new IfcTextAlignment(e); break;
        case Type::IfcTextDecoration: return new IfcTextDecoration(e); break;
        case Type::IfcTextFontName: return new IfcTextFontName(e); break;
        case Type::IfcTextTransformation: return new IfcTextTransformation(e); break;
        case Type::IfcThermalAdmittanceMeasure: return new IfcThermalAdmittanceMeasure(e); break;
        case Type::IfcThermalConductivityMeasure: return new IfcThermalConductivityMeasure(e); break;
        case Type::IfcThermalExpansionCoefficientMeasure: return new IfcThermalExpansionCoefficientMeasure(e); break;
        case Type::IfcThermalResistanceMeasure: return new IfcThermalResistanceMeasure(e); break;
        case Type::IfcThermalTransmittanceMeasure: return new IfcThermalTransmittanceMeasure(e); break;
        case Type::IfcThermodynamicTemperatureMeasure: return new IfcThermodynamicTemperatureMeasure(e); break;
        case Type::IfcTimeMeasure: return new IfcTimeMeasure(e); break;
        case Type::IfcTimeStamp: return new IfcTimeStamp(e); break;
        case Type::IfcTorqueMeasure: return new IfcTorqueMeasure(e); break;
        case Type::IfcVaporPermeabilityMeasure: return new IfcVaporPermeabilityMeasure(e); break;
        case Type::IfcVolumeMeasure: return new IfcVolumeMeasure(e); break;
        case Type::IfcVolumetricFlowRateMeasure: return new IfcVolumetricFlowRateMeasure(e); break;
        case Type::IfcWarpingConstantMeasure: return new IfcWarpingConstantMeasure(e); break;
        case Type::IfcWarpingMomentMeasure: return new IfcWarpingMomentMeasure(e); break;
        case Type::IfcYearNumber: return new IfcYearNumber(e); break;
        case Type::Ifc2DCompositeCurve: return new Ifc2DCompositeCurve(e); break;
        case Type::IfcActionRequest: return new IfcActionRequest(e); break;
        case Type::IfcActor: return new IfcActor(e); break;
        case Type::IfcActorRole: return new IfcActorRole(e); break;
        case Type::IfcActuatorType: return new IfcActuatorType(e); break;
        case Type::IfcAddress: return new IfcAddress(e); break;
        case Type::IfcAirTerminalBoxType: return new IfcAirTerminalBoxType(e); break;
        case Type::IfcAirTerminalType: return new IfcAirTerminalType(e); break;
        case Type::IfcAirToAirHeatRecoveryType: return new IfcAirToAirHeatRecoveryType(e); break;
        case Type::IfcAlarmType: return new IfcAlarmType(e); break;
        case Type::IfcAngularDimension: return new IfcAngularDimension(e); break;
        case Type::IfcAnnotation: return new IfcAnnotation(e); break;
        case Type::IfcAnnotationCurveOccurrence: return new IfcAnnotationCurveOccurrence(e); break;
        case Type::IfcAnnotationFillArea: return new IfcAnnotationFillArea(e); break;
        case Type::IfcAnnotationFillAreaOccurrence: return new IfcAnnotationFillAreaOccurrence(e); break;
        case Type::IfcAnnotationOccurrence: return new IfcAnnotationOccurrence(e); break;
        case Type::IfcAnnotationSurface: return new IfcAnnotationSurface(e); break;
        case Type::IfcAnnotationSurfaceOccurrence: return new IfcAnnotationSurfaceOccurrence(e); break;
        case Type::IfcAnnotationSymbolOccurrence: return new IfcAnnotationSymbolOccurrence(e); break;
        case Type::IfcAnnotationTextOccurrence: return new IfcAnnotationTextOccurrence(e); break;
        case Type::IfcApplication: return new IfcApplication(e); break;
        case Type::IfcAppliedValue: return new IfcAppliedValue(e); break;
        case Type::IfcAppliedValueRelationship: return new IfcAppliedValueRelationship(e); break;
        case Type::IfcApproval: return new IfcApproval(e); break;
        case Type::IfcApprovalActorRelationship: return new IfcApprovalActorRelationship(e); break;
        case Type::IfcApprovalPropertyRelationship: return new IfcApprovalPropertyRelationship(e); break;
        case Type::IfcApprovalRelationship: return new IfcApprovalRelationship(e); break;
        case Type::IfcArbitraryClosedProfileDef: return new IfcArbitraryClosedProfileDef(e); break;
        case Type::IfcArbitraryOpenProfileDef: return new IfcArbitraryOpenProfileDef(e); break;
        case Type::IfcArbitraryProfileDefWithVoids: return new IfcArbitraryProfileDefWithVoids(e); break;
        case Type::IfcAsset: return new IfcAsset(e); break;
        case Type::IfcAsymmetricIShapeProfileDef: return new IfcAsymmetricIShapeProfileDef(e); break;
        case Type::IfcAxis1Placement: return new IfcAxis1Placement(e); break;
        case Type::IfcAxis2Placement2D: return new IfcAxis2Placement2D(e); break;
        case Type::IfcAxis2Placement3D: return new IfcAxis2Placement3D(e); break;
        case Type::IfcBSplineCurve: return new IfcBSplineCurve(e); break;
        case Type::IfcBeam: return new IfcBeam(e); break;
        case Type::IfcBeamType: return new IfcBeamType(e); break;
        case Type::IfcBezierCurve: return new IfcBezierCurve(e); break;
        case Type::IfcBlobTexture: return new IfcBlobTexture(e); break;
        case Type::IfcBlock: return new IfcBlock(e); break;
        case Type::IfcBoilerType: return new IfcBoilerType(e); break;
        case Type::IfcBooleanClippingResult: return new IfcBooleanClippingResult(e); break;
        case Type::IfcBooleanResult: return new IfcBooleanResult(e); break;
        case Type::IfcBoundaryCondition: return new IfcBoundaryCondition(e); break;
        case Type::IfcBoundaryEdgeCondition: return new IfcBoundaryEdgeCondition(e); break;
        case Type::IfcBoundaryFaceCondition: return new IfcBoundaryFaceCondition(e); break;
        case Type::IfcBoundaryNodeCondition: return new IfcBoundaryNodeCondition(e); break;
        case Type::IfcBoundaryNodeConditionWarping: return new IfcBoundaryNodeConditionWarping(e); break;
        case Type::IfcBoundedCurve: return new IfcBoundedCurve(e); break;
        case Type::IfcBoundedSurface: return new IfcBoundedSurface(e); break;
        case Type::IfcBoundingBox: return new IfcBoundingBox(e); break;
        case Type::IfcBoxedHalfSpace: return new IfcBoxedHalfSpace(e); break;
        case Type::IfcBuilding: return new IfcBuilding(e); break;
        case Type::IfcBuildingElement: return new IfcBuildingElement(e); break;
        case Type::IfcBuildingElementComponent: return new IfcBuildingElementComponent(e); break;
        case Type::IfcBuildingElementPart: return new IfcBuildingElementPart(e); break;
        case Type::IfcBuildingElementProxy: return new IfcBuildingElementProxy(e); break;
        case Type::IfcBuildingElementProxyType: return new IfcBuildingElementProxyType(e); break;
        case Type::IfcBuildingElementType: return new IfcBuildingElementType(e); break;
        case Type::IfcBuildingStorey: return new IfcBuildingStorey(e); break;
        case Type::IfcCShapeProfileDef: return new IfcCShapeProfileDef(e); break;
        case Type::IfcCableCarrierFittingType: return new IfcCableCarrierFittingType(e); break;
        case Type::IfcCableCarrierSegmentType: return new IfcCableCarrierSegmentType(e); break;
        case Type::IfcCableSegmentType: return new IfcCableSegmentType(e); break;
        case Type::IfcCalendarDate: return new IfcCalendarDate(e); break;
        case Type::IfcCartesianPoint: return new IfcCartesianPoint(e); break;
        case Type::IfcCartesianTransformationOperator: return new IfcCartesianTransformationOperator(e); break;
        case Type::IfcCartesianTransformationOperator2D: return new IfcCartesianTransformationOperator2D(e); break;
        case Type::IfcCartesianTransformationOperator2DnonUniform: return new IfcCartesianTransformationOperator2DnonUniform(e); break;
        case Type::IfcCartesianTransformationOperator3D: return new IfcCartesianTransformationOperator3D(e); break;
        case Type::IfcCartesianTransformationOperator3DnonUniform: return new IfcCartesianTransformationOperator3DnonUniform(e); break;
        case Type::IfcCenterLineProfileDef: return new IfcCenterLineProfileDef(e); break;
        case Type::IfcChamferEdgeFeature: return new IfcChamferEdgeFeature(e); break;
        case Type::IfcChillerType: return new IfcChillerType(e); break;
        case Type::IfcCircle: return new IfcCircle(e); break;
        case Type::IfcCircleHollowProfileDef: return new IfcCircleHollowProfileDef(e); break;
        case Type::IfcCircleProfileDef: return new IfcCircleProfileDef(e); break;
        case Type::IfcClassification: return new IfcClassification(e); break;
        case Type::IfcClassificationItem: return new IfcClassificationItem(e); break;
        case Type::IfcClassificationItemRelationship: return new IfcClassificationItemRelationship(e); break;
        case Type::IfcClassificationNotation: return new IfcClassificationNotation(e); break;
        case Type::IfcClassificationNotationFacet: return new IfcClassificationNotationFacet(e); break;
        case Type::IfcClassificationReference: return new IfcClassificationReference(e); break;
        case Type::IfcClosedShell: return new IfcClosedShell(e); break;
        case Type::IfcCoilType: return new IfcCoilType(e); break;
        case Type::IfcColourRgb: return new IfcColourRgb(e); break;
        case Type::IfcColourSpecification: return new IfcColourSpecification(e); break;
        case Type::IfcColumn: return new IfcColumn(e); break;
        case Type::IfcColumnType: return new IfcColumnType(e); break;
        case Type::IfcComplexProperty: return new IfcComplexProperty(e); break;
        case Type::IfcCompositeCurve: return new IfcCompositeCurve(e); break;
        case Type::IfcCompositeCurveSegment: return new IfcCompositeCurveSegment(e); break;
        case Type::IfcCompositeProfileDef: return new IfcCompositeProfileDef(e); break;
        case Type::IfcCompressorType: return new IfcCompressorType(e); break;
        case Type::IfcCondenserType: return new IfcCondenserType(e); break;
        case Type::IfcCondition: return new IfcCondition(e); break;
        case Type::IfcConditionCriterion: return new IfcConditionCriterion(e); break;
        case Type::IfcConic: return new IfcConic(e); break;
        case Type::IfcConnectedFaceSet: return new IfcConnectedFaceSet(e); break;
        case Type::IfcConnectionCurveGeometry: return new IfcConnectionCurveGeometry(e); break;
        case Type::IfcConnectionGeometry: return new IfcConnectionGeometry(e); break;
        case Type::IfcConnectionPointEccentricity: return new IfcConnectionPointEccentricity(e); break;
        case Type::IfcConnectionPointGeometry: return new IfcConnectionPointGeometry(e); break;
        case Type::IfcConnectionPortGeometry: return new IfcConnectionPortGeometry(e); break;
        case Type::IfcConnectionSurfaceGeometry: return new IfcConnectionSurfaceGeometry(e); break;
        case Type::IfcConstraint: return new IfcConstraint(e); break;
        case Type::IfcConstraintAggregationRelationship: return new IfcConstraintAggregationRelationship(e); break;
        case Type::IfcConstraintClassificationRelationship: return new IfcConstraintClassificationRelationship(e); break;
        case Type::IfcConstraintRelationship: return new IfcConstraintRelationship(e); break;
        case Type::IfcConstructionEquipmentResource: return new IfcConstructionEquipmentResource(e); break;
        case Type::IfcConstructionMaterialResource: return new IfcConstructionMaterialResource(e); break;
        case Type::IfcConstructionProductResource: return new IfcConstructionProductResource(e); break;
        case Type::IfcConstructionResource: return new IfcConstructionResource(e); break;
        case Type::IfcContextDependentUnit: return new IfcContextDependentUnit(e); break;
        case Type::IfcControl: return new IfcControl(e); break;
        case Type::IfcControllerType: return new IfcControllerType(e); break;
        case Type::IfcConversionBasedUnit: return new IfcConversionBasedUnit(e); break;
        case Type::IfcCooledBeamType: return new IfcCooledBeamType(e); break;
        case Type::IfcCoolingTowerType: return new IfcCoolingTowerType(e); break;
        case Type::IfcCoordinatedUniversalTimeOffset: return new IfcCoordinatedUniversalTimeOffset(e); break;
        case Type::IfcCostItem: return new IfcCostItem(e); break;
        case Type::IfcCostSchedule: return new IfcCostSchedule(e); break;
        case Type::IfcCostValue: return new IfcCostValue(e); break;
        case Type::IfcCovering: return new IfcCovering(e); break;
        case Type::IfcCoveringType: return new IfcCoveringType(e); break;
        case Type::IfcCraneRailAShapeProfileDef: return new IfcCraneRailAShapeProfileDef(e); break;
        case Type::IfcCraneRailFShapeProfileDef: return new IfcCraneRailFShapeProfileDef(e); break;
        case Type::IfcCrewResource: return new IfcCrewResource(e); break;
        case Type::IfcCsgPrimitive3D: return new IfcCsgPrimitive3D(e); break;
        case Type::IfcCsgSolid: return new IfcCsgSolid(e); break;
        case Type::IfcCurrencyRelationship: return new IfcCurrencyRelationship(e); break;
        case Type::IfcCurtainWall: return new IfcCurtainWall(e); break;
        case Type::IfcCurtainWallType: return new IfcCurtainWallType(e); break;
        case Type::IfcCurve: return new IfcCurve(e); break;
        case Type::IfcCurveBoundedPlane: return new IfcCurveBoundedPlane(e); break;
        case Type::IfcCurveStyle: return new IfcCurveStyle(e); break;
        case Type::IfcCurveStyleFont: return new IfcCurveStyleFont(e); break;
        case Type::IfcCurveStyleFontAndScaling: return new IfcCurveStyleFontAndScaling(e); break;
        case Type::IfcCurveStyleFontPattern: return new IfcCurveStyleFontPattern(e); break;
        case Type::IfcDamperType: return new IfcDamperType(e); break;
        case Type::IfcDateAndTime: return new IfcDateAndTime(e); break;
        case Type::IfcDefinedSymbol: return new IfcDefinedSymbol(e); break;
        case Type::IfcDerivedProfileDef: return new IfcDerivedProfileDef(e); break;
        case Type::IfcDerivedUnit: return new IfcDerivedUnit(e); break;
        case Type::IfcDerivedUnitElement: return new IfcDerivedUnitElement(e); break;
        case Type::IfcDiameterDimension: return new IfcDiameterDimension(e); break;
        case Type::IfcDimensionCalloutRelationship: return new IfcDimensionCalloutRelationship(e); break;
        case Type::IfcDimensionCurve: return new IfcDimensionCurve(e); break;
        case Type::IfcDimensionCurveDirectedCallout: return new IfcDimensionCurveDirectedCallout(e); break;
        case Type::IfcDimensionCurveTerminator: return new IfcDimensionCurveTerminator(e); break;
        case Type::IfcDimensionPair: return new IfcDimensionPair(e); break;
        case Type::IfcDimensionalExponents: return new IfcDimensionalExponents(e); break;
        case Type::IfcDirection: return new IfcDirection(e); break;
        case Type::IfcDiscreteAccessory: return new IfcDiscreteAccessory(e); break;
        case Type::IfcDiscreteAccessoryType: return new IfcDiscreteAccessoryType(e); break;
        case Type::IfcDistributionChamberElement: return new IfcDistributionChamberElement(e); break;
        case Type::IfcDistributionChamberElementType: return new IfcDistributionChamberElementType(e); break;
        case Type::IfcDistributionControlElement: return new IfcDistributionControlElement(e); break;
        case Type::IfcDistributionControlElementType: return new IfcDistributionControlElementType(e); break;
        case Type::IfcDistributionElement: return new IfcDistributionElement(e); break;
        case Type::IfcDistributionElementType: return new IfcDistributionElementType(e); break;
        case Type::IfcDistributionFlowElement: return new IfcDistributionFlowElement(e); break;
        case Type::IfcDistributionFlowElementType: return new IfcDistributionFlowElementType(e); break;
        case Type::IfcDistributionPort: return new IfcDistributionPort(e); break;
        case Type::IfcDocumentElectronicFormat: return new IfcDocumentElectronicFormat(e); break;
        case Type::IfcDocumentInformation: return new IfcDocumentInformation(e); break;
        case Type::IfcDocumentInformationRelationship: return new IfcDocumentInformationRelationship(e); break;
        case Type::IfcDocumentReference: return new IfcDocumentReference(e); break;
        case Type::IfcDoor: return new IfcDoor(e); break;
        case Type::IfcDoorLiningProperties: return new IfcDoorLiningProperties(e); break;
        case Type::IfcDoorPanelProperties: return new IfcDoorPanelProperties(e); break;
        case Type::IfcDoorStyle: return new IfcDoorStyle(e); break;
        case Type::IfcDraughtingCallout: return new IfcDraughtingCallout(e); break;
        case Type::IfcDraughtingCalloutRelationship: return new IfcDraughtingCalloutRelationship(e); break;
        case Type::IfcDraughtingPreDefinedColour: return new IfcDraughtingPreDefinedColour(e); break;
        case Type::IfcDraughtingPreDefinedCurveFont: return new IfcDraughtingPreDefinedCurveFont(e); break;
        case Type::IfcDraughtingPreDefinedTextFont: return new IfcDraughtingPreDefinedTextFont(e); break;
        case Type::IfcDuctFittingType: return new IfcDuctFittingType(e); break;
        case Type::IfcDuctSegmentType: return new IfcDuctSegmentType(e); break;
        case Type::IfcDuctSilencerType: return new IfcDuctSilencerType(e); break;
        case Type::IfcEdge: return new IfcEdge(e); break;
        case Type::IfcEdgeCurve: return new IfcEdgeCurve(e); break;
        case Type::IfcEdgeFeature: return new IfcEdgeFeature(e); break;
        case Type::IfcEdgeLoop: return new IfcEdgeLoop(e); break;
        case Type::IfcElectricApplianceType: return new IfcElectricApplianceType(e); break;
        case Type::IfcElectricDistributionPoint: return new IfcElectricDistributionPoint(e); break;
        case Type::IfcElectricFlowStorageDeviceType: return new IfcElectricFlowStorageDeviceType(e); break;
        case Type::IfcElectricGeneratorType: return new IfcElectricGeneratorType(e); break;
        case Type::IfcElectricHeaterType: return new IfcElectricHeaterType(e); break;
        case Type::IfcElectricMotorType: return new IfcElectricMotorType(e); break;
        case Type::IfcElectricTimeControlType: return new IfcElectricTimeControlType(e); break;
        case Type::IfcElectricalBaseProperties: return new IfcElectricalBaseProperties(e); break;
        case Type::IfcElectricalCircuit: return new IfcElectricalCircuit(e); break;
        case Type::IfcElectricalElement: return new IfcElectricalElement(e); break;
        case Type::IfcElement: return new IfcElement(e); break;
        case Type::IfcElementAssembly: return new IfcElementAssembly(e); break;
        case Type::IfcElementComponent: return new IfcElementComponent(e); break;
        case Type::IfcElementComponentType: return new IfcElementComponentType(e); break;
        case Type::IfcElementQuantity: return new IfcElementQuantity(e); break;
        case Type::IfcElementType: return new IfcElementType(e); break;
        case Type::IfcElementarySurface: return new IfcElementarySurface(e); break;
        case Type::IfcEllipse: return new IfcEllipse(e); break;
        case Type::IfcEllipseProfileDef: return new IfcEllipseProfileDef(e); break;
        case Type::IfcEnergyConversionDevice: return new IfcEnergyConversionDevice(e); break;
        case Type::IfcEnergyConversionDeviceType: return new IfcEnergyConversionDeviceType(e); break;
        case Type::IfcEnergyProperties: return new IfcEnergyProperties(e); break;
        case Type::IfcEnvironmentalImpactValue: return new IfcEnvironmentalImpactValue(e); break;
        case Type::IfcEquipmentElement: return new IfcEquipmentElement(e); break;
        case Type::IfcEquipmentStandard: return new IfcEquipmentStandard(e); break;
        case Type::IfcEvaporativeCoolerType: return new IfcEvaporativeCoolerType(e); break;
        case Type::IfcEvaporatorType: return new IfcEvaporatorType(e); break;
        case Type::IfcExtendedMaterialProperties: return new IfcExtendedMaterialProperties(e); break;
        case Type::IfcExternalReference: return new IfcExternalReference(e); break;
        case Type::IfcExternallyDefinedHatchStyle: return new IfcExternallyDefinedHatchStyle(e); break;
        case Type::IfcExternallyDefinedSurfaceStyle: return new IfcExternallyDefinedSurfaceStyle(e); break;
        case Type::IfcExternallyDefinedSymbol: return new IfcExternallyDefinedSymbol(e); break;
        case Type::IfcExternallyDefinedTextFont: return new IfcExternallyDefinedTextFont(e); break;
        case Type::IfcExtrudedAreaSolid: return new IfcExtrudedAreaSolid(e); break;
        case Type::IfcFace: return new IfcFace(e); break;
        case Type::IfcFaceBasedSurfaceModel: return new IfcFaceBasedSurfaceModel(e); break;
        case Type::IfcFaceBound: return new IfcFaceBound(e); break;
        case Type::IfcFaceOuterBound: return new IfcFaceOuterBound(e); break;
        case Type::IfcFaceSurface: return new IfcFaceSurface(e); break;
        case Type::IfcFacetedBrep: return new IfcFacetedBrep(e); break;
        case Type::IfcFacetedBrepWithVoids: return new IfcFacetedBrepWithVoids(e); break;
        case Type::IfcFailureConnectionCondition: return new IfcFailureConnectionCondition(e); break;
        case Type::IfcFanType: return new IfcFanType(e); break;
        case Type::IfcFastener: return new IfcFastener(e); break;
        case Type::IfcFastenerType: return new IfcFastenerType(e); break;
        case Type::IfcFeatureElement: return new IfcFeatureElement(e); break;
        case Type::IfcFeatureElementAddition: return new IfcFeatureElementAddition(e); break;
        case Type::IfcFeatureElementSubtraction: return new IfcFeatureElementSubtraction(e); break;
        case Type::IfcFillAreaStyle: return new IfcFillAreaStyle(e); break;
        case Type::IfcFillAreaStyleHatching: return new IfcFillAreaStyleHatching(e); break;
        case Type::IfcFillAreaStyleTileSymbolWithStyle: return new IfcFillAreaStyleTileSymbolWithStyle(e); break;
        case Type::IfcFillAreaStyleTiles: return new IfcFillAreaStyleTiles(e); break;
        case Type::IfcFilterType: return new IfcFilterType(e); break;
        case Type::IfcFireSuppressionTerminalType: return new IfcFireSuppressionTerminalType(e); break;
        case Type::IfcFlowController: return new IfcFlowController(e); break;
        case Type::IfcFlowControllerType: return new IfcFlowControllerType(e); break;
        case Type::IfcFlowFitting: return new IfcFlowFitting(e); break;
        case Type::IfcFlowFittingType: return new IfcFlowFittingType(e); break;
        case Type::IfcFlowInstrumentType: return new IfcFlowInstrumentType(e); break;
        case Type::IfcFlowMeterType: return new IfcFlowMeterType(e); break;
        case Type::IfcFlowMovingDevice: return new IfcFlowMovingDevice(e); break;
        case Type::IfcFlowMovingDeviceType: return new IfcFlowMovingDeviceType(e); break;
        case Type::IfcFlowSegment: return new IfcFlowSegment(e); break;
        case Type::IfcFlowSegmentType: return new IfcFlowSegmentType(e); break;
        case Type::IfcFlowStorageDevice: return new IfcFlowStorageDevice(e); break;
        case Type::IfcFlowStorageDeviceType: return new IfcFlowStorageDeviceType(e); break;
        case Type::IfcFlowTerminal: return new IfcFlowTerminal(e); break;
        case Type::IfcFlowTerminalType: return new IfcFlowTerminalType(e); break;
        case Type::IfcFlowTreatmentDevice: return new IfcFlowTreatmentDevice(e); break;
        case Type::IfcFlowTreatmentDeviceType: return new IfcFlowTreatmentDeviceType(e); break;
        case Type::IfcFluidFlowProperties: return new IfcFluidFlowProperties(e); break;
        case Type::IfcFooting: return new IfcFooting(e); break;
        case Type::IfcFuelProperties: return new IfcFuelProperties(e); break;
        case Type::IfcFurnishingElement: return new IfcFurnishingElement(e); break;
        case Type::IfcFurnishingElementType: return new IfcFurnishingElementType(e); break;
        case Type::IfcFurnitureStandard: return new IfcFurnitureStandard(e); break;
        case Type::IfcFurnitureType: return new IfcFurnitureType(e); break;
        case Type::IfcGasTerminalType: return new IfcGasTerminalType(e); break;
        case Type::IfcGeneralMaterialProperties: return new IfcGeneralMaterialProperties(e); break;
        case Type::IfcGeneralProfileProperties: return new IfcGeneralProfileProperties(e); break;
        case Type::IfcGeometricCurveSet: return new IfcGeometricCurveSet(e); break;
        case Type::IfcGeometricRepresentationContext: return new IfcGeometricRepresentationContext(e); break;
        case Type::IfcGeometricRepresentationItem: return new IfcGeometricRepresentationItem(e); break;
        case Type::IfcGeometricRepresentationSubContext: return new IfcGeometricRepresentationSubContext(e); break;
        case Type::IfcGeometricSet: return new IfcGeometricSet(e); break;
        case Type::IfcGrid: return new IfcGrid(e); break;
        case Type::IfcGridAxis: return new IfcGridAxis(e); break;
        case Type::IfcGridPlacement: return new IfcGridPlacement(e); break;
        case Type::IfcGroup: return new IfcGroup(e); break;
        case Type::IfcHalfSpaceSolid: return new IfcHalfSpaceSolid(e); break;
        case Type::IfcHeatExchangerType: return new IfcHeatExchangerType(e); break;
        case Type::IfcHumidifierType: return new IfcHumidifierType(e); break;
        case Type::IfcHygroscopicMaterialProperties: return new IfcHygroscopicMaterialProperties(e); break;
        case Type::IfcIShapeProfileDef: return new IfcIShapeProfileDef(e); break;
        case Type::IfcImageTexture: return new IfcImageTexture(e); break;
        case Type::IfcInventory: return new IfcInventory(e); break;
        case Type::IfcIrregularTimeSeries: return new IfcIrregularTimeSeries(e); break;
        case Type::IfcIrregularTimeSeriesValue: return new IfcIrregularTimeSeriesValue(e); break;
        case Type::IfcJunctionBoxType: return new IfcJunctionBoxType(e); break;
        case Type::IfcLShapeProfileDef: return new IfcLShapeProfileDef(e); break;
        case Type::IfcLaborResource: return new IfcLaborResource(e); break;
        case Type::IfcLampType: return new IfcLampType(e); break;
        case Type::IfcLibraryInformation: return new IfcLibraryInformation(e); break;
        case Type::IfcLibraryReference: return new IfcLibraryReference(e); break;
        case Type::IfcLightDistributionData: return new IfcLightDistributionData(e); break;
        case Type::IfcLightFixtureType: return new IfcLightFixtureType(e); break;
        case Type::IfcLightIntensityDistribution: return new IfcLightIntensityDistribution(e); break;
        case Type::IfcLightSource: return new IfcLightSource(e); break;
        case Type::IfcLightSourceAmbient: return new IfcLightSourceAmbient(e); break;
        case Type::IfcLightSourceDirectional: return new IfcLightSourceDirectional(e); break;
        case Type::IfcLightSourceGoniometric: return new IfcLightSourceGoniometric(e); break;
        case Type::IfcLightSourcePositional: return new IfcLightSourcePositional(e); break;
        case Type::IfcLightSourceSpot: return new IfcLightSourceSpot(e); break;
        case Type::IfcLine: return new IfcLine(e); break;
        case Type::IfcLinearDimension: return new IfcLinearDimension(e); break;
        case Type::IfcLocalPlacement: return new IfcLocalPlacement(e); break;
        case Type::IfcLocalTime: return new IfcLocalTime(e); break;
        case Type::IfcLoop: return new IfcLoop(e); break;
        case Type::IfcManifoldSolidBrep: return new IfcManifoldSolidBrep(e); break;
        case Type::IfcMappedItem: return new IfcMappedItem(e); break;
        case Type::IfcMaterial: return new IfcMaterial(e); break;
        case Type::IfcMaterialClassificationRelationship: return new IfcMaterialClassificationRelationship(e); break;
        case Type::IfcMaterialDefinitionRepresentation: return new IfcMaterialDefinitionRepresentation(e); break;
        case Type::IfcMaterialLayer: return new IfcMaterialLayer(e); break;
        case Type::IfcMaterialLayerSet: return new IfcMaterialLayerSet(e); break;
        case Type::IfcMaterialLayerSetUsage: return new IfcMaterialLayerSetUsage(e); break;
        case Type::IfcMaterialList: return new IfcMaterialList(e); break;
        case Type::IfcMaterialProperties: return new IfcMaterialProperties(e); break;
        case Type::IfcMeasureWithUnit: return new IfcMeasureWithUnit(e); break;
        case Type::IfcMechanicalConcreteMaterialProperties: return new IfcMechanicalConcreteMaterialProperties(e); break;
        case Type::IfcMechanicalFastener: return new IfcMechanicalFastener(e); break;
        case Type::IfcMechanicalFastenerType: return new IfcMechanicalFastenerType(e); break;
        case Type::IfcMechanicalMaterialProperties: return new IfcMechanicalMaterialProperties(e); break;
        case Type::IfcMechanicalSteelMaterialProperties: return new IfcMechanicalSteelMaterialProperties(e); break;
        case Type::IfcMember: return new IfcMember(e); break;
        case Type::IfcMemberType: return new IfcMemberType(e); break;
        case Type::IfcMetric: return new IfcMetric(e); break;
        case Type::IfcMonetaryUnit: return new IfcMonetaryUnit(e); break;
        case Type::IfcMotorConnectionType: return new IfcMotorConnectionType(e); break;
        case Type::IfcMove: return new IfcMove(e); break;
        case Type::IfcNamedUnit: return new IfcNamedUnit(e); break;
        case Type::IfcObject: return new IfcObject(e); break;
        case Type::IfcObjectDefinition: return new IfcObjectDefinition(e); break;
        case Type::IfcObjectPlacement: return new IfcObjectPlacement(e); break;
        case Type::IfcObjective: return new IfcObjective(e); break;
        case Type::IfcOccupant: return new IfcOccupant(e); break;
        case Type::IfcOffsetCurve2D: return new IfcOffsetCurve2D(e); break;
        case Type::IfcOffsetCurve3D: return new IfcOffsetCurve3D(e); break;
        case Type::IfcOneDirectionRepeatFactor: return new IfcOneDirectionRepeatFactor(e); break;
        case Type::IfcOpenShell: return new IfcOpenShell(e); break;
        case Type::IfcOpeningElement: return new IfcOpeningElement(e); break;
        case Type::IfcOpticalMaterialProperties: return new IfcOpticalMaterialProperties(e); break;
        case Type::IfcOrderAction: return new IfcOrderAction(e); break;
        case Type::IfcOrganization: return new IfcOrganization(e); break;
        case Type::IfcOrganizationRelationship: return new IfcOrganizationRelationship(e); break;
        case Type::IfcOrientedEdge: return new IfcOrientedEdge(e); break;
        case Type::IfcOutletType: return new IfcOutletType(e); break;
        case Type::IfcOwnerHistory: return new IfcOwnerHistory(e); break;
        case Type::IfcParameterizedProfileDef: return new IfcParameterizedProfileDef(e); break;
        case Type::IfcPath: return new IfcPath(e); break;
        case Type::IfcPerformanceHistory: return new IfcPerformanceHistory(e); break;
        case Type::IfcPermeableCoveringProperties: return new IfcPermeableCoveringProperties(e); break;
        case Type::IfcPermit: return new IfcPermit(e); break;
        case Type::IfcPerson: return new IfcPerson(e); break;
        case Type::IfcPersonAndOrganization: return new IfcPersonAndOrganization(e); break;
        case Type::IfcPhysicalComplexQuantity: return new IfcPhysicalComplexQuantity(e); break;
        case Type::IfcPhysicalQuantity: return new IfcPhysicalQuantity(e); break;
        case Type::IfcPhysicalSimpleQuantity: return new IfcPhysicalSimpleQuantity(e); break;
        case Type::IfcPile: return new IfcPile(e); break;
        case Type::IfcPipeFittingType: return new IfcPipeFittingType(e); break;
        case Type::IfcPipeSegmentType: return new IfcPipeSegmentType(e); break;
        case Type::IfcPixelTexture: return new IfcPixelTexture(e); break;
        case Type::IfcPlacement: return new IfcPlacement(e); break;
        case Type::IfcPlanarBox: return new IfcPlanarBox(e); break;
        case Type::IfcPlanarExtent: return new IfcPlanarExtent(e); break;
        case Type::IfcPlane: return new IfcPlane(e); break;
        case Type::IfcPlate: return new IfcPlate(e); break;
        case Type::IfcPlateType: return new IfcPlateType(e); break;
        case Type::IfcPoint: return new IfcPoint(e); break;
        case Type::IfcPointOnCurve: return new IfcPointOnCurve(e); break;
        case Type::IfcPointOnSurface: return new IfcPointOnSurface(e); break;
        case Type::IfcPolyLoop: return new IfcPolyLoop(e); break;
        case Type::IfcPolygonalBoundedHalfSpace: return new IfcPolygonalBoundedHalfSpace(e); break;
        case Type::IfcPolyline: return new IfcPolyline(e); break;
        case Type::IfcPort: return new IfcPort(e); break;
        case Type::IfcPostalAddress: return new IfcPostalAddress(e); break;
        case Type::IfcPreDefinedColour: return new IfcPreDefinedColour(e); break;
        case Type::IfcPreDefinedCurveFont: return new IfcPreDefinedCurveFont(e); break;
        case Type::IfcPreDefinedDimensionSymbol: return new IfcPreDefinedDimensionSymbol(e); break;
        case Type::IfcPreDefinedItem: return new IfcPreDefinedItem(e); break;
        case Type::IfcPreDefinedPointMarkerSymbol: return new IfcPreDefinedPointMarkerSymbol(e); break;
        case Type::IfcPreDefinedSymbol: return new IfcPreDefinedSymbol(e); break;
        case Type::IfcPreDefinedTerminatorSymbol: return new IfcPreDefinedTerminatorSymbol(e); break;
        case Type::IfcPreDefinedTextFont: return new IfcPreDefinedTextFont(e); break;
        case Type::IfcPresentationLayerAssignment: return new IfcPresentationLayerAssignment(e); break;
        case Type::IfcPresentationLayerWithStyle: return new IfcPresentationLayerWithStyle(e); break;
        case Type::IfcPresentationStyle: return new IfcPresentationStyle(e); break;
        case Type::IfcPresentationStyleAssignment: return new IfcPresentationStyleAssignment(e); break;
        case Type::IfcProcedure: return new IfcProcedure(e); break;
        case Type::IfcProcess: return new IfcProcess(e); break;
        case Type::IfcProduct: return new IfcProduct(e); break;
        case Type::IfcProductDefinitionShape: return new IfcProductDefinitionShape(e); break;
        case Type::IfcProductRepresentation: return new IfcProductRepresentation(e); break;
        case Type::IfcProductsOfCombustionProperties: return new IfcProductsOfCombustionProperties(e); break;
        case Type::IfcProfileDef: return new IfcProfileDef(e); break;
        case Type::IfcProfileProperties: return new IfcProfileProperties(e); break;
        case Type::IfcProject: return new IfcProject(e); break;
        case Type::IfcProjectOrder: return new IfcProjectOrder(e); break;
        case Type::IfcProjectOrderRecord: return new IfcProjectOrderRecord(e); break;
        case Type::IfcProjectionCurve: return new IfcProjectionCurve(e); break;
        case Type::IfcProjectionElement: return new IfcProjectionElement(e); break;
        case Type::IfcProperty: return new IfcProperty(e); break;
        case Type::IfcPropertyBoundedValue: return new IfcPropertyBoundedValue(e); break;
        case Type::IfcPropertyConstraintRelationship: return new IfcPropertyConstraintRelationship(e); break;
        case Type::IfcPropertyDefinition: return new IfcPropertyDefinition(e); break;
        case Type::IfcPropertyDependencyRelationship: return new IfcPropertyDependencyRelationship(e); break;
        case Type::IfcPropertyEnumeratedValue: return new IfcPropertyEnumeratedValue(e); break;
        case Type::IfcPropertyEnumeration: return new IfcPropertyEnumeration(e); break;
        case Type::IfcPropertyListValue: return new IfcPropertyListValue(e); break;
        case Type::IfcPropertyReferenceValue: return new IfcPropertyReferenceValue(e); break;
        case Type::IfcPropertySet: return new IfcPropertySet(e); break;
        case Type::IfcPropertySetDefinition: return new IfcPropertySetDefinition(e); break;
        case Type::IfcPropertySingleValue: return new IfcPropertySingleValue(e); break;
        case Type::IfcPropertyTableValue: return new IfcPropertyTableValue(e); break;
        case Type::IfcProtectiveDeviceType: return new IfcProtectiveDeviceType(e); break;
        case Type::IfcProxy: return new IfcProxy(e); break;
        case Type::IfcPumpType: return new IfcPumpType(e); break;
        case Type::IfcQuantityArea: return new IfcQuantityArea(e); break;
        case Type::IfcQuantityCount: return new IfcQuantityCount(e); break;
        case Type::IfcQuantityLength: return new IfcQuantityLength(e); break;
        case Type::IfcQuantityTime: return new IfcQuantityTime(e); break;
        case Type::IfcQuantityVolume: return new IfcQuantityVolume(e); break;
        case Type::IfcQuantityWeight: return new IfcQuantityWeight(e); break;
        case Type::IfcRadiusDimension: return new IfcRadiusDimension(e); break;
        case Type::IfcRailing: return new IfcRailing(e); break;
        case Type::IfcRailingType: return new IfcRailingType(e); break;
        case Type::IfcRamp: return new IfcRamp(e); break;
        case Type::IfcRampFlight: return new IfcRampFlight(e); break;
        case Type::IfcRampFlightType: return new IfcRampFlightType(e); break;
        case Type::IfcRationalBezierCurve: return new IfcRationalBezierCurve(e); break;
        case Type::IfcRectangleHollowProfileDef: return new IfcRectangleHollowProfileDef(e); break;
        case Type::IfcRectangleProfileDef: return new IfcRectangleProfileDef(e); break;
        case Type::IfcRectangularPyramid: return new IfcRectangularPyramid(e); break;
        case Type::IfcRectangularTrimmedSurface: return new IfcRectangularTrimmedSurface(e); break;
        case Type::IfcReferencesValueDocument: return new IfcReferencesValueDocument(e); break;
        case Type::IfcRegularTimeSeries: return new IfcRegularTimeSeries(e); break;
        case Type::IfcReinforcementBarProperties: return new IfcReinforcementBarProperties(e); break;
        case Type::IfcReinforcementDefinitionProperties: return new IfcReinforcementDefinitionProperties(e); break;
        case Type::IfcReinforcingBar: return new IfcReinforcingBar(e); break;
        case Type::IfcReinforcingElement: return new IfcReinforcingElement(e); break;
        case Type::IfcReinforcingMesh: return new IfcReinforcingMesh(e); break;
        case Type::IfcRelAggregates: return new IfcRelAggregates(e); break;
        case Type::IfcRelAssigns: return new IfcRelAssigns(e); break;
        case Type::IfcRelAssignsTasks: return new IfcRelAssignsTasks(e); break;
        case Type::IfcRelAssignsToActor: return new IfcRelAssignsToActor(e); break;
        case Type::IfcRelAssignsToControl: return new IfcRelAssignsToControl(e); break;
        case Type::IfcRelAssignsToGroup: return new IfcRelAssignsToGroup(e); break;
        case Type::IfcRelAssignsToProcess: return new IfcRelAssignsToProcess(e); break;
        case Type::IfcRelAssignsToProduct: return new IfcRelAssignsToProduct(e); break;
        case Type::IfcRelAssignsToProjectOrder: return new IfcRelAssignsToProjectOrder(e); break;
        case Type::IfcRelAssignsToResource: return new IfcRelAssignsToResource(e); break;
        case Type::IfcRelAssociates: return new IfcRelAssociates(e); break;
        case Type::IfcRelAssociatesAppliedValue: return new IfcRelAssociatesAppliedValue(e); break;
        case Type::IfcRelAssociatesApproval: return new IfcRelAssociatesApproval(e); break;
        case Type::IfcRelAssociatesClassification: return new IfcRelAssociatesClassification(e); break;
        case Type::IfcRelAssociatesConstraint: return new IfcRelAssociatesConstraint(e); break;
        case Type::IfcRelAssociatesDocument: return new IfcRelAssociatesDocument(e); break;
        case Type::IfcRelAssociatesLibrary: return new IfcRelAssociatesLibrary(e); break;
        case Type::IfcRelAssociatesMaterial: return new IfcRelAssociatesMaterial(e); break;
        case Type::IfcRelAssociatesProfileProperties: return new IfcRelAssociatesProfileProperties(e); break;
        case Type::IfcRelConnects: return new IfcRelConnects(e); break;
        case Type::IfcRelConnectsElements: return new IfcRelConnectsElements(e); break;
        case Type::IfcRelConnectsPathElements: return new IfcRelConnectsPathElements(e); break;
        case Type::IfcRelConnectsPortToElement: return new IfcRelConnectsPortToElement(e); break;
        case Type::IfcRelConnectsPorts: return new IfcRelConnectsPorts(e); break;
        case Type::IfcRelConnectsStructuralActivity: return new IfcRelConnectsStructuralActivity(e); break;
        case Type::IfcRelConnectsStructuralElement: return new IfcRelConnectsStructuralElement(e); break;
        case Type::IfcRelConnectsStructuralMember: return new IfcRelConnectsStructuralMember(e); break;
        case Type::IfcRelConnectsWithEccentricity: return new IfcRelConnectsWithEccentricity(e); break;
        case Type::IfcRelConnectsWithRealizingElements: return new IfcRelConnectsWithRealizingElements(e); break;
        case Type::IfcRelContainedInSpatialStructure: return new IfcRelContainedInSpatialStructure(e); break;
        case Type::IfcRelCoversBldgElements: return new IfcRelCoversBldgElements(e); break;
        case Type::IfcRelCoversSpaces: return new IfcRelCoversSpaces(e); break;
        case Type::IfcRelDecomposes: return new IfcRelDecomposes(e); break;
        case Type::IfcRelDefines: return new IfcRelDefines(e); break;
        case Type::IfcRelDefinesByProperties: return new IfcRelDefinesByProperties(e); break;
        case Type::IfcRelDefinesByType: return new IfcRelDefinesByType(e); break;
        case Type::IfcRelFillsElement: return new IfcRelFillsElement(e); break;
        case Type::IfcRelFlowControlElements: return new IfcRelFlowControlElements(e); break;
        case Type::IfcRelInteractionRequirements: return new IfcRelInteractionRequirements(e); break;
        case Type::IfcRelNests: return new IfcRelNests(e); break;
        case Type::IfcRelOccupiesSpaces: return new IfcRelOccupiesSpaces(e); break;
        case Type::IfcRelOverridesProperties: return new IfcRelOverridesProperties(e); break;
        case Type::IfcRelProjectsElement: return new IfcRelProjectsElement(e); break;
        case Type::IfcRelReferencedInSpatialStructure: return new IfcRelReferencedInSpatialStructure(e); break;
        case Type::IfcRelSchedulesCostItems: return new IfcRelSchedulesCostItems(e); break;
        case Type::IfcRelSequence: return new IfcRelSequence(e); break;
        case Type::IfcRelServicesBuildings: return new IfcRelServicesBuildings(e); break;
        case Type::IfcRelSpaceBoundary: return new IfcRelSpaceBoundary(e); break;
        case Type::IfcRelVoidsElement: return new IfcRelVoidsElement(e); break;
        case Type::IfcRelationship: return new IfcRelationship(e); break;
        case Type::IfcRelaxation: return new IfcRelaxation(e); break;
        case Type::IfcRepresentation: return new IfcRepresentation(e); break;
        case Type::IfcRepresentationContext: return new IfcRepresentationContext(e); break;
        case Type::IfcRepresentationItem: return new IfcRepresentationItem(e); break;
        case Type::IfcRepresentationMap: return new IfcRepresentationMap(e); break;
        case Type::IfcResource: return new IfcResource(e); break;
        case Type::IfcRevolvedAreaSolid: return new IfcRevolvedAreaSolid(e); break;
        case Type::IfcRibPlateProfileProperties: return new IfcRibPlateProfileProperties(e); break;
        case Type::IfcRightCircularCone: return new IfcRightCircularCone(e); break;
        case Type::IfcRightCircularCylinder: return new IfcRightCircularCylinder(e); break;
        case Type::IfcRoof: return new IfcRoof(e); break;
        case Type::IfcRoot: return new IfcRoot(e); break;
        case Type::IfcRoundedEdgeFeature: return new IfcRoundedEdgeFeature(e); break;
        case Type::IfcRoundedRectangleProfileDef: return new IfcRoundedRectangleProfileDef(e); break;
        case Type::IfcSIUnit: return new IfcSIUnit(e); break;
        case Type::IfcSanitaryTerminalType: return new IfcSanitaryTerminalType(e); break;
        case Type::IfcScheduleTimeControl: return new IfcScheduleTimeControl(e); break;
        case Type::IfcSectionProperties: return new IfcSectionProperties(e); break;
        case Type::IfcSectionReinforcementProperties: return new IfcSectionReinforcementProperties(e); break;
        case Type::IfcSectionedSpine: return new IfcSectionedSpine(e); break;
        case Type::IfcSensorType: return new IfcSensorType(e); break;
        case Type::IfcServiceLife: return new IfcServiceLife(e); break;
        case Type::IfcServiceLifeFactor: return new IfcServiceLifeFactor(e); break;
        case Type::IfcShapeAspect: return new IfcShapeAspect(e); break;
        case Type::IfcShapeModel: return new IfcShapeModel(e); break;
        case Type::IfcShapeRepresentation: return new IfcShapeRepresentation(e); break;
        case Type::IfcShellBasedSurfaceModel: return new IfcShellBasedSurfaceModel(e); break;
        case Type::IfcSimpleProperty: return new IfcSimpleProperty(e); break;
        case Type::IfcSite: return new IfcSite(e); break;
        case Type::IfcSlab: return new IfcSlab(e); break;
        case Type::IfcSlabType: return new IfcSlabType(e); break;
        case Type::IfcSlippageConnectionCondition: return new IfcSlippageConnectionCondition(e); break;
        case Type::IfcSolidModel: return new IfcSolidModel(e); break;
        case Type::IfcSoundProperties: return new IfcSoundProperties(e); break;
        case Type::IfcSoundValue: return new IfcSoundValue(e); break;
        case Type::IfcSpace: return new IfcSpace(e); break;
        case Type::IfcSpaceHeaterType: return new IfcSpaceHeaterType(e); break;
        case Type::IfcSpaceProgram: return new IfcSpaceProgram(e); break;
        case Type::IfcSpaceThermalLoadProperties: return new IfcSpaceThermalLoadProperties(e); break;
        case Type::IfcSpaceType: return new IfcSpaceType(e); break;
        case Type::IfcSpatialStructureElement: return new IfcSpatialStructureElement(e); break;
        case Type::IfcSpatialStructureElementType: return new IfcSpatialStructureElementType(e); break;
        case Type::IfcSphere: return new IfcSphere(e); break;
        case Type::IfcStackTerminalType: return new IfcStackTerminalType(e); break;
        case Type::IfcStair: return new IfcStair(e); break;
        case Type::IfcStairFlight: return new IfcStairFlight(e); break;
        case Type::IfcStairFlightType: return new IfcStairFlightType(e); break;
        case Type::IfcStructuralAction: return new IfcStructuralAction(e); break;
        case Type::IfcStructuralActivity: return new IfcStructuralActivity(e); break;
        case Type::IfcStructuralAnalysisModel: return new IfcStructuralAnalysisModel(e); break;
        case Type::IfcStructuralConnection: return new IfcStructuralConnection(e); break;
        case Type::IfcStructuralConnectionCondition: return new IfcStructuralConnectionCondition(e); break;
        case Type::IfcStructuralCurveConnection: return new IfcStructuralCurveConnection(e); break;
        case Type::IfcStructuralCurveMember: return new IfcStructuralCurveMember(e); break;
        case Type::IfcStructuralCurveMemberVarying: return new IfcStructuralCurveMemberVarying(e); break;
        case Type::IfcStructuralItem: return new IfcStructuralItem(e); break;
        case Type::IfcStructuralLinearAction: return new IfcStructuralLinearAction(e); break;
        case Type::IfcStructuralLinearActionVarying: return new IfcStructuralLinearActionVarying(e); break;
        case Type::IfcStructuralLoad: return new IfcStructuralLoad(e); break;
        case Type::IfcStructuralLoadGroup: return new IfcStructuralLoadGroup(e); break;
        case Type::IfcStructuralLoadLinearForce: return new IfcStructuralLoadLinearForce(e); break;
        case Type::IfcStructuralLoadPlanarForce: return new IfcStructuralLoadPlanarForce(e); break;
        case Type::IfcStructuralLoadSingleDisplacement: return new IfcStructuralLoadSingleDisplacement(e); break;
        case Type::IfcStructuralLoadSingleDisplacementDistortion: return new IfcStructuralLoadSingleDisplacementDistortion(e); break;
        case Type::IfcStructuralLoadSingleForce: return new IfcStructuralLoadSingleForce(e); break;
        case Type::IfcStructuralLoadSingleForceWarping: return new IfcStructuralLoadSingleForceWarping(e); break;
        case Type::IfcStructuralLoadStatic: return new IfcStructuralLoadStatic(e); break;
        case Type::IfcStructuralLoadTemperature: return new IfcStructuralLoadTemperature(e); break;
        case Type::IfcStructuralMember: return new IfcStructuralMember(e); break;
        case Type::IfcStructuralPlanarAction: return new IfcStructuralPlanarAction(e); break;
        case Type::IfcStructuralPlanarActionVarying: return new IfcStructuralPlanarActionVarying(e); break;
        case Type::IfcStructuralPointAction: return new IfcStructuralPointAction(e); break;
        case Type::IfcStructuralPointConnection: return new IfcStructuralPointConnection(e); break;
        case Type::IfcStructuralPointReaction: return new IfcStructuralPointReaction(e); break;
        case Type::IfcStructuralProfileProperties: return new IfcStructuralProfileProperties(e); break;
        case Type::IfcStructuralReaction: return new IfcStructuralReaction(e); break;
        case Type::IfcStructuralResultGroup: return new IfcStructuralResultGroup(e); break;
        case Type::IfcStructuralSteelProfileProperties: return new IfcStructuralSteelProfileProperties(e); break;
        case Type::IfcStructuralSurfaceConnection: return new IfcStructuralSurfaceConnection(e); break;
        case Type::IfcStructuralSurfaceMember: return new IfcStructuralSurfaceMember(e); break;
        case Type::IfcStructuralSurfaceMemberVarying: return new IfcStructuralSurfaceMemberVarying(e); break;
        case Type::IfcStructuredDimensionCallout: return new IfcStructuredDimensionCallout(e); break;
        case Type::IfcStyleModel: return new IfcStyleModel(e); break;
        case Type::IfcStyledItem: return new IfcStyledItem(e); break;
        case Type::IfcStyledRepresentation: return new IfcStyledRepresentation(e); break;
        case Type::IfcSubContractResource: return new IfcSubContractResource(e); break;
        case Type::IfcSubedge: return new IfcSubedge(e); break;
        case Type::IfcSurface: return new IfcSurface(e); break;
        case Type::IfcSurfaceCurveSweptAreaSolid: return new IfcSurfaceCurveSweptAreaSolid(e); break;
        case Type::IfcSurfaceOfLinearExtrusion: return new IfcSurfaceOfLinearExtrusion(e); break;
        case Type::IfcSurfaceOfRevolution: return new IfcSurfaceOfRevolution(e); break;
        case Type::IfcSurfaceStyle: return new IfcSurfaceStyle(e); break;
        case Type::IfcSurfaceStyleLighting: return new IfcSurfaceStyleLighting(e); break;
        case Type::IfcSurfaceStyleRefraction: return new IfcSurfaceStyleRefraction(e); break;
        case Type::IfcSurfaceStyleRendering: return new IfcSurfaceStyleRendering(e); break;
        case Type::IfcSurfaceStyleShading: return new IfcSurfaceStyleShading(e); break;
        case Type::IfcSurfaceStyleWithTextures: return new IfcSurfaceStyleWithTextures(e); break;
        case Type::IfcSurfaceTexture: return new IfcSurfaceTexture(e); break;
        case Type::IfcSweptAreaSolid: return new IfcSweptAreaSolid(e); break;
        case Type::IfcSweptDiskSolid: return new IfcSweptDiskSolid(e); break;
        case Type::IfcSweptSurface: return new IfcSweptSurface(e); break;
        case Type::IfcSwitchingDeviceType: return new IfcSwitchingDeviceType(e); break;
        case Type::IfcSymbolStyle: return new IfcSymbolStyle(e); break;
        case Type::IfcSystem: return new IfcSystem(e); break;
        case Type::IfcSystemFurnitureElementType: return new IfcSystemFurnitureElementType(e); break;
        case Type::IfcTShapeProfileDef: return new IfcTShapeProfileDef(e); break;
        case Type::IfcTable: return new IfcTable(e); break;
        case Type::IfcTableRow: return new IfcTableRow(e); break;
        case Type::IfcTankType: return new IfcTankType(e); break;
        case Type::IfcTask: return new IfcTask(e); break;
        case Type::IfcTelecomAddress: return new IfcTelecomAddress(e); break;
        case Type::IfcTendon: return new IfcTendon(e); break;
        case Type::IfcTendonAnchor: return new IfcTendonAnchor(e); break;
        case Type::IfcTerminatorSymbol: return new IfcTerminatorSymbol(e); break;
        case Type::IfcTextLiteral: return new IfcTextLiteral(e); break;
        case Type::IfcTextLiteralWithExtent: return new IfcTextLiteralWithExtent(e); break;
        case Type::IfcTextStyle: return new IfcTextStyle(e); break;
        case Type::IfcTextStyleFontModel: return new IfcTextStyleFontModel(e); break;
        case Type::IfcTextStyleForDefinedFont: return new IfcTextStyleForDefinedFont(e); break;
        case Type::IfcTextStyleTextModel: return new IfcTextStyleTextModel(e); break;
        case Type::IfcTextStyleWithBoxCharacteristics: return new IfcTextStyleWithBoxCharacteristics(e); break;
        case Type::IfcTextureCoordinate: return new IfcTextureCoordinate(e); break;
        case Type::IfcTextureCoordinateGenerator: return new IfcTextureCoordinateGenerator(e); break;
        case Type::IfcTextureMap: return new IfcTextureMap(e); break;
        case Type::IfcTextureVertex: return new IfcTextureVertex(e); break;
        case Type::IfcThermalMaterialProperties: return new IfcThermalMaterialProperties(e); break;
        case Type::IfcTimeSeries: return new IfcTimeSeries(e); break;
        case Type::IfcTimeSeriesReferenceRelationship: return new IfcTimeSeriesReferenceRelationship(e); break;
        case Type::IfcTimeSeriesSchedule: return new IfcTimeSeriesSchedule(e); break;
        case Type::IfcTimeSeriesValue: return new IfcTimeSeriesValue(e); break;
        case Type::IfcTopologicalRepresentationItem: return new IfcTopologicalRepresentationItem(e); break;
        case Type::IfcTopologyRepresentation: return new IfcTopologyRepresentation(e); break;
        case Type::IfcTransformerType: return new IfcTransformerType(e); break;
        case Type::IfcTransportElement: return new IfcTransportElement(e); break;
        case Type::IfcTransportElementType: return new IfcTransportElementType(e); break;
        case Type::IfcTrapeziumProfileDef: return new IfcTrapeziumProfileDef(e); break;
        case Type::IfcTrimmedCurve: return new IfcTrimmedCurve(e); break;
        case Type::IfcTubeBundleType: return new IfcTubeBundleType(e); break;
        case Type::IfcTwoDirectionRepeatFactor: return new IfcTwoDirectionRepeatFactor(e); break;
        case Type::IfcTypeObject: return new IfcTypeObject(e); break;
        case Type::IfcTypeProduct: return new IfcTypeProduct(e); break;
        case Type::IfcUShapeProfileDef: return new IfcUShapeProfileDef(e); break;
        case Type::IfcUnitAssignment: return new IfcUnitAssignment(e); break;
        case Type::IfcUnitaryEquipmentType: return new IfcUnitaryEquipmentType(e); break;
        case Type::IfcValveType: return new IfcValveType(e); break;
        case Type::IfcVector: return new IfcVector(e); break;
        case Type::IfcVertex: return new IfcVertex(e); break;
        case Type::IfcVertexBasedTextureMap: return new IfcVertexBasedTextureMap(e); break;
        case Type::IfcVertexLoop: return new IfcVertexLoop(e); break;
        case Type::IfcVertexPoint: return new IfcVertexPoint(e); break;
        case Type::IfcVibrationIsolatorType: return new IfcVibrationIsolatorType(e); break;
        case Type::IfcVirtualElement: return new IfcVirtualElement(e); break;
        case Type::IfcVirtualGridIntersection: return new IfcVirtualGridIntersection(e); break;
        case Type::IfcWall: return new IfcWall(e); break;
        case Type::IfcWallStandardCase: return new IfcWallStandardCase(e); break;
        case Type::IfcWallType: return new IfcWallType(e); break;
        case Type::IfcWasteTerminalType: return new IfcWasteTerminalType(e); break;
        case Type::IfcWaterProperties: return new IfcWaterProperties(e); break;
        case Type::IfcWindow: return new IfcWindow(e); break;
        case Type::IfcWindowLiningProperties: return new IfcWindowLiningProperties(e); break;
        case Type::IfcWindowPanelProperties: return new IfcWindowPanelProperties(e); break;
        case Type::IfcWindowStyle: return new IfcWindowStyle(e); break;
        case Type::IfcWorkControl: return new IfcWorkControl(e); break;
        case Type::IfcWorkPlan: return new IfcWorkPlan(e); break;
        case Type::IfcWorkSchedule: return new IfcWorkSchedule(e); break;
        case Type::IfcZShapeProfileDef: return new IfcZShapeProfileDef(e); break;
        case Type::IfcZone: return new IfcZone(e); break;
        default: throw IfcException("Unable to find find keyword in schema"); break;
    }
}

std::string Type::ToString(Enum v) {
    if (v < 0 || v >= 980) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "Ifc2DCompositeCurve", "IfcAbsorbedDoseMeasure", "IfcAccelerationMeasure", "IfcActionRequest", "IfcActionSourceTypeEnum", "IfcActionTypeEnum", "IfcActor", "IfcActorRole", "IfcActorSelect", "IfcActuatorType", "IfcActuatorTypeEnum", "IfcAddress", "IfcAddressTypeEnum", "IfcAheadOrBehind", "IfcAirTerminalBoxType", "IfcAirTerminalBoxTypeEnum", "IfcAirTerminalType", "IfcAirTerminalTypeEnum", "IfcAirToAirHeatRecoveryType", "IfcAirToAirHeatRecoveryTypeEnum", "IfcAlarmType", "IfcAlarmTypeEnum", "IfcAmountOfSubstanceMeasure", "IfcAnalysisModelTypeEnum", "IfcAnalysisTheoryTypeEnum", "IfcAngularDimension", "IfcAngularVelocityMeasure", "IfcAnnotation", "IfcAnnotationCurveOccurrence", "IfcAnnotationFillArea", "IfcAnnotationFillAreaOccurrence", "IfcAnnotationOccurrence", "IfcAnnotationSurface", "IfcAnnotationSurfaceOccurrence", "IfcAnnotationSymbolOccurrence", "IfcAnnotationTextOccurrence", "IfcApplication", "IfcAppliedValue", "IfcAppliedValueRelationship", "IfcAppliedValueSelect", "IfcApproval", "IfcApprovalActorRelationship", "IfcApprovalPropertyRelationship", "IfcApprovalRelationship", "IfcArbitraryClosedProfileDef", "IfcArbitraryOpenProfileDef", "IfcArbitraryProfileDefWithVoids", "IfcAreaMeasure", "IfcArithmeticOperatorEnum", "IfcAssemblyPlaceEnum", "IfcAsset", "IfcAsymmetricIShapeProfileDef", "IfcAxis1Placement", "IfcAxis2Placement", "IfcAxis2Placement2D", "IfcAxis2Placement3D", "IfcBSplineCurve", "IfcBSplineCurveForm", "IfcBeam", "IfcBeamType", "IfcBeamTypeEnum", "IfcBenchmarkEnum", "IfcBezierCurve", "IfcBlobTexture", "IfcBlock", "IfcBoilerType", "IfcBoilerTypeEnum", "IfcBoolean", "IfcBooleanClippingResult", "IfcBooleanOperand", "IfcBooleanOperator", "IfcBooleanResult", "IfcBoundaryCondition", "IfcBoundaryEdgeCondition", "IfcBoundaryFaceCondition", "IfcBoundaryNodeCondition", "IfcBoundaryNodeConditionWarping", "IfcBoundedCurve", "IfcBoundedSurface", "IfcBoundingBox", "IfcBoxAlignment", "IfcBoxedHalfSpace", "IfcBuilding", "IfcBuildingElement", "IfcBuildingElementComponent", "IfcBuildingElementPart", "IfcBuildingElementProxy", "IfcBuildingElementProxyType", "IfcBuildingElementProxyTypeEnum", "IfcBuildingElementType", "IfcBuildingStorey", "IfcCShapeProfileDef", "IfcCableCarrierFittingType", "IfcCableCarrierFittingTypeEnum", "IfcCableCarrierSegmentType", "IfcCableCarrierSegmentTypeEnum", "IfcCableSegmentType", "IfcCableSegmentTypeEnum", "IfcCalendarDate", "IfcCartesianPoint", "IfcCartesianTransformationOperator", "IfcCartesianTransformationOperator2D", "IfcCartesianTransformationOperator2DnonUniform", "IfcCartesianTransformationOperator3D", "IfcCartesianTransformationOperator3DnonUniform", "IfcCenterLineProfileDef", "IfcChamferEdgeFeature", "IfcChangeActionEnum", "IfcCharacterStyleSelect", "IfcChillerType", "IfcChillerTypeEnum", "IfcCircle", "IfcCircleHollowProfileDef", "IfcCircleProfileDef", "IfcClassification", "IfcClassificationItem", "IfcClassificationItemRelationship", "IfcClassificationNotation", "IfcClassificationNotationFacet", "IfcClassificationNotationSelect", "IfcClassificationReference", "IfcClosedShell", "IfcCoilType", "IfcCoilTypeEnum", "IfcColour", "IfcColourOrFactor", "IfcColourRgb", "IfcColourSpecification", "IfcColumn", "IfcColumnType", "IfcColumnTypeEnum", "IfcComplexNumber", "IfcComplexProperty", "IfcCompositeCurve", "IfcCompositeCurveSegment", "IfcCompositeProfileDef", "IfcCompoundPlaneAngleMeasure", "IfcCompressorType", "IfcCompressorTypeEnum", "IfcCondenserType", "IfcCondenserTypeEnum", "IfcCondition", "IfcConditionCriterion", "IfcConditionCriterionSelect", "IfcConic", "IfcConnectedFaceSet", "IfcConnectionCurveGeometry", "IfcConnectionGeometry", "IfcConnectionPointEccentricity", "IfcConnectionPointGeometry", "IfcConnectionPortGeometry", "IfcConnectionSurfaceGeometry", "IfcConnectionTypeEnum", "IfcConstraint", "IfcConstraintAggregationRelationship", "IfcConstraintClassificationRelationship", "IfcConstraintEnum", "IfcConstraintRelationship", "IfcConstructionEquipmentResource", "IfcConstructionMaterialResource", "IfcConstructionProductResource", "IfcConstructionResource", "IfcContextDependentMeasure", "IfcContextDependentUnit", "IfcControl", "IfcControllerType", "IfcControllerTypeEnum", "IfcConversionBasedUnit", "IfcCooledBeamType", "IfcCooledBeamTypeEnum", "IfcCoolingTowerType", "IfcCoolingTowerTypeEnum", "IfcCoordinatedUniversalTimeOffset", "IfcCostItem", "IfcCostSchedule", "IfcCostScheduleTypeEnum", "IfcCostValue", "IfcCountMeasure", "IfcCovering", "IfcCoveringType", "IfcCoveringTypeEnum", "IfcCraneRailAShapeProfileDef", "IfcCraneRailFShapeProfileDef", "IfcCrewResource", "IfcCsgPrimitive3D", "IfcCsgSelect", "IfcCsgSolid", "IfcCurrencyEnum", "IfcCurrencyRelationship", "IfcCurtainWall", "IfcCurtainWallType", "IfcCurtainWallTypeEnum", "IfcCurvatureMeasure", "IfcCurve", "IfcCurveBoundedPlane", "IfcCurveFontOrScaledCurveFontSelect", "IfcCurveOrEdgeCurve", "IfcCurveStyle", "IfcCurveStyleFont", "IfcCurveStyleFontAndScaling", "IfcCurveStyleFontPattern", "IfcCurveStyleFontSelect", "IfcDamperType", "IfcDamperTypeEnum", "IfcDataOriginEnum", "IfcDateAndTime", "IfcDateTimeSelect", "IfcDayInMonthNumber", "IfcDaylightSavingHour", "IfcDefinedSymbol", "IfcDefinedSymbolSelect", "IfcDerivedMeasureValue", "IfcDerivedProfileDef", "IfcDerivedUnit", "IfcDerivedUnitElement", "IfcDerivedUnitEnum", "IfcDescriptiveMeasure", "IfcDiameterDimension", "IfcDimensionCalloutRelationship", "IfcDimensionCount", "IfcDimensionCurve", "IfcDimensionCurveDirectedCallout", "IfcDimensionCurveTerminator", "IfcDimensionExtentUsage", "IfcDimensionPair", "IfcDimensionalExponents", "IfcDirection", "IfcDirectionSenseEnum", "IfcDiscreteAccessory", "IfcDiscreteAccessoryType", "IfcDistributionChamberElement", "IfcDistributionChamberElementType", "IfcDistributionChamberElementTypeEnum", "IfcDistributionControlElement", "IfcDistributionControlElementType", "IfcDistributionElement", "IfcDistributionElementType", "IfcDistributionFlowElement", "IfcDistributionFlowElementType", "IfcDistributionPort", "IfcDocumentConfidentialityEnum", "IfcDocumentElectronicFormat", "IfcDocumentInformation", "IfcDocumentInformationRelationship", "IfcDocumentReference", "IfcDocumentSelect", "IfcDocumentStatusEnum", "IfcDoor", "IfcDoorLiningProperties", "IfcDoorPanelOperationEnum", "IfcDoorPanelPositionEnum", "IfcDoorPanelProperties", "IfcDoorStyle", "IfcDoorStyleConstructionEnum", "IfcDoorStyleOperationEnum", "IfcDoseEquivalentMeasure", "IfcDraughtingCallout", "IfcDraughtingCalloutElement", "IfcDraughtingCalloutRelationship", "IfcDraughtingPreDefinedColour", "IfcDraughtingPreDefinedCurveFont", "IfcDraughtingPreDefinedTextFont", "IfcDuctFittingType", "IfcDuctFittingTypeEnum", "IfcDuctSegmentType", "IfcDuctSegmentTypeEnum", "IfcDuctSilencerType", "IfcDuctSilencerTypeEnum", "IfcDynamicViscosityMeasure", "IfcEdge", "IfcEdgeCurve", "IfcEdgeFeature", "IfcEdgeLoop", "IfcElectricApplianceType", "IfcElectricApplianceTypeEnum", "IfcElectricCapacitanceMeasure", "IfcElectricChargeMeasure", "IfcElectricConductanceMeasure", "IfcElectricCurrentEnum", "IfcElectricCurrentMeasure", "IfcElectricDistributionPoint", "IfcElectricDistributionPointFunctionEnum", "IfcElectricFlowStorageDeviceType", "IfcElectricFlowStorageDeviceTypeEnum", "IfcElectricGeneratorType", "IfcElectricGeneratorTypeEnum", "IfcElectricHeaterType", "IfcElectricHeaterTypeEnum", "IfcElectricMotorType", "IfcElectricMotorTypeEnum", "IfcElectricResistanceMeasure", "IfcElectricTimeControlType", "IfcElectricTimeControlTypeEnum", "IfcElectricVoltageMeasure", "IfcElectricalBaseProperties", "IfcElectricalCircuit", "IfcElectricalElement", "IfcElement", "IfcElementAssembly", "IfcElementAssemblyTypeEnum", "IfcElementComponent", "IfcElementComponentType", "IfcElementCompositionEnum", "IfcElementQuantity", "IfcElementType", "IfcElementarySurface", "IfcEllipse", "IfcEllipseProfileDef", "IfcEnergyConversionDevice", "IfcEnergyConversionDeviceType", "IfcEnergyMeasure", "IfcEnergyProperties", "IfcEnergySequenceEnum", "IfcEnvironmentalImpactCategoryEnum", "IfcEnvironmentalImpactValue", "IfcEquipmentElement", "IfcEquipmentStandard", "IfcEvaporativeCoolerType", "IfcEvaporativeCoolerTypeEnum", "IfcEvaporatorType", "IfcEvaporatorTypeEnum", "IfcExtendedMaterialProperties", "IfcExternalReference", "IfcExternallyDefinedHatchStyle", "IfcExternallyDefinedSurfaceStyle", "IfcExternallyDefinedSymbol", "IfcExternallyDefinedTextFont", "IfcExtrudedAreaSolid", "IfcFace", "IfcFaceBasedSurfaceModel", "IfcFaceBound", "IfcFaceOuterBound", "IfcFaceSurface", "IfcFacetedBrep", "IfcFacetedBrepWithVoids", "IfcFailureConnectionCondition", "IfcFanType", "IfcFanTypeEnum", "IfcFastener", "IfcFastenerType", "IfcFeatureElement", "IfcFeatureElementAddition", "IfcFeatureElementSubtraction", "IfcFillAreaStyle", "IfcFillAreaStyleHatching", "IfcFillAreaStyleTileShapeSelect", "IfcFillAreaStyleTileSymbolWithStyle", "IfcFillAreaStyleTiles", "IfcFillStyleSelect", "IfcFilterType", "IfcFilterTypeEnum", "IfcFireSuppressionTerminalType", "IfcFireSuppressionTerminalTypeEnum", "IfcFlowController", "IfcFlowControllerType", "IfcFlowDirectionEnum", "IfcFlowFitting", "IfcFlowFittingType", "IfcFlowInstrumentType", "IfcFlowInstrumentTypeEnum", "IfcFlowMeterType", "IfcFlowMeterTypeEnum", "IfcFlowMovingDevice", "IfcFlowMovingDeviceType", "IfcFlowSegment", "IfcFlowSegmentType", "IfcFlowStorageDevice", "IfcFlowStorageDeviceType", "IfcFlowTerminal", "IfcFlowTerminalType", "IfcFlowTreatmentDevice", "IfcFlowTreatmentDeviceType", "IfcFluidFlowProperties", "IfcFontStyle", "IfcFontVariant", "IfcFontWeight", "IfcFooting", "IfcFootingTypeEnum", "IfcForceMeasure", "IfcFrequencyMeasure", "IfcFuelProperties", "IfcFurnishingElement", "IfcFurnishingElementType", "IfcFurnitureStandard", "IfcFurnitureType", "IfcGasTerminalType", "IfcGasTerminalTypeEnum", "IfcGeneralMaterialProperties", "IfcGeneralProfileProperties", "IfcGeometricCurveSet", "IfcGeometricProjectionEnum", "IfcGeometricRepresentationContext", "IfcGeometricRepresentationItem", "IfcGeometricRepresentationSubContext", "IfcGeometricSet", "IfcGeometricSetSelect", "IfcGlobalOrLocalEnum", "IfcGloballyUniqueId", "IfcGrid", "IfcGridAxis", "IfcGridPlacement", "IfcGroup", "IfcHalfSpaceSolid", "IfcHatchLineDistanceSelect", "IfcHeatExchangerType", "IfcHeatExchangerTypeEnum", "IfcHeatFluxDensityMeasure", "IfcHeatingValueMeasure", "IfcHourInDay", "IfcHumidifierType", "IfcHumidifierTypeEnum", "IfcHygroscopicMaterialProperties", "IfcIShapeProfileDef", "IfcIdentifier", "IfcIlluminanceMeasure", "IfcImageTexture", "IfcInductanceMeasure", "IfcInteger", "IfcIntegerCountRateMeasure", "IfcInternalOrExternalEnum", "IfcInventory", "IfcInventoryTypeEnum", "IfcIonConcentrationMeasure", "IfcIrregularTimeSeries", "IfcIrregularTimeSeriesValue", "IfcIsothermalMoistureCapacityMeasure", "IfcJunctionBoxType", "IfcJunctionBoxTypeEnum", "IfcKinematicViscosityMeasure", "IfcLShapeProfileDef", "IfcLabel", "IfcLaborResource", "IfcLampType", "IfcLampTypeEnum", "IfcLayerSetDirectionEnum", "IfcLayeredItem", "IfcLengthMeasure", "IfcLibraryInformation", "IfcLibraryReference", "IfcLibrarySelect", "IfcLightDistributionCurveEnum", "IfcLightDistributionData", "IfcLightDistributionDataSourceSelect", "IfcLightEmissionSourceEnum", "IfcLightFixtureType", "IfcLightFixtureTypeEnum", "IfcLightIntensityDistribution", "IfcLightSource", "IfcLightSourceAmbient", "IfcLightSourceDirectional", "IfcLightSourceGoniometric", "IfcLightSourcePositional", "IfcLightSourceSpot", "IfcLine", "IfcLinearDimension", "IfcLinearForceMeasure", "IfcLinearMomentMeasure", "IfcLinearStiffnessMeasure", "IfcLinearVelocityMeasure", "IfcLoadGroupTypeEnum", "IfcLocalPlacement", "IfcLocalTime", "IfcLogical", "IfcLogicalOperatorEnum", "IfcLoop", "IfcLuminousFluxMeasure", "IfcLuminousIntensityDistributionMeasure", "IfcLuminousIntensityMeasure", "IfcMagneticFluxDensityMeasure", "IfcMagneticFluxMeasure", "IfcManifoldSolidBrep", "IfcMappedItem", "IfcMassDensityMeasure", "IfcMassFlowRateMeasure", "IfcMassMeasure", "IfcMassPerLengthMeasure", "IfcMaterial", "IfcMaterialClassificationRelationship", "IfcMaterialDefinitionRepresentation", "IfcMaterialLayer", "IfcMaterialLayerSet", "IfcMaterialLayerSetUsage", "IfcMaterialList", "IfcMaterialProperties", "IfcMaterialSelect", "IfcMeasureValue", "IfcMeasureWithUnit", "IfcMechanicalConcreteMaterialProperties", "IfcMechanicalFastener", "IfcMechanicalFastenerType", "IfcMechanicalMaterialProperties", "IfcMechanicalSteelMaterialProperties", "IfcMember", "IfcMemberType", "IfcMemberTypeEnum", "IfcMetric", "IfcMetricValueSelect", "IfcMinuteInHour", "IfcModulusOfElasticityMeasure", "IfcModulusOfLinearSubgradeReactionMeasure", "IfcModulusOfRotationalSubgradeReactionMeasure", "IfcModulusOfSubgradeReactionMeasure", "IfcMoistureDiffusivityMeasure", "IfcMolecularWeightMeasure", "IfcMomentOfInertiaMeasure", "IfcMonetaryMeasure", "IfcMonetaryUnit", "IfcMonthInYearNumber", "IfcMotorConnectionType", "IfcMotorConnectionTypeEnum", "IfcMove", "IfcNamedUnit", "IfcNormalisedRatioMeasure", "IfcNullStyle", "IfcNumericMeasure", "IfcObject", "IfcObjectDefinition", "IfcObjectPlacement", "IfcObjectReferenceSelect", "IfcObjectTypeEnum", "IfcObjective", "IfcObjectiveEnum", "IfcOccupant", "IfcOccupantTypeEnum", "IfcOffsetCurve2D", "IfcOffsetCurve3D", "IfcOneDirectionRepeatFactor", "IfcOpenShell", "IfcOpeningElement", "IfcOpticalMaterialProperties", "IfcOrderAction", "IfcOrganization", "IfcOrganizationRelationship", "IfcOrientationSelect", "IfcOrientedEdge", "IfcOutletType", "IfcOutletTypeEnum", "IfcOwnerHistory", "IfcPHMeasure", "IfcParameterValue", "IfcParameterizedProfileDef", "IfcPath", "IfcPerformanceHistory", "IfcPermeableCoveringOperationEnum", "IfcPermeableCoveringProperties", "IfcPermit", "IfcPerson", "IfcPersonAndOrganization", "IfcPhysicalComplexQuantity", "IfcPhysicalOrVirtualEnum", "IfcPhysicalQuantity", "IfcPhysicalSimpleQuantity", "IfcPile", "IfcPileConstructionEnum", "IfcPileTypeEnum", "IfcPipeFittingType", "IfcPipeFittingTypeEnum", "IfcPipeSegmentType", "IfcPipeSegmentTypeEnum", "IfcPixelTexture", "IfcPlacement", "IfcPlanarBox", "IfcPlanarExtent", "IfcPlanarForceMeasure", "IfcPlane", "IfcPlaneAngleMeasure", "IfcPlate", "IfcPlateType", "IfcPlateTypeEnum", "IfcPoint", "IfcPointOnCurve", "IfcPointOnSurface", "IfcPointOrVertexPoint", "IfcPolyLoop", "IfcPolygonalBoundedHalfSpace", "IfcPolyline", "IfcPort", "IfcPositiveLengthMeasure", "IfcPositivePlaneAngleMeasure", "IfcPositiveRatioMeasure", "IfcPostalAddress", "IfcPowerMeasure", "IfcPreDefinedColour", "IfcPreDefinedCurveFont", "IfcPreDefinedDimensionSymbol", "IfcPreDefinedItem", "IfcPreDefinedPointMarkerSymbol", "IfcPreDefinedSymbol", "IfcPreDefinedTerminatorSymbol", "IfcPreDefinedTextFont", "IfcPresentableText", "IfcPresentationLayerAssignment", "IfcPresentationLayerWithStyle", "IfcPresentationStyle", "IfcPresentationStyleAssignment", "IfcPresentationStyleSelect", "IfcPressureMeasure", "IfcProcedure", "IfcProcedureTypeEnum", "IfcProcess", "IfcProduct", "IfcProductDefinitionShape", "IfcProductRepresentation", "IfcProductsOfCombustionProperties", "IfcProfileDef", "IfcProfileProperties", "IfcProfileTypeEnum", "IfcProject", "IfcProjectOrder", "IfcProjectOrderRecord", "IfcProjectOrderRecordTypeEnum", "IfcProjectOrderTypeEnum", "IfcProjectedOrTrueLengthEnum", "IfcProjectionCurve", "IfcProjectionElement", "IfcProperty", "IfcPropertyBoundedValue", "IfcPropertyConstraintRelationship", "IfcPropertyDefinition", "IfcPropertyDependencyRelationship", "IfcPropertyEnumeratedValue", "IfcPropertyEnumeration", "IfcPropertyListValue", "IfcPropertyReferenceValue", "IfcPropertySet", "IfcPropertySetDefinition", "IfcPropertySingleValue", "IfcPropertySourceEnum", "IfcPropertyTableValue", "IfcProtectiveDeviceType", "IfcProtectiveDeviceTypeEnum", "IfcProxy", "IfcPumpType", "IfcPumpTypeEnum", "IfcQuantityArea", "IfcQuantityCount", "IfcQuantityLength", "IfcQuantityTime", "IfcQuantityVolume", "IfcQuantityWeight", "IfcRadioActivityMeasure", "IfcRadiusDimension", "IfcRailing", "IfcRailingType", "IfcRailingTypeEnum", "IfcRamp", "IfcRampFlight", "IfcRampFlightType", "IfcRampFlightTypeEnum", "IfcRampTypeEnum", "IfcRatioMeasure", "IfcRationalBezierCurve", "IfcReal", "IfcRectangleHollowProfileDef", "IfcRectangleProfileDef", "IfcRectangularPyramid", "IfcRectangularTrimmedSurface", "IfcReferencesValueDocument", "IfcReflectanceMethodEnum", "IfcRegularTimeSeries", "IfcReinforcementBarProperties", "IfcReinforcementDefinitionProperties", "IfcReinforcingBar", "IfcReinforcingBarRoleEnum", "IfcReinforcingBarSurfaceEnum", "IfcReinforcingElement", "IfcReinforcingMesh", "IfcRelAggregates", "IfcRelAssigns", "IfcRelAssignsTasks", "IfcRelAssignsToActor", "IfcRelAssignsToControl", "IfcRelAssignsToGroup", "IfcRelAssignsToProcess", "IfcRelAssignsToProduct", "IfcRelAssignsToProjectOrder", "IfcRelAssignsToResource", "IfcRelAssociates", "IfcRelAssociatesAppliedValue", "IfcRelAssociatesApproval", "IfcRelAssociatesClassification", "IfcRelAssociatesConstraint", "IfcRelAssociatesDocument", "IfcRelAssociatesLibrary", "IfcRelAssociatesMaterial", "IfcRelAssociatesProfileProperties", "IfcRelConnects", "IfcRelConnectsElements", "IfcRelConnectsPathElements", "IfcRelConnectsPortToElement", "IfcRelConnectsPorts", "IfcRelConnectsStructuralActivity", "IfcRelConnectsStructuralElement", "IfcRelConnectsStructuralMember", "IfcRelConnectsWithEccentricity", "IfcRelConnectsWithRealizingElements", "IfcRelContainedInSpatialStructure", "IfcRelCoversBldgElements", "IfcRelCoversSpaces", "IfcRelDecomposes", "IfcRelDefines", "IfcRelDefinesByProperties", "IfcRelDefinesByType", "IfcRelFillsElement", "IfcRelFlowControlElements", "IfcRelInteractionRequirements", "IfcRelNests", "IfcRelOccupiesSpaces", "IfcRelOverridesProperties", "IfcRelProjectsElement", "IfcRelReferencedInSpatialStructure", "IfcRelSchedulesCostItems", "IfcRelSequence", "IfcRelServicesBuildings", "IfcRelSpaceBoundary", "IfcRelVoidsElement", "IfcRelationship", "IfcRelaxation", "IfcRepresentation", "IfcRepresentationContext", "IfcRepresentationItem", "IfcRepresentationMap", "IfcResource", "IfcResourceConsumptionEnum", "IfcRevolvedAreaSolid", "IfcRibPlateDirectionEnum", "IfcRibPlateProfileProperties", "IfcRightCircularCone", "IfcRightCircularCylinder", "IfcRoleEnum", "IfcRoof", "IfcRoofTypeEnum", "IfcRoot", "IfcRotationalFrequencyMeasure", "IfcRotationalMassMeasure", "IfcRotationalStiffnessMeasure", "IfcRoundedEdgeFeature", "IfcRoundedRectangleProfileDef", "IfcSIPrefix", "IfcSIUnit", "IfcSIUnitName", "IfcSanitaryTerminalType", "IfcSanitaryTerminalTypeEnum", "IfcScheduleTimeControl", "IfcSecondInMinute", "IfcSectionModulusMeasure", "IfcSectionProperties", "IfcSectionReinforcementProperties", "IfcSectionTypeEnum", "IfcSectionalAreaIntegralMeasure", "IfcSectionedSpine", "IfcSensorType", "IfcSensorTypeEnum", "IfcSequenceEnum", "IfcServiceLife", "IfcServiceLifeFactor", "IfcServiceLifeFactorTypeEnum", "IfcServiceLifeTypeEnum", "IfcShapeAspect", "IfcShapeModel", "IfcShapeRepresentation", "IfcShearModulusMeasure", "IfcShell", "IfcShellBasedSurfaceModel", "IfcSimpleProperty", "IfcSimpleValue", "IfcSite", "IfcSizeSelect", "IfcSlab", "IfcSlabType", "IfcSlabTypeEnum", "IfcSlippageConnectionCondition", "IfcSolidAngleMeasure", "IfcSolidModel", "IfcSoundPowerMeasure", "IfcSoundPressureMeasure", "IfcSoundProperties", "IfcSoundScaleEnum", "IfcSoundValue", "IfcSpace", "IfcSpaceHeaterType", "IfcSpaceHeaterTypeEnum", "IfcSpaceProgram", "IfcSpaceThermalLoadProperties", "IfcSpaceType", "IfcSpaceTypeEnum", "IfcSpatialStructureElement", "IfcSpatialStructureElementType", "IfcSpecificHeatCapacityMeasure", "IfcSpecularExponent", "IfcSpecularHighlightSelect", "IfcSpecularRoughness", "IfcSphere", "IfcStackTerminalType", "IfcStackTerminalTypeEnum", "IfcStair", "IfcStairFlight", "IfcStairFlightType", "IfcStairFlightTypeEnum", "IfcStairTypeEnum", "IfcStateEnum", "IfcStructuralAction", "IfcStructuralActivity", "IfcStructuralActivityAssignmentSelect", "IfcStructuralAnalysisModel", "IfcStructuralConnection", "IfcStructuralConnectionCondition", "IfcStructuralCurveConnection", "IfcStructuralCurveMember", "IfcStructuralCurveMemberVarying", "IfcStructuralCurveTypeEnum", "IfcStructuralItem", "IfcStructuralLinearAction", "IfcStructuralLinearActionVarying", "IfcStructuralLoad", "IfcStructuralLoadGroup", "IfcStructuralLoadLinearForce", "IfcStructuralLoadPlanarForce", "IfcStructuralLoadSingleDisplacement", "IfcStructuralLoadSingleDisplacementDistortion", "IfcStructuralLoadSingleForce", "IfcStructuralLoadSingleForceWarping", "IfcStructuralLoadStatic", "IfcStructuralLoadTemperature", "IfcStructuralMember", "IfcStructuralPlanarAction", "IfcStructuralPlanarActionVarying", "IfcStructuralPointAction", "IfcStructuralPointConnection", "IfcStructuralPointReaction", "IfcStructuralProfileProperties", "IfcStructuralReaction", "IfcStructuralResultGroup", "IfcStructuralSteelProfileProperties", "IfcStructuralSurfaceConnection", "IfcStructuralSurfaceMember", "IfcStructuralSurfaceMemberVarying", "IfcStructuralSurfaceTypeEnum", "IfcStructuredDimensionCallout", "IfcStyleModel", "IfcStyledItem", "IfcStyledRepresentation", "IfcSubContractResource", "IfcSubedge", "IfcSurface", "IfcSurfaceCurveSweptAreaSolid", "IfcSurfaceOfLinearExtrusion", "IfcSurfaceOfRevolution", "IfcSurfaceOrFaceSurface", "IfcSurfaceSide", "IfcSurfaceStyle", "IfcSurfaceStyleElementSelect", "IfcSurfaceStyleLighting", "IfcSurfaceStyleRefraction", "IfcSurfaceStyleRendering", "IfcSurfaceStyleShading", "IfcSurfaceStyleWithTextures", "IfcSurfaceTexture", "IfcSurfaceTextureEnum", "IfcSweptAreaSolid", "IfcSweptDiskSolid", "IfcSweptSurface", "IfcSwitchingDeviceType", "IfcSwitchingDeviceTypeEnum", "IfcSymbolStyle", "IfcSymbolStyleSelect", "IfcSystem", "IfcSystemFurnitureElementType", "IfcTShapeProfileDef", "IfcTable", "IfcTableRow", "IfcTankType", "IfcTankTypeEnum", "IfcTask", "IfcTelecomAddress", "IfcTemperatureGradientMeasure", "IfcTendon", "IfcTendonAnchor", "IfcTendonTypeEnum", "IfcTerminatorSymbol", "IfcText", "IfcTextAlignment", "IfcTextDecoration", "IfcTextFontName", "IfcTextFontSelect", "IfcTextLiteral", "IfcTextLiteralWithExtent", "IfcTextPath", "IfcTextStyle", "IfcTextStyleFontModel", "IfcTextStyleForDefinedFont", "IfcTextStyleSelect", "IfcTextStyleTextModel", "IfcTextStyleWithBoxCharacteristics", "IfcTextTransformation", "IfcTextureCoordinate", "IfcTextureCoordinateGenerator", "IfcTextureMap", "IfcTextureVertex", "IfcThermalAdmittanceMeasure", "IfcThermalConductivityMeasure", "IfcThermalExpansionCoefficientMeasure", "IfcThermalLoadSourceEnum", "IfcThermalLoadTypeEnum", "IfcThermalMaterialProperties", "IfcThermalResistanceMeasure", "IfcThermalTransmittanceMeasure", "IfcThermodynamicTemperatureMeasure", "IfcTimeMeasure", "IfcTimeSeries", "IfcTimeSeriesDataTypeEnum", "IfcTimeSeriesReferenceRelationship", "IfcTimeSeriesSchedule", "IfcTimeSeriesScheduleTypeEnum", "IfcTimeSeriesValue", "IfcTimeStamp", "IfcTopologicalRepresentationItem", "IfcTopologyRepresentation", "IfcTorqueMeasure", "IfcTransformerType", "IfcTransformerTypeEnum", "IfcTransitionCode", "IfcTransportElement", "IfcTransportElementType", "IfcTransportElementTypeEnum", "IfcTrapeziumProfileDef", "IfcTrimmedCurve", "IfcTrimmingPreference", "IfcTrimmingSelect", "IfcTubeBundleType", "IfcTubeBundleTypeEnum", "IfcTwoDirectionRepeatFactor", "IfcTypeObject", "IfcTypeProduct", "IfcUShapeProfileDef", "IfcUnit", "IfcUnitAssignment", "IfcUnitEnum", "IfcUnitaryEquipmentType", "IfcUnitaryEquipmentTypeEnum", "IfcValue", "IfcValveType", "IfcValveTypeEnum", "IfcVaporPermeabilityMeasure", "IfcVector", "IfcVectorOrDirection", "IfcVertex", "IfcVertexBasedTextureMap", "IfcVertexLoop", "IfcVertexPoint", "IfcVibrationIsolatorType", "IfcVibrationIsolatorTypeEnum", "IfcVirtualElement", "IfcVirtualGridIntersection", "IfcVolumeMeasure", "IfcVolumetricFlowRateMeasure", "IfcWall", "IfcWallStandardCase", "IfcWallType", "IfcWallTypeEnum", "IfcWarpingConstantMeasure", "IfcWarpingMomentMeasure", "IfcWasteTerminalType", "IfcWasteTerminalTypeEnum", "IfcWaterProperties", "IfcWindow", "IfcWindowLiningProperties", "IfcWindowPanelOperationEnum", "IfcWindowPanelPositionEnum", "IfcWindowPanelProperties", "IfcWindowStyle", "IfcWindowStyleConstructionEnum", "IfcWindowStyleOperationEnum", "IfcWorkControl", "IfcWorkControlTypeEnum", "IfcWorkPlan", "IfcWorkSchedule", "IfcYearNumber", "IfcZShapeProfileDef", "IfcZone" };
    return names[v];
}

static std::map<std::string,Type::Enum> string_map;
void Ifc2x3::InitStringMap() {
    string_map["IFC2DCOMPOSITECURVE"                           ] = Type::Ifc2DCompositeCurve;
    string_map["IFCABSORBEDDOSEMEASURE"                        ] = Type::IfcAbsorbedDoseMeasure;
    string_map["IFCACCELERATIONMEASURE"                        ] = Type::IfcAccelerationMeasure;
    string_map["IFCACTIONREQUEST"                              ] = Type::IfcActionRequest;
    string_map["IFCACTIONSOURCETYPEENUM"                       ] = Type::IfcActionSourceTypeEnum;
    string_map["IFCACTIONTYPEENUM"                             ] = Type::IfcActionTypeEnum;
    string_map["IFCACTOR"                                      ] = Type::IfcActor;
    string_map["IFCACTORROLE"                                  ] = Type::IfcActorRole;
    string_map["IFCACTORSELECT"                                ] = Type::IfcActorSelect;
    string_map["IFCACTUATORTYPE"                               ] = Type::IfcActuatorType;
    string_map["IFCACTUATORTYPEENUM"                           ] = Type::IfcActuatorTypeEnum;
    string_map["IFCADDRESS"                                    ] = Type::IfcAddress;
    string_map["IFCADDRESSTYPEENUM"                            ] = Type::IfcAddressTypeEnum;
    string_map["IFCAHEADORBEHIND"                              ] = Type::IfcAheadOrBehind;
    string_map["IFCAIRTERMINALBOXTYPE"                         ] = Type::IfcAirTerminalBoxType;
    string_map["IFCAIRTERMINALBOXTYPEENUM"                     ] = Type::IfcAirTerminalBoxTypeEnum;
    string_map["IFCAIRTERMINALTYPE"                            ] = Type::IfcAirTerminalType;
    string_map["IFCAIRTERMINALTYPEENUM"                        ] = Type::IfcAirTerminalTypeEnum;
    string_map["IFCAIRTOAIRHEATRECOVERYTYPE"                   ] = Type::IfcAirToAirHeatRecoveryType;
    string_map["IFCAIRTOAIRHEATRECOVERYTYPEENUM"               ] = Type::IfcAirToAirHeatRecoveryTypeEnum;
    string_map["IFCALARMTYPE"                                  ] = Type::IfcAlarmType;
    string_map["IFCALARMTYPEENUM"                              ] = Type::IfcAlarmTypeEnum;
    string_map["IFCAMOUNTOFSUBSTANCEMEASURE"                   ] = Type::IfcAmountOfSubstanceMeasure;
    string_map["IFCANALYSISMODELTYPEENUM"                      ] = Type::IfcAnalysisModelTypeEnum;
    string_map["IFCANALYSISTHEORYTYPEENUM"                     ] = Type::IfcAnalysisTheoryTypeEnum;
    string_map["IFCANGULARDIMENSION"                           ] = Type::IfcAngularDimension;
    string_map["IFCANGULARVELOCITYMEASURE"                     ] = Type::IfcAngularVelocityMeasure;
    string_map["IFCANNOTATION"                                 ] = Type::IfcAnnotation;
    string_map["IFCANNOTATIONCURVEOCCURRENCE"                  ] = Type::IfcAnnotationCurveOccurrence;
    string_map["IFCANNOTATIONFILLAREA"                         ] = Type::IfcAnnotationFillArea;
    string_map["IFCANNOTATIONFILLAREAOCCURRENCE"               ] = Type::IfcAnnotationFillAreaOccurrence;
    string_map["IFCANNOTATIONOCCURRENCE"                       ] = Type::IfcAnnotationOccurrence;
    string_map["IFCANNOTATIONSURFACE"                          ] = Type::IfcAnnotationSurface;
    string_map["IFCANNOTATIONSURFACEOCCURRENCE"                ] = Type::IfcAnnotationSurfaceOccurrence;
    string_map["IFCANNOTATIONSYMBOLOCCURRENCE"                 ] = Type::IfcAnnotationSymbolOccurrence;
    string_map["IFCANNOTATIONTEXTOCCURRENCE"                   ] = Type::IfcAnnotationTextOccurrence;
    string_map["IFCAPPLICATION"                                ] = Type::IfcApplication;
    string_map["IFCAPPLIEDVALUE"                               ] = Type::IfcAppliedValue;
    string_map["IFCAPPLIEDVALUERELATIONSHIP"                   ] = Type::IfcAppliedValueRelationship;
    string_map["IFCAPPLIEDVALUESELECT"                         ] = Type::IfcAppliedValueSelect;
    string_map["IFCAPPROVAL"                                   ] = Type::IfcApproval;
    string_map["IFCAPPROVALACTORRELATIONSHIP"                  ] = Type::IfcApprovalActorRelationship;
    string_map["IFCAPPROVALPROPERTYRELATIONSHIP"               ] = Type::IfcApprovalPropertyRelationship;
    string_map["IFCAPPROVALRELATIONSHIP"                       ] = Type::IfcApprovalRelationship;
    string_map["IFCARBITRARYCLOSEDPROFILEDEF"                  ] = Type::IfcArbitraryClosedProfileDef;
    string_map["IFCARBITRARYOPENPROFILEDEF"                    ] = Type::IfcArbitraryOpenProfileDef;
    string_map["IFCARBITRARYPROFILEDEFWITHVOIDS"               ] = Type::IfcArbitraryProfileDefWithVoids;
    string_map["IFCAREAMEASURE"                                ] = Type::IfcAreaMeasure;
    string_map["IFCARITHMETICOPERATORENUM"                     ] = Type::IfcArithmeticOperatorEnum;
    string_map["IFCASSEMBLYPLACEENUM"                          ] = Type::IfcAssemblyPlaceEnum;
    string_map["IFCASSET"                                      ] = Type::IfcAsset;
    string_map["IFCASYMMETRICISHAPEPROFILEDEF"                 ] = Type::IfcAsymmetricIShapeProfileDef;
    string_map["IFCAXIS1PLACEMENT"                             ] = Type::IfcAxis1Placement;
    string_map["IFCAXIS2PLACEMENT"                             ] = Type::IfcAxis2Placement;
    string_map["IFCAXIS2PLACEMENT2D"                           ] = Type::IfcAxis2Placement2D;
    string_map["IFCAXIS2PLACEMENT3D"                           ] = Type::IfcAxis2Placement3D;
    string_map["IFCBSPLINECURVE"                               ] = Type::IfcBSplineCurve;
    string_map["IFCBSPLINECURVEFORM"                           ] = Type::IfcBSplineCurveForm;
    string_map["IFCBEAM"                                       ] = Type::IfcBeam;
    string_map["IFCBEAMTYPE"                                   ] = Type::IfcBeamType;
    string_map["IFCBEAMTYPEENUM"                               ] = Type::IfcBeamTypeEnum;
    string_map["IFCBENCHMARKENUM"                              ] = Type::IfcBenchmarkEnum;
    string_map["IFCBEZIERCURVE"                                ] = Type::IfcBezierCurve;
    string_map["IFCBLOBTEXTURE"                                ] = Type::IfcBlobTexture;
    string_map["IFCBLOCK"                                      ] = Type::IfcBlock;
    string_map["IFCBOILERTYPE"                                 ] = Type::IfcBoilerType;
    string_map["IFCBOILERTYPEENUM"                             ] = Type::IfcBoilerTypeEnum;
    string_map["IFCBOOLEAN"                                    ] = Type::IfcBoolean;
    string_map["IFCBOOLEANCLIPPINGRESULT"                      ] = Type::IfcBooleanClippingResult;
    string_map["IFCBOOLEANOPERAND"                             ] = Type::IfcBooleanOperand;
    string_map["IFCBOOLEANOPERATOR"                            ] = Type::IfcBooleanOperator;
    string_map["IFCBOOLEANRESULT"                              ] = Type::IfcBooleanResult;
    string_map["IFCBOUNDARYCONDITION"                          ] = Type::IfcBoundaryCondition;
    string_map["IFCBOUNDARYEDGECONDITION"                      ] = Type::IfcBoundaryEdgeCondition;
    string_map["IFCBOUNDARYFACECONDITION"                      ] = Type::IfcBoundaryFaceCondition;
    string_map["IFCBOUNDARYNODECONDITION"                      ] = Type::IfcBoundaryNodeCondition;
    string_map["IFCBOUNDARYNODECONDITIONWARPING"               ] = Type::IfcBoundaryNodeConditionWarping;
    string_map["IFCBOUNDEDCURVE"                               ] = Type::IfcBoundedCurve;
    string_map["IFCBOUNDEDSURFACE"                             ] = Type::IfcBoundedSurface;
    string_map["IFCBOUNDINGBOX"                                ] = Type::IfcBoundingBox;
    string_map["IFCBOXALIGNMENT"                               ] = Type::IfcBoxAlignment;
    string_map["IFCBOXEDHALFSPACE"                             ] = Type::IfcBoxedHalfSpace;
    string_map["IFCBUILDING"                                   ] = Type::IfcBuilding;
    string_map["IFCBUILDINGELEMENT"                            ] = Type::IfcBuildingElement;
    string_map["IFCBUILDINGELEMENTCOMPONENT"                   ] = Type::IfcBuildingElementComponent;
    string_map["IFCBUILDINGELEMENTPART"                        ] = Type::IfcBuildingElementPart;
    string_map["IFCBUILDINGELEMENTPROXY"                       ] = Type::IfcBuildingElementProxy;
    string_map["IFCBUILDINGELEMENTPROXYTYPE"                   ] = Type::IfcBuildingElementProxyType;
    string_map["IFCBUILDINGELEMENTPROXYTYPEENUM"               ] = Type::IfcBuildingElementProxyTypeEnum;
    string_map["IFCBUILDINGELEMENTTYPE"                        ] = Type::IfcBuildingElementType;
    string_map["IFCBUILDINGSTOREY"                             ] = Type::IfcBuildingStorey;
    string_map["IFCCSHAPEPROFILEDEF"                           ] = Type::IfcCShapeProfileDef;
    string_map["IFCCABLECARRIERFITTINGTYPE"                    ] = Type::IfcCableCarrierFittingType;
    string_map["IFCCABLECARRIERFITTINGTYPEENUM"                ] = Type::IfcCableCarrierFittingTypeEnum;
    string_map["IFCCABLECARRIERSEGMENTTYPE"                    ] = Type::IfcCableCarrierSegmentType;
    string_map["IFCCABLECARRIERSEGMENTTYPEENUM"                ] = Type::IfcCableCarrierSegmentTypeEnum;
    string_map["IFCCABLESEGMENTTYPE"                           ] = Type::IfcCableSegmentType;
    string_map["IFCCABLESEGMENTTYPEENUM"                       ] = Type::IfcCableSegmentTypeEnum;
    string_map["IFCCALENDARDATE"                               ] = Type::IfcCalendarDate;
    string_map["IFCCARTESIANPOINT"                             ] = Type::IfcCartesianPoint;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR"            ] = Type::IfcCartesianTransformationOperator;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2D"          ] = Type::IfcCartesianTransformationOperator2D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM"] = Type::IfcCartesianTransformationOperator2DnonUniform;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3D"          ] = Type::IfcCartesianTransformationOperator3D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM"] = Type::IfcCartesianTransformationOperator3DnonUniform;
    string_map["IFCCENTERLINEPROFILEDEF"                       ] = Type::IfcCenterLineProfileDef;
    string_map["IFCCHAMFEREDGEFEATURE"                         ] = Type::IfcChamferEdgeFeature;
    string_map["IFCCHANGEACTIONENUM"                           ] = Type::IfcChangeActionEnum;
    string_map["IFCCHARACTERSTYLESELECT"                       ] = Type::IfcCharacterStyleSelect;
    string_map["IFCCHILLERTYPE"                                ] = Type::IfcChillerType;
    string_map["IFCCHILLERTYPEENUM"                            ] = Type::IfcChillerTypeEnum;
    string_map["IFCCIRCLE"                                     ] = Type::IfcCircle;
    string_map["IFCCIRCLEHOLLOWPROFILEDEF"                     ] = Type::IfcCircleHollowProfileDef;
    string_map["IFCCIRCLEPROFILEDEF"                           ] = Type::IfcCircleProfileDef;
    string_map["IFCCLASSIFICATION"                             ] = Type::IfcClassification;
    string_map["IFCCLASSIFICATIONITEM"                         ] = Type::IfcClassificationItem;
    string_map["IFCCLASSIFICATIONITEMRELATIONSHIP"             ] = Type::IfcClassificationItemRelationship;
    string_map["IFCCLASSIFICATIONNOTATION"                     ] = Type::IfcClassificationNotation;
    string_map["IFCCLASSIFICATIONNOTATIONFACET"                ] = Type::IfcClassificationNotationFacet;
    string_map["IFCCLASSIFICATIONNOTATIONSELECT"               ] = Type::IfcClassificationNotationSelect;
    string_map["IFCCLASSIFICATIONREFERENCE"                    ] = Type::IfcClassificationReference;
    string_map["IFCCLOSEDSHELL"                                ] = Type::IfcClosedShell;
    string_map["IFCCOILTYPE"                                   ] = Type::IfcCoilType;
    string_map["IFCCOILTYPEENUM"                               ] = Type::IfcCoilTypeEnum;
    string_map["IFCCOLOUR"                                     ] = Type::IfcColour;
    string_map["IFCCOLOURORFACTOR"                             ] = Type::IfcColourOrFactor;
    string_map["IFCCOLOURRGB"                                  ] = Type::IfcColourRgb;
    string_map["IFCCOLOURSPECIFICATION"                        ] = Type::IfcColourSpecification;
    string_map["IFCCOLUMN"                                     ] = Type::IfcColumn;
    string_map["IFCCOLUMNTYPE"                                 ] = Type::IfcColumnType;
    string_map["IFCCOLUMNTYPEENUM"                             ] = Type::IfcColumnTypeEnum;
    string_map["IFCCOMPLEXNUMBER"                              ] = Type::IfcComplexNumber;
    string_map["IFCCOMPLEXPROPERTY"                            ] = Type::IfcComplexProperty;
    string_map["IFCCOMPOSITECURVE"                             ] = Type::IfcCompositeCurve;
    string_map["IFCCOMPOSITECURVESEGMENT"                      ] = Type::IfcCompositeCurveSegment;
    string_map["IFCCOMPOSITEPROFILEDEF"                        ] = Type::IfcCompositeProfileDef;
    string_map["IFCCOMPOUNDPLANEANGLEMEASURE"                  ] = Type::IfcCompoundPlaneAngleMeasure;
    string_map["IFCCOMPRESSORTYPE"                             ] = Type::IfcCompressorType;
    string_map["IFCCOMPRESSORTYPEENUM"                         ] = Type::IfcCompressorTypeEnum;
    string_map["IFCCONDENSERTYPE"                              ] = Type::IfcCondenserType;
    string_map["IFCCONDENSERTYPEENUM"                          ] = Type::IfcCondenserTypeEnum;
    string_map["IFCCONDITION"                                  ] = Type::IfcCondition;
    string_map["IFCCONDITIONCRITERION"                         ] = Type::IfcConditionCriterion;
    string_map["IFCCONDITIONCRITERIONSELECT"                   ] = Type::IfcConditionCriterionSelect;
    string_map["IFCCONIC"                                      ] = Type::IfcConic;
    string_map["IFCCONNECTEDFACESET"                           ] = Type::IfcConnectedFaceSet;
    string_map["IFCCONNECTIONCURVEGEOMETRY"                    ] = Type::IfcConnectionCurveGeometry;
    string_map["IFCCONNECTIONGEOMETRY"                         ] = Type::IfcConnectionGeometry;
    string_map["IFCCONNECTIONPOINTECCENTRICITY"                ] = Type::IfcConnectionPointEccentricity;
    string_map["IFCCONNECTIONPOINTGEOMETRY"                    ] = Type::IfcConnectionPointGeometry;
    string_map["IFCCONNECTIONPORTGEOMETRY"                     ] = Type::IfcConnectionPortGeometry;
    string_map["IFCCONNECTIONSURFACEGEOMETRY"                  ] = Type::IfcConnectionSurfaceGeometry;
    string_map["IFCCONNECTIONTYPEENUM"                         ] = Type::IfcConnectionTypeEnum;
    string_map["IFCCONSTRAINT"                                 ] = Type::IfcConstraint;
    string_map["IFCCONSTRAINTAGGREGATIONRELATIONSHIP"          ] = Type::IfcConstraintAggregationRelationship;
    string_map["IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP"       ] = Type::IfcConstraintClassificationRelationship;
    string_map["IFCCONSTRAINTENUM"                             ] = Type::IfcConstraintEnum;
    string_map["IFCCONSTRAINTRELATIONSHIP"                     ] = Type::IfcConstraintRelationship;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCE"              ] = Type::IfcConstructionEquipmentResource;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCE"               ] = Type::IfcConstructionMaterialResource;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCE"                ] = Type::IfcConstructionProductResource;
    string_map["IFCCONSTRUCTIONRESOURCE"                       ] = Type::IfcConstructionResource;
    string_map["IFCCONTEXTDEPENDENTMEASURE"                    ] = Type::IfcContextDependentMeasure;
    string_map["IFCCONTEXTDEPENDENTUNIT"                       ] = Type::IfcContextDependentUnit;
    string_map["IFCCONTROL"                                    ] = Type::IfcControl;
    string_map["IFCCONTROLLERTYPE"                             ] = Type::IfcControllerType;
    string_map["IFCCONTROLLERTYPEENUM"                         ] = Type::IfcControllerTypeEnum;
    string_map["IFCCONVERSIONBASEDUNIT"                        ] = Type::IfcConversionBasedUnit;
    string_map["IFCCOOLEDBEAMTYPE"                             ] = Type::IfcCooledBeamType;
    string_map["IFCCOOLEDBEAMTYPEENUM"                         ] = Type::IfcCooledBeamTypeEnum;
    string_map["IFCCOOLINGTOWERTYPE"                           ] = Type::IfcCoolingTowerType;
    string_map["IFCCOOLINGTOWERTYPEENUM"                       ] = Type::IfcCoolingTowerTypeEnum;
    string_map["IFCCOORDINATEDUNIVERSALTIMEOFFSET"             ] = Type::IfcCoordinatedUniversalTimeOffset;
    string_map["IFCCOSTITEM"                                   ] = Type::IfcCostItem;
    string_map["IFCCOSTSCHEDULE"                               ] = Type::IfcCostSchedule;
    string_map["IFCCOSTSCHEDULETYPEENUM"                       ] = Type::IfcCostScheduleTypeEnum;
    string_map["IFCCOSTVALUE"                                  ] = Type::IfcCostValue;
    string_map["IFCCOUNTMEASURE"                               ] = Type::IfcCountMeasure;
    string_map["IFCCOVERING"                                   ] = Type::IfcCovering;
    string_map["IFCCOVERINGTYPE"                               ] = Type::IfcCoveringType;
    string_map["IFCCOVERINGTYPEENUM"                           ] = Type::IfcCoveringTypeEnum;
    string_map["IFCCRANERAILASHAPEPROFILEDEF"                  ] = Type::IfcCraneRailAShapeProfileDef;
    string_map["IFCCRANERAILFSHAPEPROFILEDEF"                  ] = Type::IfcCraneRailFShapeProfileDef;
    string_map["IFCCREWRESOURCE"                               ] = Type::IfcCrewResource;
    string_map["IFCCSGPRIMITIVE3D"                             ] = Type::IfcCsgPrimitive3D;
    string_map["IFCCSGSELECT"                                  ] = Type::IfcCsgSelect;
    string_map["IFCCSGSOLID"                                   ] = Type::IfcCsgSolid;
    string_map["IFCCURRENCYENUM"                               ] = Type::IfcCurrencyEnum;
    string_map["IFCCURRENCYRELATIONSHIP"                       ] = Type::IfcCurrencyRelationship;
    string_map["IFCCURTAINWALL"                                ] = Type::IfcCurtainWall;
    string_map["IFCCURTAINWALLTYPE"                            ] = Type::IfcCurtainWallType;
    string_map["IFCCURTAINWALLTYPEENUM"                        ] = Type::IfcCurtainWallTypeEnum;
    string_map["IFCCURVATUREMEASURE"                           ] = Type::IfcCurvatureMeasure;
    string_map["IFCCURVE"                                      ] = Type::IfcCurve;
    string_map["IFCCURVEBOUNDEDPLANE"                          ] = Type::IfcCurveBoundedPlane;
    string_map["IFCCURVEFONTORSCALEDCURVEFONTSELECT"           ] = Type::IfcCurveFontOrScaledCurveFontSelect;
    string_map["IFCCURVEOREDGECURVE"                           ] = Type::IfcCurveOrEdgeCurve;
    string_map["IFCCURVESTYLE"                                 ] = Type::IfcCurveStyle;
    string_map["IFCCURVESTYLEFONT"                             ] = Type::IfcCurveStyleFont;
    string_map["IFCCURVESTYLEFONTANDSCALING"                   ] = Type::IfcCurveStyleFontAndScaling;
    string_map["IFCCURVESTYLEFONTPATTERN"                      ] = Type::IfcCurveStyleFontPattern;
    string_map["IFCCURVESTYLEFONTSELECT"                       ] = Type::IfcCurveStyleFontSelect;
    string_map["IFCDAMPERTYPE"                                 ] = Type::IfcDamperType;
    string_map["IFCDAMPERTYPEENUM"                             ] = Type::IfcDamperTypeEnum;
    string_map["IFCDATAORIGINENUM"                             ] = Type::IfcDataOriginEnum;
    string_map["IFCDATEANDTIME"                                ] = Type::IfcDateAndTime;
    string_map["IFCDATETIMESELECT"                             ] = Type::IfcDateTimeSelect;
    string_map["IFCDAYINMONTHNUMBER"                           ] = Type::IfcDayInMonthNumber;
    string_map["IFCDAYLIGHTSAVINGHOUR"                         ] = Type::IfcDaylightSavingHour;
    string_map["IFCDEFINEDSYMBOL"                              ] = Type::IfcDefinedSymbol;
    string_map["IFCDEFINEDSYMBOLSELECT"                        ] = Type::IfcDefinedSymbolSelect;
    string_map["IFCDERIVEDMEASUREVALUE"                        ] = Type::IfcDerivedMeasureValue;
    string_map["IFCDERIVEDPROFILEDEF"                          ] = Type::IfcDerivedProfileDef;
    string_map["IFCDERIVEDUNIT"                                ] = Type::IfcDerivedUnit;
    string_map["IFCDERIVEDUNITELEMENT"                         ] = Type::IfcDerivedUnitElement;
    string_map["IFCDERIVEDUNITENUM"                            ] = Type::IfcDerivedUnitEnum;
    string_map["IFCDESCRIPTIVEMEASURE"                         ] = Type::IfcDescriptiveMeasure;
    string_map["IFCDIAMETERDIMENSION"                          ] = Type::IfcDiameterDimension;
    string_map["IFCDIMENSIONCALLOUTRELATIONSHIP"               ] = Type::IfcDimensionCalloutRelationship;
    string_map["IFCDIMENSIONCOUNT"                             ] = Type::IfcDimensionCount;
    string_map["IFCDIMENSIONCURVE"                             ] = Type::IfcDimensionCurve;
    string_map["IFCDIMENSIONCURVEDIRECTEDCALLOUT"              ] = Type::IfcDimensionCurveDirectedCallout;
    string_map["IFCDIMENSIONCURVETERMINATOR"                   ] = Type::IfcDimensionCurveTerminator;
    string_map["IFCDIMENSIONEXTENTUSAGE"                       ] = Type::IfcDimensionExtentUsage;
    string_map["IFCDIMENSIONPAIR"                              ] = Type::IfcDimensionPair;
    string_map["IFCDIMENSIONALEXPONENTS"                       ] = Type::IfcDimensionalExponents;
    string_map["IFCDIRECTION"                                  ] = Type::IfcDirection;
    string_map["IFCDIRECTIONSENSEENUM"                         ] = Type::IfcDirectionSenseEnum;
    string_map["IFCDISCRETEACCESSORY"                          ] = Type::IfcDiscreteAccessory;
    string_map["IFCDISCRETEACCESSORYTYPE"                      ] = Type::IfcDiscreteAccessoryType;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENT"                 ] = Type::IfcDistributionChamberElement;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENTTYPE"             ] = Type::IfcDistributionChamberElementType;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENTTYPEENUM"         ] = Type::IfcDistributionChamberElementTypeEnum;
    string_map["IFCDISTRIBUTIONCONTROLELEMENT"                 ] = Type::IfcDistributionControlElement;
    string_map["IFCDISTRIBUTIONCONTROLELEMENTTYPE"             ] = Type::IfcDistributionControlElementType;
    string_map["IFCDISTRIBUTIONELEMENT"                        ] = Type::IfcDistributionElement;
    string_map["IFCDISTRIBUTIONELEMENTTYPE"                    ] = Type::IfcDistributionElementType;
    string_map["IFCDISTRIBUTIONFLOWELEMENT"                    ] = Type::IfcDistributionFlowElement;
    string_map["IFCDISTRIBUTIONFLOWELEMENTTYPE"                ] = Type::IfcDistributionFlowElementType;
    string_map["IFCDISTRIBUTIONPORT"                           ] = Type::IfcDistributionPort;
    string_map["IFCDOCUMENTCONFIDENTIALITYENUM"                ] = Type::IfcDocumentConfidentialityEnum;
    string_map["IFCDOCUMENTELECTRONICFORMAT"                   ] = Type::IfcDocumentElectronicFormat;
    string_map["IFCDOCUMENTINFORMATION"                        ] = Type::IfcDocumentInformation;
    string_map["IFCDOCUMENTINFORMATIONRELATIONSHIP"            ] = Type::IfcDocumentInformationRelationship;
    string_map["IFCDOCUMENTREFERENCE"                          ] = Type::IfcDocumentReference;
    string_map["IFCDOCUMENTSELECT"                             ] = Type::IfcDocumentSelect;
    string_map["IFCDOCUMENTSTATUSENUM"                         ] = Type::IfcDocumentStatusEnum;
    string_map["IFCDOOR"                                       ] = Type::IfcDoor;
    string_map["IFCDOORLININGPROPERTIES"                       ] = Type::IfcDoorLiningProperties;
    string_map["IFCDOORPANELOPERATIONENUM"                     ] = Type::IfcDoorPanelOperationEnum;
    string_map["IFCDOORPANELPOSITIONENUM"                      ] = Type::IfcDoorPanelPositionEnum;
    string_map["IFCDOORPANELPROPERTIES"                        ] = Type::IfcDoorPanelProperties;
    string_map["IFCDOORSTYLE"                                  ] = Type::IfcDoorStyle;
    string_map["IFCDOORSTYLECONSTRUCTIONENUM"                  ] = Type::IfcDoorStyleConstructionEnum;
    string_map["IFCDOORSTYLEOPERATIONENUM"                     ] = Type::IfcDoorStyleOperationEnum;
    string_map["IFCDOSEEQUIVALENTMEASURE"                      ] = Type::IfcDoseEquivalentMeasure;
    string_map["IFCDRAUGHTINGCALLOUT"                          ] = Type::IfcDraughtingCallout;
    string_map["IFCDRAUGHTINGCALLOUTELEMENT"                   ] = Type::IfcDraughtingCalloutElement;
    string_map["IFCDRAUGHTINGCALLOUTRELATIONSHIP"              ] = Type::IfcDraughtingCalloutRelationship;
    string_map["IFCDRAUGHTINGPREDEFINEDCOLOUR"                 ] = Type::IfcDraughtingPreDefinedColour;
    string_map["IFCDRAUGHTINGPREDEFINEDCURVEFONT"              ] = Type::IfcDraughtingPreDefinedCurveFont;
    string_map["IFCDRAUGHTINGPREDEFINEDTEXTFONT"               ] = Type::IfcDraughtingPreDefinedTextFont;
    string_map["IFCDUCTFITTINGTYPE"                            ] = Type::IfcDuctFittingType;
    string_map["IFCDUCTFITTINGTYPEENUM"                        ] = Type::IfcDuctFittingTypeEnum;
    string_map["IFCDUCTSEGMENTTYPE"                            ] = Type::IfcDuctSegmentType;
    string_map["IFCDUCTSEGMENTTYPEENUM"                        ] = Type::IfcDuctSegmentTypeEnum;
    string_map["IFCDUCTSILENCERTYPE"                           ] = Type::IfcDuctSilencerType;
    string_map["IFCDUCTSILENCERTYPEENUM"                       ] = Type::IfcDuctSilencerTypeEnum;
    string_map["IFCDYNAMICVISCOSITYMEASURE"                    ] = Type::IfcDynamicViscosityMeasure;
    string_map["IFCEDGE"                                       ] = Type::IfcEdge;
    string_map["IFCEDGECURVE"                                  ] = Type::IfcEdgeCurve;
    string_map["IFCEDGEFEATURE"                                ] = Type::IfcEdgeFeature;
    string_map["IFCEDGELOOP"                                   ] = Type::IfcEdgeLoop;
    string_map["IFCELECTRICAPPLIANCETYPE"                      ] = Type::IfcElectricApplianceType;
    string_map["IFCELECTRICAPPLIANCETYPEENUM"                  ] = Type::IfcElectricApplianceTypeEnum;
    string_map["IFCELECTRICCAPACITANCEMEASURE"                 ] = Type::IfcElectricCapacitanceMeasure;
    string_map["IFCELECTRICCHARGEMEASURE"                      ] = Type::IfcElectricChargeMeasure;
    string_map["IFCELECTRICCONDUCTANCEMEASURE"                 ] = Type::IfcElectricConductanceMeasure;
    string_map["IFCELECTRICCURRENTENUM"                        ] = Type::IfcElectricCurrentEnum;
    string_map["IFCELECTRICCURRENTMEASURE"                     ] = Type::IfcElectricCurrentMeasure;
    string_map["IFCELECTRICDISTRIBUTIONPOINT"                  ] = Type::IfcElectricDistributionPoint;
    string_map["IFCELECTRICDISTRIBUTIONPOINTFUNCTIONENUM"      ] = Type::IfcElectricDistributionPointFunctionEnum;
    string_map["IFCELECTRICFLOWSTORAGEDEVICETYPE"              ] = Type::IfcElectricFlowStorageDeviceType;
    string_map["IFCELECTRICFLOWSTORAGEDEVICETYPEENUM"          ] = Type::IfcElectricFlowStorageDeviceTypeEnum;
    string_map["IFCELECTRICGENERATORTYPE"                      ] = Type::IfcElectricGeneratorType;
    string_map["IFCELECTRICGENERATORTYPEENUM"                  ] = Type::IfcElectricGeneratorTypeEnum;
    string_map["IFCELECTRICHEATERTYPE"                         ] = Type::IfcElectricHeaterType;
    string_map["IFCELECTRICHEATERTYPEENUM"                     ] = Type::IfcElectricHeaterTypeEnum;
    string_map["IFCELECTRICMOTORTYPE"                          ] = Type::IfcElectricMotorType;
    string_map["IFCELECTRICMOTORTYPEENUM"                      ] = Type::IfcElectricMotorTypeEnum;
    string_map["IFCELECTRICRESISTANCEMEASURE"                  ] = Type::IfcElectricResistanceMeasure;
    string_map["IFCELECTRICTIMECONTROLTYPE"                    ] = Type::IfcElectricTimeControlType;
    string_map["IFCELECTRICTIMECONTROLTYPEENUM"                ] = Type::IfcElectricTimeControlTypeEnum;
    string_map["IFCELECTRICVOLTAGEMEASURE"                     ] = Type::IfcElectricVoltageMeasure;
    string_map["IFCELECTRICALBASEPROPERTIES"                   ] = Type::IfcElectricalBaseProperties;
    string_map["IFCELECTRICALCIRCUIT"                          ] = Type::IfcElectricalCircuit;
    string_map["IFCELECTRICALELEMENT"                          ] = Type::IfcElectricalElement;
    string_map["IFCELEMENT"                                    ] = Type::IfcElement;
    string_map["IFCELEMENTASSEMBLY"                            ] = Type::IfcElementAssembly;
    string_map["IFCELEMENTASSEMBLYTYPEENUM"                    ] = Type::IfcElementAssemblyTypeEnum;
    string_map["IFCELEMENTCOMPONENT"                           ] = Type::IfcElementComponent;
    string_map["IFCELEMENTCOMPONENTTYPE"                       ] = Type::IfcElementComponentType;
    string_map["IFCELEMENTCOMPOSITIONENUM"                     ] = Type::IfcElementCompositionEnum;
    string_map["IFCELEMENTQUANTITY"                            ] = Type::IfcElementQuantity;
    string_map["IFCELEMENTTYPE"                                ] = Type::IfcElementType;
    string_map["IFCELEMENTARYSURFACE"                          ] = Type::IfcElementarySurface;
    string_map["IFCELLIPSE"                                    ] = Type::IfcEllipse;
    string_map["IFCELLIPSEPROFILEDEF"                          ] = Type::IfcEllipseProfileDef;
    string_map["IFCENERGYCONVERSIONDEVICE"                     ] = Type::IfcEnergyConversionDevice;
    string_map["IFCENERGYCONVERSIONDEVICETYPE"                 ] = Type::IfcEnergyConversionDeviceType;
    string_map["IFCENERGYMEASURE"                              ] = Type::IfcEnergyMeasure;
    string_map["IFCENERGYPROPERTIES"                           ] = Type::IfcEnergyProperties;
    string_map["IFCENERGYSEQUENCEENUM"                         ] = Type::IfcEnergySequenceEnum;
    string_map["IFCENVIRONMENTALIMPACTCATEGORYENUM"            ] = Type::IfcEnvironmentalImpactCategoryEnum;
    string_map["IFCENVIRONMENTALIMPACTVALUE"                   ] = Type::IfcEnvironmentalImpactValue;
    string_map["IFCEQUIPMENTELEMENT"                           ] = Type::IfcEquipmentElement;
    string_map["IFCEQUIPMENTSTANDARD"                          ] = Type::IfcEquipmentStandard;
    string_map["IFCEVAPORATIVECOOLERTYPE"                      ] = Type::IfcEvaporativeCoolerType;
    string_map["IFCEVAPORATIVECOOLERTYPEENUM"                  ] = Type::IfcEvaporativeCoolerTypeEnum;
    string_map["IFCEVAPORATORTYPE"                             ] = Type::IfcEvaporatorType;
    string_map["IFCEVAPORATORTYPEENUM"                         ] = Type::IfcEvaporatorTypeEnum;
    string_map["IFCEXTENDEDMATERIALPROPERTIES"                 ] = Type::IfcExtendedMaterialProperties;
    string_map["IFCEXTERNALREFERENCE"                          ] = Type::IfcExternalReference;
    string_map["IFCEXTERNALLYDEFINEDHATCHSTYLE"                ] = Type::IfcExternallyDefinedHatchStyle;
    string_map["IFCEXTERNALLYDEFINEDSURFACESTYLE"              ] = Type::IfcExternallyDefinedSurfaceStyle;
    string_map["IFCEXTERNALLYDEFINEDSYMBOL"                    ] = Type::IfcExternallyDefinedSymbol;
    string_map["IFCEXTERNALLYDEFINEDTEXTFONT"                  ] = Type::IfcExternallyDefinedTextFont;
    string_map["IFCEXTRUDEDAREASOLID"                          ] = Type::IfcExtrudedAreaSolid;
    string_map["IFCFACE"                                       ] = Type::IfcFace;
    string_map["IFCFACEBASEDSURFACEMODEL"                      ] = Type::IfcFaceBasedSurfaceModel;
    string_map["IFCFACEBOUND"                                  ] = Type::IfcFaceBound;
    string_map["IFCFACEOUTERBOUND"                             ] = Type::IfcFaceOuterBound;
    string_map["IFCFACESURFACE"                                ] = Type::IfcFaceSurface;
    string_map["IFCFACETEDBREP"                                ] = Type::IfcFacetedBrep;
    string_map["IFCFACETEDBREPWITHVOIDS"                       ] = Type::IfcFacetedBrepWithVoids;
    string_map["IFCFAILURECONNECTIONCONDITION"                 ] = Type::IfcFailureConnectionCondition;
    string_map["IFCFANTYPE"                                    ] = Type::IfcFanType;
    string_map["IFCFANTYPEENUM"                                ] = Type::IfcFanTypeEnum;
    string_map["IFCFASTENER"                                   ] = Type::IfcFastener;
    string_map["IFCFASTENERTYPE"                               ] = Type::IfcFastenerType;
    string_map["IFCFEATUREELEMENT"                             ] = Type::IfcFeatureElement;
    string_map["IFCFEATUREELEMENTADDITION"                     ] = Type::IfcFeatureElementAddition;
    string_map["IFCFEATUREELEMENTSUBTRACTION"                  ] = Type::IfcFeatureElementSubtraction;
    string_map["IFCFILLAREASTYLE"                              ] = Type::IfcFillAreaStyle;
    string_map["IFCFILLAREASTYLEHATCHING"                      ] = Type::IfcFillAreaStyleHatching;
    string_map["IFCFILLAREASTYLETILESHAPESELECT"               ] = Type::IfcFillAreaStyleTileShapeSelect;
    string_map["IFCFILLAREASTYLETILESYMBOLWITHSTYLE"           ] = Type::IfcFillAreaStyleTileSymbolWithStyle;
    string_map["IFCFILLAREASTYLETILES"                         ] = Type::IfcFillAreaStyleTiles;
    string_map["IFCFILLSTYLESELECT"                            ] = Type::IfcFillStyleSelect;
    string_map["IFCFILTERTYPE"                                 ] = Type::IfcFilterType;
    string_map["IFCFILTERTYPEENUM"                             ] = Type::IfcFilterTypeEnum;
    string_map["IFCFIRESUPPRESSIONTERMINALTYPE"                ] = Type::IfcFireSuppressionTerminalType;
    string_map["IFCFIRESUPPRESSIONTERMINALTYPEENUM"            ] = Type::IfcFireSuppressionTerminalTypeEnum;
    string_map["IFCFLOWCONTROLLER"                             ] = Type::IfcFlowController;
    string_map["IFCFLOWCONTROLLERTYPE"                         ] = Type::IfcFlowControllerType;
    string_map["IFCFLOWDIRECTIONENUM"                          ] = Type::IfcFlowDirectionEnum;
    string_map["IFCFLOWFITTING"                                ] = Type::IfcFlowFitting;
    string_map["IFCFLOWFITTINGTYPE"                            ] = Type::IfcFlowFittingType;
    string_map["IFCFLOWINSTRUMENTTYPE"                         ] = Type::IfcFlowInstrumentType;
    string_map["IFCFLOWINSTRUMENTTYPEENUM"                     ] = Type::IfcFlowInstrumentTypeEnum;
    string_map["IFCFLOWMETERTYPE"                              ] = Type::IfcFlowMeterType;
    string_map["IFCFLOWMETERTYPEENUM"                          ] = Type::IfcFlowMeterTypeEnum;
    string_map["IFCFLOWMOVINGDEVICE"                           ] = Type::IfcFlowMovingDevice;
    string_map["IFCFLOWMOVINGDEVICETYPE"                       ] = Type::IfcFlowMovingDeviceType;
    string_map["IFCFLOWSEGMENT"                                ] = Type::IfcFlowSegment;
    string_map["IFCFLOWSEGMENTTYPE"                            ] = Type::IfcFlowSegmentType;
    string_map["IFCFLOWSTORAGEDEVICE"                          ] = Type::IfcFlowStorageDevice;
    string_map["IFCFLOWSTORAGEDEVICETYPE"                      ] = Type::IfcFlowStorageDeviceType;
    string_map["IFCFLOWTERMINAL"                               ] = Type::IfcFlowTerminal;
    string_map["IFCFLOWTERMINALTYPE"                           ] = Type::IfcFlowTerminalType;
    string_map["IFCFLOWTREATMENTDEVICE"                        ] = Type::IfcFlowTreatmentDevice;
    string_map["IFCFLOWTREATMENTDEVICETYPE"                    ] = Type::IfcFlowTreatmentDeviceType;
    string_map["IFCFLUIDFLOWPROPERTIES"                        ] = Type::IfcFluidFlowProperties;
    string_map["IFCFONTSTYLE"                                  ] = Type::IfcFontStyle;
    string_map["IFCFONTVARIANT"                                ] = Type::IfcFontVariant;
    string_map["IFCFONTWEIGHT"                                 ] = Type::IfcFontWeight;
    string_map["IFCFOOTING"                                    ] = Type::IfcFooting;
    string_map["IFCFOOTINGTYPEENUM"                            ] = Type::IfcFootingTypeEnum;
    string_map["IFCFORCEMEASURE"                               ] = Type::IfcForceMeasure;
    string_map["IFCFREQUENCYMEASURE"                           ] = Type::IfcFrequencyMeasure;
    string_map["IFCFUELPROPERTIES"                             ] = Type::IfcFuelProperties;
    string_map["IFCFURNISHINGELEMENT"                          ] = Type::IfcFurnishingElement;
    string_map["IFCFURNISHINGELEMENTTYPE"                      ] = Type::IfcFurnishingElementType;
    string_map["IFCFURNITURESTANDARD"                          ] = Type::IfcFurnitureStandard;
    string_map["IFCFURNITURETYPE"                              ] = Type::IfcFurnitureType;
    string_map["IFCGASTERMINALTYPE"                            ] = Type::IfcGasTerminalType;
    string_map["IFCGASTERMINALTYPEENUM"                        ] = Type::IfcGasTerminalTypeEnum;
    string_map["IFCGENERALMATERIALPROPERTIES"                  ] = Type::IfcGeneralMaterialProperties;
    string_map["IFCGENERALPROFILEPROPERTIES"                   ] = Type::IfcGeneralProfileProperties;
    string_map["IFCGEOMETRICCURVESET"                          ] = Type::IfcGeometricCurveSet;
    string_map["IFCGEOMETRICPROJECTIONENUM"                    ] = Type::IfcGeometricProjectionEnum;
    string_map["IFCGEOMETRICREPRESENTATIONCONTEXT"             ] = Type::IfcGeometricRepresentationContext;
    string_map["IFCGEOMETRICREPRESENTATIONITEM"                ] = Type::IfcGeometricRepresentationItem;
    string_map["IFCGEOMETRICREPRESENTATIONSUBCONTEXT"          ] = Type::IfcGeometricRepresentationSubContext;
    string_map["IFCGEOMETRICSET"                               ] = Type::IfcGeometricSet;
    string_map["IFCGEOMETRICSETSELECT"                         ] = Type::IfcGeometricSetSelect;
    string_map["IFCGLOBALORLOCALENUM"                          ] = Type::IfcGlobalOrLocalEnum;
    string_map["IFCGLOBALLYUNIQUEID"                           ] = Type::IfcGloballyUniqueId;
    string_map["IFCGRID"                                       ] = Type::IfcGrid;
    string_map["IFCGRIDAXIS"                                   ] = Type::IfcGridAxis;
    string_map["IFCGRIDPLACEMENT"                              ] = Type::IfcGridPlacement;
    string_map["IFCGROUP"                                      ] = Type::IfcGroup;
    string_map["IFCHALFSPACESOLID"                             ] = Type::IfcHalfSpaceSolid;
    string_map["IFCHATCHLINEDISTANCESELECT"                    ] = Type::IfcHatchLineDistanceSelect;
    string_map["IFCHEATEXCHANGERTYPE"                          ] = Type::IfcHeatExchangerType;
    string_map["IFCHEATEXCHANGERTYPEENUM"                      ] = Type::IfcHeatExchangerTypeEnum;
    string_map["IFCHEATFLUXDENSITYMEASURE"                     ] = Type::IfcHeatFluxDensityMeasure;
    string_map["IFCHEATINGVALUEMEASURE"                        ] = Type::IfcHeatingValueMeasure;
    string_map["IFCHOURINDAY"                                  ] = Type::IfcHourInDay;
    string_map["IFCHUMIDIFIERTYPE"                             ] = Type::IfcHumidifierType;
    string_map["IFCHUMIDIFIERTYPEENUM"                         ] = Type::IfcHumidifierTypeEnum;
    string_map["IFCHYGROSCOPICMATERIALPROPERTIES"              ] = Type::IfcHygroscopicMaterialProperties;
    string_map["IFCISHAPEPROFILEDEF"                           ] = Type::IfcIShapeProfileDef;
    string_map["IFCIDENTIFIER"                                 ] = Type::IfcIdentifier;
    string_map["IFCILLUMINANCEMEASURE"                         ] = Type::IfcIlluminanceMeasure;
    string_map["IFCIMAGETEXTURE"                               ] = Type::IfcImageTexture;
    string_map["IFCINDUCTANCEMEASURE"                          ] = Type::IfcInductanceMeasure;
    string_map["IFCINTEGER"                                    ] = Type::IfcInteger;
    string_map["IFCINTEGERCOUNTRATEMEASURE"                    ] = Type::IfcIntegerCountRateMeasure;
    string_map["IFCINTERNALOREXTERNALENUM"                     ] = Type::IfcInternalOrExternalEnum;
    string_map["IFCINVENTORY"                                  ] = Type::IfcInventory;
    string_map["IFCINVENTORYTYPEENUM"                          ] = Type::IfcInventoryTypeEnum;
    string_map["IFCIONCONCENTRATIONMEASURE"                    ] = Type::IfcIonConcentrationMeasure;
    string_map["IFCIRREGULARTIMESERIES"                        ] = Type::IfcIrregularTimeSeries;
    string_map["IFCIRREGULARTIMESERIESVALUE"                   ] = Type::IfcIrregularTimeSeriesValue;
    string_map["IFCISOTHERMALMOISTURECAPACITYMEASURE"          ] = Type::IfcIsothermalMoistureCapacityMeasure;
    string_map["IFCJUNCTIONBOXTYPE"                            ] = Type::IfcJunctionBoxType;
    string_map["IFCJUNCTIONBOXTYPEENUM"                        ] = Type::IfcJunctionBoxTypeEnum;
    string_map["IFCKINEMATICVISCOSITYMEASURE"                  ] = Type::IfcKinematicViscosityMeasure;
    string_map["IFCLSHAPEPROFILEDEF"                           ] = Type::IfcLShapeProfileDef;
    string_map["IFCLABEL"                                      ] = Type::IfcLabel;
    string_map["IFCLABORRESOURCE"                              ] = Type::IfcLaborResource;
    string_map["IFCLAMPTYPE"                                   ] = Type::IfcLampType;
    string_map["IFCLAMPTYPEENUM"                               ] = Type::IfcLampTypeEnum;
    string_map["IFCLAYERSETDIRECTIONENUM"                      ] = Type::IfcLayerSetDirectionEnum;
    string_map["IFCLAYEREDITEM"                                ] = Type::IfcLayeredItem;
    string_map["IFCLENGTHMEASURE"                              ] = Type::IfcLengthMeasure;
    string_map["IFCLIBRARYINFORMATION"                         ] = Type::IfcLibraryInformation;
    string_map["IFCLIBRARYREFERENCE"                           ] = Type::IfcLibraryReference;
    string_map["IFCLIBRARYSELECT"                              ] = Type::IfcLibrarySelect;
    string_map["IFCLIGHTDISTRIBUTIONCURVEENUM"                 ] = Type::IfcLightDistributionCurveEnum;
    string_map["IFCLIGHTDISTRIBUTIONDATA"                      ] = Type::IfcLightDistributionData;
    string_map["IFCLIGHTDISTRIBUTIONDATASOURCESELECT"          ] = Type::IfcLightDistributionDataSourceSelect;
    string_map["IFCLIGHTEMISSIONSOURCEENUM"                    ] = Type::IfcLightEmissionSourceEnum;
    string_map["IFCLIGHTFIXTURETYPE"                           ] = Type::IfcLightFixtureType;
    string_map["IFCLIGHTFIXTURETYPEENUM"                       ] = Type::IfcLightFixtureTypeEnum;
    string_map["IFCLIGHTINTENSITYDISTRIBUTION"                 ] = Type::IfcLightIntensityDistribution;
    string_map["IFCLIGHTSOURCE"                                ] = Type::IfcLightSource;
    string_map["IFCLIGHTSOURCEAMBIENT"                         ] = Type::IfcLightSourceAmbient;
    string_map["IFCLIGHTSOURCEDIRECTIONAL"                     ] = Type::IfcLightSourceDirectional;
    string_map["IFCLIGHTSOURCEGONIOMETRIC"                     ] = Type::IfcLightSourceGoniometric;
    string_map["IFCLIGHTSOURCEPOSITIONAL"                      ] = Type::IfcLightSourcePositional;
    string_map["IFCLIGHTSOURCESPOT"                            ] = Type::IfcLightSourceSpot;
    string_map["IFCLINE"                                       ] = Type::IfcLine;
    string_map["IFCLINEARDIMENSION"                            ] = Type::IfcLinearDimension;
    string_map["IFCLINEARFORCEMEASURE"                         ] = Type::IfcLinearForceMeasure;
    string_map["IFCLINEARMOMENTMEASURE"                        ] = Type::IfcLinearMomentMeasure;
    string_map["IFCLINEARSTIFFNESSMEASURE"                     ] = Type::IfcLinearStiffnessMeasure;
    string_map["IFCLINEARVELOCITYMEASURE"                      ] = Type::IfcLinearVelocityMeasure;
    string_map["IFCLOADGROUPTYPEENUM"                          ] = Type::IfcLoadGroupTypeEnum;
    string_map["IFCLOCALPLACEMENT"                             ] = Type::IfcLocalPlacement;
    string_map["IFCLOCALTIME"                                  ] = Type::IfcLocalTime;
    string_map["IFCLOGICAL"                                    ] = Type::IfcLogical;
    string_map["IFCLOGICALOPERATORENUM"                        ] = Type::IfcLogicalOperatorEnum;
    string_map["IFCLOOP"                                       ] = Type::IfcLoop;
    string_map["IFCLUMINOUSFLUXMEASURE"                        ] = Type::IfcLuminousFluxMeasure;
    string_map["IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE"       ] = Type::IfcLuminousIntensityDistributionMeasure;
    string_map["IFCLUMINOUSINTENSITYMEASURE"                   ] = Type::IfcLuminousIntensityMeasure;
    string_map["IFCMAGNETICFLUXDENSITYMEASURE"                 ] = Type::IfcMagneticFluxDensityMeasure;
    string_map["IFCMAGNETICFLUXMEASURE"                        ] = Type::IfcMagneticFluxMeasure;
    string_map["IFCMANIFOLDSOLIDBREP"                          ] = Type::IfcManifoldSolidBrep;
    string_map["IFCMAPPEDITEM"                                 ] = Type::IfcMappedItem;
    string_map["IFCMASSDENSITYMEASURE"                         ] = Type::IfcMassDensityMeasure;
    string_map["IFCMASSFLOWRATEMEASURE"                        ] = Type::IfcMassFlowRateMeasure;
    string_map["IFCMASSMEASURE"                                ] = Type::IfcMassMeasure;
    string_map["IFCMASSPERLENGTHMEASURE"                       ] = Type::IfcMassPerLengthMeasure;
    string_map["IFCMATERIAL"                                   ] = Type::IfcMaterial;
    string_map["IFCMATERIALCLASSIFICATIONRELATIONSHIP"         ] = Type::IfcMaterialClassificationRelationship;
    string_map["IFCMATERIALDEFINITIONREPRESENTATION"           ] = Type::IfcMaterialDefinitionRepresentation;
    string_map["IFCMATERIALLAYER"                              ] = Type::IfcMaterialLayer;
    string_map["IFCMATERIALLAYERSET"                           ] = Type::IfcMaterialLayerSet;
    string_map["IFCMATERIALLAYERSETUSAGE"                      ] = Type::IfcMaterialLayerSetUsage;
    string_map["IFCMATERIALLIST"                               ] = Type::IfcMaterialList;
    string_map["IFCMATERIALPROPERTIES"                         ] = Type::IfcMaterialProperties;
    string_map["IFCMATERIALSELECT"                             ] = Type::IfcMaterialSelect;
    string_map["IFCMEASUREVALUE"                               ] = Type::IfcMeasureValue;
    string_map["IFCMEASUREWITHUNIT"                            ] = Type::IfcMeasureWithUnit;
    string_map["IFCMECHANICALCONCRETEMATERIALPROPERTIES"       ] = Type::IfcMechanicalConcreteMaterialProperties;
    string_map["IFCMECHANICALFASTENER"                         ] = Type::IfcMechanicalFastener;
    string_map["IFCMECHANICALFASTENERTYPE"                     ] = Type::IfcMechanicalFastenerType;
    string_map["IFCMECHANICALMATERIALPROPERTIES"               ] = Type::IfcMechanicalMaterialProperties;
    string_map["IFCMECHANICALSTEELMATERIALPROPERTIES"          ] = Type::IfcMechanicalSteelMaterialProperties;
    string_map["IFCMEMBER"                                     ] = Type::IfcMember;
    string_map["IFCMEMBERTYPE"                                 ] = Type::IfcMemberType;
    string_map["IFCMEMBERTYPEENUM"                             ] = Type::IfcMemberTypeEnum;
    string_map["IFCMETRIC"                                     ] = Type::IfcMetric;
    string_map["IFCMETRICVALUESELECT"                          ] = Type::IfcMetricValueSelect;
    string_map["IFCMINUTEINHOUR"                               ] = Type::IfcMinuteInHour;
    string_map["IFCMODULUSOFELASTICITYMEASURE"                 ] = Type::IfcModulusOfElasticityMeasure;
    string_map["IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE"     ] = Type::IfcModulusOfLinearSubgradeReactionMeasure;
    string_map["IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" ] = Type::IfcModulusOfRotationalSubgradeReactionMeasure;
    string_map["IFCMODULUSOFSUBGRADEREACTIONMEASURE"           ] = Type::IfcModulusOfSubgradeReactionMeasure;
    string_map["IFCMOISTUREDIFFUSIVITYMEASURE"                 ] = Type::IfcMoistureDiffusivityMeasure;
    string_map["IFCMOLECULARWEIGHTMEASURE"                     ] = Type::IfcMolecularWeightMeasure;
    string_map["IFCMOMENTOFINERTIAMEASURE"                     ] = Type::IfcMomentOfInertiaMeasure;
    string_map["IFCMONETARYMEASURE"                            ] = Type::IfcMonetaryMeasure;
    string_map["IFCMONETARYUNIT"                               ] = Type::IfcMonetaryUnit;
    string_map["IFCMONTHINYEARNUMBER"                          ] = Type::IfcMonthInYearNumber;
    string_map["IFCMOTORCONNECTIONTYPE"                        ] = Type::IfcMotorConnectionType;
    string_map["IFCMOTORCONNECTIONTYPEENUM"                    ] = Type::IfcMotorConnectionTypeEnum;
    string_map["IFCMOVE"                                       ] = Type::IfcMove;
    string_map["IFCNAMEDUNIT"                                  ] = Type::IfcNamedUnit;
    string_map["IFCNORMALISEDRATIOMEASURE"                     ] = Type::IfcNormalisedRatioMeasure;
    string_map["IFCNULLSTYLE"                                  ] = Type::IfcNullStyle;
    string_map["IFCNUMERICMEASURE"                             ] = Type::IfcNumericMeasure;
    string_map["IFCOBJECT"                                     ] = Type::IfcObject;
    string_map["IFCOBJECTDEFINITION"                           ] = Type::IfcObjectDefinition;
    string_map["IFCOBJECTPLACEMENT"                            ] = Type::IfcObjectPlacement;
    string_map["IFCOBJECTREFERENCESELECT"                      ] = Type::IfcObjectReferenceSelect;
    string_map["IFCOBJECTTYPEENUM"                             ] = Type::IfcObjectTypeEnum;
    string_map["IFCOBJECTIVE"                                  ] = Type::IfcObjective;
    string_map["IFCOBJECTIVEENUM"                              ] = Type::IfcObjectiveEnum;
    string_map["IFCOCCUPANT"                                   ] = Type::IfcOccupant;
    string_map["IFCOCCUPANTTYPEENUM"                           ] = Type::IfcOccupantTypeEnum;
    string_map["IFCOFFSETCURVE2D"                              ] = Type::IfcOffsetCurve2D;
    string_map["IFCOFFSETCURVE3D"                              ] = Type::IfcOffsetCurve3D;
    string_map["IFCONEDIRECTIONREPEATFACTOR"                   ] = Type::IfcOneDirectionRepeatFactor;
    string_map["IFCOPENSHELL"                                  ] = Type::IfcOpenShell;
    string_map["IFCOPENINGELEMENT"                             ] = Type::IfcOpeningElement;
    string_map["IFCOPTICALMATERIALPROPERTIES"                  ] = Type::IfcOpticalMaterialProperties;
    string_map["IFCORDERACTION"                                ] = Type::IfcOrderAction;
    string_map["IFCORGANIZATION"                               ] = Type::IfcOrganization;
    string_map["IFCORGANIZATIONRELATIONSHIP"                   ] = Type::IfcOrganizationRelationship;
    string_map["IFCORIENTATIONSELECT"                          ] = Type::IfcOrientationSelect;
    string_map["IFCORIENTEDEDGE"                               ] = Type::IfcOrientedEdge;
    string_map["IFCOUTLETTYPE"                                 ] = Type::IfcOutletType;
    string_map["IFCOUTLETTYPEENUM"                             ] = Type::IfcOutletTypeEnum;
    string_map["IFCOWNERHISTORY"                               ] = Type::IfcOwnerHistory;
    string_map["IFCPHMEASURE"                                  ] = Type::IfcPHMeasure;
    string_map["IFCPARAMETERVALUE"                             ] = Type::IfcParameterValue;
    string_map["IFCPARAMETERIZEDPROFILEDEF"                    ] = Type::IfcParameterizedProfileDef;
    string_map["IFCPATH"                                       ] = Type::IfcPath;
    string_map["IFCPERFORMANCEHISTORY"                         ] = Type::IfcPerformanceHistory;
    string_map["IFCPERMEABLECOVERINGOPERATIONENUM"             ] = Type::IfcPermeableCoveringOperationEnum;
    string_map["IFCPERMEABLECOVERINGPROPERTIES"                ] = Type::IfcPermeableCoveringProperties;
    string_map["IFCPERMIT"                                     ] = Type::IfcPermit;
    string_map["IFCPERSON"                                     ] = Type::IfcPerson;
    string_map["IFCPERSONANDORGANIZATION"                      ] = Type::IfcPersonAndOrganization;
    string_map["IFCPHYSICALCOMPLEXQUANTITY"                    ] = Type::IfcPhysicalComplexQuantity;
    string_map["IFCPHYSICALORVIRTUALENUM"                      ] = Type::IfcPhysicalOrVirtualEnum;
    string_map["IFCPHYSICALQUANTITY"                           ] = Type::IfcPhysicalQuantity;
    string_map["IFCPHYSICALSIMPLEQUANTITY"                     ] = Type::IfcPhysicalSimpleQuantity;
    string_map["IFCPILE"                                       ] = Type::IfcPile;
    string_map["IFCPILECONSTRUCTIONENUM"                       ] = Type::IfcPileConstructionEnum;
    string_map["IFCPILETYPEENUM"                               ] = Type::IfcPileTypeEnum;
    string_map["IFCPIPEFITTINGTYPE"                            ] = Type::IfcPipeFittingType;
    string_map["IFCPIPEFITTINGTYPEENUM"                        ] = Type::IfcPipeFittingTypeEnum;
    string_map["IFCPIPESEGMENTTYPE"                            ] = Type::IfcPipeSegmentType;
    string_map["IFCPIPESEGMENTTYPEENUM"                        ] = Type::IfcPipeSegmentTypeEnum;
    string_map["IFCPIXELTEXTURE"                               ] = Type::IfcPixelTexture;
    string_map["IFCPLACEMENT"                                  ] = Type::IfcPlacement;
    string_map["IFCPLANARBOX"                                  ] = Type::IfcPlanarBox;
    string_map["IFCPLANAREXTENT"                               ] = Type::IfcPlanarExtent;
    string_map["IFCPLANARFORCEMEASURE"                         ] = Type::IfcPlanarForceMeasure;
    string_map["IFCPLANE"                                      ] = Type::IfcPlane;
    string_map["IFCPLANEANGLEMEASURE"                          ] = Type::IfcPlaneAngleMeasure;
    string_map["IFCPLATE"                                      ] = Type::IfcPlate;
    string_map["IFCPLATETYPE"                                  ] = Type::IfcPlateType;
    string_map["IFCPLATETYPEENUM"                              ] = Type::IfcPlateTypeEnum;
    string_map["IFCPOINT"                                      ] = Type::IfcPoint;
    string_map["IFCPOINTONCURVE"                               ] = Type::IfcPointOnCurve;
    string_map["IFCPOINTONSURFACE"                             ] = Type::IfcPointOnSurface;
    string_map["IFCPOINTORVERTEXPOINT"                         ] = Type::IfcPointOrVertexPoint;
    string_map["IFCPOLYLOOP"                                   ] = Type::IfcPolyLoop;
    string_map["IFCPOLYGONALBOUNDEDHALFSPACE"                  ] = Type::IfcPolygonalBoundedHalfSpace;
    string_map["IFCPOLYLINE"                                   ] = Type::IfcPolyline;
    string_map["IFCPORT"                                       ] = Type::IfcPort;
    string_map["IFCPOSITIVELENGTHMEASURE"                      ] = Type::IfcPositiveLengthMeasure;
    string_map["IFCPOSITIVEPLANEANGLEMEASURE"                  ] = Type::IfcPositivePlaneAngleMeasure;
    string_map["IFCPOSITIVERATIOMEASURE"                       ] = Type::IfcPositiveRatioMeasure;
    string_map["IFCPOSTALADDRESS"                              ] = Type::IfcPostalAddress;
    string_map["IFCPOWERMEASURE"                               ] = Type::IfcPowerMeasure;
    string_map["IFCPREDEFINEDCOLOUR"                           ] = Type::IfcPreDefinedColour;
    string_map["IFCPREDEFINEDCURVEFONT"                        ] = Type::IfcPreDefinedCurveFont;
    string_map["IFCPREDEFINEDDIMENSIONSYMBOL"                  ] = Type::IfcPreDefinedDimensionSymbol;
    string_map["IFCPREDEFINEDITEM"                             ] = Type::IfcPreDefinedItem;
    string_map["IFCPREDEFINEDPOINTMARKERSYMBOL"                ] = Type::IfcPreDefinedPointMarkerSymbol;
    string_map["IFCPREDEFINEDSYMBOL"                           ] = Type::IfcPreDefinedSymbol;
    string_map["IFCPREDEFINEDTERMINATORSYMBOL"                 ] = Type::IfcPreDefinedTerminatorSymbol;
    string_map["IFCPREDEFINEDTEXTFONT"                         ] = Type::IfcPreDefinedTextFont;
    string_map["IFCPRESENTABLETEXT"                            ] = Type::IfcPresentableText;
    string_map["IFCPRESENTATIONLAYERASSIGNMENT"                ] = Type::IfcPresentationLayerAssignment;
    string_map["IFCPRESENTATIONLAYERWITHSTYLE"                 ] = Type::IfcPresentationLayerWithStyle;
    string_map["IFCPRESENTATIONSTYLE"                          ] = Type::IfcPresentationStyle;
    string_map["IFCPRESENTATIONSTYLEASSIGNMENT"                ] = Type::IfcPresentationStyleAssignment;
    string_map["IFCPRESENTATIONSTYLESELECT"                    ] = Type::IfcPresentationStyleSelect;
    string_map["IFCPRESSUREMEASURE"                            ] = Type::IfcPressureMeasure;
    string_map["IFCPROCEDURE"                                  ] = Type::IfcProcedure;
    string_map["IFCPROCEDURETYPEENUM"                          ] = Type::IfcProcedureTypeEnum;
    string_map["IFCPROCESS"                                    ] = Type::IfcProcess;
    string_map["IFCPRODUCT"                                    ] = Type::IfcProduct;
    string_map["IFCPRODUCTDEFINITIONSHAPE"                     ] = Type::IfcProductDefinitionShape;
    string_map["IFCPRODUCTREPRESENTATION"                      ] = Type::IfcProductRepresentation;
    string_map["IFCPRODUCTSOFCOMBUSTIONPROPERTIES"             ] = Type::IfcProductsOfCombustionProperties;
    string_map["IFCPROFILEDEF"                                 ] = Type::IfcProfileDef;
    string_map["IFCPROFILEPROPERTIES"                          ] = Type::IfcProfileProperties;
    string_map["IFCPROFILETYPEENUM"                            ] = Type::IfcProfileTypeEnum;
    string_map["IFCPROJECT"                                    ] = Type::IfcProject;
    string_map["IFCPROJECTORDER"                               ] = Type::IfcProjectOrder;
    string_map["IFCPROJECTORDERRECORD"                         ] = Type::IfcProjectOrderRecord;
    string_map["IFCPROJECTORDERRECORDTYPEENUM"                 ] = Type::IfcProjectOrderRecordTypeEnum;
    string_map["IFCPROJECTORDERTYPEENUM"                       ] = Type::IfcProjectOrderTypeEnum;
    string_map["IFCPROJECTEDORTRUELENGTHENUM"                  ] = Type::IfcProjectedOrTrueLengthEnum;
    string_map["IFCPROJECTIONCURVE"                            ] = Type::IfcProjectionCurve;
    string_map["IFCPROJECTIONELEMENT"                          ] = Type::IfcProjectionElement;
    string_map["IFCPROPERTY"                                   ] = Type::IfcProperty;
    string_map["IFCPROPERTYBOUNDEDVALUE"                       ] = Type::IfcPropertyBoundedValue;
    string_map["IFCPROPERTYCONSTRAINTRELATIONSHIP"             ] = Type::IfcPropertyConstraintRelationship;
    string_map["IFCPROPERTYDEFINITION"                         ] = Type::IfcPropertyDefinition;
    string_map["IFCPROPERTYDEPENDENCYRELATIONSHIP"             ] = Type::IfcPropertyDependencyRelationship;
    string_map["IFCPROPERTYENUMERATEDVALUE"                    ] = Type::IfcPropertyEnumeratedValue;
    string_map["IFCPROPERTYENUMERATION"                        ] = Type::IfcPropertyEnumeration;
    string_map["IFCPROPERTYLISTVALUE"                          ] = Type::IfcPropertyListValue;
    string_map["IFCPROPERTYREFERENCEVALUE"                     ] = Type::IfcPropertyReferenceValue;
    string_map["IFCPROPERTYSET"                                ] = Type::IfcPropertySet;
    string_map["IFCPROPERTYSETDEFINITION"                      ] = Type::IfcPropertySetDefinition;
    string_map["IFCPROPERTYSINGLEVALUE"                        ] = Type::IfcPropertySingleValue;
    string_map["IFCPROPERTYSOURCEENUM"                         ] = Type::IfcPropertySourceEnum;
    string_map["IFCPROPERTYTABLEVALUE"                         ] = Type::IfcPropertyTableValue;
    string_map["IFCPROTECTIVEDEVICETYPE"                       ] = Type::IfcProtectiveDeviceType;
    string_map["IFCPROTECTIVEDEVICETYPEENUM"                   ] = Type::IfcProtectiveDeviceTypeEnum;
    string_map["IFCPROXY"                                      ] = Type::IfcProxy;
    string_map["IFCPUMPTYPE"                                   ] = Type::IfcPumpType;
    string_map["IFCPUMPTYPEENUM"                               ] = Type::IfcPumpTypeEnum;
    string_map["IFCQUANTITYAREA"                               ] = Type::IfcQuantityArea;
    string_map["IFCQUANTITYCOUNT"                              ] = Type::IfcQuantityCount;
    string_map["IFCQUANTITYLENGTH"                             ] = Type::IfcQuantityLength;
    string_map["IFCQUANTITYTIME"                               ] = Type::IfcQuantityTime;
    string_map["IFCQUANTITYVOLUME"                             ] = Type::IfcQuantityVolume;
    string_map["IFCQUANTITYWEIGHT"                             ] = Type::IfcQuantityWeight;
    string_map["IFCRADIOACTIVITYMEASURE"                       ] = Type::IfcRadioActivityMeasure;
    string_map["IFCRADIUSDIMENSION"                            ] = Type::IfcRadiusDimension;
    string_map["IFCRAILING"                                    ] = Type::IfcRailing;
    string_map["IFCRAILINGTYPE"                                ] = Type::IfcRailingType;
    string_map["IFCRAILINGTYPEENUM"                            ] = Type::IfcRailingTypeEnum;
    string_map["IFCRAMP"                                       ] = Type::IfcRamp;
    string_map["IFCRAMPFLIGHT"                                 ] = Type::IfcRampFlight;
    string_map["IFCRAMPFLIGHTTYPE"                             ] = Type::IfcRampFlightType;
    string_map["IFCRAMPFLIGHTTYPEENUM"                         ] = Type::IfcRampFlightTypeEnum;
    string_map["IFCRAMPTYPEENUM"                               ] = Type::IfcRampTypeEnum;
    string_map["IFCRATIOMEASURE"                               ] = Type::IfcRatioMeasure;
    string_map["IFCRATIONALBEZIERCURVE"                        ] = Type::IfcRationalBezierCurve;
    string_map["IFCREAL"                                       ] = Type::IfcReal;
    string_map["IFCRECTANGLEHOLLOWPROFILEDEF"                  ] = Type::IfcRectangleHollowProfileDef;
    string_map["IFCRECTANGLEPROFILEDEF"                        ] = Type::IfcRectangleProfileDef;
    string_map["IFCRECTANGULARPYRAMID"                         ] = Type::IfcRectangularPyramid;
    string_map["IFCRECTANGULARTRIMMEDSURFACE"                  ] = Type::IfcRectangularTrimmedSurface;
    string_map["IFCREFERENCESVALUEDOCUMENT"                    ] = Type::IfcReferencesValueDocument;
    string_map["IFCREFLECTANCEMETHODENUM"                      ] = Type::IfcReflectanceMethodEnum;
    string_map["IFCREGULARTIMESERIES"                          ] = Type::IfcRegularTimeSeries;
    string_map["IFCREINFORCEMENTBARPROPERTIES"                 ] = Type::IfcReinforcementBarProperties;
    string_map["IFCREINFORCEMENTDEFINITIONPROPERTIES"          ] = Type::IfcReinforcementDefinitionProperties;
    string_map["IFCREINFORCINGBAR"                             ] = Type::IfcReinforcingBar;
    string_map["IFCREINFORCINGBARROLEENUM"                     ] = Type::IfcReinforcingBarRoleEnum;
    string_map["IFCREINFORCINGBARSURFACEENUM"                  ] = Type::IfcReinforcingBarSurfaceEnum;
    string_map["IFCREINFORCINGELEMENT"                         ] = Type::IfcReinforcingElement;
    string_map["IFCREINFORCINGMESH"                            ] = Type::IfcReinforcingMesh;
    string_map["IFCRELAGGREGATES"                              ] = Type::IfcRelAggregates;
    string_map["IFCRELASSIGNS"                                 ] = Type::IfcRelAssigns;
    string_map["IFCRELASSIGNSTASKS"                            ] = Type::IfcRelAssignsTasks;
    string_map["IFCRELASSIGNSTOACTOR"                          ] = Type::IfcRelAssignsToActor;
    string_map["IFCRELASSIGNSTOCONTROL"                        ] = Type::IfcRelAssignsToControl;
    string_map["IFCRELASSIGNSTOGROUP"                          ] = Type::IfcRelAssignsToGroup;
    string_map["IFCRELASSIGNSTOPROCESS"                        ] = Type::IfcRelAssignsToProcess;
    string_map["IFCRELASSIGNSTOPRODUCT"                        ] = Type::IfcRelAssignsToProduct;
    string_map["IFCRELASSIGNSTOPROJECTORDER"                   ] = Type::IfcRelAssignsToProjectOrder;
    string_map["IFCRELASSIGNSTORESOURCE"                       ] = Type::IfcRelAssignsToResource;
    string_map["IFCRELASSOCIATES"                              ] = Type::IfcRelAssociates;
    string_map["IFCRELASSOCIATESAPPLIEDVALUE"                  ] = Type::IfcRelAssociatesAppliedValue;
    string_map["IFCRELASSOCIATESAPPROVAL"                      ] = Type::IfcRelAssociatesApproval;
    string_map["IFCRELASSOCIATESCLASSIFICATION"                ] = Type::IfcRelAssociatesClassification;
    string_map["IFCRELASSOCIATESCONSTRAINT"                    ] = Type::IfcRelAssociatesConstraint;
    string_map["IFCRELASSOCIATESDOCUMENT"                      ] = Type::IfcRelAssociatesDocument;
    string_map["IFCRELASSOCIATESLIBRARY"                       ] = Type::IfcRelAssociatesLibrary;
    string_map["IFCRELASSOCIATESMATERIAL"                      ] = Type::IfcRelAssociatesMaterial;
    string_map["IFCRELASSOCIATESPROFILEPROPERTIES"             ] = Type::IfcRelAssociatesProfileProperties;
    string_map["IFCRELCONNECTS"                                ] = Type::IfcRelConnects;
    string_map["IFCRELCONNECTSELEMENTS"                        ] = Type::IfcRelConnectsElements;
    string_map["IFCRELCONNECTSPATHELEMENTS"                    ] = Type::IfcRelConnectsPathElements;
    string_map["IFCRELCONNECTSPORTTOELEMENT"                   ] = Type::IfcRelConnectsPortToElement;
    string_map["IFCRELCONNECTSPORTS"                           ] = Type::IfcRelConnectsPorts;
    string_map["IFCRELCONNECTSSTRUCTURALACTIVITY"              ] = Type::IfcRelConnectsStructuralActivity;
    string_map["IFCRELCONNECTSSTRUCTURALELEMENT"               ] = Type::IfcRelConnectsStructuralElement;
    string_map["IFCRELCONNECTSSTRUCTURALMEMBER"                ] = Type::IfcRelConnectsStructuralMember;
    string_map["IFCRELCONNECTSWITHECCENTRICITY"                ] = Type::IfcRelConnectsWithEccentricity;
    string_map["IFCRELCONNECTSWITHREALIZINGELEMENTS"           ] = Type::IfcRelConnectsWithRealizingElements;
    string_map["IFCRELCONTAINEDINSPATIALSTRUCTURE"             ] = Type::IfcRelContainedInSpatialStructure;
    string_map["IFCRELCOVERSBLDGELEMENTS"                      ] = Type::IfcRelCoversBldgElements;
    string_map["IFCRELCOVERSSPACES"                            ] = Type::IfcRelCoversSpaces;
    string_map["IFCRELDECOMPOSES"                              ] = Type::IfcRelDecomposes;
    string_map["IFCRELDEFINES"                                 ] = Type::IfcRelDefines;
    string_map["IFCRELDEFINESBYPROPERTIES"                     ] = Type::IfcRelDefinesByProperties;
    string_map["IFCRELDEFINESBYTYPE"                           ] = Type::IfcRelDefinesByType;
    string_map["IFCRELFILLSELEMENT"                            ] = Type::IfcRelFillsElement;
    string_map["IFCRELFLOWCONTROLELEMENTS"                     ] = Type::IfcRelFlowControlElements;
    string_map["IFCRELINTERACTIONREQUIREMENTS"                 ] = Type::IfcRelInteractionRequirements;
    string_map["IFCRELNESTS"                                   ] = Type::IfcRelNests;
    string_map["IFCRELOCCUPIESSPACES"                          ] = Type::IfcRelOccupiesSpaces;
    string_map["IFCRELOVERRIDESPROPERTIES"                     ] = Type::IfcRelOverridesProperties;
    string_map["IFCRELPROJECTSELEMENT"                         ] = Type::IfcRelProjectsElement;
    string_map["IFCRELREFERENCEDINSPATIALSTRUCTURE"            ] = Type::IfcRelReferencedInSpatialStructure;
    string_map["IFCRELSCHEDULESCOSTITEMS"                      ] = Type::IfcRelSchedulesCostItems;
    string_map["IFCRELSEQUENCE"                                ] = Type::IfcRelSequence;
    string_map["IFCRELSERVICESBUILDINGS"                       ] = Type::IfcRelServicesBuildings;
    string_map["IFCRELSPACEBOUNDARY"                           ] = Type::IfcRelSpaceBoundary;
    string_map["IFCRELVOIDSELEMENT"                            ] = Type::IfcRelVoidsElement;
    string_map["IFCRELATIONSHIP"                               ] = Type::IfcRelationship;
    string_map["IFCRELAXATION"                                 ] = Type::IfcRelaxation;
    string_map["IFCREPRESENTATION"                             ] = Type::IfcRepresentation;
    string_map["IFCREPRESENTATIONCONTEXT"                      ] = Type::IfcRepresentationContext;
    string_map["IFCREPRESENTATIONITEM"                         ] = Type::IfcRepresentationItem;
    string_map["IFCREPRESENTATIONMAP"                          ] = Type::IfcRepresentationMap;
    string_map["IFCRESOURCE"                                   ] = Type::IfcResource;
    string_map["IFCRESOURCECONSUMPTIONENUM"                    ] = Type::IfcResourceConsumptionEnum;
    string_map["IFCREVOLVEDAREASOLID"                          ] = Type::IfcRevolvedAreaSolid;
    string_map["IFCRIBPLATEDIRECTIONENUM"                      ] = Type::IfcRibPlateDirectionEnum;
    string_map["IFCRIBPLATEPROFILEPROPERTIES"                  ] = Type::IfcRibPlateProfileProperties;
    string_map["IFCRIGHTCIRCULARCONE"                          ] = Type::IfcRightCircularCone;
    string_map["IFCRIGHTCIRCULARCYLINDER"                      ] = Type::IfcRightCircularCylinder;
    string_map["IFCROLEENUM"                                   ] = Type::IfcRoleEnum;
    string_map["IFCROOF"                                       ] = Type::IfcRoof;
    string_map["IFCROOFTYPEENUM"                               ] = Type::IfcRoofTypeEnum;
    string_map["IFCROOT"                                       ] = Type::IfcRoot;
    string_map["IFCROTATIONALFREQUENCYMEASURE"                 ] = Type::IfcRotationalFrequencyMeasure;
    string_map["IFCROTATIONALMASSMEASURE"                      ] = Type::IfcRotationalMassMeasure;
    string_map["IFCROTATIONALSTIFFNESSMEASURE"                 ] = Type::IfcRotationalStiffnessMeasure;
    string_map["IFCROUNDEDEDGEFEATURE"                         ] = Type::IfcRoundedEdgeFeature;
    string_map["IFCROUNDEDRECTANGLEPROFILEDEF"                 ] = Type::IfcRoundedRectangleProfileDef;
    string_map["IFCSIPREFIX"                                   ] = Type::IfcSIPrefix;
    string_map["IFCSIUNIT"                                     ] = Type::IfcSIUnit;
    string_map["IFCSIUNITNAME"                                 ] = Type::IfcSIUnitName;
    string_map["IFCSANITARYTERMINALTYPE"                       ] = Type::IfcSanitaryTerminalType;
    string_map["IFCSANITARYTERMINALTYPEENUM"                   ] = Type::IfcSanitaryTerminalTypeEnum;
    string_map["IFCSCHEDULETIMECONTROL"                        ] = Type::IfcScheduleTimeControl;
    string_map["IFCSECONDINMINUTE"                             ] = Type::IfcSecondInMinute;
    string_map["IFCSECTIONMODULUSMEASURE"                      ] = Type::IfcSectionModulusMeasure;
    string_map["IFCSECTIONPROPERTIES"                          ] = Type::IfcSectionProperties;
    string_map["IFCSECTIONREINFORCEMENTPROPERTIES"             ] = Type::IfcSectionReinforcementProperties;
    string_map["IFCSECTIONTYPEENUM"                            ] = Type::IfcSectionTypeEnum;
    string_map["IFCSECTIONALAREAINTEGRALMEASURE"               ] = Type::IfcSectionalAreaIntegralMeasure;
    string_map["IFCSECTIONEDSPINE"                             ] = Type::IfcSectionedSpine;
    string_map["IFCSENSORTYPE"                                 ] = Type::IfcSensorType;
    string_map["IFCSENSORTYPEENUM"                             ] = Type::IfcSensorTypeEnum;
    string_map["IFCSEQUENCEENUM"                               ] = Type::IfcSequenceEnum;
    string_map["IFCSERVICELIFE"                                ] = Type::IfcServiceLife;
    string_map["IFCSERVICELIFEFACTOR"                          ] = Type::IfcServiceLifeFactor;
    string_map["IFCSERVICELIFEFACTORTYPEENUM"                  ] = Type::IfcServiceLifeFactorTypeEnum;
    string_map["IFCSERVICELIFETYPEENUM"                        ] = Type::IfcServiceLifeTypeEnum;
    string_map["IFCSHAPEASPECT"                                ] = Type::IfcShapeAspect;
    string_map["IFCSHAPEMODEL"                                 ] = Type::IfcShapeModel;
    string_map["IFCSHAPEREPRESENTATION"                        ] = Type::IfcShapeRepresentation;
    string_map["IFCSHEARMODULUSMEASURE"                        ] = Type::IfcShearModulusMeasure;
    string_map["IFCSHELL"                                      ] = Type::IfcShell;
    string_map["IFCSHELLBASEDSURFACEMODEL"                     ] = Type::IfcShellBasedSurfaceModel;
    string_map["IFCSIMPLEPROPERTY"                             ] = Type::IfcSimpleProperty;
    string_map["IFCSIMPLEVALUE"                                ] = Type::IfcSimpleValue;
    string_map["IFCSITE"                                       ] = Type::IfcSite;
    string_map["IFCSIZESELECT"                                 ] = Type::IfcSizeSelect;
    string_map["IFCSLAB"                                       ] = Type::IfcSlab;
    string_map["IFCSLABTYPE"                                   ] = Type::IfcSlabType;
    string_map["IFCSLABTYPEENUM"                               ] = Type::IfcSlabTypeEnum;
    string_map["IFCSLIPPAGECONNECTIONCONDITION"                ] = Type::IfcSlippageConnectionCondition;
    string_map["IFCSOLIDANGLEMEASURE"                          ] = Type::IfcSolidAngleMeasure;
    string_map["IFCSOLIDMODEL"                                 ] = Type::IfcSolidModel;
    string_map["IFCSOUNDPOWERMEASURE"                          ] = Type::IfcSoundPowerMeasure;
    string_map["IFCSOUNDPRESSUREMEASURE"                       ] = Type::IfcSoundPressureMeasure;
    string_map["IFCSOUNDPROPERTIES"                            ] = Type::IfcSoundProperties;
    string_map["IFCSOUNDSCALEENUM"                             ] = Type::IfcSoundScaleEnum;
    string_map["IFCSOUNDVALUE"                                 ] = Type::IfcSoundValue;
    string_map["IFCSPACE"                                      ] = Type::IfcSpace;
    string_map["IFCSPACEHEATERTYPE"                            ] = Type::IfcSpaceHeaterType;
    string_map["IFCSPACEHEATERTYPEENUM"                        ] = Type::IfcSpaceHeaterTypeEnum;
    string_map["IFCSPACEPROGRAM"                               ] = Type::IfcSpaceProgram;
    string_map["IFCSPACETHERMALLOADPROPERTIES"                 ] = Type::IfcSpaceThermalLoadProperties;
    string_map["IFCSPACETYPE"                                  ] = Type::IfcSpaceType;
    string_map["IFCSPACETYPEENUM"                              ] = Type::IfcSpaceTypeEnum;
    string_map["IFCSPATIALSTRUCTUREELEMENT"                    ] = Type::IfcSpatialStructureElement;
    string_map["IFCSPATIALSTRUCTUREELEMENTTYPE"                ] = Type::IfcSpatialStructureElementType;
    string_map["IFCSPECIFICHEATCAPACITYMEASURE"                ] = Type::IfcSpecificHeatCapacityMeasure;
    string_map["IFCSPECULAREXPONENT"                           ] = Type::IfcSpecularExponent;
    string_map["IFCSPECULARHIGHLIGHTSELECT"                    ] = Type::IfcSpecularHighlightSelect;
    string_map["IFCSPECULARROUGHNESS"                          ] = Type::IfcSpecularRoughness;
    string_map["IFCSPHERE"                                     ] = Type::IfcSphere;
    string_map["IFCSTACKTERMINALTYPE"                          ] = Type::IfcStackTerminalType;
    string_map["IFCSTACKTERMINALTYPEENUM"                      ] = Type::IfcStackTerminalTypeEnum;
    string_map["IFCSTAIR"                                      ] = Type::IfcStair;
    string_map["IFCSTAIRFLIGHT"                                ] = Type::IfcStairFlight;
    string_map["IFCSTAIRFLIGHTTYPE"                            ] = Type::IfcStairFlightType;
    string_map["IFCSTAIRFLIGHTTYPEENUM"                        ] = Type::IfcStairFlightTypeEnum;
    string_map["IFCSTAIRTYPEENUM"                              ] = Type::IfcStairTypeEnum;
    string_map["IFCSTATEENUM"                                  ] = Type::IfcStateEnum;
    string_map["IFCSTRUCTURALACTION"                           ] = Type::IfcStructuralAction;
    string_map["IFCSTRUCTURALACTIVITY"                         ] = Type::IfcStructuralActivity;
    string_map["IFCSTRUCTURALACTIVITYASSIGNMENTSELECT"         ] = Type::IfcStructuralActivityAssignmentSelect;
    string_map["IFCSTRUCTURALANALYSISMODEL"                    ] = Type::IfcStructuralAnalysisModel;
    string_map["IFCSTRUCTURALCONNECTION"                       ] = Type::IfcStructuralConnection;
    string_map["IFCSTRUCTURALCONNECTIONCONDITION"              ] = Type::IfcStructuralConnectionCondition;
    string_map["IFCSTRUCTURALCURVECONNECTION"                  ] = Type::IfcStructuralCurveConnection;
    string_map["IFCSTRUCTURALCURVEMEMBER"                      ] = Type::IfcStructuralCurveMember;
    string_map["IFCSTRUCTURALCURVEMEMBERVARYING"               ] = Type::IfcStructuralCurveMemberVarying;
    string_map["IFCSTRUCTURALCURVETYPEENUM"                    ] = Type::IfcStructuralCurveTypeEnum;
    string_map["IFCSTRUCTURALITEM"                             ] = Type::IfcStructuralItem;
    string_map["IFCSTRUCTURALLINEARACTION"                     ] = Type::IfcStructuralLinearAction;
    string_map["IFCSTRUCTURALLINEARACTIONVARYING"              ] = Type::IfcStructuralLinearActionVarying;
    string_map["IFCSTRUCTURALLOAD"                             ] = Type::IfcStructuralLoad;
    string_map["IFCSTRUCTURALLOADGROUP"                        ] = Type::IfcStructuralLoadGroup;
    string_map["IFCSTRUCTURALLOADLINEARFORCE"                  ] = Type::IfcStructuralLoadLinearForce;
    string_map["IFCSTRUCTURALLOADPLANARFORCE"                  ] = Type::IfcStructuralLoadPlanarForce;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENT"           ] = Type::IfcStructuralLoadSingleDisplacement;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION" ] = Type::IfcStructuralLoadSingleDisplacementDistortion;
    string_map["IFCSTRUCTURALLOADSINGLEFORCE"                  ] = Type::IfcStructuralLoadSingleForce;
    string_map["IFCSTRUCTURALLOADSINGLEFORCEWARPING"           ] = Type::IfcStructuralLoadSingleForceWarping;
    string_map["IFCSTRUCTURALLOADSTATIC"                       ] = Type::IfcStructuralLoadStatic;
    string_map["IFCSTRUCTURALLOADTEMPERATURE"                  ] = Type::IfcStructuralLoadTemperature;
    string_map["IFCSTRUCTURALMEMBER"                           ] = Type::IfcStructuralMember;
    string_map["IFCSTRUCTURALPLANARACTION"                     ] = Type::IfcStructuralPlanarAction;
    string_map["IFCSTRUCTURALPLANARACTIONVARYING"              ] = Type::IfcStructuralPlanarActionVarying;
    string_map["IFCSTRUCTURALPOINTACTION"                      ] = Type::IfcStructuralPointAction;
    string_map["IFCSTRUCTURALPOINTCONNECTION"                  ] = Type::IfcStructuralPointConnection;
    string_map["IFCSTRUCTURALPOINTREACTION"                    ] = Type::IfcStructuralPointReaction;
    string_map["IFCSTRUCTURALPROFILEPROPERTIES"                ] = Type::IfcStructuralProfileProperties;
    string_map["IFCSTRUCTURALREACTION"                         ] = Type::IfcStructuralReaction;
    string_map["IFCSTRUCTURALRESULTGROUP"                      ] = Type::IfcStructuralResultGroup;
    string_map["IFCSTRUCTURALSTEELPROFILEPROPERTIES"           ] = Type::IfcStructuralSteelProfileProperties;
    string_map["IFCSTRUCTURALSURFACECONNECTION"                ] = Type::IfcStructuralSurfaceConnection;
    string_map["IFCSTRUCTURALSURFACEMEMBER"                    ] = Type::IfcStructuralSurfaceMember;
    string_map["IFCSTRUCTURALSURFACEMEMBERVARYING"             ] = Type::IfcStructuralSurfaceMemberVarying;
    string_map["IFCSTRUCTURALSURFACETYPEENUM"                  ] = Type::IfcStructuralSurfaceTypeEnum;
    string_map["IFCSTRUCTUREDDIMENSIONCALLOUT"                 ] = Type::IfcStructuredDimensionCallout;
    string_map["IFCSTYLEMODEL"                                 ] = Type::IfcStyleModel;
    string_map["IFCSTYLEDITEM"                                 ] = Type::IfcStyledItem;
    string_map["IFCSTYLEDREPRESENTATION"                       ] = Type::IfcStyledRepresentation;
    string_map["IFCSUBCONTRACTRESOURCE"                        ] = Type::IfcSubContractResource;
    string_map["IFCSUBEDGE"                                    ] = Type::IfcSubedge;
    string_map["IFCSURFACE"                                    ] = Type::IfcSurface;
    string_map["IFCSURFACECURVESWEPTAREASOLID"                 ] = Type::IfcSurfaceCurveSweptAreaSolid;
    string_map["IFCSURFACEOFLINEAREXTRUSION"                   ] = Type::IfcSurfaceOfLinearExtrusion;
    string_map["IFCSURFACEOFREVOLUTION"                        ] = Type::IfcSurfaceOfRevolution;
    string_map["IFCSURFACEORFACESURFACE"                       ] = Type::IfcSurfaceOrFaceSurface;
    string_map["IFCSURFACESIDE"                                ] = Type::IfcSurfaceSide;
    string_map["IFCSURFACESTYLE"                               ] = Type::IfcSurfaceStyle;
    string_map["IFCSURFACESTYLEELEMENTSELECT"                  ] = Type::IfcSurfaceStyleElementSelect;
    string_map["IFCSURFACESTYLELIGHTING"                       ] = Type::IfcSurfaceStyleLighting;
    string_map["IFCSURFACESTYLEREFRACTION"                     ] = Type::IfcSurfaceStyleRefraction;
    string_map["IFCSURFACESTYLERENDERING"                      ] = Type::IfcSurfaceStyleRendering;
    string_map["IFCSURFACESTYLESHADING"                        ] = Type::IfcSurfaceStyleShading;
    string_map["IFCSURFACESTYLEWITHTEXTURES"                   ] = Type::IfcSurfaceStyleWithTextures;
    string_map["IFCSURFACETEXTURE"                             ] = Type::IfcSurfaceTexture;
    string_map["IFCSURFACETEXTUREENUM"                         ] = Type::IfcSurfaceTextureEnum;
    string_map["IFCSWEPTAREASOLID"                             ] = Type::IfcSweptAreaSolid;
    string_map["IFCSWEPTDISKSOLID"                             ] = Type::IfcSweptDiskSolid;
    string_map["IFCSWEPTSURFACE"                               ] = Type::IfcSweptSurface;
    string_map["IFCSWITCHINGDEVICETYPE"                        ] = Type::IfcSwitchingDeviceType;
    string_map["IFCSWITCHINGDEVICETYPEENUM"                    ] = Type::IfcSwitchingDeviceTypeEnum;
    string_map["IFCSYMBOLSTYLE"                                ] = Type::IfcSymbolStyle;
    string_map["IFCSYMBOLSTYLESELECT"                          ] = Type::IfcSymbolStyleSelect;
    string_map["IFCSYSTEM"                                     ] = Type::IfcSystem;
    string_map["IFCSYSTEMFURNITUREELEMENTTYPE"                 ] = Type::IfcSystemFurnitureElementType;
    string_map["IFCTSHAPEPROFILEDEF"                           ] = Type::IfcTShapeProfileDef;
    string_map["IFCTABLE"                                      ] = Type::IfcTable;
    string_map["IFCTABLEROW"                                   ] = Type::IfcTableRow;
    string_map["IFCTANKTYPE"                                   ] = Type::IfcTankType;
    string_map["IFCTANKTYPEENUM"                               ] = Type::IfcTankTypeEnum;
    string_map["IFCTASK"                                       ] = Type::IfcTask;
    string_map["IFCTELECOMADDRESS"                             ] = Type::IfcTelecomAddress;
    string_map["IFCTEMPERATUREGRADIENTMEASURE"                 ] = Type::IfcTemperatureGradientMeasure;
    string_map["IFCTENDON"                                     ] = Type::IfcTendon;
    string_map["IFCTENDONANCHOR"                               ] = Type::IfcTendonAnchor;
    string_map["IFCTENDONTYPEENUM"                             ] = Type::IfcTendonTypeEnum;
    string_map["IFCTERMINATORSYMBOL"                           ] = Type::IfcTerminatorSymbol;
    string_map["IFCTEXT"                                       ] = Type::IfcText;
    string_map["IFCTEXTALIGNMENT"                              ] = Type::IfcTextAlignment;
    string_map["IFCTEXTDECORATION"                             ] = Type::IfcTextDecoration;
    string_map["IFCTEXTFONTNAME"                               ] = Type::IfcTextFontName;
    string_map["IFCTEXTFONTSELECT"                             ] = Type::IfcTextFontSelect;
    string_map["IFCTEXTLITERAL"                                ] = Type::IfcTextLiteral;
    string_map["IFCTEXTLITERALWITHEXTENT"                      ] = Type::IfcTextLiteralWithExtent;
    string_map["IFCTEXTPATH"                                   ] = Type::IfcTextPath;
    string_map["IFCTEXTSTYLE"                                  ] = Type::IfcTextStyle;
    string_map["IFCTEXTSTYLEFONTMODEL"                         ] = Type::IfcTextStyleFontModel;
    string_map["IFCTEXTSTYLEFORDEFINEDFONT"                    ] = Type::IfcTextStyleForDefinedFont;
    string_map["IFCTEXTSTYLESELECT"                            ] = Type::IfcTextStyleSelect;
    string_map["IFCTEXTSTYLETEXTMODEL"                         ] = Type::IfcTextStyleTextModel;
    string_map["IFCTEXTSTYLEWITHBOXCHARACTERISTICS"            ] = Type::IfcTextStyleWithBoxCharacteristics;
    string_map["IFCTEXTTRANSFORMATION"                         ] = Type::IfcTextTransformation;
    string_map["IFCTEXTURECOORDINATE"                          ] = Type::IfcTextureCoordinate;
    string_map["IFCTEXTURECOORDINATEGENERATOR"                 ] = Type::IfcTextureCoordinateGenerator;
    string_map["IFCTEXTUREMAP"                                 ] = Type::IfcTextureMap;
    string_map["IFCTEXTUREVERTEX"                              ] = Type::IfcTextureVertex;
    string_map["IFCTHERMALADMITTANCEMEASURE"                   ] = Type::IfcThermalAdmittanceMeasure;
    string_map["IFCTHERMALCONDUCTIVITYMEASURE"                 ] = Type::IfcThermalConductivityMeasure;
    string_map["IFCTHERMALEXPANSIONCOEFFICIENTMEASURE"         ] = Type::IfcThermalExpansionCoefficientMeasure;
    string_map["IFCTHERMALLOADSOURCEENUM"                      ] = Type::IfcThermalLoadSourceEnum;
    string_map["IFCTHERMALLOADTYPEENUM"                        ] = Type::IfcThermalLoadTypeEnum;
    string_map["IFCTHERMALMATERIALPROPERTIES"                  ] = Type::IfcThermalMaterialProperties;
    string_map["IFCTHERMALRESISTANCEMEASURE"                   ] = Type::IfcThermalResistanceMeasure;
    string_map["IFCTHERMALTRANSMITTANCEMEASURE"                ] = Type::IfcThermalTransmittanceMeasure;
    string_map["IFCTHERMODYNAMICTEMPERATUREMEASURE"            ] = Type::IfcThermodynamicTemperatureMeasure;
    string_map["IFCTIMEMEASURE"                                ] = Type::IfcTimeMeasure;
    string_map["IFCTIMESERIES"                                 ] = Type::IfcTimeSeries;
    string_map["IFCTIMESERIESDATATYPEENUM"                     ] = Type::IfcTimeSeriesDataTypeEnum;
    string_map["IFCTIMESERIESREFERENCERELATIONSHIP"            ] = Type::IfcTimeSeriesReferenceRelationship;
    string_map["IFCTIMESERIESSCHEDULE"                         ] = Type::IfcTimeSeriesSchedule;
    string_map["IFCTIMESERIESSCHEDULETYPEENUM"                 ] = Type::IfcTimeSeriesScheduleTypeEnum;
    string_map["IFCTIMESERIESVALUE"                            ] = Type::IfcTimeSeriesValue;
    string_map["IFCTIMESTAMP"                                  ] = Type::IfcTimeStamp;
    string_map["IFCTOPOLOGICALREPRESENTATIONITEM"              ] = Type::IfcTopologicalRepresentationItem;
    string_map["IFCTOPOLOGYREPRESENTATION"                     ] = Type::IfcTopologyRepresentation;
    string_map["IFCTORQUEMEASURE"                              ] = Type::IfcTorqueMeasure;
    string_map["IFCTRANSFORMERTYPE"                            ] = Type::IfcTransformerType;
    string_map["IFCTRANSFORMERTYPEENUM"                        ] = Type::IfcTransformerTypeEnum;
    string_map["IFCTRANSITIONCODE"                             ] = Type::IfcTransitionCode;
    string_map["IFCTRANSPORTELEMENT"                           ] = Type::IfcTransportElement;
    string_map["IFCTRANSPORTELEMENTTYPE"                       ] = Type::IfcTransportElementType;
    string_map["IFCTRANSPORTELEMENTTYPEENUM"                   ] = Type::IfcTransportElementTypeEnum;
    string_map["IFCTRAPEZIUMPROFILEDEF"                        ] = Type::IfcTrapeziumProfileDef;
    string_map["IFCTRIMMEDCURVE"                               ] = Type::IfcTrimmedCurve;
    string_map["IFCTRIMMINGPREFERENCE"                         ] = Type::IfcTrimmingPreference;
    string_map["IFCTRIMMINGSELECT"                             ] = Type::IfcTrimmingSelect;
    string_map["IFCTUBEBUNDLETYPE"                             ] = Type::IfcTubeBundleType;
    string_map["IFCTUBEBUNDLETYPEENUM"                         ] = Type::IfcTubeBundleTypeEnum;
    string_map["IFCTWODIRECTIONREPEATFACTOR"                   ] = Type::IfcTwoDirectionRepeatFactor;
    string_map["IFCTYPEOBJECT"                                 ] = Type::IfcTypeObject;
    string_map["IFCTYPEPRODUCT"                                ] = Type::IfcTypeProduct;
    string_map["IFCUSHAPEPROFILEDEF"                           ] = Type::IfcUShapeProfileDef;
    string_map["IFCUNIT"                                       ] = Type::IfcUnit;
    string_map["IFCUNITASSIGNMENT"                             ] = Type::IfcUnitAssignment;
    string_map["IFCUNITENUM"                                   ] = Type::IfcUnitEnum;
    string_map["IFCUNITARYEQUIPMENTTYPE"                       ] = Type::IfcUnitaryEquipmentType;
    string_map["IFCUNITARYEQUIPMENTTYPEENUM"                   ] = Type::IfcUnitaryEquipmentTypeEnum;
    string_map["IFCVALUE"                                      ] = Type::IfcValue;
    string_map["IFCVALVETYPE"                                  ] = Type::IfcValveType;
    string_map["IFCVALVETYPEENUM"                              ] = Type::IfcValveTypeEnum;
    string_map["IFCVAPORPERMEABILITYMEASURE"                   ] = Type::IfcVaporPermeabilityMeasure;
    string_map["IFCVECTOR"                                     ] = Type::IfcVector;
    string_map["IFCVECTORORDIRECTION"                          ] = Type::IfcVectorOrDirection;
    string_map["IFCVERTEX"                                     ] = Type::IfcVertex;
    string_map["IFCVERTEXBASEDTEXTUREMAP"                      ] = Type::IfcVertexBasedTextureMap;
    string_map["IFCVERTEXLOOP"                                 ] = Type::IfcVertexLoop;
    string_map["IFCVERTEXPOINT"                                ] = Type::IfcVertexPoint;
    string_map["IFCVIBRATIONISOLATORTYPE"                      ] = Type::IfcVibrationIsolatorType;
    string_map["IFCVIBRATIONISOLATORTYPEENUM"                  ] = Type::IfcVibrationIsolatorTypeEnum;
    string_map["IFCVIRTUALELEMENT"                             ] = Type::IfcVirtualElement;
    string_map["IFCVIRTUALGRIDINTERSECTION"                    ] = Type::IfcVirtualGridIntersection;
    string_map["IFCVOLUMEMEASURE"                              ] = Type::IfcVolumeMeasure;
    string_map["IFCVOLUMETRICFLOWRATEMEASURE"                  ] = Type::IfcVolumetricFlowRateMeasure;
    string_map["IFCWALL"                                       ] = Type::IfcWall;
    string_map["IFCWALLSTANDARDCASE"                           ] = Type::IfcWallStandardCase;
    string_map["IFCWALLTYPE"                                   ] = Type::IfcWallType;
    string_map["IFCWALLTYPEENUM"                               ] = Type::IfcWallTypeEnum;
    string_map["IFCWARPINGCONSTANTMEASURE"                     ] = Type::IfcWarpingConstantMeasure;
    string_map["IFCWARPINGMOMENTMEASURE"                       ] = Type::IfcWarpingMomentMeasure;
    string_map["IFCWASTETERMINALTYPE"                          ] = Type::IfcWasteTerminalType;
    string_map["IFCWASTETERMINALTYPEENUM"                      ] = Type::IfcWasteTerminalTypeEnum;
    string_map["IFCWATERPROPERTIES"                            ] = Type::IfcWaterProperties;
    string_map["IFCWINDOW"                                     ] = Type::IfcWindow;
    string_map["IFCWINDOWLININGPROPERTIES"                     ] = Type::IfcWindowLiningProperties;
    string_map["IFCWINDOWPANELOPERATIONENUM"                   ] = Type::IfcWindowPanelOperationEnum;
    string_map["IFCWINDOWPANELPOSITIONENUM"                    ] = Type::IfcWindowPanelPositionEnum;
    string_map["IFCWINDOWPANELPROPERTIES"                      ] = Type::IfcWindowPanelProperties;
    string_map["IFCWINDOWSTYLE"                                ] = Type::IfcWindowStyle;
    string_map["IFCWINDOWSTYLECONSTRUCTIONENUM"                ] = Type::IfcWindowStyleConstructionEnum;
    string_map["IFCWINDOWSTYLEOPERATIONENUM"                   ] = Type::IfcWindowStyleOperationEnum;
    string_map["IFCWORKCONTROL"                                ] = Type::IfcWorkControl;
    string_map["IFCWORKCONTROLTYPEENUM"                        ] = Type::IfcWorkControlTypeEnum;
    string_map["IFCWORKPLAN"                                   ] = Type::IfcWorkPlan;
    string_map["IFCWORKSCHEDULE"                               ] = Type::IfcWorkSchedule;
    string_map["IFCYEARNUMBER"                                 ] = Type::IfcYearNumber;
    string_map["IFCZSHAPEPROFILEDEF"                           ] = Type::IfcZShapeProfileDef;
    string_map["IFCZONE"                                       ] = Type::IfcZone;
}

Type::Enum Type::FromString(const std::string& s) {
    if (string_map.empty()) InitStringMap();
    std::map<std::string,Type::Enum>::const_iterator it = string_map.find(s);
    if ( it == string_map.end() ) throw IfcException("Unable to find find keyword in schema");
    else return it->second;
}

static int parent_map[] = {133,-1,-1,164,-1,-1,515,-1,-1,234,-1,-1,-1,-1,354,-1,369,-1,309,-1,234,-1,-1,-1,-1,221,-1,600,31,392,31,840,392,31,31,31,-1,-1,-1,-1,-1,-1,-1,-1,604,604,44,-1,-1,-1,401,412,560,-1,560,560,77,-1,83,89,-1,-1,56,857,184,309,-1,-1,71,-1,-1,392,-1,72,72,72,75,193,844,392,-1,402,786,297,83,84,83,89,-1,304,786,540,357,-1,365,-1,365,-1,-1,569,392,100,101,100,103,45,271,-1,-1,309,-1,144,113,540,-1,-1,-1,-1,-1,-1,322,145,309,-1,-1,-1,127,-1,83,89,-1,-1,615,77,392,604,-1,363,-1,309,-1,401,164,-1,193,916,147,-1,149,147,147,147,-1,-1,-1,-1,-1,-1,161,161,161,722,-1,511,515,234,-1,511,309,-1,309,-1,-1,164,164,-1,37,-1,83,89,-1,540,540,161,392,-1,773,-1,-1,83,89,-1,-1,392,78,-1,-1,593,-1,-1,-1,-1,354,-1,-1,-1,-1,-1,-1,392,-1,-1,604,-1,-1,-1,-1,221,258,-1,28,256,879,-1,258,-1,392,-1,300,301,237,238,-1,235,236,297,304,235,236,576,-1,-1,-1,-1,322,-1,-1,83,625,-1,-1,625,933,-1,-1,-1,392,-1,-1,582,583,589,357,-1,365,-1,371,-1,-1,916,269,342,464,369,-1,-1,-1,-1,-1,-1,353,-1,367,-1,309,-1,369,-1,309,-1,-1,354,-1,-1,311,866,297,600,297,-1,297,304,-1,625,933,844,144,540,237,238,-1,625,-1,-1,37,297,164,309,-1,309,-1,483,-1,322,322,322,322,859,916,392,916,330,328,470,470,806,363,-1,300,301,297,340,340,593,392,-1,392,392,-1,371,-1,369,-1,237,238,-1,237,238,234,-1,354,-1,237,238,237,238,237,238,237,238,237,238,625,-1,-1,-1,83,-1,-1,-1,483,297,304,164,382,369,-1,483,605,394,-1,719,720,391,392,-1,-1,-1,600,-1,517,515,392,-1,309,-1,-1,-1,-1,309,-1,483,540,-1,-1,857,-1,-1,-1,-1,401,-1,-1,909,-1,-1,357,-1,-1,540,-1,161,369,-1,-1,-1,-1,-1,322,-1,-1,-1,-1,-1,369,-1,-1,392,447,447,447,447,451,193,221,-1,-1,-1,-1,-1,517,-1,-1,-1,916,-1,-1,-1,-1,-1,773,720,-1,-1,-1,-1,-1,-1,602,-1,-1,-1,-1,-1,-1,-1,-1,490,338,339,483,490,83,89,-1,153,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,309,-1,873,-1,-1,-1,-1,516,732,-1,-1,-1,153,-1,6,-1,193,193,392,145,342,483,873,-1,-1,-1,269,369,-1,-1,-1,-1,604,916,164,-1,625,164,-1,-1,550,-1,-1,550,83,-1,-1,357,-1,365,-1,857,392,562,392,-1,305,-1,83,89,-1,392,569,569,-1,464,402,77,600,-1,-1,-1,11,-1,585,585,587,-1,587,585,587,585,-1,-1,591,-1,-1,-1,-1,599,-1,515,515,602,-1,483,-1,-1,-1,515,164,164,-1,-1,-1,28,341,-1,764,-1,732,-1,764,-1,764,764,625,618,764,-1,764,354,-1,600,363,-1,551,551,551,551,551,551,-1,221,83,89,-1,83,83,89,-1,-1,-1,62,-1,654,540,184,78,-1,-1,909,-1,625,665,-1,-1,84,665,699,716,671,668,668,668,668,668,671,668,716,677,677,677,677,677,677,677,677,716,686,687,686,686,686,686,686,693,687,686,686,686,716,716,700,700,686,686,686,699,670,701,686,686,671,686,686,686,686,732,-1,-1,-1,-1,-1,515,-1,859,-1,605,184,184,-1,83,-1,-1,-1,-1,-1,271,654,-1,511,-1,369,-1,164,-1,-1,-1,-1,-1,-1,392,234,-1,-1,164,625,-1,-1,-1,718,759,-1,-1,392,615,-1,786,-1,83,89,-1,806,-1,392,-1,-1,625,-1,625,786,309,-1,164,625,787,-1,600,304,-1,-1,-1,-1,184,369,-1,83,83,89,-1,-1,-1,802,600,-1,866,811,-1,805,824,808,-1,600,801,812,-1,401,822,822,822,818,822,820,814,822,811,801,825,801,805,831,388,802,401,830,805,824,835,-1,256,718,720,839,161,269,392,859,861,861,-1,-1,593,-1,-1,-1,855,-1,-1,-1,-1,773,773,844,354,-1,593,-1,401,382,540,-1,-1,367,-1,599,11,-1,665,665,-1,34,-1,-1,-1,-1,-1,392,885,-1,593,589,-1,-1,-1,-1,-1,-1,895,895,-1,-1,-1,-1,-1,-1,483,-1,-1,-1,-1,-1,-1,-1,164,-1,-1,-1,720,759,-1,309,-1,-1,297,304,-1,540,77,-1,-1,309,-1,526,516,932,540,-1,-1,-1,309,-1,-1,354,-1,-1,392,-1,916,-1,464,946,229,-1,297,-1,-1,-1,83,956,89,-1,-1,-1,369,-1,483,83,625,-1,-1,625,933,-1,-1,164,-1,973,973,-1,540,401};
boost::optional<Type::Enum> Type::Parent(Enum v){
    const int p = parent_map[static_cast<int>(v)];
    if (p >= 0) {
        return static_cast<Type::Enum>(p);
    } else {
        return boost::none;
    }
}

bool Type::IsSimple(Enum v) {
    return v == Type::IfcAbsorbedDoseMeasure || v == Type::IfcAccelerationMeasure || v == Type::IfcAmountOfSubstanceMeasure || v == Type::IfcAngularVelocityMeasure || v == Type::IfcAreaMeasure || v == Type::IfcBoolean || v == Type::IfcColour || v == Type::IfcComplexNumber || v == Type::IfcCompoundPlaneAngleMeasure || v == Type::IfcContextDependentMeasure || v == Type::IfcCountMeasure || v == Type::IfcCurvatureMeasure || v == Type::IfcCurveStyleFontSelect || v == Type::IfcDateTimeSelect || v == Type::IfcDerivedMeasureValue || v == Type::IfcDescriptiveMeasure || v == Type::IfcDoseEquivalentMeasure || v == Type::IfcDynamicViscosityMeasure || v == Type::IfcElectricCapacitanceMeasure || v == Type::IfcElectricChargeMeasure || v == Type::IfcElectricConductanceMeasure || v == Type::IfcElectricCurrentMeasure || v == Type::IfcElectricResistanceMeasure || v == Type::IfcElectricVoltageMeasure || v == Type::IfcEnergyMeasure || v == Type::IfcForceMeasure || v == Type::IfcFrequencyMeasure || v == Type::IfcHeatFluxDensityMeasure || v == Type::IfcHeatingValueMeasure || v == Type::IfcIdentifier || v == Type::IfcIlluminanceMeasure || v == Type::IfcInductanceMeasure || v == Type::IfcInteger || v == Type::IfcIntegerCountRateMeasure || v == Type::IfcIonConcentrationMeasure || v == Type::IfcIsothermalMoistureCapacityMeasure || v == Type::IfcKinematicViscosityMeasure || v == Type::IfcLabel || v == Type::IfcLengthMeasure || v == Type::IfcLinearForceMeasure || v == Type::IfcLinearMomentMeasure || v == Type::IfcLinearStiffnessMeasure || v == Type::IfcLinearVelocityMeasure || v == Type::IfcLogical || v == Type::IfcLuminousFluxMeasure || v == Type::IfcLuminousIntensityDistributionMeasure || v == Type::IfcLuminousIntensityMeasure || v == Type::IfcMagneticFluxDensityMeasure || v == Type::IfcMagneticFluxMeasure || v == Type::IfcMassDensityMeasure || v == Type::IfcMassFlowRateMeasure || v == Type::IfcMassMeasure || v == Type::IfcMassPerLengthMeasure || v == Type::IfcMeasureValue || v == Type::IfcModulusOfElasticityMeasure || v == Type::IfcModulusOfLinearSubgradeReactionMeasure || v == Type::IfcModulusOfRotationalSubgradeReactionMeasure || v == Type::IfcModulusOfSubgradeReactionMeasure || v == Type::IfcMoistureDiffusivityMeasure || v == Type::IfcMolecularWeightMeasure || v == Type::IfcMomentOfInertiaMeasure || v == Type::IfcMonetaryMeasure || v == Type::IfcNormalisedRatioMeasure || v == Type::IfcNullStyle || v == Type::IfcNumericMeasure || v == Type::IfcPHMeasure || v == Type::IfcParameterValue || v == Type::IfcPlanarForceMeasure || v == Type::IfcPlaneAngleMeasure || v == Type::IfcPositiveLengthMeasure || v == Type::IfcPositivePlaneAngleMeasure || v == Type::IfcPositiveRatioMeasure || v == Type::IfcPowerMeasure || v == Type::IfcPressureMeasure || v == Type::IfcRadioActivityMeasure || v == Type::IfcRatioMeasure || v == Type::IfcReal || v == Type::IfcRotationalFrequencyMeasure || v == Type::IfcRotationalMassMeasure || v == Type::IfcRotationalStiffnessMeasure || v == Type::IfcSectionModulusMeasure || v == Type::IfcSectionalAreaIntegralMeasure || v == Type::IfcShearModulusMeasure || v == Type::IfcSimpleValue || v == Type::IfcSolidAngleMeasure || v == Type::IfcSoundPowerMeasure || v == Type::IfcSoundPressureMeasure || v == Type::IfcSpecificHeatCapacityMeasure || v == Type::IfcSpecularExponent || v == Type::IfcSpecularRoughness || v == Type::IfcTemperatureGradientMeasure || v == Type::IfcText || v == Type::IfcThermalAdmittanceMeasure || v == Type::IfcThermalConductivityMeasure || v == Type::IfcThermalExpansionCoefficientMeasure || v == Type::IfcThermalResistanceMeasure || v == Type::IfcThermalTransmittanceMeasure || v == Type::IfcThermodynamicTemperatureMeasure || v == Type::IfcTimeMeasure || v == Type::IfcTimeStamp || v == Type::IfcTorqueMeasure || v == Type::IfcVaporPermeabilityMeasure || v == Type::IfcVolumeMeasure || v == Type::IfcVolumetricFlowRateMeasure || v == Type::IfcWarpingConstantMeasure || v == Type::IfcWarpingMomentMeasure;
}


const char* IfcActionSourceTypeEnum::ToString(IfcActionSourceTypeEnum v) {
    if ( v < 0 || v >= 27 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DEAD_LOAD_G", "COMPLETION_G1", "LIVE_LOAD_Q", "SNOW_S", "WIND_W", "PRESTRESSING_P", "SETTLEMENT_U", "TEMPERATURE_T", "EARTHQUAKE_E", "FIRE", "IMPULSE", "IMPACT", "TRANSPORT", "ERECTION", "PROPPING", "SYSTEM_IMPERFECTION", "SHRINKAGE", "CREEP", "LACK_OF_FIT", "BUOYANCY", "ICE", "CURRENT", "WAVE", "RAIN", "BRAKES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcActionSourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEAD_LOAD_G") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_DEAD_LOAD_G;
    if (s == "COMPLETION_G1") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_COMPLETION_G1;
    if (s == "LIVE_LOAD_Q") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_LIVE_LOAD_Q;
    if (s == "SNOW_S") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SNOW_S;
    if (s == "WIND_W") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_WIND_W;
    if (s == "PRESTRESSING_P") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_PRESTRESSING_P;
    if (s == "SETTLEMENT_U") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SETTLEMENT_U;
    if (s == "TEMPERATURE_T") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_TEMPERATURE_T;
    if (s == "EARTHQUAKE_E") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_EARTHQUAKE_E;
    if (s == "FIRE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_FIRE;
    if (s == "IMPULSE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_IMPULSE;
    if (s == "IMPACT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_IMPACT;
    if (s == "TRANSPORT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_TRANSPORT;
    if (s == "ERECTION") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_ERECTION;
    if (s == "PROPPING") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_PROPPING;
    if (s == "SYSTEM_IMPERFECTION") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SYSTEM_IMPERFECTION;
    if (s == "SHRINKAGE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SHRINKAGE;
    if (s == "CREEP") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_CREEP;
    if (s == "LACK_OF_FIT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_LACK_OF_FIT;
    if (s == "BUOYANCY") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_BUOYANCY;
    if (s == "ICE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_ICE;
    if (s == "CURRENT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_CURRENT;
    if (s == "WAVE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_WAVE;
    if (s == "RAIN") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_RAIN;
    if (s == "BRAKES") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_BRAKES;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActionTypeEnum::ToString(IfcActionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PERMANENT_G", "VARIABLE_Q", "EXTRAORDINARY_A", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionTypeEnum::IfcActionTypeEnum IfcActionTypeEnum::FromString(const std::string& s) {
    if (s == "PERMANENT_G") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_PERMANENT_G;
    if (s == "VARIABLE_Q") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_VARIABLE_Q;
    if (s == "EXTRAORDINARY_A") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_EXTRAORDINARY_A;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActuatorTypeEnum::ToString(IfcActuatorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRICACTUATOR", "HANDOPERATEDACTUATOR", "HYDRAULICACTUATOR", "PNEUMATICACTUATOR", "THERMOSTATICACTUATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_ELECTRICACTUATOR;
    if (s == "HANDOPERATEDACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_HANDOPERATEDACTUATOR;
    if (s == "HYDRAULICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_HYDRAULICACTUATOR;
    if (s == "PNEUMATICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_PNEUMATICACTUATOR;
    if (s == "THERMOSTATICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_THERMOSTATICACTUATOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAddressTypeEnum::ToString(IfcAddressTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "HOME", "DISTRIBUTIONPOINT", "USERDEFINED" };
    return names[v];
}

IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddressTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_OFFICE;
    if (s == "SITE") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_SITE;
    if (s == "HOME") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_HOME;
    if (s == "DISTRIBUTIONPOINT") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_DISTRIBUTIONPOINT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAheadOrBehind::ToString(IfcAheadOrBehind v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AHEAD", "BEHIND" };
    return names[v];
}

IfcAheadOrBehind::IfcAheadOrBehind IfcAheadOrBehind::FromString(const std::string& s) {
    if (s == "AHEAD") return ::Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind_AHEAD;
    if (s == "BEHIND") return ::Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind_BEHIND;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalBoxTypeEnum::ToString(IfcAirTerminalBoxTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSTANTFLOW", "VARIABLEFLOWPRESSUREDEPENDANT", "VARIABLEFLOWPRESSUREINDEPENDANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTANTFLOW") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_CONSTANTFLOW;
    if (s == "VARIABLEFLOWPRESSUREDEPENDANT") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT;
    if (s == "VARIABLEFLOWPRESSUREINDEPENDANT") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalTypeEnum::ToString(IfcAirTerminalTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRILLE", "REGISTER", "DIFFUSER", "EYEBALL", "IRIS", "LINEARGRILLE", "LINEARDIFFUSER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "GRILLE") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_GRILLE;
    if (s == "REGISTER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_REGISTER;
    if (s == "DIFFUSER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_DIFFUSER;
    if (s == "EYEBALL") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_EYEBALL;
    if (s == "IRIS") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_IRIS;
    if (s == "LINEARGRILLE") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_LINEARGRILLE;
    if (s == "LINEARDIFFUSER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_LINEARDIFFUSER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirToAirHeatRecoveryTypeEnum::ToString(IfcAirToAirHeatRecoveryTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIXEDPLATECOUNTERFLOWEXCHANGER", "FIXEDPLATECROSSFLOWEXCHANGER", "FIXEDPLATEPARALLELFLOWEXCHANGER", "ROTARYWHEEL", "RUNAROUNDCOILLOOP", "HEATPIPE", "TWINTOWERENTHALPYRECOVERYLOOPS", "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS", "THERMOSIPHONCOILTYPEHEATEXCHANGERS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryTypeEnum::FromString(const std::string& s) {
    if (s == "FIXEDPLATECOUNTERFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER;
    if (s == "FIXEDPLATECROSSFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER;
    if (s == "FIXEDPLATEPARALLELFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER;
    if (s == "ROTARYWHEEL") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_ROTARYWHEEL;
    if (s == "RUNAROUNDCOILLOOP") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP;
    if (s == "HEATPIPE") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_HEATPIPE;
    if (s == "TWINTOWERENTHALPYRECOVERYLOOPS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS;
    if (s == "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS;
    if (s == "THERMOSIPHONCOILTYPEHEATEXCHANGERS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAlarmTypeEnum::ToString(IfcAlarmTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELL", "BREAKGLASSBUTTON", "LIGHT", "MANUALPULLBOX", "SIREN", "WHISTLE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmTypeEnum::FromString(const std::string& s) {
    if (s == "BELL") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_BELL;
    if (s == "BREAKGLASSBUTTON") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_BREAKGLASSBUTTON;
    if (s == "LIGHT") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_LIGHT;
    if (s == "MANUALPULLBOX") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_MANUALPULLBOX;
    if (s == "SIREN") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_SIREN;
    if (s == "WHISTLE") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_WHISTLE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisModelTypeEnum::ToString(IfcAnalysisModelTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "IN_PLANE_LOADING_2D", "OUT_PLANE_LOADING_2D", "LOADING_3D", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcAnalysisModelTypeEnum::FromString(const std::string& s) {
    if (s == "IN_PLANE_LOADING_2D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_IN_PLANE_LOADING_2D;
    if (s == "OUT_PLANE_LOADING_2D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_OUT_PLANE_LOADING_2D;
    if (s == "LOADING_3D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_LOADING_3D;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisTheoryTypeEnum::ToString(IfcAnalysisTheoryTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIRST_ORDER_THEORY", "SECOND_ORDER_THEORY", "THIRD_ORDER_THEORY", "FULL_NONLINEAR_THEORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcAnalysisTheoryTypeEnum::FromString(const std::string& s) {
    if (s == "FIRST_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FIRST_ORDER_THEORY;
    if (s == "SECOND_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_SECOND_ORDER_THEORY;
    if (s == "THIRD_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_THIRD_ORDER_THEORY;
    if (s == "FULL_NONLINEAR_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcArithmeticOperatorEnum::ToString(IfcArithmeticOperatorEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADD", "DIVIDE", "MULTIPLY", "SUBTRACT" };
    return names[v];
}

IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcArithmeticOperatorEnum::FromString(const std::string& s) {
    if (s == "ADD") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_ADD;
    if (s == "DIVIDE") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_DIVIDE;
    if (s == "MULTIPLY") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_MULTIPLY;
    if (s == "SUBTRACT") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_SUBTRACT;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAssemblyPlaceEnum::ToString(IfcAssemblyPlaceEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SITE", "FACTORY", "NOTDEFINED" };
    return names[v];
}

IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcAssemblyPlaceEnum::FromString(const std::string& s) {
    if (s == "SITE") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_SITE;
    if (s == "FACTORY") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_FACTORY;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBSplineCurveForm::ToString(IfcBSplineCurveForm v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POLYLINE_FORM", "CIRCULAR_ARC", "ELLIPTIC_ARC", "PARABOLIC_ARC", "HYPERBOLIC_ARC", "UNSPECIFIED" };
    return names[v];
}

IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurveForm::FromString(const std::string& s) {
    if (s == "POLYLINE_FORM") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_POLYLINE_FORM;
    if (s == "CIRCULAR_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_CIRCULAR_ARC;
    if (s == "ELLIPTIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_ELLIPTIC_ARC;
    if (s == "PARABOLIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_PARABOLIC_ARC;
    if (s == "HYPERBOLIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_HYPERBOLIC_ARC;
    if (s == "UNSPECIFIED") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBeamTypeEnum::ToString(IfcBeamTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEAM", "JOIST", "LINTEL", "T_BEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamTypeEnum::FromString(const std::string& s) {
    if (s == "BEAM") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_BEAM;
    if (s == "JOIST") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_JOIST;
    if (s == "LINTEL") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_LINTEL;
    if (s == "T_BEAM") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_T_BEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBenchmarkEnum::ToString(IfcBenchmarkEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GREATERTHAN", "GREATERTHANOREQUALTO", "LESSTHAN", "LESSTHANOREQUALTO", "EQUALTO", "NOTEQUALTO" };
    return names[v];
}

IfcBenchmarkEnum::IfcBenchmarkEnum IfcBenchmarkEnum::FromString(const std::string& s) {
    if (s == "GREATERTHAN") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_GREATERTHAN;
    if (s == "GREATERTHANOREQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_GREATERTHANOREQUALTO;
    if (s == "LESSTHAN") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_LESSTHAN;
    if (s == "LESSTHANOREQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_LESSTHANOREQUALTO;
    if (s == "EQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_EQUALTO;
    if (s == "NOTEQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_NOTEQUALTO;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBoilerTypeEnum::ToString(IfcBoilerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WATER", "STEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerTypeEnum::FromString(const std::string& s) {
    if (s == "WATER") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_WATER;
    if (s == "STEAM") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_STEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBooleanOperator::ToString(IfcBooleanOperator v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNION", "INTERSECTION", "DIFFERENCE" };
    return names[v];
}

IfcBooleanOperator::IfcBooleanOperator IfcBooleanOperator::FromString(const std::string& s) {
    if (s == "UNION") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_UNION;
    if (s == "INTERSECTION") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_INTERSECTION;
    if (s == "DIFFERENCE") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_DIFFERENCE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingElementProxyTypeEnum::ToString(IfcBuildingElementProxyTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierFittingTypeEnum::ToString(IfcCableCarrierFittingTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CROSS", "REDUCER", "TEE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_BEND;
    if (s == "CROSS") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_CROSS;
    if (s == "REDUCER") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_REDUCER;
    if (s == "TEE") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_TEE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierSegmentTypeEnum::ToString(IfcCableCarrierSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLELADDERSEGMENT", "CABLETRAYSEGMENT", "CABLETRUNKINGSEGMENT", "CONDUITSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLELADDERSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLELADDERSEGMENT;
    if (s == "CABLETRAYSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRAYSEGMENT;
    if (s == "CABLETRUNKINGSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT;
    if (s == "CONDUITSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CONDUITSEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableSegmentTypeEnum::ToString(IfcCableSegmentTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLESEGMENT", "CONDUCTORSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLESEGMENT") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_CABLESEGMENT;
    if (s == "CONDUCTORSEGMENT") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_CONDUCTORSEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChangeActionEnum::ToString(IfcChangeActionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NOCHANGE", "MODIFIED", "ADDED", "DELETED", "MODIFIEDADDED", "MODIFIEDDELETED" };
    return names[v];
}

IfcChangeActionEnum::IfcChangeActionEnum IfcChangeActionEnum::FromString(const std::string& s) {
    if (s == "NOCHANGE") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_NOCHANGE;
    if (s == "MODIFIED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIED;
    if (s == "ADDED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_ADDED;
    if (s == "DELETED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_DELETED;
    if (s == "MODIFIEDADDED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIEDADDED;
    if (s == "MODIFIEDDELETED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIEDDELETED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChillerTypeEnum::ToString(IfcChillerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCOOLED", "WATERCOOLED", "HEATRECOVERY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_AIRCOOLED;
    if (s == "WATERCOOLED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_WATERCOOLED;
    if (s == "HEATRECOVERY") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_HEATRECOVERY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoilTypeEnum::ToString(IfcCoilTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DXCOOLINGCOIL", "WATERCOOLINGCOIL", "STEAMHEATINGCOIL", "WATERHEATINGCOIL", "ELECTRICHEATINGCOIL", "GASHEATINGCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilTypeEnum::FromString(const std::string& s) {
    if (s == "DXCOOLINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_DXCOOLINGCOIL;
    if (s == "WATERCOOLINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_WATERCOOLINGCOIL;
    if (s == "STEAMHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_STEAMHEATINGCOIL;
    if (s == "WATERHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_WATERHEATINGCOIL;
    if (s == "ELECTRICHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_ELECTRICHEATINGCOIL;
    if (s == "GASHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_GASHEATINGCOIL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcColumnTypeEnum::ToString(IfcColumnTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COLUMN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnTypeEnum::FromString(const std::string& s) {
    if (s == "COLUMN") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_COLUMN;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCompressorTypeEnum::ToString(IfcCompressorTypeEnum v) {
    if ( v < 0 || v >= 17 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DYNAMIC", "RECIPROCATING", "ROTARY", "SCROLL", "TROCHOIDAL", "SINGLESTAGE", "BOOSTER", "OPENTYPE", "HERMETIC", "SEMIHERMETIC", "WELDEDSHELLHERMETIC", "ROLLINGPISTON", "ROTARYVANE", "SINGLESCREW", "TWINSCREW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorTypeEnum::FromString(const std::string& s) {
    if (s == "DYNAMIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_DYNAMIC;
    if (s == "RECIPROCATING") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_RECIPROCATING;
    if (s == "ROTARY") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROTARY;
    if (s == "SCROLL") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SCROLL;
    if (s == "TROCHOIDAL") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_TROCHOIDAL;
    if (s == "SINGLESTAGE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SINGLESTAGE;
    if (s == "BOOSTER") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_BOOSTER;
    if (s == "OPENTYPE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_OPENTYPE;
    if (s == "HERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_HERMETIC;
    if (s == "SEMIHERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SEMIHERMETIC;
    if (s == "WELDEDSHELLHERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_WELDEDSHELLHERMETIC;
    if (s == "ROLLINGPISTON") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROLLINGPISTON;
    if (s == "ROTARYVANE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROTARYVANE;
    if (s == "SINGLESCREW") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SINGLESCREW;
    if (s == "TWINSCREW") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_TWINSCREW;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCondenserTypeEnum::ToString(IfcCondenserTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WATERCOOLEDSHELLTUBE", "WATERCOOLEDSHELLCOIL", "WATERCOOLEDTUBEINTUBE", "WATERCOOLEDBRAZEDPLATE", "AIRCOOLED", "EVAPORATIVECOOLED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserTypeEnum::FromString(const std::string& s) {
    if (s == "WATERCOOLEDSHELLTUBE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLTUBE;
    if (s == "WATERCOOLEDSHELLCOIL") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLCOIL;
    if (s == "WATERCOOLEDTUBEINTUBE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDTUBEINTUBE;
    if (s == "WATERCOOLEDBRAZEDPLATE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDBRAZEDPLATE;
    if (s == "AIRCOOLED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_AIRCOOLED;
    if (s == "EVAPORATIVECOOLED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_EVAPORATIVECOOLED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConnectionTypeEnum::ToString(IfcConnectionTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ATPATH", "ATSTART", "ATEND", "NOTDEFINED" };
    return names[v];
}

IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "ATPATH") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATPATH;
    if (s == "ATSTART") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATSTART;
    if (s == "ATEND") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATEND;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstraintEnum::ToString(IfcConstraintEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HARD", "SOFT", "ADVISORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstraintEnum::IfcConstraintEnum IfcConstraintEnum::FromString(const std::string& s) {
    if (s == "HARD") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_HARD;
    if (s == "SOFT") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_SOFT;
    if (s == "ADVISORY") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_ADVISORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcControllerTypeEnum::ToString(IfcControllerTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOATING", "PROPORTIONAL", "PROPORTIONALINTEGRAL", "PROPORTIONALINTEGRALDERIVATIVE", "TIMEDTWOPOSITION", "TWOPOSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerTypeEnum::FromString(const std::string& s) {
    if (s == "FLOATING") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_FLOATING;
    if (s == "PROPORTIONAL") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONAL;
    if (s == "PROPORTIONALINTEGRAL") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONALINTEGRAL;
    if (s == "PROPORTIONALINTEGRALDERIVATIVE") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONALINTEGRALDERIVATIVE;
    if (s == "TIMEDTWOPOSITION") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_TIMEDTWOPOSITION;
    if (s == "TWOPOSITION") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_TWOPOSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCooledBeamTypeEnum::ToString(IfcCooledBeamTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTIVE", "PASSIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamTypeEnum::FromString(const std::string& s) {
    if (s == "ACTIVE") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_ACTIVE;
    if (s == "PASSIVE") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_PASSIVE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoolingTowerTypeEnum::ToString(IfcCoolingTowerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NATURALDRAFT", "MECHANICALINDUCEDDRAFT", "MECHANICALFORCEDDRAFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerTypeEnum::FromString(const std::string& s) {
    if (s == "NATURALDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NATURALDRAFT;
    if (s == "MECHANICALINDUCEDDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALINDUCEDDRAFT;
    if (s == "MECHANICALFORCEDDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALFORCEDDRAFT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCostScheduleTypeEnum::ToString(IfcCostScheduleTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUDGET", "COSTPLAN", "ESTIMATE", "TENDER", "PRICEDBILLOFQUANTITIES", "UNPRICEDBILLOFQUANTITIES", "SCHEDULEOFRATES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "BUDGET") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_BUDGET;
    if (s == "COSTPLAN") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_COSTPLAN;
    if (s == "ESTIMATE") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_ESTIMATE;
    if (s == "TENDER") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_TENDER;
    if (s == "PRICEDBILLOFQUANTITIES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_PRICEDBILLOFQUANTITIES;
    if (s == "UNPRICEDBILLOFQUANTITIES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES;
    if (s == "SCHEDULEOFRATES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_SCHEDULEOFRATES;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoveringTypeEnum::ToString(IfcCoveringTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CEILING", "FLOORING", "CLADDING", "ROOFING", "INSULATION", "MEMBRANE", "SLEEVING", "WRAPPING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringTypeEnum::FromString(const std::string& s) {
    if (s == "CEILING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_CEILING;
    if (s == "FLOORING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_FLOORING;
    if (s == "CLADDING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_CLADDING;
    if (s == "ROOFING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_ROOFING;
    if (s == "INSULATION") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_INSULATION;
    if (s == "MEMBRANE") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_MEMBRANE;
    if (s == "SLEEVING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_SLEEVING;
    if (s == "WRAPPING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_WRAPPING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurrencyEnum::ToString(IfcCurrencyEnum v) {
    if ( v < 0 || v >= 83 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AED", "AES", "ATS", "AUD", "BBD", "BEG", "BGL", "BHD", "BMD", "BND", "BRL", "BSD", "BWP", "BZD", "CAD", "CBD", "CHF", "CLP", "CNY", "CYS", "CZK", "DDP", "DEM", "DKK", "EGL", "EST", "EUR", "FAK", "FIM", "FJD", "FKP", "FRF", "GBP", "GIP", "GMD", "GRX", "HKD", "HUF", "ICK", "IDR", "ILS", "INR", "IRP", "ITL", "JMD", "JOD", "JPY", "KES", "KRW", "KWD", "KYD", "LKR", "LUF", "MTL", "MUR", "MXN", "MYR", "NLG", "NZD", "OMR", "PGK", "PHP", "PKR", "PLN", "PTN", "QAR", "RUR", "SAR", "SCR", "SEK", "SGD", "SKP", "THB", "TRL", "TTD", "TWD", "USD", "VEB", "VND", "XEU", "ZAR", "ZWD", "NOK" };
    return names[v];
}

IfcCurrencyEnum::IfcCurrencyEnum IfcCurrencyEnum::FromString(const std::string& s) {
    if (s == "AED") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AED;
    if (s == "AES") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AES;
    if (s == "ATS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ATS;
    if (s == "AUD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AUD;
    if (s == "BBD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BBD;
    if (s == "BEG") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BEG;
    if (s == "BGL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BGL;
    if (s == "BHD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BHD;
    if (s == "BMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BMD;
    if (s == "BND") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BND;
    if (s == "BRL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BRL;
    if (s == "BSD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BSD;
    if (s == "BWP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BWP;
    if (s == "BZD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BZD;
    if (s == "CAD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CAD;
    if (s == "CBD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CBD;
    if (s == "CHF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CHF;
    if (s == "CLP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CLP;
    if (s == "CNY") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CNY;
    if (s == "CYS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CYS;
    if (s == "CZK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CZK;
    if (s == "DDP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DDP;
    if (s == "DEM") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DEM;
    if (s == "DKK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DKK;
    if (s == "EGL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EGL;
    if (s == "EST") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EST;
    if (s == "EUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EUR;
    if (s == "FAK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FAK;
    if (s == "FIM") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FIM;
    if (s == "FJD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FJD;
    if (s == "FKP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FKP;
    if (s == "FRF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FRF;
    if (s == "GBP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GBP;
    if (s == "GIP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GIP;
    if (s == "GMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GMD;
    if (s == "GRX") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GRX;
    if (s == "HKD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_HKD;
    if (s == "HUF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_HUF;
    if (s == "ICK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ICK;
    if (s == "IDR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_IDR;
    if (s == "ILS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ILS;
    if (s == "INR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_INR;
    if (s == "IRP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_IRP;
    if (s == "ITL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ITL;
    if (s == "JMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JMD;
    if (s == "JOD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JOD;
    if (s == "JPY") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JPY;
    if (s == "KES") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KES;
    if (s == "KRW") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KRW;
    if (s == "KWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KWD;
    if (s == "KYD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KYD;
    if (s == "LKR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_LKR;
    if (s == "LUF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_LUF;
    if (s == "MTL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MTL;
    if (s == "MUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MUR;
    if (s == "MXN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MXN;
    if (s == "MYR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MYR;
    if (s == "NLG") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NLG;
    if (s == "NZD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NZD;
    if (s == "OMR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_OMR;
    if (s == "PGK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PGK;
    if (s == "PHP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PHP;
    if (s == "PKR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PKR;
    if (s == "PLN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PLN;
    if (s == "PTN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PTN;
    if (s == "QAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_QAR;
    if (s == "RUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_RUR;
    if (s == "SAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SAR;
    if (s == "SCR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SCR;
    if (s == "SEK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SEK;
    if (s == "SGD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SGD;
    if (s == "SKP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SKP;
    if (s == "THB") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_THB;
    if (s == "TRL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TRL;
    if (s == "TTD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TTD;
    if (s == "TWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TWD;
    if (s == "USD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_USD;
    if (s == "VEB") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_VEB;
    if (s == "VND") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_VND;
    if (s == "XEU") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_XEU;
    if (s == "ZAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ZAR;
    if (s == "ZWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ZWD;
    if (s == "NOK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NOK;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurtainWallTypeEnum::ToString(IfcCurtainWallTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDamperTypeEnum::ToString(IfcDamperTypeEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTROLDAMPER", "FIREDAMPER", "SMOKEDAMPER", "FIRESMOKEDAMPER", "BACKDRAFTDAMPER", "RELIEFDAMPER", "BLASTDAMPER", "GRAVITYDAMPER", "GRAVITYRELIEFDAMPER", "BALANCINGDAMPER", "FUMEHOODEXHAUST", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperTypeEnum::FromString(const std::string& s) {
    if (s == "CONTROLDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_CONTROLDAMPER;
    if (s == "FIREDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FIREDAMPER;
    if (s == "SMOKEDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_SMOKEDAMPER;
    if (s == "FIRESMOKEDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FIRESMOKEDAMPER;
    if (s == "BACKDRAFTDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BACKDRAFTDAMPER;
    if (s == "RELIEFDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_RELIEFDAMPER;
    if (s == "BLASTDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BLASTDAMPER;
    if (s == "GRAVITYDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_GRAVITYDAMPER;
    if (s == "GRAVITYRELIEFDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_GRAVITYRELIEFDAMPER;
    if (s == "BALANCINGDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BALANCINGDAMPER;
    if (s == "FUMEHOODEXHAUST") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FUMEHOODEXHAUST;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDataOriginEnum::ToString(IfcDataOriginEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MEASURED", "PREDICTED", "SIMULATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDataOriginEnum::IfcDataOriginEnum IfcDataOriginEnum::FromString(const std::string& s) {
    if (s == "MEASURED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_MEASURED;
    if (s == "PREDICTED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_PREDICTED;
    if (s == "SIMULATED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_SIMULATED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDerivedUnitEnum::ToString(IfcDerivedUnitEnum v) {
    if ( v < 0 || v >= 49 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANGULARVELOCITYUNIT", "COMPOUNDPLANEANGLEUNIT", "DYNAMICVISCOSITYUNIT", "HEATFLUXDENSITYUNIT", "INTEGERCOUNTRATEUNIT", "ISOTHERMALMOISTURECAPACITYUNIT", "KINEMATICVISCOSITYUNIT", "LINEARVELOCITYUNIT", "MASSDENSITYUNIT", "MASSFLOWRATEUNIT", "MOISTUREDIFFUSIVITYUNIT", "MOLECULARWEIGHTUNIT", "SPECIFICHEATCAPACITYUNIT", "THERMALADMITTANCEUNIT", "THERMALCONDUCTANCEUNIT", "THERMALRESISTANCEUNIT", "THERMALTRANSMITTANCEUNIT", "VAPORPERMEABILITYUNIT", "VOLUMETRICFLOWRATEUNIT", "ROTATIONALFREQUENCYUNIT", "TORQUEUNIT", "MOMENTOFINERTIAUNIT", "LINEARMOMENTUNIT", "LINEARFORCEUNIT", "PLANARFORCEUNIT", "MODULUSOFELASTICITYUNIT", "SHEARMODULUSUNIT", "LINEARSTIFFNESSUNIT", "ROTATIONALSTIFFNESSUNIT", "MODULUSOFSUBGRADEREACTIONUNIT", "ACCELERATIONUNIT", "CURVATUREUNIT", "HEATINGVALUEUNIT", "IONCONCENTRATIONUNIT", "LUMINOUSINTENSITYDISTRIBUTIONUNIT", "MASSPERLENGTHUNIT", "MODULUSOFLINEARSUBGRADEREACTIONUNIT", "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT", "PHUNIT", "ROTATIONALMASSUNIT", "SECTIONAREAINTEGRALUNIT", "SECTIONMODULUSUNIT", "SOUNDPOWERUNIT", "SOUNDPRESSUREUNIT", "TEMPERATUREGRADIENTUNIT", "THERMALEXPANSIONCOEFFICIENTUNIT", "WARPINGCONSTANTUNIT", "WARPINGMOMENTUNIT", "USERDEFINED" };
    return names[v];
}

IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnitEnum::FromString(const std::string& s) {
    if (s == "ANGULARVELOCITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ANGULARVELOCITYUNIT;
    if (s == "COMPOUNDPLANEANGLEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT;
    if (s == "DYNAMICVISCOSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_DYNAMICVISCOSITYUNIT;
    if (s == "HEATFLUXDENSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_HEATFLUXDENSITYUNIT;
    if (s == "INTEGERCOUNTRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_INTEGERCOUNTRATEUNIT;
    if (s == "ISOTHERMALMOISTURECAPACITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT;
    if (s == "KINEMATICVISCOSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_KINEMATICVISCOSITYUNIT;
    if (s == "LINEARVELOCITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARVELOCITYUNIT;
    if (s == "MASSDENSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSDENSITYUNIT;
    if (s == "MASSFLOWRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSFLOWRATEUNIT;
    if (s == "MOISTUREDIFFUSIVITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT;
    if (s == "MOLECULARWEIGHTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOLECULARWEIGHTUNIT;
    if (s == "SPECIFICHEATCAPACITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT;
    if (s == "THERMALADMITTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALADMITTANCEUNIT;
    if (s == "THERMALCONDUCTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALCONDUCTANCEUNIT;
    if (s == "THERMALRESISTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALRESISTANCEUNIT;
    if (s == "THERMALTRANSMITTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALTRANSMITTANCEUNIT;
    if (s == "VAPORPERMEABILITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_VAPORPERMEABILITYUNIT;
    if (s == "VOLUMETRICFLOWRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT;
    if (s == "ROTATIONALFREQUENCYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALFREQUENCYUNIT;
    if (s == "TORQUEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_TORQUEUNIT;
    if (s == "MOMENTOFINERTIAUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOMENTOFINERTIAUNIT;
    if (s == "LINEARMOMENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARMOMENTUNIT;
    if (s == "LINEARFORCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARFORCEUNIT;
    if (s == "PLANARFORCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_PLANARFORCEUNIT;
    if (s == "MODULUSOFELASTICITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFELASTICITYUNIT;
    if (s == "SHEARMODULUSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SHEARMODULUSUNIT;
    if (s == "LINEARSTIFFNESSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARSTIFFNESSUNIT;
    if (s == "ROTATIONALSTIFFNESSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT;
    if (s == "MODULUSOFSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT;
    if (s == "ACCELERATIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ACCELERATIONUNIT;
    if (s == "CURVATUREUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_CURVATUREUNIT;
    if (s == "HEATINGVALUEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_HEATINGVALUEUNIT;
    if (s == "IONCONCENTRATIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_IONCONCENTRATIONUNIT;
    if (s == "LUMINOUSINTENSITYDISTRIBUTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT;
    if (s == "MASSPERLENGTHUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSPERLENGTHUNIT;
    if (s == "MODULUSOFLINEARSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT;
    if (s == "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT;
    if (s == "PHUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_PHUNIT;
    if (s == "ROTATIONALMASSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALMASSUNIT;
    if (s == "SECTIONAREAINTEGRALUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONAREAINTEGRALUNIT;
    if (s == "SECTIONMODULUSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONMODULUSUNIT;
    if (s == "SOUNDPOWERUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERUNIT;
    if (s == "SOUNDPRESSUREUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSUREUNIT;
    if (s == "TEMPERATUREGRADIENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATUREGRADIENTUNIT;
    if (s == "THERMALEXPANSIONCOEFFICIENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT;
    if (s == "WARPINGCONSTANTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGCONSTANTUNIT;
    if (s == "WARPINGMOMENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGMOMENTUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDimensionExtentUsage::ToString(IfcDimensionExtentUsage v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ORIGIN", "TARGET" };
    return names[v];
}

IfcDimensionExtentUsage::IfcDimensionExtentUsage IfcDimensionExtentUsage::FromString(const std::string& s) {
    if (s == "ORIGIN") return ::Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage_ORIGIN;
    if (s == "TARGET") return ::Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage_TARGET;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDirectionSenseEnum::ToString(IfcDirectionSenseEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE" };
    return names[v];
}

IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcDirectionSenseEnum::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSense_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSense_NEGATIVE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionChamberElementTypeEnum::ToString(IfcDistributionChamberElementTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FORMEDDUCT", "INSPECTIONCHAMBER", "INSPECTIONPIT", "MANHOLE", "METERCHAMBER", "SUMP", "TRENCH", "VALVECHAMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementTypeEnum::FromString(const std::string& s) {
    if (s == "FORMEDDUCT") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_FORMEDDUCT;
    if (s == "INSPECTIONCHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONCHAMBER;
    if (s == "INSPECTIONPIT") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONPIT;
    if (s == "MANHOLE") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_MANHOLE;
    if (s == "METERCHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_METERCHAMBER;
    if (s == "SUMP") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_SUMP;
    if (s == "TRENCH") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_TRENCH;
    if (s == "VALVECHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_VALVECHAMBER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentConfidentialityEnum::ToString(IfcDocumentConfidentialityEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PUBLIC", "RESTRICTED", "CONFIDENTIAL", "PERSONAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentConfidentialityEnum::FromString(const std::string& s) {
    if (s == "PUBLIC") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PUBLIC;
    if (s == "RESTRICTED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_RESTRICTED;
    if (s == "CONFIDENTIAL") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_CONFIDENTIAL;
    if (s == "PERSONAL") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PERSONAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentStatusEnum::ToString(IfcDocumentStatusEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DRAFT", "FINALDRAFT", "FINAL", "REVISION", "NOTDEFINED" };
    return names[v];
}

IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentStatusEnum::FromString(const std::string& s) {
    if (s == "DRAFT") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_DRAFT;
    if (s == "FINALDRAFT") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_FINALDRAFT;
    if (s == "FINAL") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_FINAL;
    if (s == "REVISION") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_REVISION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelOperationEnum::ToString(IfcDoorPanelOperationEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SWINGING", "DOUBLE_ACTING", "SLIDING", "FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SWINGING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SWINGING;
    if (s == "DOUBLE_ACTING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_DOUBLE_ACTING;
    if (s == "SLIDING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SLIDING;
    if (s == "FOLDING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FOLDING;
    if (s == "REVOLVING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelPositionEnum::ToString(IfcDoorPanelPositionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_RIGHT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleConstructionEnum::ToString(IfcDoorStyleConstructionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "ALUMINIUM_PLASTIC", "PLASTIC", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_WOOD;
    if (s == "ALUMINIUM_PLASTIC") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_PLASTIC;
    if (s == "PLASTIC") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_PLASTIC;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleOperationEnum::ToString(IfcDoorStyleOperationEnum v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctFittingTypeEnum::ToString(IfcDuctFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSegmentTypeEnum::ToString(IfcDuctSegmentTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGIDSEGMENT", "FLEXIBLESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "RIGIDSEGMENT") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_RIGIDSEGMENT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_FLEXIBLESEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSilencerTypeEnum::ToString(IfcDuctSilencerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLATOVAL", "RECTANGULAR", "ROUND", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerTypeEnum::FromString(const std::string& s) {
    if (s == "FLATOVAL") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_FLATOVAL;
    if (s == "RECTANGULAR") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_RECTANGULAR;
    if (s == "ROUND") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_ROUND;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricApplianceTypeEnum::ToString(IfcElectricApplianceTypeEnum v) {
    if ( v < 0 || v >= 26 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPUTER", "DIRECTWATERHEATER", "DISHWASHER", "ELECTRICCOOKER", "ELECTRICHEATER", "FACSIMILE", "FREESTANDINGFAN", "FREEZER", "FRIDGE_FREEZER", "HANDDRYER", "INDIRECTWATERHEATER", "MICROWAVE", "PHOTOCOPIER", "PRINTER", "REFRIGERATOR", "RADIANTHEATER", "SCANNER", "TELEPHONE", "TUMBLEDRYER", "TV", "VENDINGMACHINE", "WASHINGMACHINE", "WATERHEATER", "WATERCOOLER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "COMPUTER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_COMPUTER;
    if (s == "DIRECTWATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DIRECTWATERHEATER;
    if (s == "DISHWASHER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DISHWASHER;
    if (s == "ELECTRICCOOKER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICCOOKER;
    if (s == "ELECTRICHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICHEATER;
    if (s == "FACSIMILE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FACSIMILE;
    if (s == "FREESTANDINGFAN") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGFAN;
    if (s == "FREEZER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREEZER;
    if (s == "FRIDGE_FREEZER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FRIDGE_FREEZER;
    if (s == "HANDDRYER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_HANDDRYER;
    if (s == "INDIRECTWATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_INDIRECTWATERHEATER;
    if (s == "MICROWAVE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_MICROWAVE;
    if (s == "PHOTOCOPIER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PHOTOCOPIER;
    if (s == "PRINTER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PRINTER;
    if (s == "REFRIGERATOR") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_REFRIGERATOR;
    if (s == "RADIANTHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_RADIANTHEATER;
    if (s == "SCANNER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_SCANNER;
    if (s == "TELEPHONE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TELEPHONE;
    if (s == "TUMBLEDRYER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TUMBLEDRYER;
    if (s == "TV") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TV;
    if (s == "VENDINGMACHINE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_VENDINGMACHINE;
    if (s == "WASHINGMACHINE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WASHINGMACHINE;
    if (s == "WATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WATERHEATER;
    if (s == "WATERCOOLER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WATERCOOLER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricCurrentEnum::ToString(IfcElectricCurrentEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALTERNATING", "DIRECT", "NOTDEFINED" };
    return names[v];
}

IfcElectricCurrentEnum::IfcElectricCurrentEnum IfcElectricCurrentEnum::FromString(const std::string& s) {
    if (s == "ALTERNATING") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_ALTERNATING;
    if (s == "DIRECT") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_DIRECT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricDistributionPointFunctionEnum::ToString(IfcElectricDistributionPointFunctionEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALARMPANEL", "CONSUMERUNIT", "CONTROLPANEL", "DISTRIBUTIONBOARD", "GASDETECTORPANEL", "INDICATORPANEL", "MIMICPANEL", "MOTORCONTROLCENTRE", "SWITCHBOARD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum IfcElectricDistributionPointFunctionEnum::FromString(const std::string& s) {
    if (s == "ALARMPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_ALARMPANEL;
    if (s == "CONSUMERUNIT") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_CONSUMERUNIT;
    if (s == "CONTROLPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_CONTROLPANEL;
    if (s == "DISTRIBUTIONBOARD") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_DISTRIBUTIONBOARD;
    if (s == "GASDETECTORPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_GASDETECTORPANEL;
    if (s == "INDICATORPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_INDICATORPANEL;
    if (s == "MIMICPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_MIMICPANEL;
    if (s == "MOTORCONTROLCENTRE") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_MOTORCONTROLCENTRE;
    if (s == "SWITCHBOARD") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_SWITCHBOARD;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricFlowStorageDeviceTypeEnum::ToString(IfcElectricFlowStorageDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATTERY", "CAPACITORBANK", "HARMONICFILTER", "INDUCTORBANK", "UPS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "BATTERY") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_BATTERY;
    if (s == "CAPACITORBANK") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_CAPACITORBANK;
    if (s == "HARMONICFILTER") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_HARMONICFILTER;
    if (s == "INDUCTORBANK") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_INDUCTORBANK;
    if (s == "UPS") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_UPS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricGeneratorTypeEnum::ToString(IfcElectricGeneratorTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricHeaterTypeEnum::ToString(IfcElectricHeaterTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRICPOINTHEATER", "ELECTRICCABLEHEATER", "ELECTRICMATHEATER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum IfcElectricHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICPOINTHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICPOINTHEATER;
    if (s == "ELECTRICCABLEHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICCABLEHEATER;
    if (s == "ELECTRICMATHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICMATHEATER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricMotorTypeEnum::ToString(IfcElectricMotorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DC", "INDUCTION", "POLYPHASE", "RELUCTANCESYNCHRONOUS", "SYNCHRONOUS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorTypeEnum::FromString(const std::string& s) {
    if (s == "DC") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_DC;
    if (s == "INDUCTION") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_INDUCTION;
    if (s == "POLYPHASE") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_POLYPHASE;
    if (s == "RELUCTANCESYNCHRONOUS") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_RELUCTANCESYNCHRONOUS;
    if (s == "SYNCHRONOUS") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_SYNCHRONOUS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricTimeControlTypeEnum::ToString(IfcElectricTimeControlTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TIMECLOCK", "TIMEDELAY", "RELAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlTypeEnum::FromString(const std::string& s) {
    if (s == "TIMECLOCK") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMECLOCK;
    if (s == "TIMEDELAY") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMEDELAY;
    if (s == "RELAY") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_RELAY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementAssemblyTypeEnum::ToString(IfcElementAssemblyTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACCESSORY_ASSEMBLY", "ARCH", "BEAM_GRID", "BRACED_FRAME", "GIRDER", "REINFORCEMENT_UNIT", "RIGID_FRAME", "SLAB_FIELD", "TRUSS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssemblyTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESSORY_ASSEMBLY") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ACCESSORY_ASSEMBLY;
    if (s == "ARCH") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ARCH;
    if (s == "BEAM_GRID") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BEAM_GRID;
    if (s == "BRACED_FRAME") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BRACED_FRAME;
    if (s == "GIRDER") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_GIRDER;
    if (s == "REINFORCEMENT_UNIT") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_REINFORCEMENT_UNIT;
    if (s == "RIGID_FRAME") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_RIGID_FRAME;
    if (s == "SLAB_FIELD") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_SLAB_FIELD;
    if (s == "TRUSS") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_TRUSS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementCompositionEnum::ToString(IfcElementCompositionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL" };
    return names[v];
}

IfcElementCompositionEnum::IfcElementCompositionEnum IfcElementCompositionEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_COMPLEX;
    if (s == "ELEMENT") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_ELEMENT;
    if (s == "PARTIAL") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_PARTIAL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEnergySequenceEnum::ToString(IfcEnergySequenceEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRIMARY", "SECONDARY", "TERTIARY", "AUXILIARY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEnergySequenceEnum::IfcEnergySequenceEnum IfcEnergySequenceEnum::FromString(const std::string& s) {
    if (s == "PRIMARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_PRIMARY;
    if (s == "SECONDARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_SECONDARY;
    if (s == "TERTIARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_TERTIARY;
    if (s == "AUXILIARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_AUXILIARY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEnvironmentalImpactCategoryEnum::ToString(IfcEnvironmentalImpactCategoryEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMBINEDVALUE", "DISPOSAL", "EXTRACTION", "INSTALLATION", "MANUFACTURE", "TRANSPORTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum IfcEnvironmentalImpactCategoryEnum::FromString(const std::string& s) {
    if (s == "COMBINEDVALUE") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_COMBINEDVALUE;
    if (s == "DISPOSAL") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_DISPOSAL;
    if (s == "EXTRACTION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_EXTRACTION;
    if (s == "INSTALLATION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_INSTALLATION;
    if (s == "MANUFACTURE") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_MANUFACTURE;
    if (s == "TRANSPORTATION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_TRANSPORTATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporativeCoolerTypeEnum::ToString(IfcEvaporativeCoolerTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER", "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER", "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER", "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER", "DIRECTEVAPORATIVEAIRWASHER", "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER", "INDIRECTEVAPORATIVEWETCOIL", "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER", "INDIRECTDIRECTCOMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEAIRWASHER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER;
    if (s == "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER;
    if (s == "INDIRECTEVAPORATIVEWETCOIL") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL;
    if (s == "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER;
    if (s == "INDIRECTDIRECTCOMBINATION") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporatorTypeEnum::ToString(IfcEvaporatorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEXPANSIONSHELLANDTUBE", "DIRECTEXPANSIONTUBEINTUBE", "DIRECTEXPANSIONBRAZEDPLATE", "FLOODEDSHELLANDTUBE", "SHELLANDCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEXPANSIONSHELLANDTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE;
    if (s == "DIRECTEXPANSIONTUBEINTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE;
    if (s == "DIRECTEXPANSIONBRAZEDPLATE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE;
    if (s == "FLOODEDSHELLANDTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_FLOODEDSHELLANDTUBE;
    if (s == "SHELLANDCOIL") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_SHELLANDCOIL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFanTypeEnum::ToString(IfcFanTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CENTRIFUGALFORWARDCURVED", "CENTRIFUGALRADIAL", "CENTRIFUGALBACKWARDINCLINEDCURVED", "CENTRIFUGALAIRFOIL", "TUBEAXIAL", "VANEAXIAL", "PROPELLORAXIAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFanTypeEnum::IfcFanTypeEnum IfcFanTypeEnum::FromString(const std::string& s) {
    if (s == "CENTRIFUGALFORWARDCURVED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALFORWARDCURVED;
    if (s == "CENTRIFUGALRADIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALRADIAL;
    if (s == "CENTRIFUGALBACKWARDINCLINEDCURVED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED;
    if (s == "CENTRIFUGALAIRFOIL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALAIRFOIL;
    if (s == "TUBEAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_TUBEAXIAL;
    if (s == "VANEAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_VANEAXIAL;
    if (s == "PROPELLORAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_PROPELLORAXIAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFilterTypeEnum::ToString(IfcFilterTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRPARTICLEFILTER", "ODORFILTER", "OILFILTER", "STRAINER", "WATERFILTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterTypeEnum::FromString(const std::string& s) {
    if (s == "AIRPARTICLEFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_AIRPARTICLEFILTER;
    if (s == "ODORFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_ODORFILTER;
    if (s == "OILFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_OILFILTER;
    if (s == "STRAINER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_STRAINER;
    if (s == "WATERFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_WATERFILTER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFireSuppressionTerminalTypeEnum::ToString(IfcFireSuppressionTerminalTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BREECHINGINLET", "FIREHYDRANT", "HOSEREEL", "SPRINKLER", "SPRINKLERDEFLECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BREECHINGINLET") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_BREECHINGINLET;
    if (s == "FIREHYDRANT") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_FIREHYDRANT;
    if (s == "HOSEREEL") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_HOSEREEL;
    if (s == "SPRINKLER") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLER;
    if (s == "SPRINKLERDEFLECTOR") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowDirectionEnum::ToString(IfcFlowDirectionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SOURCE", "SINK", "SOURCEANDSINK", "NOTDEFINED" };
    return names[v];
}

IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcFlowDirectionEnum::FromString(const std::string& s) {
    if (s == "SOURCE") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SOURCE;
    if (s == "SINK") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SINK;
    if (s == "SOURCEANDSINK") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SOURCEANDSINK;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowInstrumentTypeEnum::ToString(IfcFlowInstrumentTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRESSUREGAUGE", "THERMOMETER", "AMMETER", "FREQUENCYMETER", "POWERFACTORMETER", "PHASEANGLEMETER", "VOLTMETER_PEAK", "VOLTMETER_RMS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentTypeEnum::FromString(const std::string& s) {
    if (s == "PRESSUREGAUGE") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PRESSUREGAUGE;
    if (s == "THERMOMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_THERMOMETER;
    if (s == "AMMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_AMMETER;
    if (s == "FREQUENCYMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_FREQUENCYMETER;
    if (s == "POWERFACTORMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_POWERFACTORMETER;
    if (s == "PHASEANGLEMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PHASEANGLEMETER;
    if (s == "VOLTMETER_PEAK") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_PEAK;
    if (s == "VOLTMETER_RMS") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_RMS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowMeterTypeEnum::ToString(IfcFlowMeterTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRICMETER", "ENERGYMETER", "FLOWMETER", "GASMETER", "OILMETER", "WATERMETER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_ELECTRICMETER;
    if (s == "ENERGYMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_ENERGYMETER;
    if (s == "FLOWMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_FLOWMETER;
    if (s == "GASMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_GASMETER;
    if (s == "OILMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_OILMETER;
    if (s == "WATERMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_WATERMETER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFootingTypeEnum::ToString(IfcFootingTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FOOTING_BEAM", "PAD_FOOTING", "PILE_CAP", "STRIP_FOOTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFootingTypeEnum::IfcFootingTypeEnum IfcFootingTypeEnum::FromString(const std::string& s) {
    if (s == "FOOTING_BEAM") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_FOOTING_BEAM;
    if (s == "PAD_FOOTING") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_PAD_FOOTING;
    if (s == "PILE_CAP") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_PILE_CAP;
    if (s == "STRIP_FOOTING") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_STRIP_FOOTING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGasTerminalTypeEnum::ToString(IfcGasTerminalTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GASAPPLIANCE", "GASBOOSTER", "GASBURNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum IfcGasTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "GASAPPLIANCE") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASAPPLIANCE;
    if (s == "GASBOOSTER") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASBOOSTER;
    if (s == "GASBURNER") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASBURNER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGeometricProjectionEnum::ToString(IfcGeometricProjectionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRAPH_VIEW", "SKETCH_VIEW", "MODEL_VIEW", "PLAN_VIEW", "REFLECTED_PLAN_VIEW", "SECTION_VIEW", "ELEVATION_VIEW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricProjectionEnum::FromString(const std::string& s) {
    if (s == "GRAPH_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_GRAPH_VIEW;
    if (s == "SKETCH_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_SKETCH_VIEW;
    if (s == "MODEL_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_MODEL_VIEW;
    if (s == "PLAN_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_PLAN_VIEW;
    if (s == "REFLECTED_PLAN_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_REFLECTED_PLAN_VIEW;
    if (s == "SECTION_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_SECTION_VIEW;
    if (s == "ELEVATION_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_ELEVATION_VIEW;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGlobalOrLocalEnum::ToString(IfcGlobalOrLocalEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GLOBAL_COORDS", "LOCAL_COORDS" };
    return names[v];
}

IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcGlobalOrLocalEnum::FromString(const std::string& s) {
    if (s == "GLOBAL_COORDS") return ::Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_GLOBAL_COORDS;
    if (s == "LOCAL_COORDS") return ::Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_LOCAL_COORDS;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHeatExchangerTypeEnum::ToString(IfcHeatExchangerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLATE", "SHELLANDTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerTypeEnum::FromString(const std::string& s) {
    if (s == "PLATE") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_PLATE;
    if (s == "SHELLANDTUBE") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_SHELLANDTUBE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHumidifierTypeEnum::ToString(IfcHumidifierTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STEAMINJECTION", "ADIABATICAIRWASHER", "ADIABATICPAN", "ADIABATICWETTEDELEMENT", "ADIABATICATOMIZING", "ADIABATICULTRASONIC", "ADIABATICRIGIDMEDIA", "ADIABATICCOMPRESSEDAIRNOZZLE", "ASSISTEDELECTRIC", "ASSISTEDNATURALGAS", "ASSISTEDPROPANE", "ASSISTEDBUTANE", "ASSISTEDSTEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierTypeEnum::FromString(const std::string& s) {
    if (s == "STEAMINJECTION") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_STEAMINJECTION;
    if (s == "ADIABATICAIRWASHER") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICAIRWASHER;
    if (s == "ADIABATICPAN") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICPAN;
    if (s == "ADIABATICWETTEDELEMENT") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICWETTEDELEMENT;
    if (s == "ADIABATICATOMIZING") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICATOMIZING;
    if (s == "ADIABATICULTRASONIC") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICULTRASONIC;
    if (s == "ADIABATICRIGIDMEDIA") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICRIGIDMEDIA;
    if (s == "ADIABATICCOMPRESSEDAIRNOZZLE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE;
    if (s == "ASSISTEDELECTRIC") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDELECTRIC;
    if (s == "ASSISTEDNATURALGAS") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDNATURALGAS;
    if (s == "ASSISTEDPROPANE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDPROPANE;
    if (s == "ASSISTEDBUTANE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDBUTANE;
    if (s == "ASSISTEDSTEAM") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDSTEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInternalOrExternalEnum::ToString(IfcInternalOrExternalEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "INTERNAL", "EXTERNAL", "NOTDEFINED" };
    return names[v];
}

IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcInternalOrExternalEnum::FromString(const std::string& s) {
    if (s == "INTERNAL") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInventoryTypeEnum::ToString(IfcInventoryTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSETINVENTORY", "SPACEINVENTORY", "FURNITUREINVENTORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventoryTypeEnum::FromString(const std::string& s) {
    if (s == "ASSETINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_ASSETINVENTORY;
    if (s == "SPACEINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_SPACEINVENTORY;
    if (s == "FURNITUREINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_FURNITUREINVENTORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcJunctionBoxTypeEnum::ToString(IfcJunctionBoxTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLampTypeEnum::ToString(IfcLampTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "METALHALIDE", "TUNGSTENFILAMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLampTypeEnum::IfcLampTypeEnum IfcLampTypeEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_HIGHPRESSURESODIUM;
    if (s == "METALHALIDE") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_TUNGSTENFILAMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLayerSetDirectionEnum::ToString(IfcLayerSetDirectionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AXIS1", "AXIS2", "AXIS3" };
    return names[v];
}

IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcLayerSetDirectionEnum::FromString(const std::string& s) {
    if (s == "AXIS1") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS1;
    if (s == "AXIS2") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS2;
    if (s == "AXIS3") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS3;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightDistributionCurveEnum::ToString(IfcLightDistributionCurveEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TYPE_A", "TYPE_B", "TYPE_C", "NOTDEFINED" };
    return names[v];
}

IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightDistributionCurveEnum::FromString(const std::string& s) {
    if (s == "TYPE_A") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_A;
    if (s == "TYPE_B") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_B;
    if (s == "TYPE_C") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_C;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightEmissionSourceEnum::ToString(IfcLightEmissionSourceEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LIGHTEMITTINGDIODE", "LOWPRESSURESODIUM", "LOWVOLTAGEHALOGEN", "MAINVOLTAGEHALOGEN", "METALHALIDE", "TUNGSTENFILAMENT", "NOTDEFINED" };
    return names[v];
}

IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightEmissionSourceEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSURESODIUM;
    if (s == "LIGHTEMITTINGDIODE") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LIGHTEMITTINGDIODE;
    if (s == "LOWPRESSURESODIUM") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWPRESSURESODIUM;
    if (s == "LOWVOLTAGEHALOGEN") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWVOLTAGEHALOGEN;
    if (s == "MAINVOLTAGEHALOGEN") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_MAINVOLTAGEHALOGEN;
    if (s == "METALHALIDE") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_TUNGSTENFILAMENT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightFixtureTypeEnum::ToString(IfcLightFixtureTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POINTSOURCE", "DIRECTIONSOURCE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureTypeEnum::FromString(const std::string& s) {
    if (s == "POINTSOURCE") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_POINTSOURCE;
    if (s == "DIRECTIONSOURCE") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_DIRECTIONSOURCE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLoadGroupTypeEnum::ToString(IfcLoadGroupTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOAD_GROUP", "LOAD_CASE", "LOAD_COMBINATION_GROUP", "LOAD_COMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcLoadGroupTypeEnum::FromString(const std::string& s) {
    if (s == "LOAD_GROUP") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_GROUP;
    if (s == "LOAD_CASE") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_CASE;
    if (s == "LOAD_COMBINATION_GROUP") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION_GROUP;
    if (s == "LOAD_COMBINATION") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLogicalOperatorEnum::ToString(IfcLogicalOperatorEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOGICALAND", "LOGICALOR" };
    return names[v];
}

IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcLogicalOperatorEnum::FromString(const std::string& s) {
    if (s == "LOGICALAND") return ::Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALAND;
    if (s == "LOGICALOR") return ::Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALOR;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMemberTypeEnum::ToString(IfcMemberTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BRACE", "CHORD", "COLLAR", "MEMBER", "MULLION", "PLATE", "POST", "PURLIN", "RAFTER", "STRINGER", "STRUT", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BRACE") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_BRACE;
    if (s == "CHORD") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_CHORD;
    if (s == "COLLAR") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_COLLAR;
    if (s == "MEMBER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_MEMBER;
    if (s == "MULLION") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_MULLION;
    if (s == "PLATE") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_PLATE;
    if (s == "POST") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_POST;
    if (s == "PURLIN") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_PURLIN;
    if (s == "RAFTER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_RAFTER;
    if (s == "STRINGER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STRINGER;
    if (s == "STRUT") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STRUT;
    if (s == "STUD") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STUD;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMotorConnectionTypeEnum::ToString(IfcMotorConnectionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELTDRIVE", "COUPLING", "DIRECTDRIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "BELTDRIVE") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_BELTDRIVE;
    if (s == "COUPLING") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_COUPLING;
    if (s == "DIRECTDRIVE") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_DIRECTDRIVE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcNullStyle::ToString(IfcNullStyle v) {
    if ( v < 0 || v >= 1 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NULL" };
    return names[v];
}

IfcNullStyle::IfcNullStyle IfcNullStyle::FromString(const std::string& s) {
    if (s == "NULL") return ::Ifc2x3::IfcNullStyle::IfcNullStyle_NULL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectTypeEnum::ToString(IfcObjectTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRODUCT", "PROCESS", "CONTROL", "RESOURCE", "ACTOR", "GROUP", "PROJECT", "NOTDEFINED" };
    return names[v];
}

IfcObjectTypeEnum::IfcObjectTypeEnum IfcObjectTypeEnum::FromString(const std::string& s) {
    if (s == "PRODUCT") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PRODUCT;
    if (s == "PROCESS") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PROCESS;
    if (s == "CONTROL") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_CONTROL;
    if (s == "RESOURCE") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_RESOURCE;
    if (s == "ACTOR") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_ACTOR;
    if (s == "GROUP") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_GROUP;
    if (s == "PROJECT") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PROJECT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectiveEnum::ToString(IfcObjectiveEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CODECOMPLIANCE", "DESIGNINTENT", "HEALTHANDSAFETY", "REQUIREMENT", "SPECIFICATION", "TRIGGERCONDITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcObjectiveEnum::IfcObjectiveEnum IfcObjectiveEnum::FromString(const std::string& s) {
    if (s == "CODECOMPLIANCE") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_CODECOMPLIANCE;
    if (s == "DESIGNINTENT") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_DESIGNINTENT;
    if (s == "HEALTHANDSAFETY") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_HEALTHANDSAFETY;
    if (s == "REQUIREMENT") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_REQUIREMENT;
    if (s == "SPECIFICATION") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_SPECIFICATION;
    if (s == "TRIGGERCONDITION") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_TRIGGERCONDITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOccupantTypeEnum::ToString(IfcOccupantTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSIGNEE", "ASSIGNOR", "LESSEE", "LESSOR", "LETTINGAGENT", "OWNER", "TENANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupantTypeEnum::FromString(const std::string& s) {
    if (s == "ASSIGNEE") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNEE;
    if (s == "ASSIGNOR") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNOR;
    if (s == "LESSEE") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LESSEE;
    if (s == "LESSOR") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LESSOR;
    if (s == "LETTINGAGENT") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LETTINGAGENT;
    if (s == "OWNER") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_OWNER;
    if (s == "TENANT") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_TENANT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOutletTypeEnum::ToString(IfcOutletTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AUDIOVISUALOUTLET", "COMMUNICATIONSOUTLET", "POWEROUTLET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletTypeEnum::FromString(const std::string& s) {
    if (s == "AUDIOVISUALOUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_AUDIOVISUALOUTLET;
    if (s == "COMMUNICATIONSOUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_COMMUNICATIONSOUTLET;
    if (s == "POWEROUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_POWEROUTLET;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPermeableCoveringOperationEnum::ToString(IfcPermeableCoveringOperationEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRILL", "LOUVER", "SCREEN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringOperationEnum::FromString(const std::string& s) {
    if (s == "GRILL") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_GRILL;
    if (s == "LOUVER") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_LOUVER;
    if (s == "SCREEN") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_SCREEN;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPhysicalOrVirtualEnum::ToString(IfcPhysicalOrVirtualEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PHYSICAL", "VIRTUAL", "NOTDEFINED" };
    return names[v];
}

IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcPhysicalOrVirtualEnum::FromString(const std::string& s) {
    if (s == "PHYSICAL") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_PHYSICAL;
    if (s == "VIRTUAL") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_VIRTUAL;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileConstructionEnum::ToString(IfcPileConstructionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CAST_IN_PLACE", "COMPOSITE", "PRECAST_CONCRETE", "PREFAB_STEEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileConstructionEnum::IfcPileConstructionEnum IfcPileConstructionEnum::FromString(const std::string& s) {
    if (s == "CAST_IN_PLACE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_CAST_IN_PLACE;
    if (s == "COMPOSITE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_COMPOSITE;
    if (s == "PRECAST_CONCRETE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_PRECAST_CONCRETE;
    if (s == "PREFAB_STEEL") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_PREFAB_STEEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileTypeEnum::ToString(IfcPileTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COHESION", "FRICTION", "SUPPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileTypeEnum::IfcPileTypeEnum IfcPileTypeEnum::FromString(const std::string& s) {
    if (s == "COHESION") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_COHESION;
    if (s == "FRICTION") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_FRICTION;
    if (s == "SUPPORT") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_SUPPORT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeFittingTypeEnum::ToString(IfcPipeFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeSegmentTypeEnum::ToString(IfcPipeSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLEXIBLESEGMENT", "RIGIDSEGMENT", "GUTTER", "SPOOL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "FLEXIBLESEGMENT") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_FLEXIBLESEGMENT;
    if (s == "RIGIDSEGMENT") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_RIGIDSEGMENT;
    if (s == "GUTTER") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_GUTTER;
    if (s == "SPOOL") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_SPOOL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPlateTypeEnum::ToString(IfcPlateTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURTAIN_PANEL", "SHEET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateTypeEnum::FromString(const std::string& s) {
    if (s == "CURTAIN_PANEL") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_CURTAIN_PANEL;
    if (s == "SHEET") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_SHEET;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProcedureTypeEnum::ToString(IfcProcedureTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADVICE_CAUTION", "ADVICE_NOTE", "ADVICE_WARNING", "CALIBRATION", "DIAGNOSTIC", "SHUTDOWN", "STARTUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedureTypeEnum::FromString(const std::string& s) {
    if (s == "ADVICE_CAUTION") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_CAUTION;
    if (s == "ADVICE_NOTE") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_NOTE;
    if (s == "ADVICE_WARNING") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_WARNING;
    if (s == "CALIBRATION") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_CALIBRATION;
    if (s == "DIAGNOSTIC") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_DIAGNOSTIC;
    if (s == "SHUTDOWN") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_SHUTDOWN;
    if (s == "STARTUP") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_STARTUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProfileTypeEnum::ToString(IfcProfileTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURVE", "AREA" };
    return names[v];
}

IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileTypeEnum::FromString(const std::string& s) {
    if (s == "CURVE") return ::Ifc2x3::IfcProfileTypeEnum::IfcProfileType_CURVE;
    if (s == "AREA") return ::Ifc2x3::IfcProfileTypeEnum::IfcProfileType_AREA;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectOrderRecordTypeEnum::ToString(IfcProjectOrderRecordTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHANGE", "MAINTENANCE", "MOVE", "PURCHASE", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum IfcProjectOrderRecordTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_CHANGE;
    if (s == "MAINTENANCE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_MAINTENANCE;
    if (s == "MOVE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_MOVE;
    if (s == "PURCHASE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_PURCHASE;
    if (s == "WORK") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_WORK;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectOrderTypeEnum::ToString(IfcProjectOrderTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHANGEORDER", "MAINTENANCEWORKORDER", "MOVEORDER", "PURCHASEORDER", "WORKORDER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrderTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_CHANGEORDER;
    if (s == "MAINTENANCEWORKORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_MAINTENANCEWORKORDER;
    if (s == "MOVEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_MOVEORDER;
    if (s == "PURCHASEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_PURCHASEORDER;
    if (s == "WORKORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_WORKORDER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectedOrTrueLengthEnum::ToString(IfcProjectedOrTrueLengthEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PROJECTED_LENGTH", "TRUE_LENGTH" };
    return names[v];
}

IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcProjectedOrTrueLengthEnum::FromString(const std::string& s) {
    if (s == "PROJECTED_LENGTH") return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_PROJECTED_LENGTH;
    if (s == "TRUE_LENGTH") return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_TRUE_LENGTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPropertySourceEnum::ToString(IfcPropertySourceEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DESIGN", "DESIGNMAXIMUM", "DESIGNMINIMUM", "SIMULATED", "ASBUILT", "COMMISSIONING", "MEASURED", "USERDEFINED", "NOTKNOWN" };
    return names[v];
}

IfcPropertySourceEnum::IfcPropertySourceEnum IfcPropertySourceEnum::FromString(const std::string& s) {
    if (s == "DESIGN") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGN;
    if (s == "DESIGNMAXIMUM") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGNMAXIMUM;
    if (s == "DESIGNMINIMUM") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGNMINIMUM;
    if (s == "SIMULATED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_SIMULATED;
    if (s == "ASBUILT") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_ASBUILT;
    if (s == "COMMISSIONING") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_COMMISSIONING;
    if (s == "MEASURED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_MEASURED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_USERDEFINED;
    if (s == "NOTKNOWN") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_NOTKNOWN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProtectiveDeviceTypeEnum::ToString(IfcProtectiveDeviceTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FUSEDISCONNECTOR", "CIRCUITBREAKER", "EARTHFAILUREDEVICE", "RESIDUALCURRENTCIRCUITBREAKER", "RESIDUALCURRENTSWITCH", "VARISTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "FUSEDISCONNECTOR") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_FUSEDISCONNECTOR;
    if (s == "CIRCUITBREAKER") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_CIRCUITBREAKER;
    if (s == "EARTHFAILUREDEVICE") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHFAILUREDEVICE;
    if (s == "RESIDUALCURRENTCIRCUITBREAKER") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER;
    if (s == "RESIDUALCURRENTSWITCH") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH;
    if (s == "VARISTOR") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_VARISTOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPumpTypeEnum::ToString(IfcPumpTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CIRCULATOR", "ENDSUCTION", "SPLITCASE", "VERTICALINLINE", "VERTICALTURBINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCULATOR") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_CIRCULATOR;
    if (s == "ENDSUCTION") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_ENDSUCTION;
    if (s == "SPLITCASE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_SPLITCASE;
    if (s == "VERTICALINLINE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_VERTICALINLINE;
    if (s == "VERTICALTURBINE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_VERTICALTURBINE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRailingTypeEnum::ToString(IfcRailingTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HANDRAIL", "GUARDRAIL", "BALUSTRADE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingTypeEnum::FromString(const std::string& s) {
    if (s == "HANDRAIL") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_HANDRAIL;
    if (s == "GUARDRAIL") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_GUARDRAIL;
    if (s == "BALUSTRADE") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_BALUSTRADE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampFlightTypeEnum::ToString(IfcRampFlightTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "SPIRAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_STRAIGHT;
    if (s == "SPIRAL") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_SPIRAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampTypeEnum::ToString(IfcRampTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_RAMP", "TWO_STRAIGHT_RUN_RAMP", "QUARTER_TURN_RAMP", "TWO_QUARTER_TURN_RAMP", "HALF_TURN_RAMP", "SPIRAL_RAMP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampTypeEnum::IfcRampTypeEnum IfcRampTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_STRAIGHT_RUN_RAMP;
    if (s == "TWO_STRAIGHT_RUN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_TWO_STRAIGHT_RUN_RAMP;
    if (s == "QUARTER_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_QUARTER_TURN_RAMP;
    if (s == "TWO_QUARTER_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_TWO_QUARTER_TURN_RAMP;
    if (s == "HALF_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_HALF_TURN_RAMP;
    if (s == "SPIRAL_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_SPIRAL_RAMP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReflectanceMethodEnum::ToString(IfcReflectanceMethodEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BLINN", "FLAT", "GLASS", "MATT", "METAL", "MIRROR", "PHONG", "PLASTIC", "STRAUSS", "NOTDEFINED" };
    return names[v];
}

IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcReflectanceMethodEnum::FromString(const std::string& s) {
    if (s == "BLINN") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_BLINN;
    if (s == "FLAT") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_FLAT;
    if (s == "GLASS") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_GLASS;
    if (s == "MATT") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_MATT;
    if (s == "METAL") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_METAL;
    if (s == "MIRROR") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_MIRROR;
    if (s == "PHONG") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_PHONG;
    if (s == "PLASTIC") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_PLASTIC;
    if (s == "STRAUSS") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_STRAUSS;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarRoleEnum::ToString(IfcReinforcingBarRoleEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MAIN", "SHEAR", "LIGATURE", "STUD", "PUNCHING", "EDGE", "RING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcReinforcingBarRoleEnum::FromString(const std::string& s) {
    if (s == "MAIN") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_MAIN;
    if (s == "SHEAR") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_SHEAR;
    if (s == "LIGATURE") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_LIGATURE;
    if (s == "STUD") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_STUD;
    if (s == "PUNCHING") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_PUNCHING;
    if (s == "EDGE") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_EDGE;
    if (s == "RING") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_RING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarSurfaceEnum::ToString(IfcReinforcingBarSurfaceEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLAIN", "TEXTURED" };
    return names[v];
}

IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBarSurfaceEnum::FromString(const std::string& s) {
    if (s == "PLAIN") return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_PLAIN;
    if (s == "TEXTURED") return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_TEXTURED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcResourceConsumptionEnum::ToString(IfcResourceConsumptionEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSUMED", "PARTIALLYCONSUMED", "NOTCONSUMED", "OCCUPIED", "PARTIALLYOCCUPIED", "NOTOCCUPIED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcResourceConsumptionEnum::IfcResourceConsumptionEnum IfcResourceConsumptionEnum::FromString(const std::string& s) {
    if (s == "CONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_CONSUMED;
    if (s == "PARTIALLYCONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_PARTIALLYCONSUMED;
    if (s == "NOTCONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTCONSUMED;
    if (s == "OCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_OCCUPIED;
    if (s == "PARTIALLYOCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_PARTIALLYOCCUPIED;
    if (s == "NOTOCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTOCCUPIED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRibPlateDirectionEnum::ToString(IfcRibPlateDirectionEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTION_X", "DIRECTION_Y" };
    return names[v];
}

IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum IfcRibPlateDirectionEnum::FromString(const std::string& s) {
    if (s == "DIRECTION_X") return ::Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirection_DIRECTION_X;
    if (s == "DIRECTION_Y") return ::Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirection_DIRECTION_Y;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoleEnum::ToString(IfcRoleEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SUPPLIER", "MANUFACTURER", "CONTRACTOR", "SUBCONTRACTOR", "ARCHITECT", "STRUCTURALENGINEER", "COSTENGINEER", "CLIENT", "BUILDINGOWNER", "BUILDINGOPERATOR", "MECHANICALENGINEER", "ELECTRICALENGINEER", "PROJECTMANAGER", "FACILITIESMANAGER", "CIVILENGINEER", "COMISSIONINGENGINEER", "ENGINEER", "OWNER", "CONSULTANT", "CONSTRUCTIONMANAGER", "FIELDCONSTRUCTIONMANAGER", "RESELLER", "USERDEFINED" };
    return names[v];
}

IfcRoleEnum::IfcRoleEnum IfcRoleEnum::FromString(const std::string& s) {
    if (s == "SUPPLIER") return ::Ifc2x3::IfcRoleEnum::IfcRole_SUPPLIER;
    if (s == "MANUFACTURER") return ::Ifc2x3::IfcRoleEnum::IfcRole_MANUFACTURER;
    if (s == "CONTRACTOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONTRACTOR;
    if (s == "SUBCONTRACTOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_SUBCONTRACTOR;
    if (s == "ARCHITECT") return ::Ifc2x3::IfcRoleEnum::IfcRole_ARCHITECT;
    if (s == "STRUCTURALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_STRUCTURALENGINEER;
    if (s == "COSTENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_COSTENGINEER;
    if (s == "CLIENT") return ::Ifc2x3::IfcRoleEnum::IfcRole_CLIENT;
    if (s == "BUILDINGOWNER") return ::Ifc2x3::IfcRoleEnum::IfcRole_BUILDINGOWNER;
    if (s == "BUILDINGOPERATOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_BUILDINGOPERATOR;
    if (s == "MECHANICALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_MECHANICALENGINEER;
    if (s == "ELECTRICALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_ELECTRICALENGINEER;
    if (s == "PROJECTMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_PROJECTMANAGER;
    if (s == "FACILITIESMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_FACILITIESMANAGER;
    if (s == "CIVILENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_CIVILENGINEER;
    if (s == "COMISSIONINGENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_COMISSIONINGENGINEER;
    if (s == "ENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_ENGINEER;
    if (s == "OWNER") return ::Ifc2x3::IfcRoleEnum::IfcRole_OWNER;
    if (s == "CONSULTANT") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONSULTANT;
    if (s == "CONSTRUCTIONMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONSTRUCTIONMANAGER;
    if (s == "FIELDCONSTRUCTIONMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_FIELDCONSTRUCTIONMANAGER;
    if (s == "RESELLER") return ::Ifc2x3::IfcRoleEnum::IfcRole_RESELLER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRoleEnum::IfcRole_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoofTypeEnum::ToString(IfcRoofTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLAT_ROOF", "SHED_ROOF", "GABLE_ROOF", "HIP_ROOF", "HIPPED_GABLE_ROOF", "GAMBREL_ROOF", "MANSARD_ROOF", "BARREL_ROOF", "RAINBOW_ROOF", "BUTTERFLY_ROOF", "PAVILION_ROOF", "DOME_ROOF", "FREEFORM", "NOTDEFINED" };
    return names[v];
}

IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoofTypeEnum::FromString(const std::string& s) {
    if (s == "FLAT_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_FLAT_ROOF;
    if (s == "SHED_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_SHED_ROOF;
    if (s == "GABLE_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_GABLE_ROOF;
    if (s == "HIP_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_HIP_ROOF;
    if (s == "HIPPED_GABLE_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_HIPPED_GABLE_ROOF;
    if (s == "GAMBREL_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_GAMBREL_ROOF;
    if (s == "MANSARD_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_MANSARD_ROOF;
    if (s == "BARREL_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_BARREL_ROOF;
    if (s == "RAINBOW_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_RAINBOW_ROOF;
    if (s == "BUTTERFLY_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_BUTTERFLY_ROOF;
    if (s == "PAVILION_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_PAVILION_ROOF;
    if (s == "DOME_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_DOME_ROOF;
    if (s == "FREEFORM") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_FREEFORM;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIPrefix::ToString(IfcSIPrefix v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXA", "PETA", "TERA", "GIGA", "MEGA", "KILO", "HECTO", "DECA", "DECI", "CENTI", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO" };
    return names[v];
}

IfcSIPrefix::IfcSIPrefix IfcSIPrefix::FromString(const std::string& s) {
    if (s == "EXA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_EXA;
    if (s == "PETA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_PETA;
    if (s == "TERA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_TERA;
    if (s == "GIGA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_GIGA;
    if (s == "MEGA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MEGA;
    if (s == "KILO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_KILO;
    if (s == "HECTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_HECTO;
    if (s == "DECA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_DECA;
    if (s == "DECI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_DECI;
    if (s == "CENTI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_CENTI;
    if (s == "MILLI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MILLI;
    if (s == "MICRO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MICRO;
    if (s == "NANO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_NANO;
    if (s == "PICO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_PICO;
    if (s == "FEMTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_FEMTO;
    if (s == "ATTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_ATTO;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIUnitName::ToString(IfcSIUnitName v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AMPERE", "BECQUEREL", "CANDELA", "COULOMB", "CUBIC_METRE", "DEGREE_CELSIUS", "FARAD", "GRAM", "GRAY", "HENRY", "HERTZ", "JOULE", "KELVIN", "LUMEN", "LUX", "METRE", "MOLE", "NEWTON", "OHM", "PASCAL", "RADIAN", "SECOND", "SIEMENS", "SIEVERT", "SQUARE_METRE", "STERADIAN", "TESLA", "VOLT", "WATT", "WEBER" };
    return names[v];
}

IfcSIUnitName::IfcSIUnitName IfcSIUnitName::FromString(const std::string& s) {
    if (s == "AMPERE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_AMPERE;
    if (s == "BECQUEREL") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_BECQUEREL;
    if (s == "CANDELA") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_CANDELA;
    if (s == "COULOMB") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_COULOMB;
    if (s == "CUBIC_METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_CUBIC_METRE;
    if (s == "DEGREE_CELSIUS") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_DEGREE_CELSIUS;
    if (s == "FARAD") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_FARAD;
    if (s == "GRAM") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_GRAM;
    if (s == "GRAY") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_GRAY;
    if (s == "HENRY") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_HENRY;
    if (s == "HERTZ") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_HERTZ;
    if (s == "JOULE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_JOULE;
    if (s == "KELVIN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_KELVIN;
    if (s == "LUMEN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_LUMEN;
    if (s == "LUX") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_LUX;
    if (s == "METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_METRE;
    if (s == "MOLE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_MOLE;
    if (s == "NEWTON") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_NEWTON;
    if (s == "OHM") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_OHM;
    if (s == "PASCAL") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_PASCAL;
    if (s == "RADIAN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_RADIAN;
    if (s == "SECOND") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SECOND;
    if (s == "SIEMENS") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SIEMENS;
    if (s == "SIEVERT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SIEVERT;
    if (s == "SQUARE_METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SQUARE_METRE;
    if (s == "STERADIAN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_STERADIAN;
    if (s == "TESLA") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_TESLA;
    if (s == "VOLT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_VOLT;
    if (s == "WATT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_WATT;
    if (s == "WEBER") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_WEBER;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSanitaryTerminalTypeEnum::ToString(IfcSanitaryTerminalTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATH", "BIDET", "CISTERN", "SHOWER", "SINK", "SANITARYFOUNTAIN", "TOILETPAN", "URINAL", "WASHHANDBASIN", "WCSEAT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BATH") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BATH;
    if (s == "BIDET") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BIDET;
    if (s == "CISTERN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_CISTERN;
    if (s == "SHOWER") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SHOWER;
    if (s == "SINK") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SINK;
    if (s == "SANITARYFOUNTAIN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SANITARYFOUNTAIN;
    if (s == "TOILETPAN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_TOILETPAN;
    if (s == "URINAL") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_URINAL;
    if (s == "WASHHANDBASIN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WASHHANDBASIN;
    if (s == "WCSEAT") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WCSEAT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSectionTypeEnum::ToString(IfcSectionTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNIFORM", "TAPERED" };
    return names[v];
}

IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionTypeEnum::FromString(const std::string& s) {
    if (s == "UNIFORM") return ::Ifc2x3::IfcSectionTypeEnum::IfcSectionType_UNIFORM;
    if (s == "TAPERED") return ::Ifc2x3::IfcSectionTypeEnum::IfcSectionType_TAPERED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSensorTypeEnum::ToString(IfcSensorTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CO2SENSOR", "FIRESENSOR", "FLOWSENSOR", "GASSENSOR", "HEATSENSOR", "HUMIDITYSENSOR", "LIGHTSENSOR", "MOISTURESENSOR", "MOVEMENTSENSOR", "PRESSURESENSOR", "SMOKESENSOR", "SOUNDSENSOR", "TEMPERATURESENSOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorTypeEnum::FromString(const std::string& s) {
    if (s == "CO2SENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_CO2SENSOR;
    if (s == "FIRESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_FIRESENSOR;
    if (s == "FLOWSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_FLOWSENSOR;
    if (s == "GASSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_GASSENSOR;
    if (s == "HEATSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_HEATSENSOR;
    if (s == "HUMIDITYSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_HUMIDITYSENSOR;
    if (s == "LIGHTSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_LIGHTSENSOR;
    if (s == "MOISTURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_MOISTURESENSOR;
    if (s == "MOVEMENTSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_MOVEMENTSENSOR;
    if (s == "PRESSURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_PRESSURESENSOR;
    if (s == "SMOKESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_SMOKESENSOR;
    if (s == "SOUNDSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_SOUNDSENSOR;
    if (s == "TEMPERATURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_TEMPERATURESENSOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSequenceEnum::ToString(IfcSequenceEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "START_START", "START_FINISH", "FINISH_START", "FINISH_FINISH", "NOTDEFINED" };
    return names[v];
}

IfcSequenceEnum::IfcSequenceEnum IfcSequenceEnum::FromString(const std::string& s) {
    if (s == "START_START") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_START_START;
    if (s == "START_FINISH") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_START_FINISH;
    if (s == "FINISH_START") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_FINISH_START;
    if (s == "FINISH_FINISH") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_FINISH_FINISH;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcServiceLifeFactorTypeEnum::ToString(IfcServiceLifeFactorTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "A_QUALITYOFCOMPONENTS", "B_DESIGNLEVEL", "C_WORKEXECUTIONLEVEL", "D_INDOORENVIRONMENT", "E_OUTDOORENVIRONMENT", "F_INUSECONDITIONS", "G_MAINTENANCELEVEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum IfcServiceLifeFactorTypeEnum::FromString(const std::string& s) {
    if (s == "A_QUALITYOFCOMPONENTS") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_A_QUALITYOFCOMPONENTS;
    if (s == "B_DESIGNLEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_B_DESIGNLEVEL;
    if (s == "C_WORKEXECUTIONLEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_C_WORKEXECUTIONLEVEL;
    if (s == "D_INDOORENVIRONMENT") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_D_INDOORENVIRONMENT;
    if (s == "E_OUTDOORENVIRONMENT") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_E_OUTDOORENVIRONMENT;
    if (s == "F_INUSECONDITIONS") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_F_INUSECONDITIONS;
    if (s == "G_MAINTENANCELEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_G_MAINTENANCELEVEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcServiceLifeTypeEnum::ToString(IfcServiceLifeTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUALSERVICELIFE", "EXPECTEDSERVICELIFE", "OPTIMISTICREFERENCESERVICELIFE", "PESSIMISTICREFERENCESERVICELIFE", "REFERENCESERVICELIFE" };
    return names[v];
}

IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum IfcServiceLifeTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUALSERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_ACTUALSERVICELIFE;
    if (s == "EXPECTEDSERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_EXPECTEDSERVICELIFE;
    if (s == "OPTIMISTICREFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_OPTIMISTICREFERENCESERVICELIFE;
    if (s == "PESSIMISTICREFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_PESSIMISTICREFERENCESERVICELIFE;
    if (s == "REFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_REFERENCESERVICELIFE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSlabTypeEnum::ToString(IfcSlabTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOOR", "ROOF", "LANDING", "BASESLAB", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabTypeEnum::FromString(const std::string& s) {
    if (s == "FLOOR") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_FLOOR;
    if (s == "ROOF") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_ROOF;
    if (s == "LANDING") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_LANDING;
    if (s == "BASESLAB") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_BASESLAB;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSoundScaleEnum::ToString(IfcSoundScaleEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DBA", "DBB", "DBC", "NC", "NR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSoundScaleEnum::IfcSoundScaleEnum IfcSoundScaleEnum::FromString(const std::string& s) {
    if (s == "DBA") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBA;
    if (s == "DBB") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBB;
    if (s == "DBC") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBC;
    if (s == "NC") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NC;
    if (s == "NR") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceHeaterTypeEnum::ToString(IfcSpaceHeaterTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SECTIONALRADIATOR", "PANELRADIATOR", "TUBULARRADIATOR", "CONVECTOR", "BASEBOARDHEATER", "FINNEDTUBEUNIT", "UNITHEATER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "SECTIONALRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_SECTIONALRADIATOR;
    if (s == "PANELRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_PANELRADIATOR;
    if (s == "TUBULARRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_TUBULARRADIATOR;
    if (s == "CONVECTOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_CONVECTOR;
    if (s == "BASEBOARDHEATER") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_BASEBOARDHEATER;
    if (s == "FINNEDTUBEUNIT") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_FINNEDTUBEUNIT;
    if (s == "UNITHEATER") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_UNITHEATER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceTypeEnum::ToString(IfcSpaceTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSpaceTypeEnum::IfcSpaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSpaceTypeEnum::IfcSpaceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStackTerminalTypeEnum::ToString(IfcStackTerminalTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BIRDCAGE", "COWL", "RAINWATERHOPPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BIRDCAGE") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_BIRDCAGE;
    if (s == "COWL") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_COWL;
    if (s == "RAINWATERHOPPER") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_RAINWATERHOPPER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairFlightTypeEnum::ToString(IfcStairFlightTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "WINDER", "SPIRAL", "CURVED", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_STRAIGHT;
    if (s == "WINDER") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_WINDER;
    if (s == "SPIRAL") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_SPIRAL;
    if (s == "CURVED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_CURVED;
    if (s == "FREEFORM") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairTypeEnum::ToString(IfcStairTypeEnum v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_STAIR", "TWO_STRAIGHT_RUN_STAIR", "QUARTER_WINDING_STAIR", "QUARTER_TURN_STAIR", "HALF_WINDING_STAIR", "HALF_TURN_STAIR", "TWO_QUARTER_WINDING_STAIR", "TWO_QUARTER_TURN_STAIR", "THREE_QUARTER_WINDING_STAIR", "THREE_QUARTER_TURN_STAIR", "SPIRAL_STAIR", "DOUBLE_RETURN_STAIR", "CURVED_RUN_STAIR", "TWO_CURVED_RUN_STAIR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairTypeEnum::IfcStairTypeEnum IfcStairTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_STRAIGHT_RUN_STAIR;
    if (s == "TWO_STRAIGHT_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_STRAIGHT_RUN_STAIR;
    if (s == "QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_QUARTER_WINDING_STAIR;
    if (s == "QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_QUARTER_TURN_STAIR;
    if (s == "HALF_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_HALF_WINDING_STAIR;
    if (s == "HALF_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_HALF_TURN_STAIR;
    if (s == "TWO_QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_WINDING_STAIR;
    if (s == "TWO_QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_TURN_STAIR;
    if (s == "THREE_QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_WINDING_STAIR;
    if (s == "THREE_QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_TURN_STAIR;
    if (s == "SPIRAL_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_SPIRAL_STAIR;
    if (s == "DOUBLE_RETURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_DOUBLE_RETURN_STAIR;
    if (s == "CURVED_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_CURVED_RUN_STAIR;
    if (s == "TWO_CURVED_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_CURVED_RUN_STAIR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStateEnum::ToString(IfcStateEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "READWRITE", "READONLY", "LOCKED", "READWRITELOCKED", "READONLYLOCKED" };
    return names[v];
}

IfcStateEnum::IfcStateEnum IfcStateEnum::FromString(const std::string& s) {
    if (s == "READWRITE") return ::Ifc2x3::IfcStateEnum::IfcState_READWRITE;
    if (s == "READONLY") return ::Ifc2x3::IfcStateEnum::IfcState_READONLY;
    if (s == "LOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_LOCKED;
    if (s == "READWRITELOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_READWRITELOCKED;
    if (s == "READONLYLOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_READONLYLOCKED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralCurveTypeEnum::ToString(IfcStructuralCurveTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGID_JOINED_MEMBER", "PIN_JOINED_MEMBER", "CABLE", "TENSION_MEMBER", "COMPRESSION_MEMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum IfcStructuralCurveTypeEnum::FromString(const std::string& s) {
    if (s == "RIGID_JOINED_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_RIGID_JOINED_MEMBER;
    if (s == "PIN_JOINED_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_PIN_JOINED_MEMBER;
    if (s == "CABLE") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_CABLE;
    if (s == "TENSION_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_TENSION_MEMBER;
    if (s == "COMPRESSION_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_COMPRESSION_MEMBER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralSurfaceTypeEnum::ToString(IfcStructuralSurfaceTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BENDING_ELEMENT", "MEMBRANE_ELEMENT", "SHELL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum IfcStructuralSurfaceTypeEnum::FromString(const std::string& s) {
    if (s == "BENDING_ELEMENT") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_BENDING_ELEMENT;
    if (s == "MEMBRANE_ELEMENT") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_MEMBRANE_ELEMENT;
    if (s == "SHELL") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_SHELL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceSide::ToString(IfcSurfaceSide v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE", "BOTH" };
    return names[v];
}

IfcSurfaceSide::IfcSurfaceSide IfcSurfaceSide::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_NEGATIVE;
    if (s == "BOTH") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_BOTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceTextureEnum::ToString(IfcSurfaceTextureEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUMP", "OPACITY", "REFLECTION", "SELFILLUMINATION", "SHININESS", "SPECULAR", "TEXTURE", "TRANSPARENCYMAP", "NOTDEFINED" };
    return names[v];
}

IfcSurfaceTextureEnum::IfcSurfaceTextureEnum IfcSurfaceTextureEnum::FromString(const std::string& s) {
    if (s == "BUMP") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_BUMP;
    if (s == "OPACITY") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_OPACITY;
    if (s == "REFLECTION") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_REFLECTION;
    if (s == "SELFILLUMINATION") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SELFILLUMINATION;
    if (s == "SHININESS") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SHININESS;
    if (s == "SPECULAR") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SPECULAR;
    if (s == "TEXTURE") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_TEXTURE;
    if (s == "TRANSPARENCYMAP") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_TRANSPARENCYMAP;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSwitchingDeviceTypeEnum::ToString(IfcSwitchingDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTACTOR", "EMERGENCYSTOP", "STARTER", "SWITCHDISCONNECTOR", "TOGGLESWITCH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CONTACTOR") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_CONTACTOR;
    if (s == "EMERGENCYSTOP") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_EMERGENCYSTOP;
    if (s == "STARTER") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_STARTER;
    if (s == "SWITCHDISCONNECTOR") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SWITCHDISCONNECTOR;
    if (s == "TOGGLESWITCH") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_TOGGLESWITCH;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTankTypeEnum::ToString(IfcTankTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PREFORMED", "SECTIONAL", "EXPANSION", "PRESSUREVESSEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTankTypeEnum::IfcTankTypeEnum IfcTankTypeEnum::FromString(const std::string& s) {
    if (s == "PREFORMED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_PREFORMED;
    if (s == "SECTIONAL") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_SECTIONAL;
    if (s == "EXPANSION") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_EXPANSION;
    if (s == "PRESSUREVESSEL") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_PRESSUREVESSEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTendonTypeEnum::ToString(IfcTendonTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAND", "WIRE", "BAR", "COATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendonTypeEnum::FromString(const std::string& s) {
    if (s == "STRAND") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_STRAND;
    if (s == "WIRE") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_WIRE;
    if (s == "BAR") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_BAR;
    if (s == "COATED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_COATED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTextPath::ToString(IfcTextPath v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "RIGHT", "UP", "DOWN" };
    return names[v];
}

IfcTextPath::IfcTextPath IfcTextPath::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcTextPath::IfcTextPath_LEFT;
    if (s == "RIGHT") return ::Ifc2x3::IfcTextPath::IfcTextPath_RIGHT;
    if (s == "UP") return ::Ifc2x3::IfcTextPath::IfcTextPath_UP;
    if (s == "DOWN") return ::Ifc2x3::IfcTextPath::IfcTextPath_DOWN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcThermalLoadSourceEnum::ToString(IfcThermalLoadSourceEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PEOPLE", "LIGHTING", "EQUIPMENT", "VENTILATIONINDOORAIR", "VENTILATIONOUTSIDEAIR", "RECIRCULATEDAIR", "EXHAUSTAIR", "AIREXCHANGERATE", "DRYBULBTEMPERATURE", "RELATIVEHUMIDITY", "INFILTRATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum IfcThermalLoadSourceEnum::FromString(const std::string& s) {
    if (s == "PEOPLE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_PEOPLE;
    if (s == "LIGHTING") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_LIGHTING;
    if (s == "EQUIPMENT") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_EQUIPMENT;
    if (s == "VENTILATIONINDOORAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_VENTILATIONINDOORAIR;
    if (s == "VENTILATIONOUTSIDEAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_VENTILATIONOUTSIDEAIR;
    if (s == "RECIRCULATEDAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_RECIRCULATEDAIR;
    if (s == "EXHAUSTAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_EXHAUSTAIR;
    if (s == "AIREXCHANGERATE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_AIREXCHANGERATE;
    if (s == "DRYBULBTEMPERATURE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_DRYBULBTEMPERATURE;
    if (s == "RELATIVEHUMIDITY") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_RELATIVEHUMIDITY;
    if (s == "INFILTRATION") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_INFILTRATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcThermalLoadTypeEnum::ToString(IfcThermalLoadTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SENSIBLE", "LATENT", "RADIANT", "NOTDEFINED" };
    return names[v];
}

IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum IfcThermalLoadTypeEnum::FromString(const std::string& s) {
    if (s == "SENSIBLE") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_SENSIBLE;
    if (s == "LATENT") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_LATENT;
    if (s == "RADIANT") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_RADIANT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTimeSeriesDataTypeEnum::ToString(IfcTimeSeriesDataTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTINUOUS", "DISCRETE", "DISCRETEBINARY", "PIECEWISEBINARY", "PIECEWISECONSTANT", "PIECEWISECONTINUOUS", "NOTDEFINED" };
    return names[v];
}

IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeriesDataTypeEnum::FromString(const std::string& s) {
    if (s == "CONTINUOUS") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_CONTINUOUS;
    if (s == "DISCRETE") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETE;
    if (s == "DISCRETEBINARY") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETEBINARY;
    if (s == "PIECEWISEBINARY") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISEBINARY;
    if (s == "PIECEWISECONSTANT") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONSTANT;
    if (s == "PIECEWISECONTINUOUS") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONTINUOUS;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTimeSeriesScheduleTypeEnum::ToString(IfcTimeSeriesScheduleTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANNUAL", "MONTHLY", "WEEKLY", "DAILY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum IfcTimeSeriesScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "ANNUAL") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_ANNUAL;
    if (s == "MONTHLY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_MONTHLY;
    if (s == "WEEKLY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_WEEKLY;
    if (s == "DAILY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_DAILY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransformerTypeEnum::ToString(IfcTransformerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURRENT", "FREQUENCY", "VOLTAGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerTypeEnum::FromString(const std::string& s) {
    if (s == "CURRENT") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_CURRENT;
    if (s == "FREQUENCY") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_FREQUENCY;
    if (s == "VOLTAGE") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_VOLTAGE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransitionCode::ToString(IfcTransitionCode v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DISCONTINUOUS", "CONTINUOUS", "CONTSAMEGRADIENT", "CONTSAMEGRADIENTSAMECURVATURE" };
    return names[v];
}

IfcTransitionCode::IfcTransitionCode IfcTransitionCode::FromString(const std::string& s) {
    if (s == "DISCONTINUOUS") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_DISCONTINUOUS;
    if (s == "CONTINUOUS") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTINUOUS;
    if (s == "CONTSAMEGRADIENT") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENT;
    if (s == "CONTSAMEGRADIENTSAMECURVATURE") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransportElementTypeEnum::ToString(IfcTransportElementTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELEVATOR", "ESCALATOR", "MOVINGWALKWAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementTypeEnum::FromString(const std::string& s) {
    if (s == "ELEVATOR") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_ELEVATOR;
    if (s == "ESCALATOR") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_ESCALATOR;
    if (s == "MOVINGWALKWAY") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_MOVINGWALKWAY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTrimmingPreference::ToString(IfcTrimmingPreference v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CARTESIAN", "PARAMETER", "UNSPECIFIED" };
    return names[v];
}

IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmingPreference::FromString(const std::string& s) {
    if (s == "CARTESIAN") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_CARTESIAN;
    if (s == "PARAMETER") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_PARAMETER;
    if (s == "UNSPECIFIED") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTubeBundleTypeEnum::ToString(IfcTubeBundleTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FINNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleTypeEnum::FromString(const std::string& s) {
    if (s == "FINNED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_FINNED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitEnum::ToString(IfcUnitEnum v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ABSORBEDDOSEUNIT", "AMOUNTOFSUBSTANCEUNIT", "AREAUNIT", "DOSEEQUIVALENTUNIT", "ELECTRICCAPACITANCEUNIT", "ELECTRICCHARGEUNIT", "ELECTRICCONDUCTANCEUNIT", "ELECTRICCURRENTUNIT", "ELECTRICRESISTANCEUNIT", "ELECTRICVOLTAGEUNIT", "ENERGYUNIT", "FORCEUNIT", "FREQUENCYUNIT", "ILLUMINANCEUNIT", "INDUCTANCEUNIT", "LENGTHUNIT", "LUMINOUSFLUXUNIT", "LUMINOUSINTENSITYUNIT", "MAGNETICFLUXDENSITYUNIT", "MAGNETICFLUXUNIT", "MASSUNIT", "PLANEANGLEUNIT", "POWERUNIT", "PRESSUREUNIT", "RADIOACTIVITYUNIT", "SOLIDANGLEUNIT", "THERMODYNAMICTEMPERATUREUNIT", "TIMEUNIT", "VOLUMEUNIT", "USERDEFINED" };
    return names[v];
}

IfcUnitEnum::IfcUnitEnum IfcUnitEnum::FromString(const std::string& s) {
    if (s == "ABSORBEDDOSEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ABSORBEDDOSEUNIT;
    if (s == "AMOUNTOFSUBSTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_AMOUNTOFSUBSTANCEUNIT;
    if (s == "AREAUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_AREAUNIT;
    if (s == "DOSEEQUIVALENTUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_DOSEEQUIVALENTUNIT;
    if (s == "ELECTRICCAPACITANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCAPACITANCEUNIT;
    if (s == "ELECTRICCHARGEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCHARGEUNIT;
    if (s == "ELECTRICCONDUCTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCONDUCTANCEUNIT;
    if (s == "ELECTRICCURRENTUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCURRENTUNIT;
    if (s == "ELECTRICRESISTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICRESISTANCEUNIT;
    if (s == "ELECTRICVOLTAGEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICVOLTAGEUNIT;
    if (s == "ENERGYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ENERGYUNIT;
    if (s == "FORCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_FORCEUNIT;
    if (s == "FREQUENCYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_FREQUENCYUNIT;
    if (s == "ILLUMINANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ILLUMINANCEUNIT;
    if (s == "INDUCTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_INDUCTANCEUNIT;
    if (s == "LENGTHUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LENGTHUNIT;
    if (s == "LUMINOUSFLUXUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LUMINOUSFLUXUNIT;
    if (s == "LUMINOUSINTENSITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LUMINOUSINTENSITYUNIT;
    if (s == "MAGNETICFLUXDENSITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MAGNETICFLUXDENSITYUNIT;
    if (s == "MAGNETICFLUXUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MAGNETICFLUXUNIT;
    if (s == "MASSUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MASSUNIT;
    if (s == "PLANEANGLEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_PLANEANGLEUNIT;
    if (s == "POWERUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_POWERUNIT;
    if (s == "PRESSUREUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_PRESSUREUNIT;
    if (s == "RADIOACTIVITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_RADIOACTIVITYUNIT;
    if (s == "SOLIDANGLEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_SOLIDANGLEUNIT;
    if (s == "THERMODYNAMICTEMPERATUREUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_THERMODYNAMICTEMPERATUREUNIT;
    if (s == "TIMEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_TIMEUNIT;
    if (s == "VOLUMEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_VOLUMEUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcUnitEnum::IfcUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitaryEquipmentTypeEnum::ToString(IfcUnitaryEquipmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRHANDLER", "AIRCONDITIONINGUNIT", "SPLITSYSTEM", "ROOFTOPUNIT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentTypeEnum::FromString(const std::string& s) {
    if (s == "AIRHANDLER") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRHANDLER;
    if (s == "AIRCONDITIONINGUNIT") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT;
    if (s == "SPLITSYSTEM") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_SPLITSYSTEM;
    if (s == "ROOFTOPUNIT") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_ROOFTOPUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcValveTypeEnum::ToString(IfcValveTypeEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRRELEASE", "ANTIVACUUM", "CHANGEOVER", "CHECK", "COMMISSIONING", "DIVERTING", "DRAWOFFCOCK", "DOUBLECHECK", "DOUBLEREGULATING", "FAUCET", "FLUSHING", "GASCOCK", "GASTAP", "ISOLATING", "MIXING", "PRESSUREREDUCING", "PRESSURERELIEF", "REGULATING", "SAFETYCUTOFF", "STEAMTRAP", "STOPCOCK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcValveTypeEnum::IfcValveTypeEnum IfcValveTypeEnum::FromString(const std::string& s) {
    if (s == "AIRRELEASE") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_AIRRELEASE;
    if (s == "ANTIVACUUM") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_ANTIVACUUM;
    if (s == "CHANGEOVER") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_CHANGEOVER;
    if (s == "CHECK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_CHECK;
    if (s == "COMMISSIONING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_COMMISSIONING;
    if (s == "DIVERTING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DIVERTING;
    if (s == "DRAWOFFCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DRAWOFFCOCK;
    if (s == "DOUBLECHECK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DOUBLECHECK;
    if (s == "DOUBLEREGULATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DOUBLEREGULATING;
    if (s == "FAUCET") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_FAUCET;
    if (s == "FLUSHING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_FLUSHING;
    if (s == "GASCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_GASCOCK;
    if (s == "GASTAP") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_GASTAP;
    if (s == "ISOLATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_ISOLATING;
    if (s == "MIXING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_MIXING;
    if (s == "PRESSUREREDUCING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_PRESSUREREDUCING;
    if (s == "PRESSURERELIEF") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_PRESSURERELIEF;
    if (s == "REGULATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_REGULATING;
    if (s == "SAFETYCUTOFF") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_SAFETYCUTOFF;
    if (s == "STEAMTRAP") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_STEAMTRAP;
    if (s == "STOPCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_STOPCOCK;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcVibrationIsolatorTypeEnum::ToString(IfcVibrationIsolatorTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPRESSION", "SPRING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorTypeEnum::FromString(const std::string& s) {
    if (s == "COMPRESSION") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_COMPRESSION;
    if (s == "SPRING") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_SPRING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWallTypeEnum::ToString(IfcWallTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STANDARD", "POLYGONAL", "SHEAR", "ELEMENTEDWALL", "PLUMBINGWALL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWallTypeEnum::IfcWallTypeEnum IfcWallTypeEnum::FromString(const std::string& s) {
    if (s == "STANDARD") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_STANDARD;
    if (s == "POLYGONAL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_POLYGONAL;
    if (s == "SHEAR") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_SHEAR;
    if (s == "ELEMENTEDWALL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_ELEMENTEDWALL;
    if (s == "PLUMBINGWALL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_PLUMBINGWALL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWasteTerminalTypeEnum::ToString(IfcWasteTerminalTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOORTRAP", "FLOORWASTE", "GULLYSUMP", "GULLYTRAP", "GREASEINTERCEPTOR", "OILINTERCEPTOR", "PETROLINTERCEPTOR", "ROOFDRAIN", "WASTEDISPOSALUNIT", "WASTETRAP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "FLOORTRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORTRAP;
    if (s == "FLOORWASTE") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORWASTE;
    if (s == "GULLYSUMP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYSUMP;
    if (s == "GULLYTRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYTRAP;
    if (s == "GREASEINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GREASEINTERCEPTOR;
    if (s == "OILINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_OILINTERCEPTOR;
    if (s == "PETROLINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_PETROLINTERCEPTOR;
    if (s == "ROOFDRAIN") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_ROOFDRAIN;
    if (s == "WASTEDISPOSALUNIT") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTEDISPOSALUNIT;
    if (s == "WASTETRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTETRAP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelOperationEnum::ToString(IfcWindowPanelOperationEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SIDEHUNGRIGHTHAND", "SIDEHUNGLEFTHAND", "TILTANDTURNRIGHTHAND", "TILTANDTURNLEFTHAND", "TOPHUNG", "BOTTOMHUNG", "PIVOTHORIZONTAL", "PIVOTVERTICAL", "SLIDINGHORIZONTAL", "SLIDINGVERTICAL", "REMOVABLECASEMENT", "FIXEDCASEMENT", "OTHEROPERATION", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SIDEHUNGRIGHTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGRIGHTHAND;
    if (s == "SIDEHUNGLEFTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGLEFTHAND;
    if (s == "TILTANDTURNRIGHTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNRIGHTHAND;
    if (s == "TILTANDTURNLEFTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNLEFTHAND;
    if (s == "TOPHUNG") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TOPHUNG;
    if (s == "BOTTOMHUNG") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_BOTTOMHUNG;
    if (s == "PIVOTHORIZONTAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTHORIZONTAL;
    if (s == "PIVOTVERTICAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTVERTICAL;
    if (s == "SLIDINGHORIZONTAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGHORIZONTAL;
    if (s == "SLIDINGVERTICAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGVERTICAL;
    if (s == "REMOVABLECASEMENT") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_REMOVABLECASEMENT;
    if (s == "FIXEDCASEMENT") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_FIXEDCASEMENT;
    if (s == "OTHEROPERATION") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_OTHEROPERATION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelPositionEnum::ToString(IfcWindowPanelPositionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "BOTTOM", "TOP", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_RIGHT;
    if (s == "BOTTOM") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_BOTTOM;
    if (s == "TOP") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_TOP;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleConstructionEnum::ToString(IfcWindowStyleConstructionEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "PLASTIC", "OTHER_CONSTRUCTION", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM_WOOD;
    if (s == "PLASTIC") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_PLASTIC;
    if (s == "OTHER_CONSTRUCTION") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_OTHER_CONSTRUCTION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleOperationEnum::ToString(IfcWindowStyleOperationEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkControlTypeEnum::ToString(IfcWorkControlTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkControlTypeEnum::IfcWorkControlTypeEnum IfcWorkControlTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_ACTUAL;
    if (s == "BASELINE") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_BASELINE;
    if (s == "PLANNED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}


// Function implementations for IfcAbsorbedDoseMeasure
IfcUtil::ArgumentType IfcAbsorbedDoseMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcAbsorbedDoseMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcAbsorbedDoseMeasure::is(Type::Enum v) const { return v == IfcAbsorbedDoseMeasure::Class(); }
Type::Enum IfcAbsorbedDoseMeasure::type() const { return Type::IfcAbsorbedDoseMeasure; }
Type::Enum IfcAbsorbedDoseMeasure::Class() { return Type::IfcAbsorbedDoseMeasure; }
IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcAbsorbedDoseMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcAccelerationMeasure
IfcUtil::ArgumentType IfcAccelerationMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcAccelerationMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcAccelerationMeasure::is(Type::Enum v) const { return v == IfcAccelerationMeasure::Class(); }
Type::Enum IfcAccelerationMeasure::type() const { return Type::IfcAccelerationMeasure; }
Type::Enum IfcAccelerationMeasure::Class() { return Type::IfcAccelerationMeasure; }
IfcAccelerationMeasure::IfcAccelerationMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcAccelerationMeasure::IfcAccelerationMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcAccelerationMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcAmountOfSubstanceMeasure
IfcUtil::ArgumentType IfcAmountOfSubstanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcAmountOfSubstanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcAmountOfSubstanceMeasure::is(Type::Enum v) const { return v == IfcAmountOfSubstanceMeasure::Class(); }
Type::Enum IfcAmountOfSubstanceMeasure::type() const { return Type::IfcAmountOfSubstanceMeasure; }
Type::Enum IfcAmountOfSubstanceMeasure::Class() { return Type::IfcAmountOfSubstanceMeasure; }
IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcAmountOfSubstanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcAngularVelocityMeasure
IfcUtil::ArgumentType IfcAngularVelocityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcAngularVelocityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcAngularVelocityMeasure::is(Type::Enum v) const { return v == IfcAngularVelocityMeasure::Class(); }
Type::Enum IfcAngularVelocityMeasure::type() const { return Type::IfcAngularVelocityMeasure; }
Type::Enum IfcAngularVelocityMeasure::Class() { return Type::IfcAngularVelocityMeasure; }
IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcAngularVelocityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcAreaMeasure
IfcUtil::ArgumentType IfcAreaMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcAreaMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcAreaMeasure::is(Type::Enum v) const { return v == IfcAreaMeasure::Class(); }
Type::Enum IfcAreaMeasure::type() const { return Type::IfcAreaMeasure; }
Type::Enum IfcAreaMeasure::Class() { return Type::IfcAreaMeasure; }
IfcAreaMeasure::IfcAreaMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcAreaMeasure::IfcAreaMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcAreaMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcBoolean
IfcUtil::ArgumentType IfcBoolean::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_BOOL; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcBoolean::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcBoolean::is(Type::Enum v) const { return v == IfcBoolean::Class(); }
Type::Enum IfcBoolean::type() const { return Type::IfcBoolean; }
Type::Enum IfcBoolean::Class() { return Type::IfcBoolean; }
IfcBoolean::IfcBoolean(IfcEntityInstanceData* e) { entity = e; }
IfcBoolean::IfcBoolean(bool v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcBoolean::operator bool() const { return *entity->getArgument(0); }

// Function implementations for IfcBoxAlignment
IfcUtil::ArgumentType IfcBoxAlignment::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcBoxAlignment::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcBoxAlignment::is(Type::Enum v) const { return v == Type::IfcBoxAlignment || IfcLabel::is(v); }
Type::Enum IfcBoxAlignment::type() const { return Type::IfcBoxAlignment; }
Type::Enum IfcBoxAlignment::Class() { return Type::IfcBoxAlignment; }
IfcBoxAlignment::IfcBoxAlignment(IfcEntityInstanceData* e) : IfcLabel((IfcEntityInstanceData*)0) { entity = e; }
IfcBoxAlignment::IfcBoxAlignment(std::string v) : IfcLabel((IfcEntityInstanceData*)0) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcBoxAlignment::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcComplexNumber
IfcUtil::ArgumentType IfcComplexNumber::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcComplexNumber::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcComplexNumber::is(Type::Enum v) const { return v == IfcComplexNumber::Class(); }
Type::Enum IfcComplexNumber::type() const { return Type::IfcComplexNumber; }
Type::Enum IfcComplexNumber::Class() { return Type::IfcComplexNumber; }
IfcComplexNumber::IfcComplexNumber(IfcEntityInstanceData* e) { entity = e; }
IfcComplexNumber::IfcComplexNumber(std::vector< double > /*[1:2]*/ v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcComplexNumber::operator std::vector< double > /*[1:2]*/() const { return *entity->getArgument(0); }

// Function implementations for IfcCompoundPlaneAngleMeasure
IfcUtil::ArgumentType IfcCompoundPlaneAngleMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcCompoundPlaneAngleMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcCompoundPlaneAngleMeasure::is(Type::Enum v) const { return v == IfcCompoundPlaneAngleMeasure::Class(); }
Type::Enum IfcCompoundPlaneAngleMeasure::type() const { return Type::IfcCompoundPlaneAngleMeasure; }
Type::Enum IfcCompoundPlaneAngleMeasure::Class() { return Type::IfcCompoundPlaneAngleMeasure; }
IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(std::vector< int > /*[3:4]*/ v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcCompoundPlaneAngleMeasure::operator std::vector< int > /*[3:4]*/() const { return *entity->getArgument(0); }

// Function implementations for IfcContextDependentMeasure
IfcUtil::ArgumentType IfcContextDependentMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcContextDependentMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcContextDependentMeasure::is(Type::Enum v) const { return v == IfcContextDependentMeasure::Class(); }
Type::Enum IfcContextDependentMeasure::type() const { return Type::IfcContextDependentMeasure; }
Type::Enum IfcContextDependentMeasure::Class() { return Type::IfcContextDependentMeasure; }
IfcContextDependentMeasure::IfcContextDependentMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcContextDependentMeasure::IfcContextDependentMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcContextDependentMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcCountMeasure
IfcUtil::ArgumentType IfcCountMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcCountMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcCountMeasure::is(Type::Enum v) const { return v == IfcCountMeasure::Class(); }
Type::Enum IfcCountMeasure::type() const { return Type::IfcCountMeasure; }
Type::Enum IfcCountMeasure::Class() { return Type::IfcCountMeasure; }
IfcCountMeasure::IfcCountMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcCountMeasure::IfcCountMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcCountMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcCurvatureMeasure
IfcUtil::ArgumentType IfcCurvatureMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcCurvatureMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcCurvatureMeasure::is(Type::Enum v) const { return v == IfcCurvatureMeasure::Class(); }
Type::Enum IfcCurvatureMeasure::type() const { return Type::IfcCurvatureMeasure; }
Type::Enum IfcCurvatureMeasure::Class() { return Type::IfcCurvatureMeasure; }
IfcCurvatureMeasure::IfcCurvatureMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcCurvatureMeasure::IfcCurvatureMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcCurvatureMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcDayInMonthNumber
IfcUtil::ArgumentType IfcDayInMonthNumber::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDayInMonthNumber::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDayInMonthNumber::is(Type::Enum v) const { return v == IfcDayInMonthNumber::Class(); }
Type::Enum IfcDayInMonthNumber::type() const { return Type::IfcDayInMonthNumber; }
Type::Enum IfcDayInMonthNumber::Class() { return Type::IfcDayInMonthNumber; }
IfcDayInMonthNumber::IfcDayInMonthNumber(IfcEntityInstanceData* e) { entity = e; }
IfcDayInMonthNumber::IfcDayInMonthNumber(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDayInMonthNumber::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcDaylightSavingHour
IfcUtil::ArgumentType IfcDaylightSavingHour::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDaylightSavingHour::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDaylightSavingHour::is(Type::Enum v) const { return v == IfcDaylightSavingHour::Class(); }
Type::Enum IfcDaylightSavingHour::type() const { return Type::IfcDaylightSavingHour; }
Type::Enum IfcDaylightSavingHour::Class() { return Type::IfcDaylightSavingHour; }
IfcDaylightSavingHour::IfcDaylightSavingHour(IfcEntityInstanceData* e) { entity = e; }
IfcDaylightSavingHour::IfcDaylightSavingHour(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDaylightSavingHour::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcDescriptiveMeasure
IfcUtil::ArgumentType IfcDescriptiveMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDescriptiveMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDescriptiveMeasure::is(Type::Enum v) const { return v == IfcDescriptiveMeasure::Class(); }
Type::Enum IfcDescriptiveMeasure::type() const { return Type::IfcDescriptiveMeasure; }
Type::Enum IfcDescriptiveMeasure::Class() { return Type::IfcDescriptiveMeasure; }
IfcDescriptiveMeasure::IfcDescriptiveMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcDescriptiveMeasure::IfcDescriptiveMeasure(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDescriptiveMeasure::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcDimensionCount
IfcUtil::ArgumentType IfcDimensionCount::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDimensionCount::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDimensionCount::is(Type::Enum v) const { return v == IfcDimensionCount::Class(); }
Type::Enum IfcDimensionCount::type() const { return Type::IfcDimensionCount; }
Type::Enum IfcDimensionCount::Class() { return Type::IfcDimensionCount; }
IfcDimensionCount::IfcDimensionCount(IfcEntityInstanceData* e) { entity = e; }
IfcDimensionCount::IfcDimensionCount(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDimensionCount::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcDoseEquivalentMeasure
IfcUtil::ArgumentType IfcDoseEquivalentMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDoseEquivalentMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDoseEquivalentMeasure::is(Type::Enum v) const { return v == IfcDoseEquivalentMeasure::Class(); }
Type::Enum IfcDoseEquivalentMeasure::type() const { return Type::IfcDoseEquivalentMeasure; }
Type::Enum IfcDoseEquivalentMeasure::Class() { return Type::IfcDoseEquivalentMeasure; }
IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDoseEquivalentMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcDynamicViscosityMeasure
IfcUtil::ArgumentType IfcDynamicViscosityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcDynamicViscosityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcDynamicViscosityMeasure::is(Type::Enum v) const { return v == IfcDynamicViscosityMeasure::Class(); }
Type::Enum IfcDynamicViscosityMeasure::type() const { return Type::IfcDynamicViscosityMeasure; }
Type::Enum IfcDynamicViscosityMeasure::Class() { return Type::IfcDynamicViscosityMeasure; }
IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcDynamicViscosityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricCapacitanceMeasure
IfcUtil::ArgumentType IfcElectricCapacitanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricCapacitanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricCapacitanceMeasure::is(Type::Enum v) const { return v == IfcElectricCapacitanceMeasure::Class(); }
Type::Enum IfcElectricCapacitanceMeasure::type() const { return Type::IfcElectricCapacitanceMeasure; }
Type::Enum IfcElectricCapacitanceMeasure::Class() { return Type::IfcElectricCapacitanceMeasure; }
IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricCapacitanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricChargeMeasure
IfcUtil::ArgumentType IfcElectricChargeMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricChargeMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricChargeMeasure::is(Type::Enum v) const { return v == IfcElectricChargeMeasure::Class(); }
Type::Enum IfcElectricChargeMeasure::type() const { return Type::IfcElectricChargeMeasure; }
Type::Enum IfcElectricChargeMeasure::Class() { return Type::IfcElectricChargeMeasure; }
IfcElectricChargeMeasure::IfcElectricChargeMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricChargeMeasure::IfcElectricChargeMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricChargeMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricConductanceMeasure
IfcUtil::ArgumentType IfcElectricConductanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricConductanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricConductanceMeasure::is(Type::Enum v) const { return v == IfcElectricConductanceMeasure::Class(); }
Type::Enum IfcElectricConductanceMeasure::type() const { return Type::IfcElectricConductanceMeasure; }
Type::Enum IfcElectricConductanceMeasure::Class() { return Type::IfcElectricConductanceMeasure; }
IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricConductanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricCurrentMeasure
IfcUtil::ArgumentType IfcElectricCurrentMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricCurrentMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricCurrentMeasure::is(Type::Enum v) const { return v == IfcElectricCurrentMeasure::Class(); }
Type::Enum IfcElectricCurrentMeasure::type() const { return Type::IfcElectricCurrentMeasure; }
Type::Enum IfcElectricCurrentMeasure::Class() { return Type::IfcElectricCurrentMeasure; }
IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricCurrentMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricResistanceMeasure
IfcUtil::ArgumentType IfcElectricResistanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricResistanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricResistanceMeasure::is(Type::Enum v) const { return v == IfcElectricResistanceMeasure::Class(); }
Type::Enum IfcElectricResistanceMeasure::type() const { return Type::IfcElectricResistanceMeasure; }
Type::Enum IfcElectricResistanceMeasure::Class() { return Type::IfcElectricResistanceMeasure; }
IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricResistanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcElectricVoltageMeasure
IfcUtil::ArgumentType IfcElectricVoltageMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcElectricVoltageMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcElectricVoltageMeasure::is(Type::Enum v) const { return v == IfcElectricVoltageMeasure::Class(); }
Type::Enum IfcElectricVoltageMeasure::type() const { return Type::IfcElectricVoltageMeasure; }
Type::Enum IfcElectricVoltageMeasure::Class() { return Type::IfcElectricVoltageMeasure; }
IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcElectricVoltageMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcEnergyMeasure
IfcUtil::ArgumentType IfcEnergyMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcEnergyMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcEnergyMeasure::is(Type::Enum v) const { return v == IfcEnergyMeasure::Class(); }
Type::Enum IfcEnergyMeasure::type() const { return Type::IfcEnergyMeasure; }
Type::Enum IfcEnergyMeasure::Class() { return Type::IfcEnergyMeasure; }
IfcEnergyMeasure::IfcEnergyMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcEnergyMeasure::IfcEnergyMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcEnergyMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcFontStyle
IfcUtil::ArgumentType IfcFontStyle::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcFontStyle::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcFontStyle::is(Type::Enum v) const { return v == IfcFontStyle::Class(); }
Type::Enum IfcFontStyle::type() const { return Type::IfcFontStyle; }
Type::Enum IfcFontStyle::Class() { return Type::IfcFontStyle; }
IfcFontStyle::IfcFontStyle(IfcEntityInstanceData* e) { entity = e; }
IfcFontStyle::IfcFontStyle(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcFontStyle::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcFontVariant
IfcUtil::ArgumentType IfcFontVariant::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcFontVariant::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcFontVariant::is(Type::Enum v) const { return v == IfcFontVariant::Class(); }
Type::Enum IfcFontVariant::type() const { return Type::IfcFontVariant; }
Type::Enum IfcFontVariant::Class() { return Type::IfcFontVariant; }
IfcFontVariant::IfcFontVariant(IfcEntityInstanceData* e) { entity = e; }
IfcFontVariant::IfcFontVariant(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcFontVariant::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcFontWeight
IfcUtil::ArgumentType IfcFontWeight::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcFontWeight::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcFontWeight::is(Type::Enum v) const { return v == IfcFontWeight::Class(); }
Type::Enum IfcFontWeight::type() const { return Type::IfcFontWeight; }
Type::Enum IfcFontWeight::Class() { return Type::IfcFontWeight; }
IfcFontWeight::IfcFontWeight(IfcEntityInstanceData* e) { entity = e; }
IfcFontWeight::IfcFontWeight(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcFontWeight::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcForceMeasure
IfcUtil::ArgumentType IfcForceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcForceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcForceMeasure::is(Type::Enum v) const { return v == IfcForceMeasure::Class(); }
Type::Enum IfcForceMeasure::type() const { return Type::IfcForceMeasure; }
Type::Enum IfcForceMeasure::Class() { return Type::IfcForceMeasure; }
IfcForceMeasure::IfcForceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcForceMeasure::IfcForceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcForceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcFrequencyMeasure
IfcUtil::ArgumentType IfcFrequencyMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcFrequencyMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcFrequencyMeasure::is(Type::Enum v) const { return v == IfcFrequencyMeasure::Class(); }
Type::Enum IfcFrequencyMeasure::type() const { return Type::IfcFrequencyMeasure; }
Type::Enum IfcFrequencyMeasure::Class() { return Type::IfcFrequencyMeasure; }
IfcFrequencyMeasure::IfcFrequencyMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcFrequencyMeasure::IfcFrequencyMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcFrequencyMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcGloballyUniqueId
IfcUtil::ArgumentType IfcGloballyUniqueId::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcGloballyUniqueId::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcGloballyUniqueId::is(Type::Enum v) const { return v == IfcGloballyUniqueId::Class(); }
Type::Enum IfcGloballyUniqueId::type() const { return Type::IfcGloballyUniqueId; }
Type::Enum IfcGloballyUniqueId::Class() { return Type::IfcGloballyUniqueId; }
IfcGloballyUniqueId::IfcGloballyUniqueId(IfcEntityInstanceData* e) { entity = e; }
IfcGloballyUniqueId::IfcGloballyUniqueId(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcGloballyUniqueId::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcHeatFluxDensityMeasure
IfcUtil::ArgumentType IfcHeatFluxDensityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcHeatFluxDensityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcHeatFluxDensityMeasure::is(Type::Enum v) const { return v == IfcHeatFluxDensityMeasure::Class(); }
Type::Enum IfcHeatFluxDensityMeasure::type() const { return Type::IfcHeatFluxDensityMeasure; }
Type::Enum IfcHeatFluxDensityMeasure::Class() { return Type::IfcHeatFluxDensityMeasure; }
IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcHeatFluxDensityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcHeatingValueMeasure
IfcUtil::ArgumentType IfcHeatingValueMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcHeatingValueMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcHeatingValueMeasure::is(Type::Enum v) const { return v == IfcHeatingValueMeasure::Class(); }
Type::Enum IfcHeatingValueMeasure::type() const { return Type::IfcHeatingValueMeasure; }
Type::Enum IfcHeatingValueMeasure::Class() { return Type::IfcHeatingValueMeasure; }
IfcHeatingValueMeasure::IfcHeatingValueMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcHeatingValueMeasure::IfcHeatingValueMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcHeatingValueMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcHourInDay
IfcUtil::ArgumentType IfcHourInDay::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcHourInDay::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcHourInDay::is(Type::Enum v) const { return v == IfcHourInDay::Class(); }
Type::Enum IfcHourInDay::type() const { return Type::IfcHourInDay; }
Type::Enum IfcHourInDay::Class() { return Type::IfcHourInDay; }
IfcHourInDay::IfcHourInDay(IfcEntityInstanceData* e) { entity = e; }
IfcHourInDay::IfcHourInDay(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcHourInDay::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcIdentifier
IfcUtil::ArgumentType IfcIdentifier::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcIdentifier::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcIdentifier::is(Type::Enum v) const { return v == IfcIdentifier::Class(); }
Type::Enum IfcIdentifier::type() const { return Type::IfcIdentifier; }
Type::Enum IfcIdentifier::Class() { return Type::IfcIdentifier; }
IfcIdentifier::IfcIdentifier(IfcEntityInstanceData* e) { entity = e; }
IfcIdentifier::IfcIdentifier(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcIdentifier::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcIlluminanceMeasure
IfcUtil::ArgumentType IfcIlluminanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcIlluminanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcIlluminanceMeasure::is(Type::Enum v) const { return v == IfcIlluminanceMeasure::Class(); }
Type::Enum IfcIlluminanceMeasure::type() const { return Type::IfcIlluminanceMeasure; }
Type::Enum IfcIlluminanceMeasure::Class() { return Type::IfcIlluminanceMeasure; }
IfcIlluminanceMeasure::IfcIlluminanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcIlluminanceMeasure::IfcIlluminanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcIlluminanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcInductanceMeasure
IfcUtil::ArgumentType IfcInductanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcInductanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcInductanceMeasure::is(Type::Enum v) const { return v == IfcInductanceMeasure::Class(); }
Type::Enum IfcInductanceMeasure::type() const { return Type::IfcInductanceMeasure; }
Type::Enum IfcInductanceMeasure::Class() { return Type::IfcInductanceMeasure; }
IfcInductanceMeasure::IfcInductanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcInductanceMeasure::IfcInductanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcInductanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcInteger
IfcUtil::ArgumentType IfcInteger::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcInteger::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcInteger::is(Type::Enum v) const { return v == IfcInteger::Class(); }
Type::Enum IfcInteger::type() const { return Type::IfcInteger; }
Type::Enum IfcInteger::Class() { return Type::IfcInteger; }
IfcInteger::IfcInteger(IfcEntityInstanceData* e) { entity = e; }
IfcInteger::IfcInteger(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcInteger::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcIntegerCountRateMeasure
IfcUtil::ArgumentType IfcIntegerCountRateMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcIntegerCountRateMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcIntegerCountRateMeasure::is(Type::Enum v) const { return v == IfcIntegerCountRateMeasure::Class(); }
Type::Enum IfcIntegerCountRateMeasure::type() const { return Type::IfcIntegerCountRateMeasure; }
Type::Enum IfcIntegerCountRateMeasure::Class() { return Type::IfcIntegerCountRateMeasure; }
IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcIntegerCountRateMeasure::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcIonConcentrationMeasure
IfcUtil::ArgumentType IfcIonConcentrationMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcIonConcentrationMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcIonConcentrationMeasure::is(Type::Enum v) const { return v == IfcIonConcentrationMeasure::Class(); }
Type::Enum IfcIonConcentrationMeasure::type() const { return Type::IfcIonConcentrationMeasure; }
Type::Enum IfcIonConcentrationMeasure::Class() { return Type::IfcIonConcentrationMeasure; }
IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcIonConcentrationMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcIsothermalMoistureCapacityMeasure
IfcUtil::ArgumentType IfcIsothermalMoistureCapacityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcIsothermalMoistureCapacityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcIsothermalMoistureCapacityMeasure::is(Type::Enum v) const { return v == IfcIsothermalMoistureCapacityMeasure::Class(); }
Type::Enum IfcIsothermalMoistureCapacityMeasure::type() const { return Type::IfcIsothermalMoistureCapacityMeasure; }
Type::Enum IfcIsothermalMoistureCapacityMeasure::Class() { return Type::IfcIsothermalMoistureCapacityMeasure; }
IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcIsothermalMoistureCapacityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcKinematicViscosityMeasure
IfcUtil::ArgumentType IfcKinematicViscosityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcKinematicViscosityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcKinematicViscosityMeasure::is(Type::Enum v) const { return v == IfcKinematicViscosityMeasure::Class(); }
Type::Enum IfcKinematicViscosityMeasure::type() const { return Type::IfcKinematicViscosityMeasure; }
Type::Enum IfcKinematicViscosityMeasure::Class() { return Type::IfcKinematicViscosityMeasure; }
IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcKinematicViscosityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLabel
IfcUtil::ArgumentType IfcLabel::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLabel::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLabel::is(Type::Enum v) const { return v == IfcLabel::Class(); }
Type::Enum IfcLabel::type() const { return Type::IfcLabel; }
Type::Enum IfcLabel::Class() { return Type::IfcLabel; }
IfcLabel::IfcLabel(IfcEntityInstanceData* e) { entity = e; }
IfcLabel::IfcLabel(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLabel::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcLengthMeasure
IfcUtil::ArgumentType IfcLengthMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLengthMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLengthMeasure::is(Type::Enum v) const { return v == IfcLengthMeasure::Class(); }
Type::Enum IfcLengthMeasure::type() const { return Type::IfcLengthMeasure; }
Type::Enum IfcLengthMeasure::Class() { return Type::IfcLengthMeasure; }
IfcLengthMeasure::IfcLengthMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLengthMeasure::IfcLengthMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLengthMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLinearForceMeasure
IfcUtil::ArgumentType IfcLinearForceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLinearForceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLinearForceMeasure::is(Type::Enum v) const { return v == IfcLinearForceMeasure::Class(); }
Type::Enum IfcLinearForceMeasure::type() const { return Type::IfcLinearForceMeasure; }
Type::Enum IfcLinearForceMeasure::Class() { return Type::IfcLinearForceMeasure; }
IfcLinearForceMeasure::IfcLinearForceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLinearForceMeasure::IfcLinearForceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLinearForceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLinearMomentMeasure
IfcUtil::ArgumentType IfcLinearMomentMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLinearMomentMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLinearMomentMeasure::is(Type::Enum v) const { return v == IfcLinearMomentMeasure::Class(); }
Type::Enum IfcLinearMomentMeasure::type() const { return Type::IfcLinearMomentMeasure; }
Type::Enum IfcLinearMomentMeasure::Class() { return Type::IfcLinearMomentMeasure; }
IfcLinearMomentMeasure::IfcLinearMomentMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLinearMomentMeasure::IfcLinearMomentMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLinearMomentMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLinearStiffnessMeasure
IfcUtil::ArgumentType IfcLinearStiffnessMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLinearStiffnessMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLinearStiffnessMeasure::is(Type::Enum v) const { return v == IfcLinearStiffnessMeasure::Class(); }
Type::Enum IfcLinearStiffnessMeasure::type() const { return Type::IfcLinearStiffnessMeasure; }
Type::Enum IfcLinearStiffnessMeasure::Class() { return Type::IfcLinearStiffnessMeasure; }
IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLinearStiffnessMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLinearVelocityMeasure
IfcUtil::ArgumentType IfcLinearVelocityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLinearVelocityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLinearVelocityMeasure::is(Type::Enum v) const { return v == IfcLinearVelocityMeasure::Class(); }
Type::Enum IfcLinearVelocityMeasure::type() const { return Type::IfcLinearVelocityMeasure; }
Type::Enum IfcLinearVelocityMeasure::Class() { return Type::IfcLinearVelocityMeasure; }
IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLinearVelocityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLogical
IfcUtil::ArgumentType IfcLogical::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_BOOL; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLogical::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLogical::is(Type::Enum v) const { return v == IfcLogical::Class(); }
Type::Enum IfcLogical::type() const { return Type::IfcLogical; }
Type::Enum IfcLogical::Class() { return Type::IfcLogical; }
IfcLogical::IfcLogical(IfcEntityInstanceData* e) { entity = e; }
IfcLogical::IfcLogical(bool v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLogical::operator bool() const { return *entity->getArgument(0); }

// Function implementations for IfcLuminousFluxMeasure
IfcUtil::ArgumentType IfcLuminousFluxMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLuminousFluxMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLuminousFluxMeasure::is(Type::Enum v) const { return v == IfcLuminousFluxMeasure::Class(); }
Type::Enum IfcLuminousFluxMeasure::type() const { return Type::IfcLuminousFluxMeasure; }
Type::Enum IfcLuminousFluxMeasure::Class() { return Type::IfcLuminousFluxMeasure; }
IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLuminousFluxMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLuminousIntensityDistributionMeasure
IfcUtil::ArgumentType IfcLuminousIntensityDistributionMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLuminousIntensityDistributionMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLuminousIntensityDistributionMeasure::is(Type::Enum v) const { return v == IfcLuminousIntensityDistributionMeasure::Class(); }
Type::Enum IfcLuminousIntensityDistributionMeasure::type() const { return Type::IfcLuminousIntensityDistributionMeasure; }
Type::Enum IfcLuminousIntensityDistributionMeasure::Class() { return Type::IfcLuminousIntensityDistributionMeasure; }
IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLuminousIntensityDistributionMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcLuminousIntensityMeasure
IfcUtil::ArgumentType IfcLuminousIntensityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcLuminousIntensityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcLuminousIntensityMeasure::is(Type::Enum v) const { return v == IfcLuminousIntensityMeasure::Class(); }
Type::Enum IfcLuminousIntensityMeasure::type() const { return Type::IfcLuminousIntensityMeasure; }
Type::Enum IfcLuminousIntensityMeasure::Class() { return Type::IfcLuminousIntensityMeasure; }
IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcLuminousIntensityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMagneticFluxDensityMeasure
IfcUtil::ArgumentType IfcMagneticFluxDensityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMagneticFluxDensityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMagneticFluxDensityMeasure::is(Type::Enum v) const { return v == IfcMagneticFluxDensityMeasure::Class(); }
Type::Enum IfcMagneticFluxDensityMeasure::type() const { return Type::IfcMagneticFluxDensityMeasure; }
Type::Enum IfcMagneticFluxDensityMeasure::Class() { return Type::IfcMagneticFluxDensityMeasure; }
IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMagneticFluxDensityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMagneticFluxMeasure
IfcUtil::ArgumentType IfcMagneticFluxMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMagneticFluxMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMagneticFluxMeasure::is(Type::Enum v) const { return v == IfcMagneticFluxMeasure::Class(); }
Type::Enum IfcMagneticFluxMeasure::type() const { return Type::IfcMagneticFluxMeasure; }
Type::Enum IfcMagneticFluxMeasure::Class() { return Type::IfcMagneticFluxMeasure; }
IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMagneticFluxMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMassDensityMeasure
IfcUtil::ArgumentType IfcMassDensityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMassDensityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMassDensityMeasure::is(Type::Enum v) const { return v == IfcMassDensityMeasure::Class(); }
Type::Enum IfcMassDensityMeasure::type() const { return Type::IfcMassDensityMeasure; }
Type::Enum IfcMassDensityMeasure::Class() { return Type::IfcMassDensityMeasure; }
IfcMassDensityMeasure::IfcMassDensityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMassDensityMeasure::IfcMassDensityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMassDensityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMassFlowRateMeasure
IfcUtil::ArgumentType IfcMassFlowRateMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMassFlowRateMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMassFlowRateMeasure::is(Type::Enum v) const { return v == IfcMassFlowRateMeasure::Class(); }
Type::Enum IfcMassFlowRateMeasure::type() const { return Type::IfcMassFlowRateMeasure; }
Type::Enum IfcMassFlowRateMeasure::Class() { return Type::IfcMassFlowRateMeasure; }
IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMassFlowRateMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMassMeasure
IfcUtil::ArgumentType IfcMassMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMassMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMassMeasure::is(Type::Enum v) const { return v == IfcMassMeasure::Class(); }
Type::Enum IfcMassMeasure::type() const { return Type::IfcMassMeasure; }
Type::Enum IfcMassMeasure::Class() { return Type::IfcMassMeasure; }
IfcMassMeasure::IfcMassMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMassMeasure::IfcMassMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMassMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMassPerLengthMeasure
IfcUtil::ArgumentType IfcMassPerLengthMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMassPerLengthMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMassPerLengthMeasure::is(Type::Enum v) const { return v == IfcMassPerLengthMeasure::Class(); }
Type::Enum IfcMassPerLengthMeasure::type() const { return Type::IfcMassPerLengthMeasure; }
Type::Enum IfcMassPerLengthMeasure::Class() { return Type::IfcMassPerLengthMeasure; }
IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMassPerLengthMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMinuteInHour
IfcUtil::ArgumentType IfcMinuteInHour::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMinuteInHour::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMinuteInHour::is(Type::Enum v) const { return v == IfcMinuteInHour::Class(); }
Type::Enum IfcMinuteInHour::type() const { return Type::IfcMinuteInHour; }
Type::Enum IfcMinuteInHour::Class() { return Type::IfcMinuteInHour; }
IfcMinuteInHour::IfcMinuteInHour(IfcEntityInstanceData* e) { entity = e; }
IfcMinuteInHour::IfcMinuteInHour(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMinuteInHour::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcModulusOfElasticityMeasure
IfcUtil::ArgumentType IfcModulusOfElasticityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcModulusOfElasticityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcModulusOfElasticityMeasure::is(Type::Enum v) const { return v == IfcModulusOfElasticityMeasure::Class(); }
Type::Enum IfcModulusOfElasticityMeasure::type() const { return Type::IfcModulusOfElasticityMeasure; }
Type::Enum IfcModulusOfElasticityMeasure::Class() { return Type::IfcModulusOfElasticityMeasure; }
IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcModulusOfElasticityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcModulusOfLinearSubgradeReactionMeasure
IfcUtil::ArgumentType IfcModulusOfLinearSubgradeReactionMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcModulusOfLinearSubgradeReactionMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcModulusOfLinearSubgradeReactionMeasure::is(Type::Enum v) const { return v == IfcModulusOfLinearSubgradeReactionMeasure::Class(); }
Type::Enum IfcModulusOfLinearSubgradeReactionMeasure::type() const { return Type::IfcModulusOfLinearSubgradeReactionMeasure; }
Type::Enum IfcModulusOfLinearSubgradeReactionMeasure::Class() { return Type::IfcModulusOfLinearSubgradeReactionMeasure; }
IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcModulusOfLinearSubgradeReactionMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcModulusOfRotationalSubgradeReactionMeasure
IfcUtil::ArgumentType IfcModulusOfRotationalSubgradeReactionMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcModulusOfRotationalSubgradeReactionMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcModulusOfRotationalSubgradeReactionMeasure::is(Type::Enum v) const { return v == IfcModulusOfRotationalSubgradeReactionMeasure::Class(); }
Type::Enum IfcModulusOfRotationalSubgradeReactionMeasure::type() const { return Type::IfcModulusOfRotationalSubgradeReactionMeasure; }
Type::Enum IfcModulusOfRotationalSubgradeReactionMeasure::Class() { return Type::IfcModulusOfRotationalSubgradeReactionMeasure; }
IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcModulusOfRotationalSubgradeReactionMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcModulusOfSubgradeReactionMeasure
IfcUtil::ArgumentType IfcModulusOfSubgradeReactionMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcModulusOfSubgradeReactionMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcModulusOfSubgradeReactionMeasure::is(Type::Enum v) const { return v == IfcModulusOfSubgradeReactionMeasure::Class(); }
Type::Enum IfcModulusOfSubgradeReactionMeasure::type() const { return Type::IfcModulusOfSubgradeReactionMeasure; }
Type::Enum IfcModulusOfSubgradeReactionMeasure::Class() { return Type::IfcModulusOfSubgradeReactionMeasure; }
IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcModulusOfSubgradeReactionMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMoistureDiffusivityMeasure
IfcUtil::ArgumentType IfcMoistureDiffusivityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMoistureDiffusivityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMoistureDiffusivityMeasure::is(Type::Enum v) const { return v == IfcMoistureDiffusivityMeasure::Class(); }
Type::Enum IfcMoistureDiffusivityMeasure::type() const { return Type::IfcMoistureDiffusivityMeasure; }
Type::Enum IfcMoistureDiffusivityMeasure::Class() { return Type::IfcMoistureDiffusivityMeasure; }
IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMoistureDiffusivityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMolecularWeightMeasure
IfcUtil::ArgumentType IfcMolecularWeightMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMolecularWeightMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMolecularWeightMeasure::is(Type::Enum v) const { return v == IfcMolecularWeightMeasure::Class(); }
Type::Enum IfcMolecularWeightMeasure::type() const { return Type::IfcMolecularWeightMeasure; }
Type::Enum IfcMolecularWeightMeasure::Class() { return Type::IfcMolecularWeightMeasure; }
IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMolecularWeightMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMomentOfInertiaMeasure
IfcUtil::ArgumentType IfcMomentOfInertiaMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMomentOfInertiaMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMomentOfInertiaMeasure::is(Type::Enum v) const { return v == IfcMomentOfInertiaMeasure::Class(); }
Type::Enum IfcMomentOfInertiaMeasure::type() const { return Type::IfcMomentOfInertiaMeasure; }
Type::Enum IfcMomentOfInertiaMeasure::Class() { return Type::IfcMomentOfInertiaMeasure; }
IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMomentOfInertiaMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMonetaryMeasure
IfcUtil::ArgumentType IfcMonetaryMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMonetaryMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMonetaryMeasure::is(Type::Enum v) const { return v == IfcMonetaryMeasure::Class(); }
Type::Enum IfcMonetaryMeasure::type() const { return Type::IfcMonetaryMeasure; }
Type::Enum IfcMonetaryMeasure::Class() { return Type::IfcMonetaryMeasure; }
IfcMonetaryMeasure::IfcMonetaryMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcMonetaryMeasure::IfcMonetaryMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMonetaryMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcMonthInYearNumber
IfcUtil::ArgumentType IfcMonthInYearNumber::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcMonthInYearNumber::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcMonthInYearNumber::is(Type::Enum v) const { return v == IfcMonthInYearNumber::Class(); }
Type::Enum IfcMonthInYearNumber::type() const { return Type::IfcMonthInYearNumber; }
Type::Enum IfcMonthInYearNumber::Class() { return Type::IfcMonthInYearNumber; }
IfcMonthInYearNumber::IfcMonthInYearNumber(IfcEntityInstanceData* e) { entity = e; }
IfcMonthInYearNumber::IfcMonthInYearNumber(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcMonthInYearNumber::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcNormalisedRatioMeasure
IfcUtil::ArgumentType IfcNormalisedRatioMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcNormalisedRatioMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcNormalisedRatioMeasure::is(Type::Enum v) const { return v == Type::IfcNormalisedRatioMeasure || IfcRatioMeasure::is(v); }
Type::Enum IfcNormalisedRatioMeasure::type() const { return Type::IfcNormalisedRatioMeasure; }
Type::Enum IfcNormalisedRatioMeasure::Class() { return Type::IfcNormalisedRatioMeasure; }
IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { entity = e; }
IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcNormalisedRatioMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcNumericMeasure
IfcUtil::ArgumentType IfcNumericMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcNumericMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcNumericMeasure::is(Type::Enum v) const { return v == IfcNumericMeasure::Class(); }
Type::Enum IfcNumericMeasure::type() const { return Type::IfcNumericMeasure; }
Type::Enum IfcNumericMeasure::Class() { return Type::IfcNumericMeasure; }
IfcNumericMeasure::IfcNumericMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcNumericMeasure::IfcNumericMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcNumericMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPHMeasure
IfcUtil::ArgumentType IfcPHMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPHMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPHMeasure::is(Type::Enum v) const { return v == IfcPHMeasure::Class(); }
Type::Enum IfcPHMeasure::type() const { return Type::IfcPHMeasure; }
Type::Enum IfcPHMeasure::Class() { return Type::IfcPHMeasure; }
IfcPHMeasure::IfcPHMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcPHMeasure::IfcPHMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPHMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcParameterValue
IfcUtil::ArgumentType IfcParameterValue::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcParameterValue::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcParameterValue::is(Type::Enum v) const { return v == IfcParameterValue::Class(); }
Type::Enum IfcParameterValue::type() const { return Type::IfcParameterValue; }
Type::Enum IfcParameterValue::Class() { return Type::IfcParameterValue; }
IfcParameterValue::IfcParameterValue(IfcEntityInstanceData* e) { entity = e; }
IfcParameterValue::IfcParameterValue(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcParameterValue::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPlanarForceMeasure
IfcUtil::ArgumentType IfcPlanarForceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPlanarForceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPlanarForceMeasure::is(Type::Enum v) const { return v == IfcPlanarForceMeasure::Class(); }
Type::Enum IfcPlanarForceMeasure::type() const { return Type::IfcPlanarForceMeasure; }
Type::Enum IfcPlanarForceMeasure::Class() { return Type::IfcPlanarForceMeasure; }
IfcPlanarForceMeasure::IfcPlanarForceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcPlanarForceMeasure::IfcPlanarForceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPlanarForceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPlaneAngleMeasure
IfcUtil::ArgumentType IfcPlaneAngleMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPlaneAngleMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPlaneAngleMeasure::is(Type::Enum v) const { return v == IfcPlaneAngleMeasure::Class(); }
Type::Enum IfcPlaneAngleMeasure::type() const { return Type::IfcPlaneAngleMeasure; }
Type::Enum IfcPlaneAngleMeasure::Class() { return Type::IfcPlaneAngleMeasure; }
IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPlaneAngleMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPositiveLengthMeasure
IfcUtil::ArgumentType IfcPositiveLengthMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPositiveLengthMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPositiveLengthMeasure::is(Type::Enum v) const { return v == Type::IfcPositiveLengthMeasure || IfcLengthMeasure::is(v); }
Type::Enum IfcPositiveLengthMeasure::type() const { return Type::IfcPositiveLengthMeasure; }
Type::Enum IfcPositiveLengthMeasure::Class() { return Type::IfcPositiveLengthMeasure; }
IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(IfcEntityInstanceData* e) : IfcLengthMeasure((IfcEntityInstanceData*)0) { entity = e; }
IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(double v) : IfcLengthMeasure((IfcEntityInstanceData*)0) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPositiveLengthMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPositivePlaneAngleMeasure
IfcUtil::ArgumentType IfcPositivePlaneAngleMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPositivePlaneAngleMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPositivePlaneAngleMeasure::is(Type::Enum v) const { return v == Type::IfcPositivePlaneAngleMeasure || IfcPlaneAngleMeasure::is(v); }
Type::Enum IfcPositivePlaneAngleMeasure::type() const { return Type::IfcPositivePlaneAngleMeasure; }
Type::Enum IfcPositivePlaneAngleMeasure::Class() { return Type::IfcPositivePlaneAngleMeasure; }
IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(IfcEntityInstanceData* e) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { entity = e; }
IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(double v) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPositivePlaneAngleMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPositiveRatioMeasure
IfcUtil::ArgumentType IfcPositiveRatioMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPositiveRatioMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPositiveRatioMeasure::is(Type::Enum v) const { return v == Type::IfcPositiveRatioMeasure || IfcRatioMeasure::is(v); }
Type::Enum IfcPositiveRatioMeasure::type() const { return Type::IfcPositiveRatioMeasure; }
Type::Enum IfcPositiveRatioMeasure::Class() { return Type::IfcPositiveRatioMeasure; }
IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { entity = e; }
IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPositiveRatioMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPowerMeasure
IfcUtil::ArgumentType IfcPowerMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPowerMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPowerMeasure::is(Type::Enum v) const { return v == IfcPowerMeasure::Class(); }
Type::Enum IfcPowerMeasure::type() const { return Type::IfcPowerMeasure; }
Type::Enum IfcPowerMeasure::Class() { return Type::IfcPowerMeasure; }
IfcPowerMeasure::IfcPowerMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcPowerMeasure::IfcPowerMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPowerMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcPresentableText
IfcUtil::ArgumentType IfcPresentableText::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPresentableText::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPresentableText::is(Type::Enum v) const { return v == IfcPresentableText::Class(); }
Type::Enum IfcPresentableText::type() const { return Type::IfcPresentableText; }
Type::Enum IfcPresentableText::Class() { return Type::IfcPresentableText; }
IfcPresentableText::IfcPresentableText(IfcEntityInstanceData* e) { entity = e; }
IfcPresentableText::IfcPresentableText(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPresentableText::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcPressureMeasure
IfcUtil::ArgumentType IfcPressureMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcPressureMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcPressureMeasure::is(Type::Enum v) const { return v == IfcPressureMeasure::Class(); }
Type::Enum IfcPressureMeasure::type() const { return Type::IfcPressureMeasure; }
Type::Enum IfcPressureMeasure::Class() { return Type::IfcPressureMeasure; }
IfcPressureMeasure::IfcPressureMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcPressureMeasure::IfcPressureMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcPressureMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcRadioActivityMeasure
IfcUtil::ArgumentType IfcRadioActivityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcRadioActivityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcRadioActivityMeasure::is(Type::Enum v) const { return v == IfcRadioActivityMeasure::Class(); }
Type::Enum IfcRadioActivityMeasure::type() const { return Type::IfcRadioActivityMeasure; }
Type::Enum IfcRadioActivityMeasure::Class() { return Type::IfcRadioActivityMeasure; }
IfcRadioActivityMeasure::IfcRadioActivityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcRadioActivityMeasure::IfcRadioActivityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcRadioActivityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcRatioMeasure
IfcUtil::ArgumentType IfcRatioMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcRatioMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcRatioMeasure::is(Type::Enum v) const { return v == IfcRatioMeasure::Class(); }
Type::Enum IfcRatioMeasure::type() const { return Type::IfcRatioMeasure; }
Type::Enum IfcRatioMeasure::Class() { return Type::IfcRatioMeasure; }
IfcRatioMeasure::IfcRatioMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcRatioMeasure::IfcRatioMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcRatioMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcReal
IfcUtil::ArgumentType IfcReal::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcReal::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcReal::is(Type::Enum v) const { return v == IfcReal::Class(); }
Type::Enum IfcReal::type() const { return Type::IfcReal; }
Type::Enum IfcReal::Class() { return Type::IfcReal; }
IfcReal::IfcReal(IfcEntityInstanceData* e) { entity = e; }
IfcReal::IfcReal(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcReal::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcRotationalFrequencyMeasure
IfcUtil::ArgumentType IfcRotationalFrequencyMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcRotationalFrequencyMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcRotationalFrequencyMeasure::is(Type::Enum v) const { return v == IfcRotationalFrequencyMeasure::Class(); }
Type::Enum IfcRotationalFrequencyMeasure::type() const { return Type::IfcRotationalFrequencyMeasure; }
Type::Enum IfcRotationalFrequencyMeasure::Class() { return Type::IfcRotationalFrequencyMeasure; }
IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcRotationalFrequencyMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcRotationalMassMeasure
IfcUtil::ArgumentType IfcRotationalMassMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcRotationalMassMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcRotationalMassMeasure::is(Type::Enum v) const { return v == IfcRotationalMassMeasure::Class(); }
Type::Enum IfcRotationalMassMeasure::type() const { return Type::IfcRotationalMassMeasure; }
Type::Enum IfcRotationalMassMeasure::Class() { return Type::IfcRotationalMassMeasure; }
IfcRotationalMassMeasure::IfcRotationalMassMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcRotationalMassMeasure::IfcRotationalMassMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcRotationalMassMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcRotationalStiffnessMeasure
IfcUtil::ArgumentType IfcRotationalStiffnessMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcRotationalStiffnessMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcRotationalStiffnessMeasure::is(Type::Enum v) const { return v == IfcRotationalStiffnessMeasure::Class(); }
Type::Enum IfcRotationalStiffnessMeasure::type() const { return Type::IfcRotationalStiffnessMeasure; }
Type::Enum IfcRotationalStiffnessMeasure::Class() { return Type::IfcRotationalStiffnessMeasure; }
IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcRotationalStiffnessMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSecondInMinute
IfcUtil::ArgumentType IfcSecondInMinute::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSecondInMinute::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSecondInMinute::is(Type::Enum v) const { return v == IfcSecondInMinute::Class(); }
Type::Enum IfcSecondInMinute::type() const { return Type::IfcSecondInMinute; }
Type::Enum IfcSecondInMinute::Class() { return Type::IfcSecondInMinute; }
IfcSecondInMinute::IfcSecondInMinute(IfcEntityInstanceData* e) { entity = e; }
IfcSecondInMinute::IfcSecondInMinute(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSecondInMinute::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSectionModulusMeasure
IfcUtil::ArgumentType IfcSectionModulusMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSectionModulusMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSectionModulusMeasure::is(Type::Enum v) const { return v == IfcSectionModulusMeasure::Class(); }
Type::Enum IfcSectionModulusMeasure::type() const { return Type::IfcSectionModulusMeasure; }
Type::Enum IfcSectionModulusMeasure::Class() { return Type::IfcSectionModulusMeasure; }
IfcSectionModulusMeasure::IfcSectionModulusMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSectionModulusMeasure::IfcSectionModulusMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSectionModulusMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSectionalAreaIntegralMeasure
IfcUtil::ArgumentType IfcSectionalAreaIntegralMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSectionalAreaIntegralMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSectionalAreaIntegralMeasure::is(Type::Enum v) const { return v == IfcSectionalAreaIntegralMeasure::Class(); }
Type::Enum IfcSectionalAreaIntegralMeasure::type() const { return Type::IfcSectionalAreaIntegralMeasure; }
Type::Enum IfcSectionalAreaIntegralMeasure::Class() { return Type::IfcSectionalAreaIntegralMeasure; }
IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSectionalAreaIntegralMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcShearModulusMeasure
IfcUtil::ArgumentType IfcShearModulusMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcShearModulusMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcShearModulusMeasure::is(Type::Enum v) const { return v == IfcShearModulusMeasure::Class(); }
Type::Enum IfcShearModulusMeasure::type() const { return Type::IfcShearModulusMeasure; }
Type::Enum IfcShearModulusMeasure::Class() { return Type::IfcShearModulusMeasure; }
IfcShearModulusMeasure::IfcShearModulusMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcShearModulusMeasure::IfcShearModulusMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcShearModulusMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSolidAngleMeasure
IfcUtil::ArgumentType IfcSolidAngleMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSolidAngleMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSolidAngleMeasure::is(Type::Enum v) const { return v == IfcSolidAngleMeasure::Class(); }
Type::Enum IfcSolidAngleMeasure::type() const { return Type::IfcSolidAngleMeasure; }
Type::Enum IfcSolidAngleMeasure::Class() { return Type::IfcSolidAngleMeasure; }
IfcSolidAngleMeasure::IfcSolidAngleMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSolidAngleMeasure::IfcSolidAngleMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSolidAngleMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSoundPowerMeasure
IfcUtil::ArgumentType IfcSoundPowerMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSoundPowerMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSoundPowerMeasure::is(Type::Enum v) const { return v == IfcSoundPowerMeasure::Class(); }
Type::Enum IfcSoundPowerMeasure::type() const { return Type::IfcSoundPowerMeasure; }
Type::Enum IfcSoundPowerMeasure::Class() { return Type::IfcSoundPowerMeasure; }
IfcSoundPowerMeasure::IfcSoundPowerMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSoundPowerMeasure::IfcSoundPowerMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSoundPowerMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSoundPressureMeasure
IfcUtil::ArgumentType IfcSoundPressureMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSoundPressureMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSoundPressureMeasure::is(Type::Enum v) const { return v == IfcSoundPressureMeasure::Class(); }
Type::Enum IfcSoundPressureMeasure::type() const { return Type::IfcSoundPressureMeasure; }
Type::Enum IfcSoundPressureMeasure::Class() { return Type::IfcSoundPressureMeasure; }
IfcSoundPressureMeasure::IfcSoundPressureMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSoundPressureMeasure::IfcSoundPressureMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSoundPressureMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSpecificHeatCapacityMeasure
IfcUtil::ArgumentType IfcSpecificHeatCapacityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSpecificHeatCapacityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSpecificHeatCapacityMeasure::is(Type::Enum v) const { return v == IfcSpecificHeatCapacityMeasure::Class(); }
Type::Enum IfcSpecificHeatCapacityMeasure::type() const { return Type::IfcSpecificHeatCapacityMeasure; }
Type::Enum IfcSpecificHeatCapacityMeasure::Class() { return Type::IfcSpecificHeatCapacityMeasure; }
IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSpecificHeatCapacityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSpecularExponent
IfcUtil::ArgumentType IfcSpecularExponent::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSpecularExponent::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSpecularExponent::is(Type::Enum v) const { return v == IfcSpecularExponent::Class(); }
Type::Enum IfcSpecularExponent::type() const { return Type::IfcSpecularExponent; }
Type::Enum IfcSpecularExponent::Class() { return Type::IfcSpecularExponent; }
IfcSpecularExponent::IfcSpecularExponent(IfcEntityInstanceData* e) { entity = e; }
IfcSpecularExponent::IfcSpecularExponent(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSpecularExponent::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcSpecularRoughness
IfcUtil::ArgumentType IfcSpecularRoughness::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcSpecularRoughness::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcSpecularRoughness::is(Type::Enum v) const { return v == IfcSpecularRoughness::Class(); }
Type::Enum IfcSpecularRoughness::type() const { return Type::IfcSpecularRoughness; }
Type::Enum IfcSpecularRoughness::Class() { return Type::IfcSpecularRoughness; }
IfcSpecularRoughness::IfcSpecularRoughness(IfcEntityInstanceData* e) { entity = e; }
IfcSpecularRoughness::IfcSpecularRoughness(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcSpecularRoughness::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcTemperatureGradientMeasure
IfcUtil::ArgumentType IfcTemperatureGradientMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTemperatureGradientMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTemperatureGradientMeasure::is(Type::Enum v) const { return v == IfcTemperatureGradientMeasure::Class(); }
Type::Enum IfcTemperatureGradientMeasure::type() const { return Type::IfcTemperatureGradientMeasure; }
Type::Enum IfcTemperatureGradientMeasure::Class() { return Type::IfcTemperatureGradientMeasure; }
IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTemperatureGradientMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcText
IfcUtil::ArgumentType IfcText::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcText::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcText::is(Type::Enum v) const { return v == IfcText::Class(); }
Type::Enum IfcText::type() const { return Type::IfcText; }
Type::Enum IfcText::Class() { return Type::IfcText; }
IfcText::IfcText(IfcEntityInstanceData* e) { entity = e; }
IfcText::IfcText(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcText::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcTextAlignment
IfcUtil::ArgumentType IfcTextAlignment::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTextAlignment::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTextAlignment::is(Type::Enum v) const { return v == IfcTextAlignment::Class(); }
Type::Enum IfcTextAlignment::type() const { return Type::IfcTextAlignment; }
Type::Enum IfcTextAlignment::Class() { return Type::IfcTextAlignment; }
IfcTextAlignment::IfcTextAlignment(IfcEntityInstanceData* e) { entity = e; }
IfcTextAlignment::IfcTextAlignment(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTextAlignment::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcTextDecoration
IfcUtil::ArgumentType IfcTextDecoration::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTextDecoration::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTextDecoration::is(Type::Enum v) const { return v == IfcTextDecoration::Class(); }
Type::Enum IfcTextDecoration::type() const { return Type::IfcTextDecoration; }
Type::Enum IfcTextDecoration::Class() { return Type::IfcTextDecoration; }
IfcTextDecoration::IfcTextDecoration(IfcEntityInstanceData* e) { entity = e; }
IfcTextDecoration::IfcTextDecoration(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTextDecoration::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcTextFontName
IfcUtil::ArgumentType IfcTextFontName::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTextFontName::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTextFontName::is(Type::Enum v) const { return v == IfcTextFontName::Class(); }
Type::Enum IfcTextFontName::type() const { return Type::IfcTextFontName; }
Type::Enum IfcTextFontName::Class() { return Type::IfcTextFontName; }
IfcTextFontName::IfcTextFontName(IfcEntityInstanceData* e) { entity = e; }
IfcTextFontName::IfcTextFontName(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTextFontName::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcTextTransformation
IfcUtil::ArgumentType IfcTextTransformation::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_STRING; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTextTransformation::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTextTransformation::is(Type::Enum v) const { return v == IfcTextTransformation::Class(); }
Type::Enum IfcTextTransformation::type() const { return Type::IfcTextTransformation; }
Type::Enum IfcTextTransformation::Class() { return Type::IfcTextTransformation; }
IfcTextTransformation::IfcTextTransformation(IfcEntityInstanceData* e) { entity = e; }
IfcTextTransformation::IfcTextTransformation(std::string v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTextTransformation::operator std::string() const { return *entity->getArgument(0); }

// Function implementations for IfcThermalAdmittanceMeasure
IfcUtil::ArgumentType IfcThermalAdmittanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermalAdmittanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermalAdmittanceMeasure::is(Type::Enum v) const { return v == IfcThermalAdmittanceMeasure::Class(); }
Type::Enum IfcThermalAdmittanceMeasure::type() const { return Type::IfcThermalAdmittanceMeasure; }
Type::Enum IfcThermalAdmittanceMeasure::Class() { return Type::IfcThermalAdmittanceMeasure; }
IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermalAdmittanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcThermalConductivityMeasure
IfcUtil::ArgumentType IfcThermalConductivityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermalConductivityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermalConductivityMeasure::is(Type::Enum v) const { return v == IfcThermalConductivityMeasure::Class(); }
Type::Enum IfcThermalConductivityMeasure::type() const { return Type::IfcThermalConductivityMeasure; }
Type::Enum IfcThermalConductivityMeasure::Class() { return Type::IfcThermalConductivityMeasure; }
IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermalConductivityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcThermalExpansionCoefficientMeasure
IfcUtil::ArgumentType IfcThermalExpansionCoefficientMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermalExpansionCoefficientMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermalExpansionCoefficientMeasure::is(Type::Enum v) const { return v == IfcThermalExpansionCoefficientMeasure::Class(); }
Type::Enum IfcThermalExpansionCoefficientMeasure::type() const { return Type::IfcThermalExpansionCoefficientMeasure; }
Type::Enum IfcThermalExpansionCoefficientMeasure::Class() { return Type::IfcThermalExpansionCoefficientMeasure; }
IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermalExpansionCoefficientMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcThermalResistanceMeasure
IfcUtil::ArgumentType IfcThermalResistanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermalResistanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermalResistanceMeasure::is(Type::Enum v) const { return v == IfcThermalResistanceMeasure::Class(); }
Type::Enum IfcThermalResistanceMeasure::type() const { return Type::IfcThermalResistanceMeasure; }
Type::Enum IfcThermalResistanceMeasure::Class() { return Type::IfcThermalResistanceMeasure; }
IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermalResistanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcThermalTransmittanceMeasure
IfcUtil::ArgumentType IfcThermalTransmittanceMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermalTransmittanceMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermalTransmittanceMeasure::is(Type::Enum v) const { return v == IfcThermalTransmittanceMeasure::Class(); }
Type::Enum IfcThermalTransmittanceMeasure::type() const { return Type::IfcThermalTransmittanceMeasure; }
Type::Enum IfcThermalTransmittanceMeasure::Class() { return Type::IfcThermalTransmittanceMeasure; }
IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermalTransmittanceMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcThermodynamicTemperatureMeasure
IfcUtil::ArgumentType IfcThermodynamicTemperatureMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcThermodynamicTemperatureMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcThermodynamicTemperatureMeasure::is(Type::Enum v) const { return v == IfcThermodynamicTemperatureMeasure::Class(); }
Type::Enum IfcThermodynamicTemperatureMeasure::type() const { return Type::IfcThermodynamicTemperatureMeasure; }
Type::Enum IfcThermodynamicTemperatureMeasure::Class() { return Type::IfcThermodynamicTemperatureMeasure; }
IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcThermodynamicTemperatureMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcTimeMeasure
IfcUtil::ArgumentType IfcTimeMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTimeMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTimeMeasure::is(Type::Enum v) const { return v == IfcTimeMeasure::Class(); }
Type::Enum IfcTimeMeasure::type() const { return Type::IfcTimeMeasure; }
Type::Enum IfcTimeMeasure::Class() { return Type::IfcTimeMeasure; }
IfcTimeMeasure::IfcTimeMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcTimeMeasure::IfcTimeMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTimeMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcTimeStamp
IfcUtil::ArgumentType IfcTimeStamp::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTimeStamp::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTimeStamp::is(Type::Enum v) const { return v == IfcTimeStamp::Class(); }
Type::Enum IfcTimeStamp::type() const { return Type::IfcTimeStamp; }
Type::Enum IfcTimeStamp::Class() { return Type::IfcTimeStamp; }
IfcTimeStamp::IfcTimeStamp(IfcEntityInstanceData* e) { entity = e; }
IfcTimeStamp::IfcTimeStamp(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTimeStamp::operator int() const { return *entity->getArgument(0); }

// Function implementations for IfcTorqueMeasure
IfcUtil::ArgumentType IfcTorqueMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcTorqueMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcTorqueMeasure::is(Type::Enum v) const { return v == IfcTorqueMeasure::Class(); }
Type::Enum IfcTorqueMeasure::type() const { return Type::IfcTorqueMeasure; }
Type::Enum IfcTorqueMeasure::Class() { return Type::IfcTorqueMeasure; }
IfcTorqueMeasure::IfcTorqueMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcTorqueMeasure::IfcTorqueMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcTorqueMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcVaporPermeabilityMeasure
IfcUtil::ArgumentType IfcVaporPermeabilityMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcVaporPermeabilityMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcVaporPermeabilityMeasure::is(Type::Enum v) const { return v == IfcVaporPermeabilityMeasure::Class(); }
Type::Enum IfcVaporPermeabilityMeasure::type() const { return Type::IfcVaporPermeabilityMeasure; }
Type::Enum IfcVaporPermeabilityMeasure::Class() { return Type::IfcVaporPermeabilityMeasure; }
IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcVaporPermeabilityMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcVolumeMeasure
IfcUtil::ArgumentType IfcVolumeMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcVolumeMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcVolumeMeasure::is(Type::Enum v) const { return v == IfcVolumeMeasure::Class(); }
Type::Enum IfcVolumeMeasure::type() const { return Type::IfcVolumeMeasure; }
Type::Enum IfcVolumeMeasure::Class() { return Type::IfcVolumeMeasure; }
IfcVolumeMeasure::IfcVolumeMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcVolumeMeasure::IfcVolumeMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcVolumeMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcVolumetricFlowRateMeasure
IfcUtil::ArgumentType IfcVolumetricFlowRateMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcVolumetricFlowRateMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcVolumetricFlowRateMeasure::is(Type::Enum v) const { return v == IfcVolumetricFlowRateMeasure::Class(); }
Type::Enum IfcVolumetricFlowRateMeasure::type() const { return Type::IfcVolumetricFlowRateMeasure; }
Type::Enum IfcVolumetricFlowRateMeasure::Class() { return Type::IfcVolumetricFlowRateMeasure; }
IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcVolumetricFlowRateMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcWarpingConstantMeasure
IfcUtil::ArgumentType IfcWarpingConstantMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcWarpingConstantMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcWarpingConstantMeasure::is(Type::Enum v) const { return v == IfcWarpingConstantMeasure::Class(); }
Type::Enum IfcWarpingConstantMeasure::type() const { return Type::IfcWarpingConstantMeasure; }
Type::Enum IfcWarpingConstantMeasure::Class() { return Type::IfcWarpingConstantMeasure; }
IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcWarpingConstantMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcWarpingMomentMeasure
IfcUtil::ArgumentType IfcWarpingMomentMeasure::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_DOUBLE; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcWarpingMomentMeasure::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcWarpingMomentMeasure::is(Type::Enum v) const { return v == IfcWarpingMomentMeasure::Class(); }
Type::Enum IfcWarpingMomentMeasure::type() const { return Type::IfcWarpingMomentMeasure; }
Type::Enum IfcWarpingMomentMeasure::Class() { return Type::IfcWarpingMomentMeasure; }
IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(IfcEntityInstanceData* e) { entity = e; }
IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(double v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcWarpingMomentMeasure::operator double() const { return *entity->getArgument(0); }

// Function implementations for IfcYearNumber
IfcUtil::ArgumentType IfcYearNumber::getArgumentType(unsigned int i) const { if (i == 0) { return IfcUtil::Argument_INT; } else { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); } }
Argument* IfcYearNumber::getArgument(unsigned int i) const { return entity->getArgument(i); }
bool IfcYearNumber::is(Type::Enum v) const { return v == IfcYearNumber::Class(); }
Type::Enum IfcYearNumber::type() const { return Type::IfcYearNumber; }
Type::Enum IfcYearNumber::Class() { return Type::IfcYearNumber; }
IfcYearNumber::IfcYearNumber(IfcEntityInstanceData* e) { entity = e; }
IfcYearNumber::IfcYearNumber(int v) { entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); entity->setArgument(0, attr);} }
IfcYearNumber::operator int() const { return *entity->getArgument(0); }


// Function implementations for Ifc2DCompositeCurve
bool Ifc2DCompositeCurve::is(Type::Enum v) const { return v == Type::Ifc2DCompositeCurve || IfcCompositeCurve::is(v); }
Type::Enum Ifc2DCompositeCurve::type() const { return Type::Ifc2DCompositeCurve; }
Type::Enum Ifc2DCompositeCurve::Class() { return Type::Ifc2DCompositeCurve; }
Ifc2DCompositeCurve::Ifc2DCompositeCurve(IfcEntityInstanceData* e) : IfcCompositeCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::Ifc2DCompositeCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
Ifc2DCompositeCurve::Ifc2DCompositeCurve(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcCompositeCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));entity->setArgument(1,attr);} }

// Function implementations for IfcActionRequest
std::string IfcActionRequest::RequestID() const { return *entity->getArgument(5); }
void IfcActionRequest::setRequestID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcActionRequest::is(Type::Enum v) const { return v == Type::IfcActionRequest || IfcControl::is(v); }
Type::Enum IfcActionRequest::type() const { return Type::IfcActionRequest; }
Type::Enum IfcActionRequest::Class() { return Type::IfcActionRequest; }
IfcActionRequest::IfcActionRequest(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcActionRequest) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActionRequest::IfcActionRequest(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_RequestID) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RequestID));entity->setArgument(5,attr);} }

// Function implementations for IfcActor
IfcActorSelect* IfcActor::TheActor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcActor::setTheActor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcRelAssignsToActor::list::ptr IfcActor::IsActingUpon() const { return entity->getInverse(Type::IfcRelAssignsToActor, 6)->as<IfcRelAssignsToActor>(); }
bool IfcActor::is(Type::Enum v) const { return v == Type::IfcActor || IfcObject::is(v); }
Type::Enum IfcActor::type() const { return Type::IfcActor; }
Type::Enum IfcActor::Class() { return Type::IfcActor; }
IfcActor::IfcActor(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcActor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActor::IfcActor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));entity->setArgument(5,attr);} }

// Function implementations for IfcActorRole
IfcRoleEnum::IfcRoleEnum IfcActorRole::Role() const { return IfcRoleEnum::FromString(*entity->getArgument(0)); }
void IfcActorRole::setRole(IfcRoleEnum::IfcRoleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRoleEnum::ToString(v)));entity->setArgument(0,attr);} }
bool IfcActorRole::hasUserDefinedRole() const { return !entity->getArgument(1)->isNull(); }
std::string IfcActorRole::UserDefinedRole() const { return *entity->getArgument(1); }
void IfcActorRole::setUserDefinedRole(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcActorRole::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcActorRole::Description() const { return *entity->getArgument(2); }
void IfcActorRole::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcActorRole::is(Type::Enum v) const { return v == Type::IfcActorRole; }
Type::Enum IfcActorRole::type() const { return Type::IfcActorRole; }
Type::Enum IfcActorRole::Class() { return Type::IfcActorRole; }
IfcActorRole::IfcActorRole(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcActorRole) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActorRole::IfcActorRole(IfcRoleEnum::IfcRoleEnum v1_Role, boost::optional< std::string > v2_UserDefinedRole, boost::optional< std::string > v3_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Role,IfcRoleEnum::ToString(v1_Role))));entity->setArgument(0,attr);} if (v2_UserDefinedRole) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_UserDefinedRole));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcActuatorType
IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorType::PredefinedType() const { return IfcActuatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcActuatorType::setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActuatorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcActuatorType::is(Type::Enum v) const { return v == Type::IfcActuatorType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcActuatorType::type() const { return Type::IfcActuatorType; }
Type::Enum IfcActuatorType::Class() { return Type::IfcActuatorType; }
IfcActuatorType::IfcActuatorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcActuatorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActuatorType::IfcActuatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcActuatorTypeEnum::IfcActuatorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcActuatorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcAddress
bool IfcAddress::hasPurpose() const { return !entity->getArgument(0)->isNull(); }
IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddress::Purpose() const { return IfcAddressTypeEnum::FromString(*entity->getArgument(0)); }
void IfcAddress::setPurpose(IfcAddressTypeEnum::IfcAddressTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAddressTypeEnum::ToString(v)));entity->setArgument(0,attr);} }
bool IfcAddress::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcAddress::Description() const { return *entity->getArgument(1); }
void IfcAddress::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAddress::hasUserDefinedPurpose() const { return !entity->getArgument(2)->isNull(); }
std::string IfcAddress::UserDefinedPurpose() const { return *entity->getArgument(2); }
void IfcAddress::setUserDefinedPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcPerson::list::ptr IfcAddress::OfPerson() const { return entity->getInverse(Type::IfcPerson, 7)->as<IfcPerson>(); }
IfcOrganization::list::ptr IfcAddress::OfOrganization() const { return entity->getInverse(Type::IfcOrganization, 4)->as<IfcOrganization>(); }
bool IfcAddress::is(Type::Enum v) const { return v == Type::IfcAddress; }
Type::Enum IfcAddress::type() const { return Type::IfcAddress; }
Type::Enum IfcAddress::Class() { return Type::IfcAddress; }
IfcAddress::IfcAddress(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcAddress) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAddress::IfcAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcAirTerminalBoxType
IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxType::PredefinedType() const { return IfcAirTerminalBoxTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirTerminalBoxType::setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalBoxTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcAirTerminalBoxType::is(Type::Enum v) const { return v == Type::IfcAirTerminalBoxType || IfcFlowControllerType::is(v); }
Type::Enum IfcAirTerminalBoxType::type() const { return Type::IfcAirTerminalBoxType; }
Type::Enum IfcAirTerminalBoxType::Class() { return Type::IfcAirTerminalBoxType; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAirTerminalBoxType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirTerminalBoxTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcAirTerminalType
IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalType::PredefinedType() const { return IfcAirTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirTerminalType::setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcAirTerminalType::is(Type::Enum v) const { return v == Type::IfcAirTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcAirTerminalType::type() const { return Type::IfcAirTerminalType; }
Type::Enum IfcAirTerminalType::Class() { return Type::IfcAirTerminalType; }
IfcAirTerminalType::IfcAirTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAirTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminalType::IfcAirTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcAirToAirHeatRecoveryType
IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryType::PredefinedType() const { return IfcAirToAirHeatRecoveryTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirToAirHeatRecoveryType::setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAirToAirHeatRecoveryTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcAirToAirHeatRecoveryType::is(Type::Enum v) const { return v == Type::IfcAirToAirHeatRecoveryType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcAirToAirHeatRecoveryType::type() const { return Type::IfcAirToAirHeatRecoveryType; }
Type::Enum IfcAirToAirHeatRecoveryType::Class() { return Type::IfcAirToAirHeatRecoveryType; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAirToAirHeatRecoveryType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAirToAirHeatRecoveryTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcAlarmType
IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmType::PredefinedType() const { return IfcAlarmTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAlarmType::setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAlarmTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcAlarmType::is(Type::Enum v) const { return v == Type::IfcAlarmType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcAlarmType::type() const { return Type::IfcAlarmType; }
Type::Enum IfcAlarmType::Class() { return Type::IfcAlarmType; }
IfcAlarmType::IfcAlarmType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAlarmType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAlarmType::IfcAlarmType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAlarmTypeEnum::IfcAlarmTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcAlarmTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcAngularDimension
bool IfcAngularDimension::is(Type::Enum v) const { return v == Type::IfcAngularDimension || IfcDimensionCurveDirectedCallout::is(v); }
Type::Enum IfcAngularDimension::type() const { return Type::IfcAngularDimension; }
Type::Enum IfcAngularDimension::Class() { return Type::IfcAngularDimension; }
IfcAngularDimension::IfcAngularDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAngularDimension) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAngularDimension::IfcAngularDimension(IfcEntityList::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcAnnotation
IfcRelContainedInSpatialStructure::list::ptr IfcAnnotation::ContainedInStructure() const { return entity->getInverse(Type::IfcRelContainedInSpatialStructure, 4)->as<IfcRelContainedInSpatialStructure>(); }
bool IfcAnnotation::is(Type::Enum v) const { return v == Type::IfcAnnotation || IfcProduct::is(v); }
Type::Enum IfcAnnotation::type() const { return Type::IfcAnnotation; }
Type::Enum IfcAnnotation::Class() { return Type::IfcAnnotation; }
IfcAnnotation::IfcAnnotation(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotation::IfcAnnotation(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} }

// Function implementations for IfcAnnotationCurveOccurrence
bool IfcAnnotationCurveOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationCurveOccurrence || IfcAnnotationOccurrence::is(v); }
Type::Enum IfcAnnotationCurveOccurrence::type() const { return Type::IfcAnnotationCurveOccurrence; }
Type::Enum IfcAnnotationCurveOccurrence::Class() { return Type::IfcAnnotationCurveOccurrence; }
IfcAnnotationCurveOccurrence::IfcAnnotationCurveOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationCurveOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationCurveOccurrence::IfcAnnotationCurveOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcAnnotationFillArea
IfcCurve* IfcAnnotationFillArea::OuterBoundary() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcAnnotationFillArea::setOuterBoundary(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcAnnotationFillArea::hasInnerBoundaries() const { return !entity->getArgument(1)->isNull(); }
IfcTemplatedEntityList< IfcCurve >::ptr IfcAnnotationFillArea::InnerBoundaries() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcCurve>(); }
void IfcAnnotationFillArea::setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcAnnotationFillArea::is(Type::Enum v) const { return v == Type::IfcAnnotationFillArea || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcAnnotationFillArea::type() const { return Type::IfcAnnotationFillArea; }
Type::Enum IfcAnnotationFillArea::Class() { return Type::IfcAnnotationFillArea; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationFillArea) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcCurve* v1_OuterBoundary, boost::optional< IfcTemplatedEntityList< IfcCurve >::ptr > v2_InnerBoundaries) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OuterBoundary));entity->setArgument(0,attr);} if (v2_InnerBoundaries) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_InnerBoundaries)->generalize());entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcAnnotationFillAreaOccurrence
bool IfcAnnotationFillAreaOccurrence::hasFillStyleTarget() const { return !entity->getArgument(3)->isNull(); }
IfcPoint* IfcAnnotationFillAreaOccurrence::FillStyleTarget() const { return (IfcPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcAnnotationFillAreaOccurrence::setFillStyleTarget(IfcPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcAnnotationFillAreaOccurrence::hasGlobalOrLocal() const { return !entity->getArgument(4)->isNull(); }
IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcAnnotationFillAreaOccurrence::GlobalOrLocal() const { return IfcGlobalOrLocalEnum::FromString(*entity->getArgument(4)); }
void IfcAnnotationFillAreaOccurrence::setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGlobalOrLocalEnum::ToString(v)));entity->setArgument(4,attr);} }
bool IfcAnnotationFillAreaOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationFillAreaOccurrence || IfcAnnotationOccurrence::is(v); }
Type::Enum IfcAnnotationFillAreaOccurrence::type() const { return Type::IfcAnnotationFillAreaOccurrence; }
Type::Enum IfcAnnotationFillAreaOccurrence::Class() { return Type::IfcAnnotationFillAreaOccurrence; }
IfcAnnotationFillAreaOccurrence::IfcAnnotationFillAreaOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationFillAreaOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationFillAreaOccurrence::IfcAnnotationFillAreaOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcPoint* v4_FillStyleTarget, boost::optional< IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum > v5_GlobalOrLocal) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_FillStyleTarget));entity->setArgument(3,attr);} if (v5_GlobalOrLocal) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(*v5_GlobalOrLocal))));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcAnnotationOccurrence
bool IfcAnnotationOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationOccurrence || IfcStyledItem::is(v); }
Type::Enum IfcAnnotationOccurrence::type() const { return Type::IfcAnnotationOccurrence; }
Type::Enum IfcAnnotationOccurrence::Class() { return Type::IfcAnnotationOccurrence; }
IfcAnnotationOccurrence::IfcAnnotationOccurrence(IfcEntityInstanceData* e) : IfcStyledItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationOccurrence::IfcAnnotationOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcStyledItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcAnnotationSurface
IfcGeometricRepresentationItem* IfcAnnotationSurface::Item() const { return (IfcGeometricRepresentationItem*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcAnnotationSurface::setItem(IfcGeometricRepresentationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcAnnotationSurface::hasTextureCoordinates() const { return !entity->getArgument(1)->isNull(); }
IfcTextureCoordinate* IfcAnnotationSurface::TextureCoordinates() const { return (IfcTextureCoordinate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcAnnotationSurface::setTextureCoordinates(IfcTextureCoordinate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAnnotationSurface::is(Type::Enum v) const { return v == Type::IfcAnnotationSurface || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcAnnotationSurface::type() const { return Type::IfcAnnotationSurface; }
Type::Enum IfcAnnotationSurface::Class() { return Type::IfcAnnotationSurface; }
IfcAnnotationSurface::IfcAnnotationSurface(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationSurface::IfcAnnotationSurface(IfcGeometricRepresentationItem* v1_Item, IfcTextureCoordinate* v2_TextureCoordinates) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TextureCoordinates));entity->setArgument(1,attr);} }

// Function implementations for IfcAnnotationSurfaceOccurrence
bool IfcAnnotationSurfaceOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationSurfaceOccurrence || IfcAnnotationOccurrence::is(v); }
Type::Enum IfcAnnotationSurfaceOccurrence::type() const { return Type::IfcAnnotationSurfaceOccurrence; }
Type::Enum IfcAnnotationSurfaceOccurrence::Class() { return Type::IfcAnnotationSurfaceOccurrence; }
IfcAnnotationSurfaceOccurrence::IfcAnnotationSurfaceOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationSurfaceOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationSurfaceOccurrence::IfcAnnotationSurfaceOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcAnnotationSymbolOccurrence
bool IfcAnnotationSymbolOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationSymbolOccurrence || IfcAnnotationOccurrence::is(v); }
Type::Enum IfcAnnotationSymbolOccurrence::type() const { return Type::IfcAnnotationSymbolOccurrence; }
Type::Enum IfcAnnotationSymbolOccurrence::Class() { return Type::IfcAnnotationSymbolOccurrence; }
IfcAnnotationSymbolOccurrence::IfcAnnotationSymbolOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationSymbolOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationSymbolOccurrence::IfcAnnotationSymbolOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcAnnotationTextOccurrence
bool IfcAnnotationTextOccurrence::is(Type::Enum v) const { return v == Type::IfcAnnotationTextOccurrence || IfcAnnotationOccurrence::is(v); }
Type::Enum IfcAnnotationTextOccurrence::type() const { return Type::IfcAnnotationTextOccurrence; }
Type::Enum IfcAnnotationTextOccurrence::Class() { return Type::IfcAnnotationTextOccurrence; }
IfcAnnotationTextOccurrence::IfcAnnotationTextOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAnnotationTextOccurrence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationTextOccurrence::IfcAnnotationTextOccurrence(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcApplication
IfcOrganization* IfcApplication::ApplicationDeveloper() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcApplication::setApplicationDeveloper(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::string IfcApplication::Version() const { return *entity->getArgument(1); }
void IfcApplication::setVersion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
std::string IfcApplication::ApplicationFullName() const { return *entity->getArgument(2); }
void IfcApplication::setApplicationFullName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
std::string IfcApplication::ApplicationIdentifier() const { return *entity->getArgument(3); }
void IfcApplication::setApplicationIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcApplication::is(Type::Enum v) const { return v == Type::IfcApplication; }
Type::Enum IfcApplication::type() const { return Type::IfcApplication; }
Type::Enum IfcApplication::Class() { return Type::IfcApplication; }
IfcApplication::IfcApplication(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcApplication) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApplication::IfcApplication(IfcOrganization* v1_ApplicationDeveloper, std::string v2_Version, std::string v3_ApplicationFullName, std::string v4_ApplicationIdentifier) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ApplicationDeveloper));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Version));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ApplicationFullName));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ApplicationIdentifier));entity->setArgument(3,attr);} }

// Function implementations for IfcAppliedValue
bool IfcAppliedValue::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcAppliedValue::Name() const { return *entity->getArgument(0); }
void IfcAppliedValue::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcAppliedValue::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcAppliedValue::Description() const { return *entity->getArgument(1); }
void IfcAppliedValue::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAppliedValue::hasAppliedValue() const { return !entity->getArgument(2)->isNull(); }
IfcAppliedValueSelect* IfcAppliedValue::AppliedValue() const { return (IfcAppliedValueSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcAppliedValue::setAppliedValue(IfcAppliedValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcAppliedValue::hasUnitBasis() const { return !entity->getArgument(3)->isNull(); }
IfcMeasureWithUnit* IfcAppliedValue::UnitBasis() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcAppliedValue::setUnitBasis(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcAppliedValue::hasApplicableDate() const { return !entity->getArgument(4)->isNull(); }
IfcDateTimeSelect* IfcAppliedValue::ApplicableDate() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcAppliedValue::setApplicableDate(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcAppliedValue::hasFixedUntilDate() const { return !entity->getArgument(5)->isNull(); }
IfcDateTimeSelect* IfcAppliedValue::FixedUntilDate() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcAppliedValue::setFixedUntilDate(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcReferencesValueDocument::list::ptr IfcAppliedValue::ValuesReferenced() const { return entity->getInverse(Type::IfcReferencesValueDocument, 1)->as<IfcReferencesValueDocument>(); }
IfcAppliedValueRelationship::list::ptr IfcAppliedValue::ValueOfComponents() const { return entity->getInverse(Type::IfcAppliedValueRelationship, 0)->as<IfcAppliedValueRelationship>(); }
IfcAppliedValueRelationship::list::ptr IfcAppliedValue::IsComponentIn() const { return entity->getInverse(Type::IfcAppliedValueRelationship, 1)->as<IfcAppliedValueRelationship>(); }
bool IfcAppliedValue::is(Type::Enum v) const { return v == Type::IfcAppliedValue; }
Type::Enum IfcAppliedValue::type() const { return Type::IfcAppliedValue; }
Type::Enum IfcAppliedValue::Class() { return Type::IfcAppliedValue; }
IfcAppliedValue::IfcAppliedValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcAppliedValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAppliedValue::IfcAppliedValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));entity->setArgument(5,attr);} }

// Function implementations for IfcAppliedValueRelationship
IfcAppliedValue* IfcAppliedValueRelationship::ComponentOfTotal() const { return (IfcAppliedValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcAppliedValueRelationship::setComponentOfTotal(IfcAppliedValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcAppliedValue >::ptr IfcAppliedValueRelationship::Components() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcAppliedValue>(); }
void IfcAppliedValueRelationship::setComponents(IfcTemplatedEntityList< IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcAppliedValueRelationship::ArithmeticOperator() const { return IfcArithmeticOperatorEnum::FromString(*entity->getArgument(2)); }
void IfcAppliedValueRelationship::setArithmeticOperator(IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcArithmeticOperatorEnum::ToString(v)));entity->setArgument(2,attr);} }
bool IfcAppliedValueRelationship::hasName() const { return !entity->getArgument(3)->isNull(); }
std::string IfcAppliedValueRelationship::Name() const { return *entity->getArgument(3); }
void IfcAppliedValueRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcAppliedValueRelationship::hasDescription() const { return !entity->getArgument(4)->isNull(); }
std::string IfcAppliedValueRelationship::Description() const { return *entity->getArgument(4); }
void IfcAppliedValueRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcAppliedValueRelationship::is(Type::Enum v) const { return v == Type::IfcAppliedValueRelationship; }
Type::Enum IfcAppliedValueRelationship::type() const { return Type::IfcAppliedValueRelationship; }
Type::Enum IfcAppliedValueRelationship::Class() { return Type::IfcAppliedValueRelationship; }
IfcAppliedValueRelationship::IfcAppliedValueRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcAppliedValueRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAppliedValueRelationship::IfcAppliedValueRelationship(IfcAppliedValue* v1_ComponentOfTotal, IfcTemplatedEntityList< IfcAppliedValue >::ptr v2_Components, IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v3_ArithmeticOperator, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ComponentOfTotal));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Components)->generalize());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ArithmeticOperator,IfcArithmeticOperatorEnum::ToString(v3_ArithmeticOperator))));entity->setArgument(2,attr);} if (v4_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Name));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcApproval
bool IfcApproval::hasDescription() const { return !entity->getArgument(0)->isNull(); }
std::string IfcApproval::Description() const { return *entity->getArgument(0); }
void IfcApproval::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcDateTimeSelect* IfcApproval::ApprovalDateTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcApproval::setApprovalDateTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcApproval::hasApprovalStatus() const { return !entity->getArgument(2)->isNull(); }
std::string IfcApproval::ApprovalStatus() const { return *entity->getArgument(2); }
void IfcApproval::setApprovalStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcApproval::hasApprovalLevel() const { return !entity->getArgument(3)->isNull(); }
std::string IfcApproval::ApprovalLevel() const { return *entity->getArgument(3); }
void IfcApproval::setApprovalLevel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcApproval::hasApprovalQualifier() const { return !entity->getArgument(4)->isNull(); }
std::string IfcApproval::ApprovalQualifier() const { return *entity->getArgument(4); }
void IfcApproval::setApprovalQualifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
std::string IfcApproval::Name() const { return *entity->getArgument(5); }
void IfcApproval::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
std::string IfcApproval::Identifier() const { return *entity->getArgument(6); }
void IfcApproval::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcApprovalActorRelationship::list::ptr IfcApproval::Actors() const { return entity->getInverse(Type::IfcApprovalActorRelationship, 1)->as<IfcApprovalActorRelationship>(); }
IfcApprovalRelationship::list::ptr IfcApproval::IsRelatedWith() const { return entity->getInverse(Type::IfcApprovalRelationship, 0)->as<IfcApprovalRelationship>(); }
IfcApprovalRelationship::list::ptr IfcApproval::Relates() const { return entity->getInverse(Type::IfcApprovalRelationship, 1)->as<IfcApprovalRelationship>(); }
bool IfcApproval::is(Type::Enum v) const { return v == Type::IfcApproval; }
Type::Enum IfcApproval::type() const { return Type::IfcApproval; }
Type::Enum IfcApproval::Class() { return Type::IfcApproval; }
IfcApproval::IfcApproval(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcApproval) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApproval::IfcApproval(boost::optional< std::string > v1_Description, IfcDateTimeSelect* v2_ApprovalDateTime, boost::optional< std::string > v3_ApprovalStatus, boost::optional< std::string > v4_ApprovalLevel, boost::optional< std::string > v5_ApprovalQualifier, std::string v6_Name, std::string v7_Identifier) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Description));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ApprovalDateTime));entity->setArgument(1,attr);} if (v3_ApprovalStatus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ApprovalStatus));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ApprovalLevel) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ApprovalLevel));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApprovalQualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApprovalQualifier));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Name));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Identifier));entity->setArgument(6,attr);} }

// Function implementations for IfcApprovalActorRelationship
IfcActorSelect* IfcApprovalActorRelationship::Actor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcApprovalActorRelationship::setActor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcApproval* IfcApprovalActorRelationship::Approval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcApprovalActorRelationship::setApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcActorRole* IfcApprovalActorRelationship::Role() const { return (IfcActorRole*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcApprovalActorRelationship::setRole(IfcActorRole* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcApprovalActorRelationship::is(Type::Enum v) const { return v == Type::IfcApprovalActorRelationship; }
Type::Enum IfcApprovalActorRelationship::type() const { return Type::IfcApprovalActorRelationship; }
Type::Enum IfcApprovalActorRelationship::Class() { return Type::IfcApprovalActorRelationship; }
IfcApprovalActorRelationship::IfcApprovalActorRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcApprovalActorRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApprovalActorRelationship::IfcApprovalActorRelationship(IfcActorSelect* v1_Actor, IfcApproval* v2_Approval, IfcActorRole* v3_Role) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Actor));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Approval));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Role));entity->setArgument(2,attr);} }

// Function implementations for IfcApprovalPropertyRelationship
IfcTemplatedEntityList< IfcProperty >::ptr IfcApprovalPropertyRelationship::ApprovedProperties() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcProperty>(); }
void IfcApprovalPropertyRelationship::setApprovedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
IfcApproval* IfcApprovalPropertyRelationship::Approval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcApprovalPropertyRelationship::setApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcApprovalPropertyRelationship::is(Type::Enum v) const { return v == Type::IfcApprovalPropertyRelationship; }
Type::Enum IfcApprovalPropertyRelationship::type() const { return Type::IfcApprovalPropertyRelationship; }
Type::Enum IfcApprovalPropertyRelationship::Class() { return Type::IfcApprovalPropertyRelationship; }
IfcApprovalPropertyRelationship::IfcApprovalPropertyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcApprovalPropertyRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApprovalPropertyRelationship::IfcApprovalPropertyRelationship(IfcTemplatedEntityList< IfcProperty >::ptr v1_ApprovedProperties, IfcApproval* v2_Approval) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ApprovedProperties)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Approval));entity->setArgument(1,attr);} }

// Function implementations for IfcApprovalRelationship
IfcApproval* IfcApprovalRelationship::RelatedApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcApprovalRelationship::setRelatedApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcApproval* IfcApprovalRelationship::RelatingApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcApprovalRelationship::setRelatingApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcApprovalRelationship::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcApprovalRelationship::Description() const { return *entity->getArgument(2); }
void IfcApprovalRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
std::string IfcApprovalRelationship::Name() const { return *entity->getArgument(3); }
void IfcApprovalRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcApprovalRelationship::is(Type::Enum v) const { return v == Type::IfcApprovalRelationship; }
Type::Enum IfcApprovalRelationship::type() const { return Type::IfcApprovalRelationship; }
Type::Enum IfcApprovalRelationship::Class() { return Type::IfcApprovalRelationship; }
IfcApprovalRelationship::IfcApprovalRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcApprovalRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApprovalRelationship::IfcApprovalRelationship(IfcApproval* v1_RelatedApproval, IfcApproval* v2_RelatingApproval, boost::optional< std::string > v3_Description, std::string v4_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatedApproval));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatingApproval));entity->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));entity->setArgument(3,attr);} }

// Function implementations for IfcArbitraryClosedProfileDef
IfcCurve* IfcArbitraryClosedProfileDef::OuterCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcArbitraryClosedProfileDef::setOuterCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcArbitraryClosedProfileDef::is(Type::Enum v) const { return v == Type::IfcArbitraryClosedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcArbitraryClosedProfileDef::type() const { return Type::IfcArbitraryClosedProfileDef; }
Type::Enum IfcArbitraryClosedProfileDef::Class() { return Type::IfcArbitraryClosedProfileDef; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcArbitraryClosedProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve) : IfcProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));entity->setArgument(2,attr);} }

// Function implementations for IfcArbitraryOpenProfileDef
IfcBoundedCurve* IfcArbitraryOpenProfileDef::Curve() const { return (IfcBoundedCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcArbitraryOpenProfileDef::setCurve(IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcArbitraryOpenProfileDef::is(Type::Enum v) const { return v == Type::IfcArbitraryOpenProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcArbitraryOpenProfileDef::type() const { return Type::IfcArbitraryOpenProfileDef; }
Type::Enum IfcArbitraryOpenProfileDef::Class() { return Type::IfcArbitraryOpenProfileDef; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcArbitraryOpenProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve) : IfcProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));entity->setArgument(2,attr);} }

// Function implementations for IfcArbitraryProfileDefWithVoids
IfcTemplatedEntityList< IfcCurve >::ptr IfcArbitraryProfileDefWithVoids::InnerCurves() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcCurve>(); }
void IfcArbitraryProfileDefWithVoids::setInnerCurves(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcArbitraryProfileDefWithVoids::is(Type::Enum v) const { return v == Type::IfcArbitraryProfileDefWithVoids || IfcArbitraryClosedProfileDef::is(v); }
Type::Enum IfcArbitraryProfileDefWithVoids::type() const { return Type::IfcArbitraryProfileDefWithVoids; }
Type::Enum IfcArbitraryProfileDefWithVoids::Class() { return Type::IfcArbitraryProfileDefWithVoids; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcEntityInstanceData* e) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcArbitraryProfileDefWithVoids) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve, IfcTemplatedEntityList< IfcCurve >::ptr v4_InnerCurves) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_InnerCurves)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcAsset
std::string IfcAsset::AssetID() const { return *entity->getArgument(5); }
void IfcAsset::setAssetID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcCostValue* IfcAsset::OriginalValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcAsset::setOriginalValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcCostValue* IfcAsset::CurrentValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcAsset::setCurrentValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcCostValue* IfcAsset::TotalReplacementCost() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcAsset::setTotalReplacementCost(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcActorSelect* IfcAsset::Owner() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcAsset::setOwner(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
IfcActorSelect* IfcAsset::User() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcAsset::setUser(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
IfcPerson* IfcAsset::ResponsiblePerson() const { return (IfcPerson*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcAsset::setResponsiblePerson(IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
IfcCalendarDate* IfcAsset::IncorporationDate() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcAsset::setIncorporationDate(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
IfcCostValue* IfcAsset::DepreciatedValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(13))); }
void IfcAsset::setDepreciatedValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcAsset::is(Type::Enum v) const { return v == Type::IfcAsset || IfcGroup::is(v); }
Type::Enum IfcAsset::type() const { return Type::IfcAsset; }
Type::Enum IfcAsset::Class() { return Type::IfcAsset; }
IfcAsset::IfcAsset(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAsset) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAsset::IfcAsset(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_AssetID, IfcCostValue* v7_OriginalValue, IfcCostValue* v8_CurrentValue, IfcCostValue* v9_TotalReplacementCost, IfcActorSelect* v10_Owner, IfcActorSelect* v11_User, IfcPerson* v12_ResponsiblePerson, IfcCalendarDate* v13_IncorporationDate, IfcCostValue* v14_DepreciatedValue) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_AssetID));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OriginalValue));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CurrentValue));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TotalReplacementCost));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Owner));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_User));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_ResponsiblePerson));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_IncorporationDate));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_DepreciatedValue));entity->setArgument(13,attr);} }

// Function implementations for IfcAsymmetricIShapeProfileDef
double IfcAsymmetricIShapeProfileDef::TopFlangeWidth() const { return *entity->getArgument(8); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeThickness() const { return !entity->getArgument(9)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeThickness() const { return *entity->getArgument(9); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeFilletRadius() const { return !entity->getArgument(10)->isNull(); }
double IfcAsymmetricIShapeProfileDef::TopFlangeFilletRadius() const { return *entity->getArgument(10); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcAsymmetricIShapeProfileDef::hasCentreOfGravityInY() const { return !entity->getArgument(11)->isNull(); }
double IfcAsymmetricIShapeProfileDef::CentreOfGravityInY() const { return *entity->getArgument(11); }
void IfcAsymmetricIShapeProfileDef::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcAsymmetricIShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcAsymmetricIShapeProfileDef || IfcIShapeProfileDef::is(v); }
Type::Enum IfcAsymmetricIShapeProfileDef::type() const { return Type::IfcAsymmetricIShapeProfileDef; }
Type::Enum IfcAsymmetricIShapeProfileDef::Class() { return Type::IfcAsymmetricIShapeProfileDef; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcEntityInstanceData* e) : IfcIShapeProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAsymmetricIShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, double v9_TopFlangeWidth, boost::optional< double > v10_TopFlangeThickness, boost::optional< double > v11_TopFlangeFilletRadius, boost::optional< double > v12_CentreOfGravityInY) : IfcIShapeProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallWidth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));entity->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TopFlangeWidth));entity->setArgument(8,attr);} if (v10_TopFlangeThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TopFlangeThickness));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_TopFlangeFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TopFlangeFilletRadius));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CentreOfGravityInY));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } }

// Function implementations for IfcAxis1Placement
bool IfcAxis1Placement::hasAxis() const { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis1Placement::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcAxis1Placement::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAxis1Placement::is(Type::Enum v) const { return v == Type::IfcAxis1Placement || IfcPlacement::is(v); }
Type::Enum IfcAxis1Placement::type() const { return Type::IfcAxis1Placement; }
Type::Enum IfcAxis1Placement::Class() { return Type::IfcAxis1Placement; }
IfcAxis1Placement::IfcAxis1Placement(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAxis1Placement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis1Placement::IfcAxis1Placement(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis) : IfcPlacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));entity->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement2D
bool IfcAxis2Placement2D::hasRefDirection() const { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement2D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcAxis2Placement2D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAxis2Placement2D::is(Type::Enum v) const { return v == Type::IfcAxis2Placement2D || IfcPlacement::is(v); }
Type::Enum IfcAxis2Placement2D::type() const { return Type::IfcAxis2Placement2D; }
Type::Enum IfcAxis2Placement2D::Class() { return Type::IfcAxis2Placement2D; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAxis2Placement2D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcCartesianPoint* v1_Location, IfcDirection* v2_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RefDirection));entity->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement3D
bool IfcAxis2Placement3D::hasAxis() const { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement3D::Axis() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcAxis2Placement3D::setAxis(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcAxis2Placement3D::hasRefDirection() const { return !entity->getArgument(2)->isNull(); }
IfcDirection* IfcAxis2Placement3D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcAxis2Placement3D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcAxis2Placement3D::is(Type::Enum v) const { return v == Type::IfcAxis2Placement3D || IfcPlacement::is(v); }
Type::Enum IfcAxis2Placement3D::type() const { return Type::IfcAxis2Placement3D; }
Type::Enum IfcAxis2Placement3D::Class() { return Type::IfcAxis2Placement3D; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcAxis2Placement3D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis, IfcDirection* v3_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RefDirection));entity->setArgument(2,attr);} }

// Function implementations for IfcBSplineCurve
int IfcBSplineCurve::Degree() const { return *entity->getArgument(0); }
void IfcBSplineCurve::setDegree(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcBSplineCurve::ControlPointsList() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcCartesianPoint>(); }
void IfcBSplineCurve::setControlPointsList(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurve::CurveForm() const { return IfcBSplineCurveForm::FromString(*entity->getArgument(2)); }
void IfcBSplineCurve::setCurveForm(IfcBSplineCurveForm::IfcBSplineCurveForm v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBSplineCurveForm::ToString(v)));entity->setArgument(2,attr);} }
bool IfcBSplineCurve::ClosedCurve() const { return *entity->getArgument(3); }
void IfcBSplineCurve::setClosedCurve(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBSplineCurve::SelfIntersect() const { return *entity->getArgument(4); }
void IfcBSplineCurve::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcBSplineCurve::is(Type::Enum v) const { return v == Type::IfcBSplineCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcBSplineCurve::type() const { return Type::IfcBSplineCurve; }
Type::Enum IfcBSplineCurve::Class() { return Type::IfcBSplineCurve; }
IfcBSplineCurve::IfcBSplineCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBSplineCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBSplineCurve::IfcBSplineCurve(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));entity->setArgument(4,attr);} }

// Function implementations for IfcBeam
bool IfcBeam::is(Type::Enum v) const { return v == Type::IfcBeam || IfcBuildingElement::is(v); }
Type::Enum IfcBeam::type() const { return Type::IfcBeam; }
Type::Enum IfcBeam::Class() { return Type::IfcBeam; }
IfcBeam::IfcBeam(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBeam) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBeam::IfcBeam(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcBeamType
IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamType::PredefinedType() const { return IfcBeamTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBeamType::setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBeamTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcBeamType::is(Type::Enum v) const { return v == Type::IfcBeamType || IfcBuildingElementType::is(v); }
Type::Enum IfcBeamType::type() const { return Type::IfcBeamType; }
Type::Enum IfcBeamType::Class() { return Type::IfcBeamType; }
IfcBeamType::IfcBeamType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBeamType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBeamType::IfcBeamType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBeamTypeEnum::IfcBeamTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBeamTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcBezierCurve
bool IfcBezierCurve::is(Type::Enum v) const { return v == Type::IfcBezierCurve || IfcBSplineCurve::is(v); }
Type::Enum IfcBezierCurve::type() const { return Type::IfcBezierCurve; }
Type::Enum IfcBezierCurve::Class() { return Type::IfcBezierCurve; }
IfcBezierCurve::IfcBezierCurve(IfcEntityInstanceData* e) : IfcBSplineCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBezierCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBezierCurve::IfcBezierCurve(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect) : IfcBSplineCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));entity->setArgument(4,attr);} }

// Function implementations for IfcBlobTexture
std::string IfcBlobTexture::RasterFormat() const { return *entity->getArgument(4); }
void IfcBlobTexture::setRasterFormat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcBlobTexture::RasterCode() const { return *entity->getArgument(5); }
void IfcBlobTexture::setRasterCode(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcBlobTexture::is(Type::Enum v) const { return v == Type::IfcBlobTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcBlobTexture::type() const { return Type::IfcBlobTexture; }
Type::Enum IfcBlobTexture::Class() { return Type::IfcBlobTexture; }
IfcBlobTexture::IfcBlobTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBlobTexture) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBlobTexture::IfcBlobTexture(bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_RasterFormat, bool v6_RasterCode) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,IfcSurfaceTextureEnum::ToString(v3_TextureType))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RasterFormat));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RasterCode));entity->setArgument(5,attr);} }

// Function implementations for IfcBlock
double IfcBlock::XLength() const { return *entity->getArgument(1); }
void IfcBlock::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcBlock::YLength() const { return *entity->getArgument(2); }
void IfcBlock::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcBlock::ZLength() const { return *entity->getArgument(3); }
void IfcBlock::setZLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBlock::is(Type::Enum v) const { return v == Type::IfcBlock || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcBlock::type() const { return Type::IfcBlock; }
Type::Enum IfcBlock::Class() { return Type::IfcBlock; }
IfcBlock::IfcBlock(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBlock) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBlock::IfcBlock(IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_ZLength) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZLength));entity->setArgument(3,attr);} }

// Function implementations for IfcBoilerType
IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerType::PredefinedType() const { return IfcBoilerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBoilerType::setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBoilerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcBoilerType::is(Type::Enum v) const { return v == Type::IfcBoilerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcBoilerType::type() const { return Type::IfcBoilerType; }
Type::Enum IfcBoilerType::Class() { return Type::IfcBoilerType; }
IfcBoilerType::IfcBoilerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoilerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoilerType::IfcBoilerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBoilerTypeEnum::IfcBoilerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBoilerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcBooleanClippingResult
bool IfcBooleanClippingResult::is(Type::Enum v) const { return v == Type::IfcBooleanClippingResult || IfcBooleanResult::is(v); }
Type::Enum IfcBooleanClippingResult::type() const { return Type::IfcBooleanClippingResult; }
Type::Enum IfcBooleanClippingResult::Class() { return Type::IfcBooleanClippingResult; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcEntityInstanceData* e) : IfcBooleanResult((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBooleanClippingResult) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand) : IfcBooleanResult((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,IfcBooleanOperator::ToString(v1_Operator))));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));entity->setArgument(2,attr);} }

// Function implementations for IfcBooleanResult
IfcBooleanOperator::IfcBooleanOperator IfcBooleanResult::Operator() const { return IfcBooleanOperator::FromString(*entity->getArgument(0)); }
void IfcBooleanResult::setOperator(IfcBooleanOperator::IfcBooleanOperator v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBooleanOperator::ToString(v)));entity->setArgument(0,attr);} }
IfcBooleanOperand* IfcBooleanResult::FirstOperand() const { return (IfcBooleanOperand*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcBooleanResult::setFirstOperand(IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcBooleanOperand* IfcBooleanResult::SecondOperand() const { return (IfcBooleanOperand*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcBooleanResult::setSecondOperand(IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcBooleanResult::is(Type::Enum v) const { return v == Type::IfcBooleanResult || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcBooleanResult::type() const { return Type::IfcBooleanResult; }
Type::Enum IfcBooleanResult::Class() { return Type::IfcBooleanResult; }
IfcBooleanResult::IfcBooleanResult(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBooleanResult) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBooleanResult::IfcBooleanResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,IfcBooleanOperator::ToString(v1_Operator))));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));entity->setArgument(2,attr);} }

// Function implementations for IfcBoundaryCondition
bool IfcBoundaryCondition::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcBoundaryCondition::Name() const { return *entity->getArgument(0); }
void IfcBoundaryCondition::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcBoundaryCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryCondition; }
Type::Enum IfcBoundaryCondition::type() const { return Type::IfcBoundaryCondition; }
Type::Enum IfcBoundaryCondition::Class() { return Type::IfcBoundaryCondition; }
IfcBoundaryCondition::IfcBoundaryCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcBoundaryCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryCondition::IfcBoundaryCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcBoundaryEdgeCondition
bool IfcBoundaryEdgeCondition::hasLinearStiffnessByLengthX() const { return !entity->getArgument(1)->isNull(); }
double IfcBoundaryEdgeCondition::LinearStiffnessByLengthX() const { return *entity->getArgument(1); }
void IfcBoundaryEdgeCondition::setLinearStiffnessByLengthX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcBoundaryEdgeCondition::hasLinearStiffnessByLengthY() const { return !entity->getArgument(2)->isNull(); }
double IfcBoundaryEdgeCondition::LinearStiffnessByLengthY() const { return *entity->getArgument(2); }
void IfcBoundaryEdgeCondition::setLinearStiffnessByLengthY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcBoundaryEdgeCondition::hasLinearStiffnessByLengthZ() const { return !entity->getArgument(3)->isNull(); }
double IfcBoundaryEdgeCondition::LinearStiffnessByLengthZ() const { return *entity->getArgument(3); }
void IfcBoundaryEdgeCondition::setLinearStiffnessByLengthZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthX() const { return !entity->getArgument(4)->isNull(); }
double IfcBoundaryEdgeCondition::RotationalStiffnessByLengthX() const { return *entity->getArgument(4); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthY() const { return !entity->getArgument(5)->isNull(); }
double IfcBoundaryEdgeCondition::RotationalStiffnessByLengthY() const { return *entity->getArgument(5); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthZ() const { return !entity->getArgument(6)->isNull(); }
double IfcBoundaryEdgeCondition::RotationalStiffnessByLengthZ() const { return *entity->getArgument(6); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcBoundaryEdgeCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryEdgeCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryEdgeCondition::type() const { return Type::IfcBoundaryEdgeCondition; }
Type::Enum IfcBoundaryEdgeCondition::Class() { return Type::IfcBoundaryEdgeCondition; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundaryEdgeCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByLengthX, boost::optional< double > v3_LinearStiffnessByLengthY, boost::optional< double > v4_LinearStiffnessByLengthZ, boost::optional< double > v5_RotationalStiffnessByLengthX, boost::optional< double > v6_RotationalStiffnessByLengthY, boost::optional< double > v7_RotationalStiffnessByLengthZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_LinearStiffnessByLengthX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessByLengthX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LinearStiffnessByLengthY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessByLengthY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LinearStiffnessByLengthZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessByLengthZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RotationalStiffnessByLengthX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessByLengthX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RotationalStiffnessByLengthY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessByLengthY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RotationalStiffnessByLengthZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessByLengthZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcBoundaryFaceCondition
bool IfcBoundaryFaceCondition::hasLinearStiffnessByAreaX() const { return !entity->getArgument(1)->isNull(); }
double IfcBoundaryFaceCondition::LinearStiffnessByAreaX() const { return *entity->getArgument(1); }
void IfcBoundaryFaceCondition::setLinearStiffnessByAreaX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcBoundaryFaceCondition::hasLinearStiffnessByAreaY() const { return !entity->getArgument(2)->isNull(); }
double IfcBoundaryFaceCondition::LinearStiffnessByAreaY() const { return *entity->getArgument(2); }
void IfcBoundaryFaceCondition::setLinearStiffnessByAreaY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcBoundaryFaceCondition::hasLinearStiffnessByAreaZ() const { return !entity->getArgument(3)->isNull(); }
double IfcBoundaryFaceCondition::LinearStiffnessByAreaZ() const { return *entity->getArgument(3); }
void IfcBoundaryFaceCondition::setLinearStiffnessByAreaZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBoundaryFaceCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryFaceCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryFaceCondition::type() const { return Type::IfcBoundaryFaceCondition; }
Type::Enum IfcBoundaryFaceCondition::Class() { return Type::IfcBoundaryFaceCondition; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundaryFaceCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByAreaX, boost::optional< double > v3_LinearStiffnessByAreaY, boost::optional< double > v4_LinearStiffnessByAreaZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_LinearStiffnessByAreaX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessByAreaX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LinearStiffnessByAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessByAreaY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LinearStiffnessByAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessByAreaZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcBoundaryNodeCondition
bool IfcBoundaryNodeCondition::hasLinearStiffnessX() const { return !entity->getArgument(1)->isNull(); }
double IfcBoundaryNodeCondition::LinearStiffnessX() const { return *entity->getArgument(1); }
void IfcBoundaryNodeCondition::setLinearStiffnessX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcBoundaryNodeCondition::hasLinearStiffnessY() const { return !entity->getArgument(2)->isNull(); }
double IfcBoundaryNodeCondition::LinearStiffnessY() const { return *entity->getArgument(2); }
void IfcBoundaryNodeCondition::setLinearStiffnessY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcBoundaryNodeCondition::hasLinearStiffnessZ() const { return !entity->getArgument(3)->isNull(); }
double IfcBoundaryNodeCondition::LinearStiffnessZ() const { return *entity->getArgument(3); }
void IfcBoundaryNodeCondition::setLinearStiffnessZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessX() const { return !entity->getArgument(4)->isNull(); }
double IfcBoundaryNodeCondition::RotationalStiffnessX() const { return *entity->getArgument(4); }
void IfcBoundaryNodeCondition::setRotationalStiffnessX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessY() const { return !entity->getArgument(5)->isNull(); }
double IfcBoundaryNodeCondition::RotationalStiffnessY() const { return *entity->getArgument(5); }
void IfcBoundaryNodeCondition::setRotationalStiffnessY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessZ() const { return !entity->getArgument(6)->isNull(); }
double IfcBoundaryNodeCondition::RotationalStiffnessZ() const { return *entity->getArgument(6); }
void IfcBoundaryNodeCondition::setRotationalStiffnessZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcBoundaryNodeCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryNodeCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryNodeCondition::type() const { return Type::IfcBoundaryNodeCondition; }
Type::Enum IfcBoundaryNodeCondition::Class() { return Type::IfcBoundaryNodeCondition; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundaryNodeCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_LinearStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LinearStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LinearStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RotationalStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RotationalStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RotationalStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcBoundaryNodeConditionWarping
bool IfcBoundaryNodeConditionWarping::hasWarpingStiffness() const { return !entity->getArgument(7)->isNull(); }
double IfcBoundaryNodeConditionWarping::WarpingStiffness() const { return *entity->getArgument(7); }
void IfcBoundaryNodeConditionWarping::setWarpingStiffness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcBoundaryNodeConditionWarping::is(Type::Enum v) const { return v == Type::IfcBoundaryNodeConditionWarping || IfcBoundaryNodeCondition::is(v); }
Type::Enum IfcBoundaryNodeConditionWarping::type() const { return Type::IfcBoundaryNodeConditionWarping; }
Type::Enum IfcBoundaryNodeConditionWarping::Class() { return Type::IfcBoundaryNodeConditionWarping; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(IfcEntityInstanceData* e) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundaryNodeConditionWarping) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ, boost::optional< double > v8_WarpingStiffness) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_LinearStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LinearStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LinearStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RotationalStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RotationalStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RotationalStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WarpingStiffness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WarpingStiffness));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcBoundedCurve
bool IfcBoundedCurve::is(Type::Enum v) const { return v == Type::IfcBoundedCurve || IfcCurve::is(v); }
Type::Enum IfcBoundedCurve::type() const { return Type::IfcBoundedCurve; }
Type::Enum IfcBoundedCurve::Class() { return Type::IfcBoundedCurve; }
IfcBoundedCurve::IfcBoundedCurve(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundedCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundedCurve::IfcBoundedCurve() : IfcCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcBoundedSurface
bool IfcBoundedSurface::is(Type::Enum v) const { return v == Type::IfcBoundedSurface || IfcSurface::is(v); }
Type::Enum IfcBoundedSurface::type() const { return Type::IfcBoundedSurface; }
Type::Enum IfcBoundedSurface::Class() { return Type::IfcBoundedSurface; }
IfcBoundedSurface::IfcBoundedSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundedSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundedSurface::IfcBoundedSurface() : IfcSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcBoundingBox
IfcCartesianPoint* IfcBoundingBox::Corner() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcBoundingBox::setCorner(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcBoundingBox::XDim() const { return *entity->getArgument(1); }
void IfcBoundingBox::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcBoundingBox::YDim() const { return *entity->getArgument(2); }
void IfcBoundingBox::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcBoundingBox::ZDim() const { return *entity->getArgument(3); }
void IfcBoundingBox::setZDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcBoundingBox::is(Type::Enum v) const { return v == Type::IfcBoundingBox || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcBoundingBox::type() const { return Type::IfcBoundingBox; }
Type::Enum IfcBoundingBox::Class() { return Type::IfcBoundingBox; }
IfcBoundingBox::IfcBoundingBox(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoundingBox) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundingBox::IfcBoundingBox(IfcCartesianPoint* v1_Corner, double v2_XDim, double v3_YDim, double v4_ZDim) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Corner));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XDim));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YDim));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZDim));entity->setArgument(3,attr);} }

// Function implementations for IfcBoxedHalfSpace
IfcBoundingBox* IfcBoxedHalfSpace::Enclosure() const { return (IfcBoundingBox*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcBoxedHalfSpace::setEnclosure(IfcBoundingBox* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcBoxedHalfSpace::is(Type::Enum v) const { return v == Type::IfcBoxedHalfSpace || IfcHalfSpaceSolid::is(v); }
Type::Enum IfcBoxedHalfSpace::type() const { return Type::IfcBoxedHalfSpace; }
Type::Enum IfcBoxedHalfSpace::Class() { return Type::IfcBoxedHalfSpace; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBoxedHalfSpace) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcBoundingBox* v3_Enclosure) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Enclosure));entity->setArgument(2,attr);} }

// Function implementations for IfcBuilding
bool IfcBuilding::hasElevationOfRefHeight() const { return !entity->getArgument(9)->isNull(); }
double IfcBuilding::ElevationOfRefHeight() const { return *entity->getArgument(9); }
void IfcBuilding::setElevationOfRefHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcBuilding::hasElevationOfTerrain() const { return !entity->getArgument(10)->isNull(); }
double IfcBuilding::ElevationOfTerrain() const { return *entity->getArgument(10); }
void IfcBuilding::setElevationOfTerrain(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcBuilding::hasBuildingAddress() const { return !entity->getArgument(11)->isNull(); }
IfcPostalAddress* IfcBuilding::BuildingAddress() const { return (IfcPostalAddress*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcBuilding::setBuildingAddress(IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcBuilding::is(Type::Enum v) const { return v == Type::IfcBuilding || IfcSpatialStructureElement::is(v); }
Type::Enum IfcBuilding::type() const { return Type::IfcBuilding; }
Type::Enum IfcBuilding::Class() { return Type::IfcBuilding; }
IfcBuilding::IfcBuilding(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuilding) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuilding::IfcBuilding(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< double > v10_ElevationOfRefHeight, boost::optional< double > v11_ElevationOfTerrain, IfcPostalAddress* v12_BuildingAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,IfcElementCompositionEnum::ToString(v9_CompositionType))));entity->setArgument(8,attr);} if (v10_ElevationOfRefHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_ElevationOfRefHeight));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_ElevationOfTerrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationOfTerrain));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_BuildingAddress));entity->setArgument(11,attr);} }

// Function implementations for IfcBuildingElement
bool IfcBuildingElement::is(Type::Enum v) const { return v == Type::IfcBuildingElement || IfcElement::is(v); }
Type::Enum IfcBuildingElement::type() const { return Type::IfcBuildingElement; }
Type::Enum IfcBuildingElement::Class() { return Type::IfcBuildingElement; }
IfcBuildingElement::IfcBuildingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElement::IfcBuildingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementComponent
bool IfcBuildingElementComponent::is(Type::Enum v) const { return v == Type::IfcBuildingElementComponent || IfcBuildingElement::is(v); }
Type::Enum IfcBuildingElementComponent::type() const { return Type::IfcBuildingElementComponent; }
Type::Enum IfcBuildingElementComponent::Class() { return Type::IfcBuildingElementComponent; }
IfcBuildingElementComponent::IfcBuildingElementComponent(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElementComponent) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementComponent::IfcBuildingElementComponent(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementPart
bool IfcBuildingElementPart::is(Type::Enum v) const { return v == Type::IfcBuildingElementPart || IfcBuildingElementComponent::is(v); }
Type::Enum IfcBuildingElementPart::type() const { return Type::IfcBuildingElementPart; }
Type::Enum IfcBuildingElementPart::Class() { return Type::IfcBuildingElementPart; }
IfcBuildingElementPart::IfcBuildingElementPart(IfcEntityInstanceData* e) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElementPart) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementPart::IfcBuildingElementPart(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementProxy
bool IfcBuildingElementProxy::hasCompositionType() const { return !entity->getArgument(8)->isNull(); }
IfcElementCompositionEnum::IfcElementCompositionEnum IfcBuildingElementProxy::CompositionType() const { return IfcElementCompositionEnum::FromString(*entity->getArgument(8)); }
void IfcBuildingElementProxy::setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementCompositionEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcBuildingElementProxy::is(Type::Enum v) const { return v == Type::IfcBuildingElementProxy || IfcBuildingElement::is(v); }
Type::Enum IfcBuildingElementProxy::type() const { return Type::IfcBuildingElementProxy; }
Type::Enum IfcBuildingElementProxy::Class() { return Type::IfcBuildingElementProxy; }
IfcBuildingElementProxy::IfcBuildingElementProxy(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElementProxy) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementProxy::IfcBuildingElementProxy(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcBuildingElementProxyType
IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyType::PredefinedType() const { return IfcBuildingElementProxyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBuildingElementProxyType::setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBuildingElementProxyTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcBuildingElementProxyType::is(Type::Enum v) const { return v == Type::IfcBuildingElementProxyType || IfcBuildingElementType::is(v); }
Type::Enum IfcBuildingElementProxyType::type() const { return Type::IfcBuildingElementProxyType; }
Type::Enum IfcBuildingElementProxyType::Class() { return Type::IfcBuildingElementProxyType; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElementProxyType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcBuildingElementProxyTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcBuildingElementType
bool IfcBuildingElementType::is(Type::Enum v) const { return v == Type::IfcBuildingElementType || IfcElementType::is(v); }
Type::Enum IfcBuildingElementType::type() const { return Type::IfcBuildingElementType; }
Type::Enum IfcBuildingElementType::Class() { return Type::IfcBuildingElementType; }
IfcBuildingElementType::IfcBuildingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementType::IfcBuildingElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcBuildingStorey
bool IfcBuildingStorey::hasElevation() const { return !entity->getArgument(9)->isNull(); }
double IfcBuildingStorey::Elevation() const { return *entity->getArgument(9); }
void IfcBuildingStorey::setElevation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcBuildingStorey::is(Type::Enum v) const { return v == Type::IfcBuildingStorey || IfcSpatialStructureElement::is(v); }
Type::Enum IfcBuildingStorey::type() const { return Type::IfcBuildingStorey; }
Type::Enum IfcBuildingStorey::Class() { return Type::IfcBuildingStorey; }
IfcBuildingStorey::IfcBuildingStorey(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcBuildingStorey) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingStorey::IfcBuildingStorey(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< double > v10_Elevation) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,IfcElementCompositionEnum::ToString(v9_CompositionType))));entity->setArgument(8,attr);} if (v10_Elevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Elevation));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcCShapeProfileDef
double IfcCShapeProfileDef::Depth() const { return *entity->getArgument(3); }
void IfcCShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcCShapeProfileDef::Width() const { return *entity->getArgument(4); }
void IfcCShapeProfileDef::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcCShapeProfileDef::WallThickness() const { return *entity->getArgument(5); }
void IfcCShapeProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcCShapeProfileDef::Girth() const { return *entity->getArgument(6); }
void IfcCShapeProfileDef::setGirth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcCShapeProfileDef::hasInternalFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcCShapeProfileDef::InternalFilletRadius() const { return *entity->getArgument(7); }
void IfcCShapeProfileDef::setInternalFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcCShapeProfileDef::hasCentreOfGravityInX() const { return !entity->getArgument(8)->isNull(); }
double IfcCShapeProfileDef::CentreOfGravityInX() const { return *entity->getArgument(8); }
void IfcCShapeProfileDef::setCentreOfGravityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcCShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcCShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCShapeProfileDef::type() const { return Type::IfcCShapeProfileDef; }
Type::Enum IfcCShapeProfileDef::Class() { return Type::IfcCShapeProfileDef; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_Width, double v6_WallThickness, double v7_Girth, boost::optional< double > v8_InternalFilletRadius, boost::optional< double > v9_CentreOfGravityInX) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Width));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Girth));entity->setArgument(6,attr);} if (v8_InternalFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_InternalFilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_CentreOfGravityInX));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcCableCarrierFittingType
IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingType::PredefinedType() const { return IfcCableCarrierFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableCarrierFittingType::setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierFittingTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCableCarrierFittingType::is(Type::Enum v) const { return v == Type::IfcCableCarrierFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcCableCarrierFittingType::type() const { return Type::IfcCableCarrierFittingType; }
Type::Enum IfcCableCarrierFittingType::Class() { return Type::IfcCableCarrierFittingType; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCableCarrierFittingType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableCarrierFittingTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCableCarrierSegmentType
IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentType::PredefinedType() const { return IfcCableCarrierSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableCarrierSegmentType::setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableCarrierSegmentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCableCarrierSegmentType::is(Type::Enum v) const { return v == Type::IfcCableCarrierSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcCableCarrierSegmentType::type() const { return Type::IfcCableCarrierSegmentType; }
Type::Enum IfcCableCarrierSegmentType::Class() { return Type::IfcCableCarrierSegmentType; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCableCarrierSegmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableCarrierSegmentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCableSegmentType
IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentType::PredefinedType() const { return IfcCableSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableSegmentType::setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCableSegmentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCableSegmentType::is(Type::Enum v) const { return v == Type::IfcCableSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcCableSegmentType::type() const { return Type::IfcCableSegmentType; }
Type::Enum IfcCableSegmentType::Class() { return Type::IfcCableSegmentType; }
IfcCableSegmentType::IfcCableSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCableSegmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableSegmentType::IfcCableSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCableSegmentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCalendarDate
int IfcCalendarDate::DayComponent() const { return *entity->getArgument(0); }
void IfcCalendarDate::setDayComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
int IfcCalendarDate::MonthComponent() const { return *entity->getArgument(1); }
void IfcCalendarDate::setMonthComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
int IfcCalendarDate::YearComponent() const { return *entity->getArgument(2); }
void IfcCalendarDate::setYearComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcCalendarDate::is(Type::Enum v) const { return v == Type::IfcCalendarDate; }
Type::Enum IfcCalendarDate::type() const { return Type::IfcCalendarDate; }
Type::Enum IfcCalendarDate::Class() { return Type::IfcCalendarDate; }
IfcCalendarDate::IfcCalendarDate(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCalendarDate) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCalendarDate::IfcCalendarDate(int v1_DayComponent, int v2_MonthComponent, int v3_YearComponent) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DayComponent));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MonthComponent));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YearComponent));entity->setArgument(2,attr);} }

// Function implementations for IfcCartesianPoint
std::vector< double > /*[1:3]*/ IfcCartesianPoint::Coordinates() const { return *entity->getArgument(0); }
void IfcCartesianPoint::setCoordinates(std::vector< double > /*[1:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcCartesianPoint::is(Type::Enum v) const { return v == Type::IfcCartesianPoint || IfcPoint::is(v); }
Type::Enum IfcCartesianPoint::type() const { return Type::IfcCartesianPoint; }
Type::Enum IfcCartesianPoint::Class() { return Type::IfcCartesianPoint; }
IfcCartesianPoint::IfcCartesianPoint(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianPoint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianPoint::IfcCartesianPoint(std::vector< double > /*[1:3]*/ v1_Coordinates) : IfcPoint((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));entity->setArgument(0,attr);} }

// Function implementations for IfcCartesianTransformationOperator
bool IfcCartesianTransformationOperator::hasAxis1() const { return !entity->getArgument(0)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis1() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcCartesianTransformationOperator::setAxis1(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcCartesianTransformationOperator::hasAxis2() const { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis2() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcCartesianTransformationOperator::setAxis2(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcCartesianPoint* IfcCartesianTransformationOperator::LocalOrigin() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcCartesianTransformationOperator::setLocalOrigin(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcCartesianTransformationOperator::hasScale() const { return !entity->getArgument(3)->isNull(); }
double IfcCartesianTransformationOperator::Scale() const { return *entity->getArgument(3); }
void IfcCartesianTransformationOperator::setScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCartesianTransformationOperator::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCartesianTransformationOperator::type() const { return Type::IfcCartesianTransformationOperator; }
Type::Enum IfcCartesianTransformationOperator::Class() { return Type::IfcCartesianTransformationOperator; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianTransformationOperator) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));entity->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2D
bool IfcCartesianTransformationOperator2D::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator2D || IfcCartesianTransformationOperator::is(v); }
Type::Enum IfcCartesianTransformationOperator2D::type() const { return Type::IfcCartesianTransformationOperator2D; }
Type::Enum IfcCartesianTransformationOperator2D::Class() { return Type::IfcCartesianTransformationOperator2D; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianTransformationOperator2D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));entity->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2DnonUniform
bool IfcCartesianTransformationOperator2DnonUniform::hasScale2() const { return !entity->getArgument(4)->isNull(); }
double IfcCartesianTransformationOperator2DnonUniform::Scale2() const { return *entity->getArgument(4); }
void IfcCartesianTransformationOperator2DnonUniform::setScale2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCartesianTransformationOperator2DnonUniform::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator2DnonUniform || IfcCartesianTransformationOperator2D::is(v); }
Type::Enum IfcCartesianTransformationOperator2DnonUniform::type() const { return Type::IfcCartesianTransformationOperator2DnonUniform; }
Type::Enum IfcCartesianTransformationOperator2DnonUniform::Class() { return Type::IfcCartesianTransformationOperator2DnonUniform; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianTransformationOperator2DnonUniform) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));entity->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Scale2));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcCartesianTransformationOperator3D
bool IfcCartesianTransformationOperator3D::hasAxis3() const { return !entity->getArgument(4)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator3D::Axis3() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcCartesianTransformationOperator3D::setAxis3(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCartesianTransformationOperator3D::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator3D || IfcCartesianTransformationOperator::is(v); }
Type::Enum IfcCartesianTransformationOperator3D::type() const { return Type::IfcCartesianTransformationOperator3D; }
Type::Enum IfcCartesianTransformationOperator3D::Class() { return Type::IfcCartesianTransformationOperator3D; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianTransformationOperator3D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));entity->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));entity->setArgument(4,attr);} }

// Function implementations for IfcCartesianTransformationOperator3DnonUniform
bool IfcCartesianTransformationOperator3DnonUniform::hasScale2() const { return !entity->getArgument(5)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale2() const { return *entity->getArgument(5); }
void IfcCartesianTransformationOperator3DnonUniform::setScale2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcCartesianTransformationOperator3DnonUniform::hasScale3() const { return !entity->getArgument(6)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale3() const { return *entity->getArgument(6); }
void IfcCartesianTransformationOperator3DnonUniform::setScale3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcCartesianTransformationOperator3DnonUniform::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator3DnonUniform || IfcCartesianTransformationOperator3D::is(v); }
Type::Enum IfcCartesianTransformationOperator3DnonUniform::type() const { return Type::IfcCartesianTransformationOperator3DnonUniform; }
Type::Enum IfcCartesianTransformationOperator3DnonUniform::Class() { return Type::IfcCartesianTransformationOperator3DnonUniform; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCartesianTransformationOperator3DnonUniform) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));entity->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));entity->setArgument(4,attr);} if (v6_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Scale2));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_Scale3) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scale3));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcCenterLineProfileDef
double IfcCenterLineProfileDef::Thickness() const { return *entity->getArgument(3); }
void IfcCenterLineProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCenterLineProfileDef::is(Type::Enum v) const { return v == Type::IfcCenterLineProfileDef || IfcArbitraryOpenProfileDef::is(v); }
Type::Enum IfcCenterLineProfileDef::type() const { return Type::IfcCenterLineProfileDef; }
Type::Enum IfcCenterLineProfileDef::Class() { return Type::IfcCenterLineProfileDef; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcEntityInstanceData* e) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCenterLineProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve, double v4_Thickness) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Thickness));entity->setArgument(3,attr);} }

// Function implementations for IfcChamferEdgeFeature
bool IfcChamferEdgeFeature::hasWidth() const { return !entity->getArgument(9)->isNull(); }
double IfcChamferEdgeFeature::Width() const { return *entity->getArgument(9); }
void IfcChamferEdgeFeature::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcChamferEdgeFeature::hasHeight() const { return !entity->getArgument(10)->isNull(); }
double IfcChamferEdgeFeature::Height() const { return *entity->getArgument(10); }
void IfcChamferEdgeFeature::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcChamferEdgeFeature::is(Type::Enum v) const { return v == Type::IfcChamferEdgeFeature || IfcEdgeFeature::is(v); }
Type::Enum IfcChamferEdgeFeature::type() const { return Type::IfcChamferEdgeFeature; }
Type::Enum IfcChamferEdgeFeature::Class() { return Type::IfcChamferEdgeFeature; }
IfcChamferEdgeFeature::IfcChamferEdgeFeature(IfcEntityInstanceData* e) : IfcEdgeFeature((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcChamferEdgeFeature) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChamferEdgeFeature::IfcChamferEdgeFeature(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Width, boost::optional< double > v11_Height) : IfcEdgeFeature((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Width) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Width));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_Height) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_Height));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcChillerType
IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerType::PredefinedType() const { return IfcChillerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcChillerType::setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChillerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcChillerType::is(Type::Enum v) const { return v == Type::IfcChillerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcChillerType::type() const { return Type::IfcChillerType; }
Type::Enum IfcChillerType::Class() { return Type::IfcChillerType; }
IfcChillerType::IfcChillerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcChillerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChillerType::IfcChillerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChillerTypeEnum::IfcChillerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcChillerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCircle
double IfcCircle::Radius() const { return *entity->getArgument(1); }
void IfcCircle::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcCircle::is(Type::Enum v) const { return v == Type::IfcCircle || IfcConic::is(v); }
Type::Enum IfcCircle::type() const { return Type::IfcCircle; }
Type::Enum IfcCircle::Class() { return Type::IfcCircle; }
IfcCircle::IfcCircle(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCircle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircle::IfcCircle(IfcAxis2Placement* v1_Position, double v2_Radius) : IfcConic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));entity->setArgument(1,attr);} }

// Function implementations for IfcCircleHollowProfileDef
double IfcCircleHollowProfileDef::WallThickness() const { return *entity->getArgument(4); }
void IfcCircleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCircleHollowProfileDef::is(Type::Enum v) const { return v == Type::IfcCircleHollowProfileDef || IfcCircleProfileDef::is(v); }
Type::Enum IfcCircleHollowProfileDef::type() const { return Type::IfcCircleHollowProfileDef; }
Type::Enum IfcCircleHollowProfileDef::Class() { return Type::IfcCircleHollowProfileDef; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcEntityInstanceData* e) : IfcCircleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCircleHollowProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius, double v5_WallThickness) : IfcCircleProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WallThickness));entity->setArgument(4,attr);} }

// Function implementations for IfcCircleProfileDef
double IfcCircleProfileDef::Radius() const { return *entity->getArgument(3); }
void IfcCircleProfileDef::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCircleProfileDef::is(Type::Enum v) const { return v == Type::IfcCircleProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCircleProfileDef::type() const { return Type::IfcCircleProfileDef; }
Type::Enum IfcCircleProfileDef::Class() { return Type::IfcCircleProfileDef; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCircleProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));entity->setArgument(3,attr);} }

// Function implementations for IfcClassification
std::string IfcClassification::Source() const { return *entity->getArgument(0); }
void IfcClassification::setSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::string IfcClassification::Edition() const { return *entity->getArgument(1); }
void IfcClassification::setEdition(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcClassification::hasEditionDate() const { return !entity->getArgument(2)->isNull(); }
IfcCalendarDate* IfcClassification::EditionDate() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcClassification::setEditionDate(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
std::string IfcClassification::Name() const { return *entity->getArgument(3); }
void IfcClassification::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
IfcClassificationItem::list::ptr IfcClassification::Contains() const { return entity->getInverse(Type::IfcClassificationItem, 1)->as<IfcClassificationItem>(); }
bool IfcClassification::is(Type::Enum v) const { return v == Type::IfcClassification; }
Type::Enum IfcClassification::type() const { return Type::IfcClassification; }
Type::Enum IfcClassification::Class() { return Type::IfcClassification; }
IfcClassification::IfcClassification(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcClassification) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassification::IfcClassification(std::string v1_Source, std::string v2_Edition, IfcCalendarDate* v3_EditionDate, std::string v4_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Source));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Edition));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EditionDate));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));entity->setArgument(3,attr);} }

// Function implementations for IfcClassificationItem
IfcClassificationNotationFacet* IfcClassificationItem::Notation() const { return (IfcClassificationNotationFacet*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcClassificationItem::setNotation(IfcClassificationNotationFacet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcClassificationItem::hasItemOf() const { return !entity->getArgument(1)->isNull(); }
IfcClassification* IfcClassificationItem::ItemOf() const { return (IfcClassification*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcClassificationItem::setItemOf(IfcClassification* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
std::string IfcClassificationItem::Title() const { return *entity->getArgument(2); }
void IfcClassificationItem::setTitle(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcClassificationItemRelationship::list::ptr IfcClassificationItem::IsClassifiedItemIn() const { return entity->getInverse(Type::IfcClassificationItemRelationship, 1)->as<IfcClassificationItemRelationship>(); }
IfcClassificationItemRelationship::list::ptr IfcClassificationItem::IsClassifyingItemIn() const { return entity->getInverse(Type::IfcClassificationItemRelationship, 0)->as<IfcClassificationItemRelationship>(); }
bool IfcClassificationItem::is(Type::Enum v) const { return v == Type::IfcClassificationItem; }
Type::Enum IfcClassificationItem::type() const { return Type::IfcClassificationItem; }
Type::Enum IfcClassificationItem::Class() { return Type::IfcClassificationItem; }
IfcClassificationItem::IfcClassificationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcClassificationItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationItem::IfcClassificationItem(IfcClassificationNotationFacet* v1_Notation, IfcClassification* v2_ItemOf, std::string v3_Title) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Notation));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ItemOf));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Title));entity->setArgument(2,attr);} }

// Function implementations for IfcClassificationItemRelationship
IfcClassificationItem* IfcClassificationItemRelationship::RelatingItem() const { return (IfcClassificationItem*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcClassificationItemRelationship::setRelatingItem(IfcClassificationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcClassificationItem >::ptr IfcClassificationItemRelationship::RelatedItems() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcClassificationItem>(); }
void IfcClassificationItemRelationship::setRelatedItems(IfcTemplatedEntityList< IfcClassificationItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcClassificationItemRelationship::is(Type::Enum v) const { return v == Type::IfcClassificationItemRelationship; }
Type::Enum IfcClassificationItemRelationship::type() const { return Type::IfcClassificationItemRelationship; }
Type::Enum IfcClassificationItemRelationship::Class() { return Type::IfcClassificationItemRelationship; }
IfcClassificationItemRelationship::IfcClassificationItemRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcClassificationItemRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationItemRelationship::IfcClassificationItemRelationship(IfcClassificationItem* v1_RelatingItem, IfcTemplatedEntityList< IfcClassificationItem >::ptr v2_RelatedItems) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingItem));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedItems)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcClassificationNotation
IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr IfcClassificationNotation::NotationFacets() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcClassificationNotationFacet>(); }
void IfcClassificationNotation::setNotationFacets(IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcClassificationNotation::is(Type::Enum v) const { return v == Type::IfcClassificationNotation; }
Type::Enum IfcClassificationNotation::type() const { return Type::IfcClassificationNotation; }
Type::Enum IfcClassificationNotation::Class() { return Type::IfcClassificationNotation; }
IfcClassificationNotation::IfcClassificationNotation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcClassificationNotation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationNotation::IfcClassificationNotation(IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr v1_NotationFacets) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_NotationFacets)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcClassificationNotationFacet
std::string IfcClassificationNotationFacet::NotationValue() const { return *entity->getArgument(0); }
void IfcClassificationNotationFacet::setNotationValue(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcClassificationNotationFacet::is(Type::Enum v) const { return v == Type::IfcClassificationNotationFacet; }
Type::Enum IfcClassificationNotationFacet::type() const { return Type::IfcClassificationNotationFacet; }
Type::Enum IfcClassificationNotationFacet::Class() { return Type::IfcClassificationNotationFacet; }
IfcClassificationNotationFacet::IfcClassificationNotationFacet(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcClassificationNotationFacet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationNotationFacet::IfcClassificationNotationFacet(std::string v1_NotationValue) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_NotationValue));entity->setArgument(0,attr);} }

// Function implementations for IfcClassificationReference
bool IfcClassificationReference::hasReferencedSource() const { return !entity->getArgument(3)->isNull(); }
IfcClassification* IfcClassificationReference::ReferencedSource() const { return (IfcClassification*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcClassificationReference::setReferencedSource(IfcClassification* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcClassificationReference::is(Type::Enum v) const { return v == Type::IfcClassificationReference || IfcExternalReference::is(v); }
Type::Enum IfcClassificationReference::type() const { return Type::IfcClassificationReference; }
Type::Enum IfcClassificationReference::Class() { return Type::IfcClassificationReference; }
IfcClassificationReference::IfcClassificationReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcClassificationReference) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationReference::IfcClassificationReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name, IfcClassification* v4_ReferencedSource) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReferencedSource));entity->setArgument(3,attr);} }

// Function implementations for IfcClosedShell
bool IfcClosedShell::is(Type::Enum v) const { return v == Type::IfcClosedShell || IfcConnectedFaceSet::is(v); }
Type::Enum IfcClosedShell::type() const { return Type::IfcClosedShell; }
Type::Enum IfcClosedShell::Class() { return Type::IfcClosedShell; }
IfcClosedShell::IfcClosedShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcClosedShell) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClosedShell::IfcClosedShell(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcCoilType
IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilType::PredefinedType() const { return IfcCoilTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoilType::setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoilTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCoilType::is(Type::Enum v) const { return v == Type::IfcCoilType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCoilType::type() const { return Type::IfcCoilType; }
Type::Enum IfcCoilType::Class() { return Type::IfcCoilType; }
IfcCoilType::IfcCoilType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCoilType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoilType::IfcCoilType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoilTypeEnum::IfcCoilTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoilTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcColourRgb
double IfcColourRgb::Red() const { return *entity->getArgument(1); }
void IfcColourRgb::setRed(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcColourRgb::Green() const { return *entity->getArgument(2); }
void IfcColourRgb::setGreen(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcColourRgb::Blue() const { return *entity->getArgument(3); }
void IfcColourRgb::setBlue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcColourRgb::is(Type::Enum v) const { return v == Type::IfcColourRgb || IfcColourSpecification::is(v); }
Type::Enum IfcColourRgb::type() const { return Type::IfcColourRgb; }
Type::Enum IfcColourRgb::Class() { return Type::IfcColourRgb; }
IfcColourRgb::IfcColourRgb(IfcEntityInstanceData* e) : IfcColourSpecification((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcColourRgb) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColourRgb::IfcColourRgb(boost::optional< std::string > v1_Name, double v2_Red, double v3_Green, double v4_Blue) : IfcColourSpecification((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Red));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Green));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Blue));entity->setArgument(3,attr);} }

// Function implementations for IfcColourSpecification
bool IfcColourSpecification::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcColourSpecification::Name() const { return *entity->getArgument(0); }
void IfcColourSpecification::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcColourSpecification::is(Type::Enum v) const { return v == Type::IfcColourSpecification; }
Type::Enum IfcColourSpecification::type() const { return Type::IfcColourSpecification; }
Type::Enum IfcColourSpecification::Class() { return Type::IfcColourSpecification; }
IfcColourSpecification::IfcColourSpecification(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcColourSpecification) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColourSpecification::IfcColourSpecification(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcColumn
bool IfcColumn::is(Type::Enum v) const { return v == Type::IfcColumn || IfcBuildingElement::is(v); }
Type::Enum IfcColumn::type() const { return Type::IfcColumn; }
Type::Enum IfcColumn::Class() { return Type::IfcColumn; }
IfcColumn::IfcColumn(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcColumn) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColumn::IfcColumn(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcColumnType
IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnType::PredefinedType() const { return IfcColumnTypeEnum::FromString(*entity->getArgument(9)); }
void IfcColumnType::setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcColumnTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcColumnType::is(Type::Enum v) const { return v == Type::IfcColumnType || IfcBuildingElementType::is(v); }
Type::Enum IfcColumnType::type() const { return Type::IfcColumnType; }
Type::Enum IfcColumnType::Class() { return Type::IfcColumnType; }
IfcColumnType::IfcColumnType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcColumnType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColumnType::IfcColumnType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcColumnTypeEnum::IfcColumnTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcColumnTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcComplexProperty
std::string IfcComplexProperty::UsageName() const { return *entity->getArgument(2); }
void IfcComplexProperty::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcProperty >::ptr IfcComplexProperty::HasProperties() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcProperty>(); }
void IfcComplexProperty::setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcComplexProperty::is(Type::Enum v) const { return v == Type::IfcComplexProperty || IfcProperty::is(v); }
Type::Enum IfcComplexProperty::type() const { return Type::IfcComplexProperty; }
Type::Enum IfcComplexProperty::Class() { return Type::IfcComplexProperty; }
IfcComplexProperty::IfcComplexProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcComplexProperty) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcComplexProperty::IfcComplexProperty(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_UsageName, IfcTemplatedEntityList< IfcProperty >::ptr v4_HasProperties) : IfcProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UsageName));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_HasProperties)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcCompositeCurve
IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr IfcCompositeCurve::Segments() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcCompositeCurveSegment>(); }
void IfcCompositeCurve::setSegments(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcCompositeCurve::SelfIntersect() const { return *entity->getArgument(1); }
void IfcCompositeCurve::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcCompositeCurve::is(Type::Enum v) const { return v == Type::IfcCompositeCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcCompositeCurve::type() const { return Type::IfcCompositeCurve; }
Type::Enum IfcCompositeCurve::Class() { return Type::IfcCompositeCurve; }
IfcCompositeCurve::IfcCompositeCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCompositeCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeCurve::IfcCompositeCurve(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));entity->setArgument(1,attr);} }

// Function implementations for IfcCompositeCurveSegment
IfcTransitionCode::IfcTransitionCode IfcCompositeCurveSegment::Transition() const { return IfcTransitionCode::FromString(*entity->getArgument(0)); }
void IfcCompositeCurveSegment::setTransition(IfcTransitionCode::IfcTransitionCode v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransitionCode::ToString(v)));entity->setArgument(0,attr);} }
bool IfcCompositeCurveSegment::SameSense() const { return *entity->getArgument(1); }
void IfcCompositeCurveSegment::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcCurve* IfcCompositeCurveSegment::ParentCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcCompositeCurveSegment::setParentCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcCompositeCurve::list::ptr IfcCompositeCurveSegment::UsingCurves() const { return entity->getInverse(Type::IfcCompositeCurve, 0)->as<IfcCompositeCurve>(); }
bool IfcCompositeCurveSegment::is(Type::Enum v) const { return v == Type::IfcCompositeCurveSegment || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCompositeCurveSegment::type() const { return Type::IfcCompositeCurveSegment; }
Type::Enum IfcCompositeCurveSegment::Class() { return Type::IfcCompositeCurveSegment; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCompositeCurveSegment) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Transition,IfcTransitionCode::ToString(v1_Transition))));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SameSense));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentCurve));entity->setArgument(2,attr);} }

// Function implementations for IfcCompositeProfileDef
IfcTemplatedEntityList< IfcProfileDef >::ptr IfcCompositeProfileDef::Profiles() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcProfileDef>(); }
void IfcCompositeProfileDef::setProfiles(IfcTemplatedEntityList< IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
bool IfcCompositeProfileDef::hasLabel() const { return !entity->getArgument(3)->isNull(); }
std::string IfcCompositeProfileDef::Label() const { return *entity->getArgument(3); }
void IfcCompositeProfileDef::setLabel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCompositeProfileDef::is(Type::Enum v) const { return v == Type::IfcCompositeProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcCompositeProfileDef::type() const { return Type::IfcCompositeProfileDef; }
Type::Enum IfcCompositeProfileDef::Class() { return Type::IfcCompositeProfileDef; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCompositeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcTemplatedEntityList< IfcProfileDef >::ptr v3_Profiles, boost::optional< std::string > v4_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Profiles)->generalize());entity->setArgument(2,attr);} if (v4_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Label));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcCompressorType
IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorType::PredefinedType() const { return IfcCompressorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCompressorType::setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCompressorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCompressorType::is(Type::Enum v) const { return v == Type::IfcCompressorType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcCompressorType::type() const { return Type::IfcCompressorType; }
Type::Enum IfcCompressorType::Class() { return Type::IfcCompressorType; }
IfcCompressorType::IfcCompressorType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCompressorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompressorType::IfcCompressorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCompressorTypeEnum::IfcCompressorTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCompressorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCondenserType
IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserType::PredefinedType() const { return IfcCondenserTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCondenserType::setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCondenserTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCondenserType::is(Type::Enum v) const { return v == Type::IfcCondenserType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCondenserType::type() const { return Type::IfcCondenserType; }
Type::Enum IfcCondenserType::Class() { return Type::IfcCondenserType; }
IfcCondenserType::IfcCondenserType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCondenserType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCondenserType::IfcCondenserType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCondenserTypeEnum::IfcCondenserTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCondenserTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCondition
bool IfcCondition::is(Type::Enum v) const { return v == Type::IfcCondition || IfcGroup::is(v); }
Type::Enum IfcCondition::type() const { return Type::IfcCondition; }
Type::Enum IfcCondition::Class() { return Type::IfcCondition; }
IfcCondition::IfcCondition(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCondition::IfcCondition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcConditionCriterion
IfcConditionCriterionSelect* IfcConditionCriterion::Criterion() const { return (IfcConditionCriterionSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcConditionCriterion::setCriterion(IfcConditionCriterionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcDateTimeSelect* IfcConditionCriterion::CriterionDateTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcConditionCriterion::setCriterionDateTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcConditionCriterion::is(Type::Enum v) const { return v == Type::IfcConditionCriterion || IfcControl::is(v); }
Type::Enum IfcConditionCriterion::type() const { return Type::IfcConditionCriterion; }
Type::Enum IfcConditionCriterion::Class() { return Type::IfcConditionCriterion; }
IfcConditionCriterion::IfcConditionCriterion(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConditionCriterion) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConditionCriterion::IfcConditionCriterion(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcConditionCriterionSelect* v6_Criterion, IfcDateTimeSelect* v7_CriterionDateTime) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Criterion));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CriterionDateTime));entity->setArgument(6,attr);} }

// Function implementations for IfcConic
IfcAxis2Placement* IfcConic::Position() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConic::setPosition(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConic::is(Type::Enum v) const { return v == Type::IfcConic || IfcCurve::is(v); }
Type::Enum IfcConic::type() const { return Type::IfcConic; }
Type::Enum IfcConic::Class() { return Type::IfcConic; }
IfcConic::IfcConic(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConic) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConic::IfcConic(IfcAxis2Placement* v1_Position) : IfcCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);} }

// Function implementations for IfcConnectedFaceSet
IfcTemplatedEntityList< IfcFace >::ptr IfcConnectedFaceSet::CfsFaces() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcFace>(); }
void IfcConnectedFaceSet::setCfsFaces(IfcTemplatedEntityList< IfcFace >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcConnectedFaceSet::is(Type::Enum v) const { return v == Type::IfcConnectedFaceSet || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcConnectedFaceSet::type() const { return Type::IfcConnectedFaceSet; }
Type::Enum IfcConnectedFaceSet::Class() { return Type::IfcConnectedFaceSet; }
IfcConnectedFaceSet::IfcConnectedFaceSet(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectedFaceSet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectedFaceSet::IfcConnectedFaceSet(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcConnectionCurveGeometry
IfcCurveOrEdgeCurve* IfcConnectionCurveGeometry::CurveOnRelatingElement() const { return (IfcCurveOrEdgeCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConnectionCurveGeometry::setCurveOnRelatingElement(IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConnectionCurveGeometry::hasCurveOnRelatedElement() const { return !entity->getArgument(1)->isNull(); }
IfcCurveOrEdgeCurve* IfcConnectionCurveGeometry::CurveOnRelatedElement() const { return (IfcCurveOrEdgeCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcConnectionCurveGeometry::setCurveOnRelatedElement(IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcConnectionCurveGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionCurveGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionCurveGeometry::type() const { return Type::IfcConnectionCurveGeometry; }
Type::Enum IfcConnectionCurveGeometry::Class() { return Type::IfcConnectionCurveGeometry; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectionCurveGeometry) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve* v1_CurveOnRelatingElement, IfcCurveOrEdgeCurve* v2_CurveOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CurveOnRelatingElement));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveOnRelatedElement));entity->setArgument(1,attr);} }

// Function implementations for IfcConnectionGeometry
bool IfcConnectionGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionGeometry; }
Type::Enum IfcConnectionGeometry::type() const { return Type::IfcConnectionGeometry; }
Type::Enum IfcConnectionGeometry::Class() { return Type::IfcConnectionGeometry; }
IfcConnectionGeometry::IfcConnectionGeometry(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcConnectionGeometry) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionGeometry::IfcConnectionGeometry() : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcConnectionPointEccentricity
bool IfcConnectionPointEccentricity::hasEccentricityInX() const { return !entity->getArgument(2)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInX() const { return *entity->getArgument(2); }
void IfcConnectionPointEccentricity::setEccentricityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcConnectionPointEccentricity::hasEccentricityInY() const { return !entity->getArgument(3)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInY() const { return *entity->getArgument(3); }
void IfcConnectionPointEccentricity::setEccentricityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcConnectionPointEccentricity::hasEccentricityInZ() const { return !entity->getArgument(4)->isNull(); }
double IfcConnectionPointEccentricity::EccentricityInZ() const { return *entity->getArgument(4); }
void IfcConnectionPointEccentricity::setEccentricityInZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcConnectionPointEccentricity::is(Type::Enum v) const { return v == Type::IfcConnectionPointEccentricity || IfcConnectionPointGeometry::is(v); }
Type::Enum IfcConnectionPointEccentricity::type() const { return Type::IfcConnectionPointEccentricity; }
Type::Enum IfcConnectionPointEccentricity::Class() { return Type::IfcConnectionPointEccentricity; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcEntityInstanceData* e) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectionPointEccentricity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement, boost::optional< double > v3_EccentricityInX, boost::optional< double > v4_EccentricityInY, boost::optional< double > v5_EccentricityInZ) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));entity->setArgument(1,attr);} if (v3_EccentricityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_EccentricityInX));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_EccentricityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EccentricityInY));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_EccentricityInZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EccentricityInZ));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcConnectionPointGeometry
IfcPointOrVertexPoint* IfcConnectionPointGeometry::PointOnRelatingElement() const { return (IfcPointOrVertexPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConnectionPointGeometry::setPointOnRelatingElement(IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConnectionPointGeometry::hasPointOnRelatedElement() const { return !entity->getArgument(1)->isNull(); }
IfcPointOrVertexPoint* IfcConnectionPointGeometry::PointOnRelatedElement() const { return (IfcPointOrVertexPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcConnectionPointGeometry::setPointOnRelatedElement(IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcConnectionPointGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionPointGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionPointGeometry::type() const { return Type::IfcConnectionPointGeometry; }
Type::Enum IfcConnectionPointGeometry::Class() { return Type::IfcConnectionPointGeometry; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectionPointGeometry) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));entity->setArgument(1,attr);} }

// Function implementations for IfcConnectionPortGeometry
IfcAxis2Placement* IfcConnectionPortGeometry::LocationAtRelatingElement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConnectionPortGeometry::setLocationAtRelatingElement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConnectionPortGeometry::hasLocationAtRelatedElement() const { return !entity->getArgument(1)->isNull(); }
IfcAxis2Placement* IfcConnectionPortGeometry::LocationAtRelatedElement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcConnectionPortGeometry::setLocationAtRelatedElement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcProfileDef* IfcConnectionPortGeometry::ProfileOfPort() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcConnectionPortGeometry::setProfileOfPort(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcConnectionPortGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionPortGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionPortGeometry::type() const { return Type::IfcConnectionPortGeometry; }
Type::Enum IfcConnectionPortGeometry::Class() { return Type::IfcConnectionPortGeometry; }
IfcConnectionPortGeometry::IfcConnectionPortGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectionPortGeometry) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionPortGeometry::IfcConnectionPortGeometry(IfcAxis2Placement* v1_LocationAtRelatingElement, IfcAxis2Placement* v2_LocationAtRelatedElement, IfcProfileDef* v3_ProfileOfPort) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LocationAtRelatingElement));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LocationAtRelatedElement));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ProfileOfPort));entity->setArgument(2,attr);} }

// Function implementations for IfcConnectionSurfaceGeometry
IfcSurfaceOrFaceSurface* IfcConnectionSurfaceGeometry::SurfaceOnRelatingElement() const { return (IfcSurfaceOrFaceSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatingElement(IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConnectionSurfaceGeometry::hasSurfaceOnRelatedElement() const { return !entity->getArgument(1)->isNull(); }
IfcSurfaceOrFaceSurface* IfcConnectionSurfaceGeometry::SurfaceOnRelatedElement() const { return (IfcSurfaceOrFaceSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatedElement(IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcConnectionSurfaceGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionSurfaceGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionSurfaceGeometry::type() const { return Type::IfcConnectionSurfaceGeometry; }
Type::Enum IfcConnectionSurfaceGeometry::Class() { return Type::IfcConnectionSurfaceGeometry; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConnectionSurfaceGeometry) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface* v1_SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface* v2_SurfaceOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceOnRelatingElement));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SurfaceOnRelatedElement));entity->setArgument(1,attr);} }

// Function implementations for IfcConstraint
std::string IfcConstraint::Name() const { return *entity->getArgument(0); }
void IfcConstraint::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConstraint::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcConstraint::Description() const { return *entity->getArgument(1); }
void IfcConstraint::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcConstraintEnum::IfcConstraintEnum IfcConstraint::ConstraintGrade() const { return IfcConstraintEnum::FromString(*entity->getArgument(2)); }
void IfcConstraint::setConstraintGrade(IfcConstraintEnum::IfcConstraintEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConstraintEnum::ToString(v)));entity->setArgument(2,attr);} }
bool IfcConstraint::hasConstraintSource() const { return !entity->getArgument(3)->isNull(); }
std::string IfcConstraint::ConstraintSource() const { return *entity->getArgument(3); }
void IfcConstraint::setConstraintSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcConstraint::hasCreatingActor() const { return !entity->getArgument(4)->isNull(); }
IfcActorSelect* IfcConstraint::CreatingActor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcConstraint::setCreatingActor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcConstraint::hasCreationTime() const { return !entity->getArgument(5)->isNull(); }
IfcDateTimeSelect* IfcConstraint::CreationTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcConstraint::setCreationTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcConstraint::hasUserDefinedGrade() const { return !entity->getArgument(6)->isNull(); }
std::string IfcConstraint::UserDefinedGrade() const { return *entity->getArgument(6); }
void IfcConstraint::setUserDefinedGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcConstraintClassificationRelationship::list::ptr IfcConstraint::ClassifiedAs() const { return entity->getInverse(Type::IfcConstraintClassificationRelationship, 0)->as<IfcConstraintClassificationRelationship>(); }
IfcConstraintRelationship::list::ptr IfcConstraint::RelatesConstraints() const { return entity->getInverse(Type::IfcConstraintRelationship, 2)->as<IfcConstraintRelationship>(); }
IfcConstraintRelationship::list::ptr IfcConstraint::IsRelatedWith() const { return entity->getInverse(Type::IfcConstraintRelationship, 3)->as<IfcConstraintRelationship>(); }
IfcPropertyConstraintRelationship::list::ptr IfcConstraint::PropertiesForConstraint() const { return entity->getInverse(Type::IfcPropertyConstraintRelationship, 0)->as<IfcPropertyConstraintRelationship>(); }
IfcConstraintAggregationRelationship::list::ptr IfcConstraint::Aggregates() const { return entity->getInverse(Type::IfcConstraintAggregationRelationship, 2)->as<IfcConstraintAggregationRelationship>(); }
IfcConstraintAggregationRelationship::list::ptr IfcConstraint::IsAggregatedIn() const { return entity->getInverse(Type::IfcConstraintAggregationRelationship, 3)->as<IfcConstraintAggregationRelationship>(); }
bool IfcConstraint::is(Type::Enum v) const { return v == Type::IfcConstraint; }
Type::Enum IfcConstraint::type() const { return Type::IfcConstraint; }
Type::Enum IfcConstraint::Class() { return Type::IfcConstraint; }
IfcConstraint::IfcConstraint(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcConstraint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstraint::IfcConstraint(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));entity->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));entity->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcConstraintAggregationRelationship
bool IfcConstraintAggregationRelationship::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcConstraintAggregationRelationship::Name() const { return *entity->getArgument(0); }
void IfcConstraintAggregationRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConstraintAggregationRelationship::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcConstraintAggregationRelationship::Description() const { return *entity->getArgument(1); }
void IfcConstraintAggregationRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcConstraint* IfcConstraintAggregationRelationship::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcConstraintAggregationRelationship::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcConstraint >::ptr IfcConstraintAggregationRelationship::RelatedConstraints() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcConstraint>(); }
void IfcConstraintAggregationRelationship::setRelatedConstraints(IfcTemplatedEntityList< IfcConstraint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcConstraintAggregationRelationship::LogicalAggregator() const { return IfcLogicalOperatorEnum::FromString(*entity->getArgument(4)); }
void IfcConstraintAggregationRelationship::setLogicalAggregator(IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLogicalOperatorEnum::ToString(v)));entity->setArgument(4,attr);} }
bool IfcConstraintAggregationRelationship::is(Type::Enum v) const { return v == Type::IfcConstraintAggregationRelationship; }
Type::Enum IfcConstraintAggregationRelationship::type() const { return Type::IfcConstraintAggregationRelationship; }
Type::Enum IfcConstraintAggregationRelationship::Class() { return Type::IfcConstraintAggregationRelationship; }
IfcConstraintAggregationRelationship::IfcConstraintAggregationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcConstraintAggregationRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstraintAggregationRelationship::IfcConstraintAggregationRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcTemplatedEntityList< IfcConstraint >::ptr v4_RelatedConstraints, IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v5_LogicalAggregator) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingConstraint));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedConstraints)->generalize());entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_LogicalAggregator,IfcLogicalOperatorEnum::ToString(v5_LogicalAggregator))));entity->setArgument(4,attr);} }

// Function implementations for IfcConstraintClassificationRelationship
IfcConstraint* IfcConstraintClassificationRelationship::ClassifiedConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcConstraintClassificationRelationship::setClassifiedConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcConstraintClassificationRelationship::RelatedClassifications() const { return *entity->getArgument(1); }
void IfcConstraintClassificationRelationship::setRelatedClassifications(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcConstraintClassificationRelationship::is(Type::Enum v) const { return v == Type::IfcConstraintClassificationRelationship; }
Type::Enum IfcConstraintClassificationRelationship::type() const { return Type::IfcConstraintClassificationRelationship; }
Type::Enum IfcConstraintClassificationRelationship::Class() { return Type::IfcConstraintClassificationRelationship; }
IfcConstraintClassificationRelationship::IfcConstraintClassificationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcConstraintClassificationRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstraintClassificationRelationship::IfcConstraintClassificationRelationship(IfcConstraint* v1_ClassifiedConstraint, IfcEntityList::ptr v2_RelatedClassifications) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ClassifiedConstraint));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedClassifications));entity->setArgument(1,attr);} }

// Function implementations for IfcConstraintRelationship
bool IfcConstraintRelationship::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcConstraintRelationship::Name() const { return *entity->getArgument(0); }
void IfcConstraintRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcConstraintRelationship::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcConstraintRelationship::Description() const { return *entity->getArgument(1); }
void IfcConstraintRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcConstraint* IfcConstraintRelationship::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcConstraintRelationship::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcConstraint >::ptr IfcConstraintRelationship::RelatedConstraints() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcConstraint>(); }
void IfcConstraintRelationship::setRelatedConstraints(IfcTemplatedEntityList< IfcConstraint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcConstraintRelationship::is(Type::Enum v) const { return v == Type::IfcConstraintRelationship; }
Type::Enum IfcConstraintRelationship::type() const { return Type::IfcConstraintRelationship; }
Type::Enum IfcConstraintRelationship::Class() { return Type::IfcConstraintRelationship; }
IfcConstraintRelationship::IfcConstraintRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcConstraintRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstraintRelationship::IfcConstraintRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcTemplatedEntityList< IfcConstraint >::ptr v4_RelatedConstraints) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingConstraint));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedConstraints)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcConstructionEquipmentResource
bool IfcConstructionEquipmentResource::is(Type::Enum v) const { return v == Type::IfcConstructionEquipmentResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionEquipmentResource::type() const { return Type::IfcConstructionEquipmentResource; }
Type::Enum IfcConstructionEquipmentResource::Class() { return Type::IfcConstructionEquipmentResource; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConstructionEquipmentResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} }

// Function implementations for IfcConstructionMaterialResource
bool IfcConstructionMaterialResource::hasSuppliers() const { return !entity->getArgument(9)->isNull(); }
IfcEntityList::ptr IfcConstructionMaterialResource::Suppliers() const { return *entity->getArgument(9); }
void IfcConstructionMaterialResource::setSuppliers(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcConstructionMaterialResource::hasUsageRatio() const { return !entity->getArgument(10)->isNull(); }
double IfcConstructionMaterialResource::UsageRatio() const { return *entity->getArgument(10); }
void IfcConstructionMaterialResource::setUsageRatio(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcConstructionMaterialResource::is(Type::Enum v) const { return v == Type::IfcConstructionMaterialResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionMaterialResource::type() const { return Type::IfcConstructionMaterialResource; }
Type::Enum IfcConstructionMaterialResource::Class() { return Type::IfcConstructionMaterialResource; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConstructionMaterialResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< IfcEntityList::ptr > v10_Suppliers, boost::optional< double > v11_UsageRatio) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} if (v10_Suppliers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Suppliers));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_UsageRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UsageRatio));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcConstructionProductResource
bool IfcConstructionProductResource::is(Type::Enum v) const { return v == Type::IfcConstructionProductResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionProductResource::type() const { return Type::IfcConstructionProductResource; }
Type::Enum IfcConstructionProductResource::Class() { return Type::IfcConstructionProductResource; }
IfcConstructionProductResource::IfcConstructionProductResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConstructionProductResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionProductResource::IfcConstructionProductResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} }

// Function implementations for IfcConstructionResource
bool IfcConstructionResource::hasResourceIdentifier() const { return !entity->getArgument(5)->isNull(); }
std::string IfcConstructionResource::ResourceIdentifier() const { return *entity->getArgument(5); }
void IfcConstructionResource::setResourceIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcConstructionResource::hasResourceGroup() const { return !entity->getArgument(6)->isNull(); }
std::string IfcConstructionResource::ResourceGroup() const { return *entity->getArgument(6); }
void IfcConstructionResource::setResourceGroup(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcConstructionResource::hasResourceConsumption() const { return !entity->getArgument(7)->isNull(); }
IfcResourceConsumptionEnum::IfcResourceConsumptionEnum IfcConstructionResource::ResourceConsumption() const { return IfcResourceConsumptionEnum::FromString(*entity->getArgument(7)); }
void IfcConstructionResource::setResourceConsumption(IfcResourceConsumptionEnum::IfcResourceConsumptionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcResourceConsumptionEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcConstructionResource::hasBaseQuantity() const { return !entity->getArgument(8)->isNull(); }
IfcMeasureWithUnit* IfcConstructionResource::BaseQuantity() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcConstructionResource::setBaseQuantity(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcConstructionResource::is(Type::Enum v) const { return v == Type::IfcConstructionResource || IfcResource::is(v); }
Type::Enum IfcConstructionResource::type() const { return Type::IfcConstructionResource; }
Type::Enum IfcConstructionResource::Class() { return Type::IfcConstructionResource; }
IfcConstructionResource::IfcConstructionResource(IfcEntityInstanceData* e) : IfcResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConstructionResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionResource::IfcConstructionResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity) : IfcResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} }

// Function implementations for IfcContextDependentUnit
std::string IfcContextDependentUnit::Name() const { return *entity->getArgument(2); }
void IfcContextDependentUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcContextDependentUnit::is(Type::Enum v) const { return v == Type::IfcContextDependentUnit || IfcNamedUnit::is(v); }
Type::Enum IfcContextDependentUnit::type() const { return Type::IfcContextDependentUnit; }
Type::Enum IfcContextDependentUnit::Class() { return Type::IfcContextDependentUnit; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcContextDependentUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));entity->setArgument(2,attr);} }

// Function implementations for IfcControl
IfcRelAssignsToControl::list::ptr IfcControl::Controls() const { return entity->getInverse(Type::IfcRelAssignsToControl, 6)->as<IfcRelAssignsToControl>(); }
bool IfcControl::is(Type::Enum v) const { return v == Type::IfcControl || IfcObject::is(v); }
Type::Enum IfcControl::type() const { return Type::IfcControl; }
Type::Enum IfcControl::Class() { return Type::IfcControl; }
IfcControl::IfcControl(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcControl) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcControl::IfcControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcControllerType
IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerType::PredefinedType() const { return IfcControllerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcControllerType::setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcControllerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcControllerType::is(Type::Enum v) const { return v == Type::IfcControllerType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcControllerType::type() const { return Type::IfcControllerType; }
Type::Enum IfcControllerType::Class() { return Type::IfcControllerType; }
IfcControllerType::IfcControllerType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcControllerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcControllerType::IfcControllerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcControllerTypeEnum::IfcControllerTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcControllerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcConversionBasedUnit
std::string IfcConversionBasedUnit::Name() const { return *entity->getArgument(2); }
void IfcConversionBasedUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcMeasureWithUnit* IfcConversionBasedUnit::ConversionFactor() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcConversionBasedUnit::setConversionFactor(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcConversionBasedUnit::is(Type::Enum v) const { return v == Type::IfcConversionBasedUnit || IfcNamedUnit::is(v); }
Type::Enum IfcConversionBasedUnit::type() const { return Type::IfcConversionBasedUnit; }
Type::Enum IfcConversionBasedUnit::Class() { return Type::IfcConversionBasedUnit; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcConversionBasedUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor) : IfcNamedUnit((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ConversionFactor));entity->setArgument(3,attr);} }

// Function implementations for IfcCooledBeamType
IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamType::PredefinedType() const { return IfcCooledBeamTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCooledBeamType::setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCooledBeamTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCooledBeamType::is(Type::Enum v) const { return v == Type::IfcCooledBeamType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCooledBeamType::type() const { return Type::IfcCooledBeamType; }
Type::Enum IfcCooledBeamType::Class() { return Type::IfcCooledBeamType; }
IfcCooledBeamType::IfcCooledBeamType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCooledBeamType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCooledBeamType::IfcCooledBeamType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCooledBeamTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCoolingTowerType
IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerType::PredefinedType() const { return IfcCoolingTowerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoolingTowerType::setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoolingTowerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCoolingTowerType::is(Type::Enum v) const { return v == Type::IfcCoolingTowerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCoolingTowerType::type() const { return Type::IfcCoolingTowerType; }
Type::Enum IfcCoolingTowerType::Class() { return Type::IfcCoolingTowerType; }
IfcCoolingTowerType::IfcCoolingTowerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCoolingTowerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoolingTowerType::IfcCoolingTowerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoolingTowerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCoordinatedUniversalTimeOffset
int IfcCoordinatedUniversalTimeOffset::HourOffset() const { return *entity->getArgument(0); }
void IfcCoordinatedUniversalTimeOffset::setHourOffset(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcCoordinatedUniversalTimeOffset::hasMinuteOffset() const { return !entity->getArgument(1)->isNull(); }
int IfcCoordinatedUniversalTimeOffset::MinuteOffset() const { return *entity->getArgument(1); }
void IfcCoordinatedUniversalTimeOffset::setMinuteOffset(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcAheadOrBehind::IfcAheadOrBehind IfcCoordinatedUniversalTimeOffset::Sense() const { return IfcAheadOrBehind::FromString(*entity->getArgument(2)); }
void IfcCoordinatedUniversalTimeOffset::setSense(IfcAheadOrBehind::IfcAheadOrBehind v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAheadOrBehind::ToString(v)));entity->setArgument(2,attr);} }
bool IfcCoordinatedUniversalTimeOffset::is(Type::Enum v) const { return v == Type::IfcCoordinatedUniversalTimeOffset; }
Type::Enum IfcCoordinatedUniversalTimeOffset::type() const { return Type::IfcCoordinatedUniversalTimeOffset; }
Type::Enum IfcCoordinatedUniversalTimeOffset::Class() { return Type::IfcCoordinatedUniversalTimeOffset; }
IfcCoordinatedUniversalTimeOffset::IfcCoordinatedUniversalTimeOffset(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCoordinatedUniversalTimeOffset) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoordinatedUniversalTimeOffset::IfcCoordinatedUniversalTimeOffset(int v1_HourOffset, boost::optional< int > v2_MinuteOffset, IfcAheadOrBehind::IfcAheadOrBehind v3_Sense) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HourOffset));entity->setArgument(0,attr);} if (v2_MinuteOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MinuteOffset));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Sense,IfcAheadOrBehind::ToString(v3_Sense))));entity->setArgument(2,attr);} }

// Function implementations for IfcCostItem
bool IfcCostItem::is(Type::Enum v) const { return v == Type::IfcCostItem || IfcControl::is(v); }
Type::Enum IfcCostItem::type() const { return Type::IfcCostItem; }
Type::Enum IfcCostItem::Class() { return Type::IfcCostItem; }
IfcCostItem::IfcCostItem(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCostItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostItem::IfcCostItem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcCostSchedule
bool IfcCostSchedule::hasSubmittedBy() const { return !entity->getArgument(5)->isNull(); }
IfcActorSelect* IfcCostSchedule::SubmittedBy() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcCostSchedule::setSubmittedBy(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcCostSchedule::hasPreparedBy() const { return !entity->getArgument(6)->isNull(); }
IfcActorSelect* IfcCostSchedule::PreparedBy() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcCostSchedule::setPreparedBy(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcCostSchedule::hasSubmittedOn() const { return !entity->getArgument(7)->isNull(); }
IfcDateTimeSelect* IfcCostSchedule::SubmittedOn() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcCostSchedule::setSubmittedOn(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcCostSchedule::hasStatus() const { return !entity->getArgument(8)->isNull(); }
std::string IfcCostSchedule::Status() const { return *entity->getArgument(8); }
void IfcCostSchedule::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcCostSchedule::hasTargetUsers() const { return !entity->getArgument(9)->isNull(); }
IfcEntityList::ptr IfcCostSchedule::TargetUsers() const { return *entity->getArgument(9); }
void IfcCostSchedule::setTargetUsers(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcCostSchedule::hasUpdateDate() const { return !entity->getArgument(10)->isNull(); }
IfcDateTimeSelect* IfcCostSchedule::UpdateDate() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcCostSchedule::setUpdateDate(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
std::string IfcCostSchedule::ID() const { return *entity->getArgument(11); }
void IfcCostSchedule::setID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostSchedule::PredefinedType() const { return IfcCostScheduleTypeEnum::FromString(*entity->getArgument(12)); }
void IfcCostSchedule::setPredefinedType(IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCostScheduleTypeEnum::ToString(v)));entity->setArgument(12,attr);} }
bool IfcCostSchedule::is(Type::Enum v) const { return v == Type::IfcCostSchedule || IfcControl::is(v); }
Type::Enum IfcCostSchedule::type() const { return Type::IfcCostSchedule; }
Type::Enum IfcCostSchedule::Class() { return Type::IfcCostSchedule; }
IfcCostSchedule::IfcCostSchedule(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCostSchedule) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostSchedule::IfcCostSchedule(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_SubmittedBy, IfcActorSelect* v7_PreparedBy, IfcDateTimeSelect* v8_SubmittedOn, boost::optional< std::string > v9_Status, boost::optional< IfcEntityList::ptr > v10_TargetUsers, IfcDateTimeSelect* v11_UpdateDate, std::string v12_ID, IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v13_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_SubmittedBy));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_PreparedBy));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_SubmittedOn));entity->setArgument(7,attr);} if (v9_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Status));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_TargetUsers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TargetUsers));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_UpdateDate));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_ID));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v13_PredefinedType,IfcCostScheduleTypeEnum::ToString(v13_PredefinedType))));entity->setArgument(12,attr);} }

// Function implementations for IfcCostValue
std::string IfcCostValue::CostType() const { return *entity->getArgument(6); }
void IfcCostValue::setCostType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcCostValue::hasCondition() const { return !entity->getArgument(7)->isNull(); }
std::string IfcCostValue::Condition() const { return *entity->getArgument(7); }
void IfcCostValue::setCondition(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcCostValue::is(Type::Enum v) const { return v == Type::IfcCostValue || IfcAppliedValue::is(v); }
Type::Enum IfcCostValue::type() const { return Type::IfcCostValue; }
Type::Enum IfcCostValue::Class() { return Type::IfcCostValue; }
IfcCostValue::IfcCostValue(IfcEntityInstanceData* e) : IfcAppliedValue((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCostValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostValue::IfcCostValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_CostType, boost::optional< std::string > v8_Condition) : IfcAppliedValue((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CostType));entity->setArgument(6,attr);} if (v8_Condition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Condition));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcCovering
bool IfcCovering::hasPredefinedType() const { return !entity->getArgument(8)->isNull(); }
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCovering::PredefinedType() const { return IfcCoveringTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCovering::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoveringTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcRelCoversSpaces::list::ptr IfcCovering::CoversSpaces() const { return entity->getInverse(Type::IfcRelCoversSpaces, 5)->as<IfcRelCoversSpaces>(); }
IfcRelCoversBldgElements::list::ptr IfcCovering::Covers() const { return entity->getInverse(Type::IfcRelCoversBldgElements, 5)->as<IfcRelCoversBldgElements>(); }
bool IfcCovering::is(Type::Enum v) const { return v == Type::IfcCovering || IfcBuildingElement::is(v); }
Type::Enum IfcCovering::type() const { return Type::IfcCovering; }
Type::Enum IfcCovering::Class() { return Type::IfcCovering; }
IfcCovering::IfcCovering(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCovering) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCovering::IfcCovering(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoveringTypeEnum::IfcCoveringTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcCoveringTypeEnum::ToString(*v9_PredefinedType))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcCoveringType
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringType::PredefinedType() const { return IfcCoveringTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoveringType::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCoveringTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCoveringType::is(Type::Enum v) const { return v == Type::IfcCoveringType || IfcBuildingElementType::is(v); }
Type::Enum IfcCoveringType::type() const { return Type::IfcCoveringType; }
Type::Enum IfcCoveringType::Class() { return Type::IfcCoveringType; }
IfcCoveringType::IfcCoveringType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCoveringType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoveringType::IfcCoveringType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoveringTypeEnum::IfcCoveringTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCoveringTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCraneRailAShapeProfileDef
double IfcCraneRailAShapeProfileDef::OverallHeight() const { return *entity->getArgument(3); }
void IfcCraneRailAShapeProfileDef::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcCraneRailAShapeProfileDef::BaseWidth2() const { return *entity->getArgument(4); }
void IfcCraneRailAShapeProfileDef::setBaseWidth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCraneRailAShapeProfileDef::hasRadius() const { return !entity->getArgument(5)->isNull(); }
double IfcCraneRailAShapeProfileDef::Radius() const { return *entity->getArgument(5); }
void IfcCraneRailAShapeProfileDef::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcCraneRailAShapeProfileDef::HeadWidth() const { return *entity->getArgument(6); }
void IfcCraneRailAShapeProfileDef::setHeadWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
double IfcCraneRailAShapeProfileDef::HeadDepth2() const { return *entity->getArgument(7); }
void IfcCraneRailAShapeProfileDef::setHeadDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
double IfcCraneRailAShapeProfileDef::HeadDepth3() const { return *entity->getArgument(8); }
void IfcCraneRailAShapeProfileDef::setHeadDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
double IfcCraneRailAShapeProfileDef::WebThickness() const { return *entity->getArgument(9); }
void IfcCraneRailAShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
double IfcCraneRailAShapeProfileDef::BaseWidth4() const { return *entity->getArgument(10); }
void IfcCraneRailAShapeProfileDef::setBaseWidth4(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
double IfcCraneRailAShapeProfileDef::BaseDepth1() const { return *entity->getArgument(11); }
void IfcCraneRailAShapeProfileDef::setBaseDepth1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
double IfcCraneRailAShapeProfileDef::BaseDepth2() const { return *entity->getArgument(12); }
void IfcCraneRailAShapeProfileDef::setBaseDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
double IfcCraneRailAShapeProfileDef::BaseDepth3() const { return *entity->getArgument(13); }
void IfcCraneRailAShapeProfileDef::setBaseDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcCraneRailAShapeProfileDef::hasCentreOfGravityInY() const { return !entity->getArgument(14)->isNull(); }
double IfcCraneRailAShapeProfileDef::CentreOfGravityInY() const { return *entity->getArgument(14); }
void IfcCraneRailAShapeProfileDef::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcCraneRailAShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcCraneRailAShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCraneRailAShapeProfileDef::type() const { return Type::IfcCraneRailAShapeProfileDef; }
Type::Enum IfcCraneRailAShapeProfileDef::Class() { return Type::IfcCraneRailAShapeProfileDef; }
IfcCraneRailAShapeProfileDef::IfcCraneRailAShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCraneRailAShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCraneRailAShapeProfileDef::IfcCraneRailAShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_BaseWidth2, boost::optional< double > v6_Radius, double v7_HeadWidth, double v8_HeadDepth2, double v9_HeadDepth3, double v10_WebThickness, double v11_BaseWidth4, double v12_BaseDepth1, double v13_BaseDepth2, double v14_BaseDepth3, boost::optional< double > v15_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallHeight));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_BaseWidth2));entity->setArgument(4,attr);} if (v6_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Radius));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_HeadWidth));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_HeadDepth2));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_HeadDepth3));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_WebThickness));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseWidth4));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_BaseDepth1));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_BaseDepth2));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_BaseDepth3));entity->setArgument(13,attr);} if (v15_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_CentreOfGravityInY));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } }

// Function implementations for IfcCraneRailFShapeProfileDef
double IfcCraneRailFShapeProfileDef::OverallHeight() const { return *entity->getArgument(3); }
void IfcCraneRailFShapeProfileDef::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcCraneRailFShapeProfileDef::HeadWidth() const { return *entity->getArgument(4); }
void IfcCraneRailFShapeProfileDef::setHeadWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCraneRailFShapeProfileDef::hasRadius() const { return !entity->getArgument(5)->isNull(); }
double IfcCraneRailFShapeProfileDef::Radius() const { return *entity->getArgument(5); }
void IfcCraneRailFShapeProfileDef::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcCraneRailFShapeProfileDef::HeadDepth2() const { return *entity->getArgument(6); }
void IfcCraneRailFShapeProfileDef::setHeadDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
double IfcCraneRailFShapeProfileDef::HeadDepth3() const { return *entity->getArgument(7); }
void IfcCraneRailFShapeProfileDef::setHeadDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
double IfcCraneRailFShapeProfileDef::WebThickness() const { return *entity->getArgument(8); }
void IfcCraneRailFShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
double IfcCraneRailFShapeProfileDef::BaseDepth1() const { return *entity->getArgument(9); }
void IfcCraneRailFShapeProfileDef::setBaseDepth1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
double IfcCraneRailFShapeProfileDef::BaseDepth2() const { return *entity->getArgument(10); }
void IfcCraneRailFShapeProfileDef::setBaseDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcCraneRailFShapeProfileDef::hasCentreOfGravityInY() const { return !entity->getArgument(11)->isNull(); }
double IfcCraneRailFShapeProfileDef::CentreOfGravityInY() const { return *entity->getArgument(11); }
void IfcCraneRailFShapeProfileDef::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcCraneRailFShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcCraneRailFShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCraneRailFShapeProfileDef::type() const { return Type::IfcCraneRailFShapeProfileDef; }
Type::Enum IfcCraneRailFShapeProfileDef::Class() { return Type::IfcCraneRailFShapeProfileDef; }
IfcCraneRailFShapeProfileDef::IfcCraneRailFShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCraneRailFShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCraneRailFShapeProfileDef::IfcCraneRailFShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_HeadWidth, boost::optional< double > v6_Radius, double v7_HeadDepth2, double v8_HeadDepth3, double v9_WebThickness, double v10_BaseDepth1, double v11_BaseDepth2, boost::optional< double > v12_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallHeight));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HeadWidth));entity->setArgument(4,attr);} if (v6_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Radius));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_HeadDepth2));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_HeadDepth3));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_WebThickness));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseDepth1));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseDepth2));entity->setArgument(10,attr);} if (v12_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CentreOfGravityInY));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } }

// Function implementations for IfcCrewResource
bool IfcCrewResource::is(Type::Enum v) const { return v == Type::IfcCrewResource || IfcConstructionResource::is(v); }
Type::Enum IfcCrewResource::type() const { return Type::IfcCrewResource; }
Type::Enum IfcCrewResource::Class() { return Type::IfcCrewResource; }
IfcCrewResource::IfcCrewResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCrewResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCrewResource::IfcCrewResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} }

// Function implementations for IfcCsgPrimitive3D
IfcAxis2Placement3D* IfcCsgPrimitive3D::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcCsgPrimitive3D::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcCsgPrimitive3D::is(Type::Enum v) const { return v == Type::IfcCsgPrimitive3D || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCsgPrimitive3D::type() const { return Type::IfcCsgPrimitive3D; }
Type::Enum IfcCsgPrimitive3D::Class() { return Type::IfcCsgPrimitive3D; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCsgPrimitive3D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcAxis2Placement3D* v1_Position) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);} }

// Function implementations for IfcCsgSolid
IfcCsgSelect* IfcCsgSolid::TreeRootExpression() const { return (IfcCsgSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcCsgSolid::setTreeRootExpression(IfcCsgSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcCsgSolid::is(Type::Enum v) const { return v == Type::IfcCsgSolid || IfcSolidModel::is(v); }
Type::Enum IfcCsgSolid::type() const { return Type::IfcCsgSolid; }
Type::Enum IfcCsgSolid::Class() { return Type::IfcCsgSolid; }
IfcCsgSolid::IfcCsgSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCsgSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCsgSolid::IfcCsgSolid(IfcCsgSelect* v1_TreeRootExpression) : IfcSolidModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TreeRootExpression));entity->setArgument(0,attr);} }

// Function implementations for IfcCurrencyRelationship
IfcMonetaryUnit* IfcCurrencyRelationship::RelatingMonetaryUnit() const { return (IfcMonetaryUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcCurrencyRelationship::setRelatingMonetaryUnit(IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcMonetaryUnit* IfcCurrencyRelationship::RelatedMonetaryUnit() const { return (IfcMonetaryUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcCurrencyRelationship::setRelatedMonetaryUnit(IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcCurrencyRelationship::ExchangeRate() const { return *entity->getArgument(2); }
void IfcCurrencyRelationship::setExchangeRate(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcDateAndTime* IfcCurrencyRelationship::RateDateTime() const { return (IfcDateAndTime*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcCurrencyRelationship::setRateDateTime(IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCurrencyRelationship::hasRateSource() const { return !entity->getArgument(4)->isNull(); }
IfcLibraryInformation* IfcCurrencyRelationship::RateSource() const { return (IfcLibraryInformation*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcCurrencyRelationship::setRateSource(IfcLibraryInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcCurrencyRelationship::is(Type::Enum v) const { return v == Type::IfcCurrencyRelationship; }
Type::Enum IfcCurrencyRelationship::type() const { return Type::IfcCurrencyRelationship; }
Type::Enum IfcCurrencyRelationship::Class() { return Type::IfcCurrencyRelationship; }
IfcCurrencyRelationship::IfcCurrencyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCurrencyRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurrencyRelationship::IfcCurrencyRelationship(IfcMonetaryUnit* v1_RelatingMonetaryUnit, IfcMonetaryUnit* v2_RelatedMonetaryUnit, double v3_ExchangeRate, IfcDateAndTime* v4_RateDateTime, IfcLibraryInformation* v5_RateSource) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingMonetaryUnit));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedMonetaryUnit));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExchangeRate));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RateDateTime));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RateSource));entity->setArgument(4,attr);} }

// Function implementations for IfcCurtainWall
bool IfcCurtainWall::is(Type::Enum v) const { return v == Type::IfcCurtainWall || IfcBuildingElement::is(v); }
Type::Enum IfcCurtainWall::type() const { return Type::IfcCurtainWall; }
Type::Enum IfcCurtainWall::Class() { return Type::IfcCurtainWall; }
IfcCurtainWall::IfcCurtainWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCurtainWall) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurtainWall::IfcCurtainWall(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcCurtainWallType
IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallType::PredefinedType() const { return IfcCurtainWallTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCurtainWallType::setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCurtainWallTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcCurtainWallType::is(Type::Enum v) const { return v == Type::IfcCurtainWallType || IfcBuildingElementType::is(v); }
Type::Enum IfcCurtainWallType::type() const { return Type::IfcCurtainWallType; }
Type::Enum IfcCurtainWallType::Class() { return Type::IfcCurtainWallType; }
IfcCurtainWallType::IfcCurtainWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCurtainWallType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurtainWallType::IfcCurtainWallType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcCurtainWallTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcCurve
bool IfcCurve::is(Type::Enum v) const { return v == Type::IfcCurve || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCurve::type() const { return Type::IfcCurve; }
Type::Enum IfcCurve::Class() { return Type::IfcCurve; }
IfcCurve::IfcCurve(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurve::IfcCurve() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcCurveBoundedPlane
IfcPlane* IfcCurveBoundedPlane::BasisSurface() const { return (IfcPlane*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcCurveBoundedPlane::setBasisSurface(IfcPlane* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcCurve* IfcCurveBoundedPlane::OuterBoundary() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcCurveBoundedPlane::setOuterBoundary(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcCurve >::ptr IfcCurveBoundedPlane::InnerBoundaries() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcCurve>(); }
void IfcCurveBoundedPlane::setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
bool IfcCurveBoundedPlane::is(Type::Enum v) const { return v == Type::IfcCurveBoundedPlane || IfcBoundedSurface::is(v); }
Type::Enum IfcCurveBoundedPlane::type() const { return Type::IfcCurveBoundedPlane; }
Type::Enum IfcCurveBoundedPlane::Class() { return Type::IfcCurveBoundedPlane; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCurveBoundedPlane) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcPlane* v1_BasisSurface, IfcCurve* v2_OuterBoundary, IfcTemplatedEntityList< IfcCurve >::ptr v3_InnerBoundaries) : IfcBoundedSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OuterBoundary));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_InnerBoundaries)->generalize());entity->setArgument(2,attr);} }

// Function implementations for IfcCurveStyle
bool IfcCurveStyle::hasCurveFont() const { return !entity->getArgument(1)->isNull(); }
IfcCurveFontOrScaledCurveFontSelect* IfcCurveStyle::CurveFont() const { return (IfcCurveFontOrScaledCurveFontSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcCurveStyle::setCurveFont(IfcCurveFontOrScaledCurveFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcCurveStyle::hasCurveWidth() const { return !entity->getArgument(2)->isNull(); }
IfcSizeSelect* IfcCurveStyle::CurveWidth() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcCurveStyle::setCurveWidth(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcCurveStyle::hasCurveColour() const { return !entity->getArgument(3)->isNull(); }
IfcColour* IfcCurveStyle::CurveColour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcCurveStyle::setCurveColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcCurveStyle::is(Type::Enum v) const { return v == Type::IfcCurveStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcCurveStyle::type() const { return Type::IfcCurveStyle; }
Type::Enum IfcCurveStyle::Class() { return Type::IfcCurveStyle; }
IfcCurveStyle::IfcCurveStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcCurveStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyle::IfcCurveStyle(boost::optional< std::string > v1_Name, IfcCurveFontOrScaledCurveFontSelect* v2_CurveFont, IfcSizeSelect* v3_CurveWidth, IfcColour* v4_CurveColour) : IfcPresentationStyle((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveWidth));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CurveColour));entity->setArgument(3,attr);} }

// Function implementations for IfcCurveStyleFont
bool IfcCurveStyleFont::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcCurveStyleFont::Name() const { return *entity->getArgument(0); }
void IfcCurveStyleFont::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr IfcCurveStyleFont::PatternList() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcCurveStyleFontPattern>(); }
void IfcCurveStyleFont::setPatternList(IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcCurveStyleFont::is(Type::Enum v) const { return v == Type::IfcCurveStyleFont; }
Type::Enum IfcCurveStyleFont::type() const { return Type::IfcCurveStyleFont; }
Type::Enum IfcCurveStyleFont::Class() { return Type::IfcCurveStyleFont; }
IfcCurveStyleFont::IfcCurveStyleFont(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCurveStyleFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFont::IfcCurveStyleFont(boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v2_PatternList) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PatternList)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcCurveStyleFontAndScaling
bool IfcCurveStyleFontAndScaling::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcCurveStyleFontAndScaling::Name() const { return *entity->getArgument(0); }
void IfcCurveStyleFontAndScaling::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcCurveStyleFontSelect* IfcCurveStyleFontAndScaling::CurveFont() const { return (IfcCurveStyleFontSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcCurveStyleFontAndScaling::setCurveFont(IfcCurveStyleFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcCurveStyleFontAndScaling::CurveFontScaling() const { return *entity->getArgument(2); }
void IfcCurveStyleFontAndScaling::setCurveFontScaling(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcCurveStyleFontAndScaling::is(Type::Enum v) const { return v == Type::IfcCurveStyleFontAndScaling; }
Type::Enum IfcCurveStyleFontAndScaling::type() const { return Type::IfcCurveStyleFontAndScaling; }
Type::Enum IfcCurveStyleFontAndScaling::Class() { return Type::IfcCurveStyleFontAndScaling; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCurveStyleFontAndScaling) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(boost::optional< std::string > v1_Name, IfcCurveStyleFontSelect* v2_CurveFont, double v3_CurveFontScaling) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveFontScaling));entity->setArgument(2,attr);} }

// Function implementations for IfcCurveStyleFontPattern
double IfcCurveStyleFontPattern::VisibleSegmentLength() const { return *entity->getArgument(0); }
void IfcCurveStyleFontPattern::setVisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcCurveStyleFontPattern::InvisibleSegmentLength() const { return *entity->getArgument(1); }
void IfcCurveStyleFontPattern::setInvisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcCurveStyleFontPattern::is(Type::Enum v) const { return v == Type::IfcCurveStyleFontPattern; }
Type::Enum IfcCurveStyleFontPattern::type() const { return Type::IfcCurveStyleFontPattern; }
Type::Enum IfcCurveStyleFontPattern::Class() { return Type::IfcCurveStyleFontPattern; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcCurveStyleFontPattern) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(double v1_VisibleSegmentLength, double v2_InvisibleSegmentLength) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VisibleSegmentLength));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_InvisibleSegmentLength));entity->setArgument(1,attr);} }

// Function implementations for IfcDamperType
IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperType::PredefinedType() const { return IfcDamperTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDamperType::setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDamperTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDamperType::is(Type::Enum v) const { return v == Type::IfcDamperType || IfcFlowControllerType::is(v); }
Type::Enum IfcDamperType::type() const { return Type::IfcDamperType; }
Type::Enum IfcDamperType::Class() { return Type::IfcDamperType; }
IfcDamperType::IfcDamperType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDamperType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDamperType::IfcDamperType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDamperTypeEnum::IfcDamperTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDamperTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcDateAndTime
IfcCalendarDate* IfcDateAndTime::DateComponent() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcDateAndTime::setDateComponent(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcLocalTime* IfcDateAndTime::TimeComponent() const { return (IfcLocalTime*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcDateAndTime::setTimeComponent(IfcLocalTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcDateAndTime::is(Type::Enum v) const { return v == Type::IfcDateAndTime; }
Type::Enum IfcDateAndTime::type() const { return Type::IfcDateAndTime; }
Type::Enum IfcDateAndTime::Class() { return Type::IfcDateAndTime; }
IfcDateAndTime::IfcDateAndTime(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDateAndTime) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDateAndTime::IfcDateAndTime(IfcCalendarDate* v1_DateComponent, IfcLocalTime* v2_TimeComponent) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DateComponent));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TimeComponent));entity->setArgument(1,attr);} }

// Function implementations for IfcDefinedSymbol
IfcDefinedSymbolSelect* IfcDefinedSymbol::Definition() const { return (IfcDefinedSymbolSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcDefinedSymbol::setDefinition(IfcDefinedSymbolSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcCartesianTransformationOperator2D* IfcDefinedSymbol::Target() const { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcDefinedSymbol::setTarget(IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcDefinedSymbol::is(Type::Enum v) const { return v == Type::IfcDefinedSymbol || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcDefinedSymbol::type() const { return Type::IfcDefinedSymbol; }
Type::Enum IfcDefinedSymbol::Class() { return Type::IfcDefinedSymbol; }
IfcDefinedSymbol::IfcDefinedSymbol(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDefinedSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDefinedSymbol::IfcDefinedSymbol(IfcDefinedSymbolSelect* v1_Definition, IfcCartesianTransformationOperator2D* v2_Target) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Definition));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Target));entity->setArgument(1,attr);} }

// Function implementations for IfcDerivedProfileDef
IfcProfileDef* IfcDerivedProfileDef::ParentProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcDerivedProfileDef::setParentProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcCartesianTransformationOperator2D* IfcDerivedProfileDef::Operator() const { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcDerivedProfileDef::setOperator(IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcDerivedProfileDef::hasLabel() const { return !entity->getArgument(4)->isNull(); }
std::string IfcDerivedProfileDef::Label() const { return *entity->getArgument(4); }
void IfcDerivedProfileDef::setLabel(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcDerivedProfileDef::is(Type::Enum v) const { return v == Type::IfcDerivedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcDerivedProfileDef::type() const { return Type::IfcDerivedProfileDef; }
Type::Enum IfcDerivedProfileDef::Class() { return Type::IfcDerivedProfileDef; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDerivedProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< std::string > v5_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentProfile));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Operator));entity->setArgument(3,attr);} if (v5_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Label));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcDerivedUnit
IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr IfcDerivedUnit::Elements() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcDerivedUnitElement>(); }
void IfcDerivedUnit::setElements(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnit::UnitType() const { return IfcDerivedUnitEnum::FromString(*entity->getArgument(1)); }
void IfcDerivedUnit::setUnitType(IfcDerivedUnitEnum::IfcDerivedUnitEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDerivedUnitEnum::ToString(v)));entity->setArgument(1,attr);} }
bool IfcDerivedUnit::hasUserDefinedType() const { return !entity->getArgument(2)->isNull(); }
std::string IfcDerivedUnit::UserDefinedType() const { return *entity->getArgument(2); }
void IfcDerivedUnit::setUserDefinedType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcDerivedUnit::is(Type::Enum v) const { return v == Type::IfcDerivedUnit; }
Type::Enum IfcDerivedUnit::type() const { return Type::IfcDerivedUnit; }
Type::Enum IfcDerivedUnit::Class() { return Type::IfcDerivedUnit; }
IfcDerivedUnit::IfcDerivedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDerivedUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedUnit::IfcDerivedUnit(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v1_Elements, IfcDerivedUnitEnum::IfcDerivedUnitEnum v2_UnitType, boost::optional< std::string > v3_UserDefinedType) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcDerivedUnitEnum::ToString(v2_UnitType))));entity->setArgument(1,attr);} if (v3_UserDefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcDerivedUnitElement
IfcNamedUnit* IfcDerivedUnitElement::Unit() const { return (IfcNamedUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcDerivedUnitElement::setUnit(IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
int IfcDerivedUnitElement::Exponent() const { return *entity->getArgument(1); }
void IfcDerivedUnitElement::setExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcDerivedUnitElement::is(Type::Enum v) const { return v == Type::IfcDerivedUnitElement; }
Type::Enum IfcDerivedUnitElement::type() const { return Type::IfcDerivedUnitElement; }
Type::Enum IfcDerivedUnitElement::Class() { return Type::IfcDerivedUnitElement; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDerivedUnitElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcNamedUnit* v1_Unit, int v2_Exponent) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Unit));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Exponent));entity->setArgument(1,attr);} }

// Function implementations for IfcDiameterDimension
bool IfcDiameterDimension::is(Type::Enum v) const { return v == Type::IfcDiameterDimension || IfcDimensionCurveDirectedCallout::is(v); }
Type::Enum IfcDiameterDimension::type() const { return Type::IfcDiameterDimension; }
Type::Enum IfcDiameterDimension::Class() { return Type::IfcDiameterDimension; }
IfcDiameterDimension::IfcDiameterDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDiameterDimension) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDiameterDimension::IfcDiameterDimension(IfcEntityList::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcDimensionCalloutRelationship
bool IfcDimensionCalloutRelationship::is(Type::Enum v) const { return v == Type::IfcDimensionCalloutRelationship || IfcDraughtingCalloutRelationship::is(v); }
Type::Enum IfcDimensionCalloutRelationship::type() const { return Type::IfcDimensionCalloutRelationship; }
Type::Enum IfcDimensionCalloutRelationship::Class() { return Type::IfcDimensionCalloutRelationship; }
IfcDimensionCalloutRelationship::IfcDimensionCalloutRelationship(IfcEntityInstanceData* e) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDimensionCalloutRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionCalloutRelationship::IfcDimensionCalloutRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));entity->setArgument(3,attr);} }

// Function implementations for IfcDimensionCurve
IfcTerminatorSymbol::list::ptr IfcDimensionCurve::AnnotatedBySymbols() const { return entity->getInverse(Type::IfcTerminatorSymbol, 3)->as<IfcTerminatorSymbol>(); }
bool IfcDimensionCurve::is(Type::Enum v) const { return v == Type::IfcDimensionCurve || IfcAnnotationCurveOccurrence::is(v); }
Type::Enum IfcDimensionCurve::type() const { return Type::IfcDimensionCurve; }
Type::Enum IfcDimensionCurve::Class() { return Type::IfcDimensionCurve; }
IfcDimensionCurve::IfcDimensionCurve(IfcEntityInstanceData* e) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDimensionCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionCurve::IfcDimensionCurve(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcDimensionCurveDirectedCallout
bool IfcDimensionCurveDirectedCallout::is(Type::Enum v) const { return v == Type::IfcDimensionCurveDirectedCallout || IfcDraughtingCallout::is(v); }
Type::Enum IfcDimensionCurveDirectedCallout::type() const { return Type::IfcDimensionCurveDirectedCallout; }
Type::Enum IfcDimensionCurveDirectedCallout::Class() { return Type::IfcDimensionCurveDirectedCallout; }
IfcDimensionCurveDirectedCallout::IfcDimensionCurveDirectedCallout(IfcEntityInstanceData* e) : IfcDraughtingCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDimensionCurveDirectedCallout) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionCurveDirectedCallout::IfcDimensionCurveDirectedCallout(IfcEntityList::ptr v1_Contents) : IfcDraughtingCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcDimensionCurveTerminator
IfcDimensionExtentUsage::IfcDimensionExtentUsage IfcDimensionCurveTerminator::Role() const { return IfcDimensionExtentUsage::FromString(*entity->getArgument(4)); }
void IfcDimensionCurveTerminator::setRole(IfcDimensionExtentUsage::IfcDimensionExtentUsage v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDimensionExtentUsage::ToString(v)));entity->setArgument(4,attr);} }
bool IfcDimensionCurveTerminator::is(Type::Enum v) const { return v == Type::IfcDimensionCurveTerminator || IfcTerminatorSymbol::is(v); }
Type::Enum IfcDimensionCurveTerminator::type() const { return Type::IfcDimensionCurveTerminator; }
Type::Enum IfcDimensionCurveTerminator::Class() { return Type::IfcDimensionCurveTerminator; }
IfcDimensionCurveTerminator::IfcDimensionCurveTerminator(IfcEntityInstanceData* e) : IfcTerminatorSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDimensionCurveTerminator) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionCurveTerminator::IfcDimensionCurveTerminator(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcAnnotationCurveOccurrence* v4_AnnotatedCurve, IfcDimensionExtentUsage::IfcDimensionExtentUsage v5_Role) : IfcTerminatorSymbol((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AnnotatedCurve));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_Role,IfcDimensionExtentUsage::ToString(v5_Role))));entity->setArgument(4,attr);} }

// Function implementations for IfcDimensionPair
bool IfcDimensionPair::is(Type::Enum v) const { return v == Type::IfcDimensionPair || IfcDraughtingCalloutRelationship::is(v); }
Type::Enum IfcDimensionPair::type() const { return Type::IfcDimensionPair; }
Type::Enum IfcDimensionPair::Class() { return Type::IfcDimensionPair; }
IfcDimensionPair::IfcDimensionPair(IfcEntityInstanceData* e) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDimensionPair) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionPair::IfcDimensionPair(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));entity->setArgument(3,attr);} }

// Function implementations for IfcDimensionalExponents
int IfcDimensionalExponents::LengthExponent() const { return *entity->getArgument(0); }
void IfcDimensionalExponents::setLengthExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
int IfcDimensionalExponents::MassExponent() const { return *entity->getArgument(1); }
void IfcDimensionalExponents::setMassExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
int IfcDimensionalExponents::TimeExponent() const { return *entity->getArgument(2); }
void IfcDimensionalExponents::setTimeExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
int IfcDimensionalExponents::ElectricCurrentExponent() const { return *entity->getArgument(3); }
void IfcDimensionalExponents::setElectricCurrentExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
int IfcDimensionalExponents::ThermodynamicTemperatureExponent() const { return *entity->getArgument(4); }
void IfcDimensionalExponents::setThermodynamicTemperatureExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
int IfcDimensionalExponents::AmountOfSubstanceExponent() const { return *entity->getArgument(5); }
void IfcDimensionalExponents::setAmountOfSubstanceExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
int IfcDimensionalExponents::LuminousIntensityExponent() const { return *entity->getArgument(6); }
void IfcDimensionalExponents::setLuminousIntensityExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcDimensionalExponents::is(Type::Enum v) const { return v == Type::IfcDimensionalExponents; }
Type::Enum IfcDimensionalExponents::type() const { return Type::IfcDimensionalExponents; }
Type::Enum IfcDimensionalExponents::Class() { return Type::IfcDimensionalExponents; }
IfcDimensionalExponents::IfcDimensionalExponents(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDimensionalExponents) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionalExponents::IfcDimensionalExponents(int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LengthExponent));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MassExponent));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TimeExponent));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ElectricCurrentExponent));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ThermodynamicTemperatureExponent));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_AmountOfSubstanceExponent));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LuminousIntensityExponent));entity->setArgument(6,attr);} }

// Function implementations for IfcDirection
std::vector< double > /*[2:3]*/ IfcDirection::DirectionRatios() const { return *entity->getArgument(0); }
void IfcDirection::setDirectionRatios(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcDirection::is(Type::Enum v) const { return v == Type::IfcDirection || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcDirection::type() const { return Type::IfcDirection; }
Type::Enum IfcDirection::Class() { return Type::IfcDirection; }
IfcDirection::IfcDirection(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDirection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDirection::IfcDirection(std::vector< double > /*[2:3]*/ v1_DirectionRatios) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DirectionRatios));entity->setArgument(0,attr);} }

// Function implementations for IfcDiscreteAccessory
bool IfcDiscreteAccessory::is(Type::Enum v) const { return v == Type::IfcDiscreteAccessory || IfcElementComponent::is(v); }
Type::Enum IfcDiscreteAccessory::type() const { return Type::IfcDiscreteAccessory; }
Type::Enum IfcDiscreteAccessory::Class() { return Type::IfcDiscreteAccessory; }
IfcDiscreteAccessory::IfcDiscreteAccessory(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDiscreteAccessory) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDiscreteAccessory::IfcDiscreteAccessory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElementComponent((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcDiscreteAccessoryType
bool IfcDiscreteAccessoryType::is(Type::Enum v) const { return v == Type::IfcDiscreteAccessoryType || IfcElementComponentType::is(v); }
Type::Enum IfcDiscreteAccessoryType::type() const { return Type::IfcDiscreteAccessoryType; }
Type::Enum IfcDiscreteAccessoryType::Class() { return Type::IfcDiscreteAccessoryType; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDiscreteAccessoryType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementComponentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcDistributionChamberElement
bool IfcDistributionChamberElement::is(Type::Enum v) const { return v == Type::IfcDistributionChamberElement || IfcDistributionFlowElement::is(v); }
Type::Enum IfcDistributionChamberElement::type() const { return Type::IfcDistributionChamberElement; }
Type::Enum IfcDistributionChamberElement::Class() { return Type::IfcDistributionChamberElement; }
IfcDistributionChamberElement::IfcDistributionChamberElement(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionChamberElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionChamberElement::IfcDistributionChamberElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcDistributionChamberElementType
IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementType::PredefinedType() const { return IfcDistributionChamberElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDistributionChamberElementType::setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDistributionChamberElementTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDistributionChamberElementType::is(Type::Enum v) const { return v == Type::IfcDistributionChamberElementType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcDistributionChamberElementType::type() const { return Type::IfcDistributionChamberElementType; }
Type::Enum IfcDistributionChamberElementType::Class() { return Type::IfcDistributionChamberElementType; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionChamberElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v10_PredefinedType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDistributionChamberElementTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcDistributionControlElement
bool IfcDistributionControlElement::hasControlElementId() const { return !entity->getArgument(8)->isNull(); }
std::string IfcDistributionControlElement::ControlElementId() const { return *entity->getArgument(8); }
void IfcDistributionControlElement::setControlElementId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcRelFlowControlElements::list::ptr IfcDistributionControlElement::AssignedToFlowElement() const { return entity->getInverse(Type::IfcRelFlowControlElements, 4)->as<IfcRelFlowControlElements>(); }
bool IfcDistributionControlElement::is(Type::Enum v) const { return v == Type::IfcDistributionControlElement || IfcDistributionElement::is(v); }
Type::Enum IfcDistributionControlElement::type() const { return Type::IfcDistributionControlElement; }
Type::Enum IfcDistributionControlElement::Class() { return Type::IfcDistributionControlElement; }
IfcDistributionControlElement::IfcDistributionControlElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionControlElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionControlElement::IfcDistributionControlElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ControlElementId) : IfcDistributionElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ControlElementId) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ControlElementId));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcDistributionControlElementType
bool IfcDistributionControlElementType::is(Type::Enum v) const { return v == Type::IfcDistributionControlElementType || IfcDistributionElementType::is(v); }
Type::Enum IfcDistributionControlElementType::type() const { return Type::IfcDistributionControlElementType; }
Type::Enum IfcDistributionControlElementType::Class() { return Type::IfcDistributionControlElementType; }
IfcDistributionControlElementType::IfcDistributionControlElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionControlElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionControlElementType::IfcDistributionControlElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcDistributionElement
bool IfcDistributionElement::is(Type::Enum v) const { return v == Type::IfcDistributionElement || IfcElement::is(v); }
Type::Enum IfcDistributionElement::type() const { return Type::IfcDistributionElement; }
Type::Enum IfcDistributionElement::Class() { return Type::IfcDistributionElement; }
IfcDistributionElement::IfcDistributionElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionElement::IfcDistributionElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcDistributionElementType
bool IfcDistributionElementType::is(Type::Enum v) const { return v == Type::IfcDistributionElementType || IfcElementType::is(v); }
Type::Enum IfcDistributionElementType::type() const { return Type::IfcDistributionElementType; }
Type::Enum IfcDistributionElementType::Class() { return Type::IfcDistributionElementType; }
IfcDistributionElementType::IfcDistributionElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionElementType::IfcDistributionElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcDistributionFlowElement
IfcRelFlowControlElements::list::ptr IfcDistributionFlowElement::HasControlElements() const { return entity->getInverse(Type::IfcRelFlowControlElements, 5)->as<IfcRelFlowControlElements>(); }
bool IfcDistributionFlowElement::is(Type::Enum v) const { return v == Type::IfcDistributionFlowElement || IfcDistributionElement::is(v); }
Type::Enum IfcDistributionFlowElement::type() const { return Type::IfcDistributionFlowElement; }
Type::Enum IfcDistributionFlowElement::Class() { return Type::IfcDistributionFlowElement; }
IfcDistributionFlowElement::IfcDistributionFlowElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionFlowElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionFlowElement::IfcDistributionFlowElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcDistributionFlowElementType
bool IfcDistributionFlowElementType::is(Type::Enum v) const { return v == Type::IfcDistributionFlowElementType || IfcDistributionElementType::is(v); }
Type::Enum IfcDistributionFlowElementType::type() const { return Type::IfcDistributionFlowElementType; }
Type::Enum IfcDistributionFlowElementType::Class() { return Type::IfcDistributionFlowElementType; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionFlowElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcDistributionPort
bool IfcDistributionPort::hasFlowDirection() const { return !entity->getArgument(7)->isNull(); }
IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcDistributionPort::FlowDirection() const { return IfcFlowDirectionEnum::FromString(*entity->getArgument(7)); }
void IfcDistributionPort::setFlowDirection(IfcFlowDirectionEnum::IfcFlowDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowDirectionEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcDistributionPort::is(Type::Enum v) const { return v == Type::IfcDistributionPort || IfcPort::is(v); }
Type::Enum IfcDistributionPort::type() const { return Type::IfcDistributionPort; }
Type::Enum IfcDistributionPort::Class() { return Type::IfcDistributionPort; }
IfcDistributionPort::IfcDistributionPort(IfcEntityInstanceData* e) : IfcPort((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDistributionPort) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionPort::IfcDistributionPort(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcFlowDirectionEnum::IfcFlowDirectionEnum > v8_FlowDirection) : IfcPort((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_FlowDirection) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_FlowDirection,IfcFlowDirectionEnum::ToString(*v8_FlowDirection))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcDocumentElectronicFormat
bool IfcDocumentElectronicFormat::hasFileExtension() const { return !entity->getArgument(0)->isNull(); }
std::string IfcDocumentElectronicFormat::FileExtension() const { return *entity->getArgument(0); }
void IfcDocumentElectronicFormat::setFileExtension(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcDocumentElectronicFormat::hasMimeContentType() const { return !entity->getArgument(1)->isNull(); }
std::string IfcDocumentElectronicFormat::MimeContentType() const { return *entity->getArgument(1); }
void IfcDocumentElectronicFormat::setMimeContentType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcDocumentElectronicFormat::hasMimeSubtype() const { return !entity->getArgument(2)->isNull(); }
std::string IfcDocumentElectronicFormat::MimeSubtype() const { return *entity->getArgument(2); }
void IfcDocumentElectronicFormat::setMimeSubtype(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcDocumentElectronicFormat::is(Type::Enum v) const { return v == Type::IfcDocumentElectronicFormat; }
Type::Enum IfcDocumentElectronicFormat::type() const { return Type::IfcDocumentElectronicFormat; }
Type::Enum IfcDocumentElectronicFormat::Class() { return Type::IfcDocumentElectronicFormat; }
IfcDocumentElectronicFormat::IfcDocumentElectronicFormat(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDocumentElectronicFormat) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentElectronicFormat::IfcDocumentElectronicFormat(boost::optional< std::string > v1_FileExtension, boost::optional< std::string > v2_MimeContentType, boost::optional< std::string > v3_MimeSubtype) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_FileExtension) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_FileExtension));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_MimeContentType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MimeContentType));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_MimeSubtype) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_MimeSubtype));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcDocumentInformation
std::string IfcDocumentInformation::DocumentId() const { return *entity->getArgument(0); }
void IfcDocumentInformation::setDocumentId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::string IfcDocumentInformation::Name() const { return *entity->getArgument(1); }
void IfcDocumentInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcDocumentInformation::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcDocumentInformation::Description() const { return *entity->getArgument(2); }
void IfcDocumentInformation::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcDocumentInformation::hasDocumentReferences() const { return !entity->getArgument(3)->isNull(); }
IfcTemplatedEntityList< IfcDocumentReference >::ptr IfcDocumentInformation::DocumentReferences() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcDocumentReference>(); }
void IfcDocumentInformation::setDocumentReferences(IfcTemplatedEntityList< IfcDocumentReference >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcDocumentInformation::hasPurpose() const { return !entity->getArgument(4)->isNull(); }
std::string IfcDocumentInformation::Purpose() const { return *entity->getArgument(4); }
void IfcDocumentInformation::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcDocumentInformation::hasIntendedUse() const { return !entity->getArgument(5)->isNull(); }
std::string IfcDocumentInformation::IntendedUse() const { return *entity->getArgument(5); }
void IfcDocumentInformation::setIntendedUse(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcDocumentInformation::hasScope() const { return !entity->getArgument(6)->isNull(); }
std::string IfcDocumentInformation::Scope() const { return *entity->getArgument(6); }
void IfcDocumentInformation::setScope(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcDocumentInformation::hasRevision() const { return !entity->getArgument(7)->isNull(); }
std::string IfcDocumentInformation::Revision() const { return *entity->getArgument(7); }
void IfcDocumentInformation::setRevision(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcDocumentInformation::hasDocumentOwner() const { return !entity->getArgument(8)->isNull(); }
IfcActorSelect* IfcDocumentInformation::DocumentOwner() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcDocumentInformation::setDocumentOwner(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcDocumentInformation::hasEditors() const { return !entity->getArgument(9)->isNull(); }
IfcEntityList::ptr IfcDocumentInformation::Editors() const { return *entity->getArgument(9); }
void IfcDocumentInformation::setEditors(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcDocumentInformation::hasCreationTime() const { return !entity->getArgument(10)->isNull(); }
IfcDateAndTime* IfcDocumentInformation::CreationTime() const { return (IfcDateAndTime*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcDocumentInformation::setCreationTime(IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcDocumentInformation::hasLastRevisionTime() const { return !entity->getArgument(11)->isNull(); }
IfcDateAndTime* IfcDocumentInformation::LastRevisionTime() const { return (IfcDateAndTime*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcDocumentInformation::setLastRevisionTime(IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcDocumentInformation::hasElectronicFormat() const { return !entity->getArgument(12)->isNull(); }
IfcDocumentElectronicFormat* IfcDocumentInformation::ElectronicFormat() const { return (IfcDocumentElectronicFormat*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcDocumentInformation::setElectronicFormat(IfcDocumentElectronicFormat* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcDocumentInformation::hasValidFrom() const { return !entity->getArgument(13)->isNull(); }
IfcCalendarDate* IfcDocumentInformation::ValidFrom() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(13))); }
void IfcDocumentInformation::setValidFrom(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcDocumentInformation::hasValidUntil() const { return !entity->getArgument(14)->isNull(); }
IfcCalendarDate* IfcDocumentInformation::ValidUntil() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(14))); }
void IfcDocumentInformation::setValidUntil(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcDocumentInformation::hasConfidentiality() const { return !entity->getArgument(15)->isNull(); }
IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentInformation::Confidentiality() const { return IfcDocumentConfidentialityEnum::FromString(*entity->getArgument(15)); }
void IfcDocumentInformation::setConfidentiality(IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDocumentConfidentialityEnum::ToString(v)));entity->setArgument(15,attr);} }
bool IfcDocumentInformation::hasStatus() const { return !entity->getArgument(16)->isNull(); }
IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentInformation::Status() const { return IfcDocumentStatusEnum::FromString(*entity->getArgument(16)); }
void IfcDocumentInformation::setStatus(IfcDocumentStatusEnum::IfcDocumentStatusEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDocumentStatusEnum::ToString(v)));entity->setArgument(16,attr);} }
IfcDocumentInformationRelationship::list::ptr IfcDocumentInformation::IsPointedTo() const { return entity->getInverse(Type::IfcDocumentInformationRelationship, 1)->as<IfcDocumentInformationRelationship>(); }
IfcDocumentInformationRelationship::list::ptr IfcDocumentInformation::IsPointer() const { return entity->getInverse(Type::IfcDocumentInformationRelationship, 0)->as<IfcDocumentInformationRelationship>(); }
bool IfcDocumentInformation::is(Type::Enum v) const { return v == Type::IfcDocumentInformation; }
Type::Enum IfcDocumentInformation::type() const { return Type::IfcDocumentInformation; }
Type::Enum IfcDocumentInformation::Class() { return Type::IfcDocumentInformation; }
IfcDocumentInformation::IfcDocumentInformation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDocumentInformation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentInformation::IfcDocumentInformation(std::string v1_DocumentId, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcDocumentReference >::ptr > v4_DocumentReferences, boost::optional< std::string > v5_Purpose, boost::optional< std::string > v6_IntendedUse, boost::optional< std::string > v7_Scope, boost::optional< std::string > v8_Revision, IfcActorSelect* v9_DocumentOwner, boost::optional< IfcEntityList::ptr > v10_Editors, IfcDateAndTime* v11_CreationTime, IfcDateAndTime* v12_LastRevisionTime, IfcDocumentElectronicFormat* v13_ElectronicFormat, IfcCalendarDate* v14_ValidFrom, IfcCalendarDate* v15_ValidUntil, boost::optional< IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum > v16_Confidentiality, boost::optional< IfcDocumentStatusEnum::IfcDocumentStatusEnum > v17_Status) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DocumentId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));entity->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_DocumentReferences) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DocumentReferences)->generalize());entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Purpose));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_IntendedUse) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_IntendedUse));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_Scope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scope));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Revision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Revision));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_DocumentOwner));entity->setArgument(8,attr);} if (v10_Editors) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Editors));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CreationTime));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LastRevisionTime));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ElectronicFormat));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_ValidFrom));entity->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_ValidUntil));entity->setArgument(14,attr);} if (v16_Confidentiality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v16_Confidentiality,IfcDocumentConfidentialityEnum::ToString(*v16_Confidentiality))));entity->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(15, attr); } if (v17_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v17_Status,IfcDocumentStatusEnum::ToString(*v17_Status))));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } }

// Function implementations for IfcDocumentInformationRelationship
IfcDocumentInformation* IfcDocumentInformationRelationship::RelatingDocument() const { return (IfcDocumentInformation*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcDocumentInformationRelationship::setRelatingDocument(IfcDocumentInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcDocumentInformation >::ptr IfcDocumentInformationRelationship::RelatedDocuments() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcDocumentInformation>(); }
void IfcDocumentInformationRelationship::setRelatedDocuments(IfcTemplatedEntityList< IfcDocumentInformation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcDocumentInformationRelationship::hasRelationshipType() const { return !entity->getArgument(2)->isNull(); }
std::string IfcDocumentInformationRelationship::RelationshipType() const { return *entity->getArgument(2); }
void IfcDocumentInformationRelationship::setRelationshipType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcDocumentInformationRelationship::is(Type::Enum v) const { return v == Type::IfcDocumentInformationRelationship; }
Type::Enum IfcDocumentInformationRelationship::type() const { return Type::IfcDocumentInformationRelationship; }
Type::Enum IfcDocumentInformationRelationship::Class() { return Type::IfcDocumentInformationRelationship; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDocumentInformationRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(IfcDocumentInformation* v1_RelatingDocument, IfcTemplatedEntityList< IfcDocumentInformation >::ptr v2_RelatedDocuments, boost::optional< std::string > v3_RelationshipType) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingDocument));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedDocuments)->generalize());entity->setArgument(1,attr);} if (v3_RelationshipType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RelationshipType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcDocumentReference
IfcDocumentInformation::list::ptr IfcDocumentReference::ReferenceToDocument() const { return entity->getInverse(Type::IfcDocumentInformation, 3)->as<IfcDocumentInformation>(); }
bool IfcDocumentReference::is(Type::Enum v) const { return v == Type::IfcDocumentReference || IfcExternalReference::is(v); }
Type::Enum IfcDocumentReference::type() const { return Type::IfcDocumentReference; }
Type::Enum IfcDocumentReference::Class() { return Type::IfcDocumentReference; }
IfcDocumentReference::IfcDocumentReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDocumentReference) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentReference::IfcDocumentReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcDoor
bool IfcDoor::hasOverallHeight() const { return !entity->getArgument(8)->isNull(); }
double IfcDoor::OverallHeight() const { return *entity->getArgument(8); }
void IfcDoor::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcDoor::hasOverallWidth() const { return !entity->getArgument(9)->isNull(); }
double IfcDoor::OverallWidth() const { return *entity->getArgument(9); }
void IfcDoor::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcDoor::is(Type::Enum v) const { return v == Type::IfcDoor || IfcBuildingElement::is(v); }
Type::Enum IfcDoor::type() const { return Type::IfcDoor; }
Type::Enum IfcDoor::Class() { return Type::IfcDoor; }
IfcDoor::IfcDoor(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDoor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoor::IfcDoor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcDoorLiningProperties
bool IfcDoorLiningProperties::hasLiningDepth() const { return !entity->getArgument(4)->isNull(); }
double IfcDoorLiningProperties::LiningDepth() const { return *entity->getArgument(4); }
void IfcDoorLiningProperties::setLiningDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcDoorLiningProperties::hasLiningThickness() const { return !entity->getArgument(5)->isNull(); }
double IfcDoorLiningProperties::LiningThickness() const { return *entity->getArgument(5); }
void IfcDoorLiningProperties::setLiningThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcDoorLiningProperties::hasThresholdDepth() const { return !entity->getArgument(6)->isNull(); }
double IfcDoorLiningProperties::ThresholdDepth() const { return *entity->getArgument(6); }
void IfcDoorLiningProperties::setThresholdDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcDoorLiningProperties::hasThresholdThickness() const { return !entity->getArgument(7)->isNull(); }
double IfcDoorLiningProperties::ThresholdThickness() const { return *entity->getArgument(7); }
void IfcDoorLiningProperties::setThresholdThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcDoorLiningProperties::hasTransomThickness() const { return !entity->getArgument(8)->isNull(); }
double IfcDoorLiningProperties::TransomThickness() const { return *entity->getArgument(8); }
void IfcDoorLiningProperties::setTransomThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcDoorLiningProperties::hasTransomOffset() const { return !entity->getArgument(9)->isNull(); }
double IfcDoorLiningProperties::TransomOffset() const { return *entity->getArgument(9); }
void IfcDoorLiningProperties::setTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcDoorLiningProperties::hasLiningOffset() const { return !entity->getArgument(10)->isNull(); }
double IfcDoorLiningProperties::LiningOffset() const { return *entity->getArgument(10); }
void IfcDoorLiningProperties::setLiningOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcDoorLiningProperties::hasThresholdOffset() const { return !entity->getArgument(11)->isNull(); }
double IfcDoorLiningProperties::ThresholdOffset() const { return *entity->getArgument(11); }
void IfcDoorLiningProperties::setThresholdOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcDoorLiningProperties::hasCasingThickness() const { return !entity->getArgument(12)->isNull(); }
double IfcDoorLiningProperties::CasingThickness() const { return *entity->getArgument(12); }
void IfcDoorLiningProperties::setCasingThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcDoorLiningProperties::hasCasingDepth() const { return !entity->getArgument(13)->isNull(); }
double IfcDoorLiningProperties::CasingDepth() const { return *entity->getArgument(13); }
void IfcDoorLiningProperties::setCasingDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcDoorLiningProperties::hasShapeAspectStyle() const { return !entity->getArgument(14)->isNull(); }
IfcShapeAspect* IfcDoorLiningProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(14))); }
void IfcDoorLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcDoorLiningProperties::is(Type::Enum v) const { return v == Type::IfcDoorLiningProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcDoorLiningProperties::type() const { return Type::IfcDoorLiningProperties; }
Type::Enum IfcDoorLiningProperties::Class() { return Type::IfcDoorLiningProperties; }
IfcDoorLiningProperties::IfcDoorLiningProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDoorLiningProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorLiningProperties::IfcDoorLiningProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_ThresholdDepth, boost::optional< double > v8_ThresholdThickness, boost::optional< double > v9_TransomThickness, boost::optional< double > v10_TransomOffset, boost::optional< double > v11_LiningOffset, boost::optional< double > v12_ThresholdOffset, boost::optional< double > v13_CasingThickness, boost::optional< double > v14_CasingDepth, IfcShapeAspect* v15_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ThresholdDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ThresholdDepth));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ThresholdThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ThresholdThickness));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_TransomThickness));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_TransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TransomOffset));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_LiningOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LiningOffset));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_ThresholdOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ThresholdOffset));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_CasingThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_CasingThickness));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } if (v14_CasingDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_CasingDepth));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_ShapeAspectStyle));entity->setArgument(14,attr);} }

// Function implementations for IfcDoorPanelProperties
bool IfcDoorPanelProperties::hasPanelDepth() const { return !entity->getArgument(4)->isNull(); }
double IfcDoorPanelProperties::PanelDepth() const { return *entity->getArgument(4); }
void IfcDoorPanelProperties::setPanelDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelProperties::PanelOperation() const { return IfcDoorPanelOperationEnum::FromString(*entity->getArgument(5)); }
void IfcDoorPanelProperties::setPanelOperation(IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorPanelOperationEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcDoorPanelProperties::hasPanelWidth() const { return !entity->getArgument(6)->isNull(); }
double IfcDoorPanelProperties::PanelWidth() const { return *entity->getArgument(6); }
void IfcDoorPanelProperties::setPanelWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelProperties::PanelPosition() const { return IfcDoorPanelPositionEnum::FromString(*entity->getArgument(7)); }
void IfcDoorPanelProperties::setPanelPosition(IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorPanelPositionEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcDoorPanelProperties::hasShapeAspectStyle() const { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcDoorPanelProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcDoorPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcDoorPanelProperties::is(Type::Enum v) const { return v == Type::IfcDoorPanelProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcDoorPanelProperties::type() const { return Type::IfcDoorPanelProperties; }
Type::Enum IfcDoorPanelProperties::Class() { return Type::IfcDoorPanelProperties; }
IfcDoorPanelProperties::IfcDoorPanelProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDoorPanelProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorPanelProperties::IfcDoorPanelProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_PanelDepth, IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v6_PanelOperation, boost::optional< double > v7_PanelWidth, IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v8_PanelPosition, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_PanelDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PanelDepth));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelOperation,IfcDoorPanelOperationEnum::ToString(v6_PanelOperation))));entity->setArgument(5,attr);} if (v7_PanelWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_PanelWidth));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PanelPosition,IfcDoorPanelPositionEnum::ToString(v8_PanelPosition))));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));entity->setArgument(8,attr);} }

// Function implementations for IfcDoorStyle
IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyle::OperationType() const { return IfcDoorStyleOperationEnum::FromString(*entity->getArgument(8)); }
void IfcDoorStyle::setOperationType(IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorStyleOperationEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyle::ConstructionType() const { return IfcDoorStyleConstructionEnum::FromString(*entity->getArgument(9)); }
void IfcDoorStyle::setConstructionType(IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDoorStyleConstructionEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDoorStyle::ParameterTakesPrecedence() const { return *entity->getArgument(10); }
void IfcDoorStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcDoorStyle::Sizeable() const { return *entity->getArgument(11); }
void IfcDoorStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcDoorStyle::is(Type::Enum v) const { return v == Type::IfcDoorStyle || IfcTypeProduct::is(v); }
Type::Enum IfcDoorStyle::type() const { return Type::IfcDoorStyle; }
Type::Enum IfcDoorStyle::Class() { return Type::IfcDoorStyle; }
IfcDoorStyle::IfcDoorStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDoorStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorStyle::IfcDoorStyle(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v9_OperationType, IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_OperationType,IfcDoorStyleOperationEnum::ToString(v9_OperationType))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ConstructionType,IfcDoorStyleConstructionEnum::ToString(v10_ConstructionType))));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));entity->setArgument(11,attr);} }

// Function implementations for IfcDraughtingCallout
IfcEntityList::ptr IfcDraughtingCallout::Contents() const { return *entity->getArgument(0); }
void IfcDraughtingCallout::setContents(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcDraughtingCalloutRelationship::list::ptr IfcDraughtingCallout::IsRelatedFromCallout() const { return entity->getInverse(Type::IfcDraughtingCalloutRelationship, 3)->as<IfcDraughtingCalloutRelationship>(); }
IfcDraughtingCalloutRelationship::list::ptr IfcDraughtingCallout::IsRelatedToCallout() const { return entity->getInverse(Type::IfcDraughtingCalloutRelationship, 2)->as<IfcDraughtingCalloutRelationship>(); }
bool IfcDraughtingCallout::is(Type::Enum v) const { return v == Type::IfcDraughtingCallout || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcDraughtingCallout::type() const { return Type::IfcDraughtingCallout; }
Type::Enum IfcDraughtingCallout::Class() { return Type::IfcDraughtingCallout; }
IfcDraughtingCallout::IfcDraughtingCallout(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDraughtingCallout) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingCallout::IfcDraughtingCallout(IfcEntityList::ptr v1_Contents) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcDraughtingCalloutRelationship
bool IfcDraughtingCalloutRelationship::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcDraughtingCalloutRelationship::Name() const { return *entity->getArgument(0); }
void IfcDraughtingCalloutRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcDraughtingCalloutRelationship::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcDraughtingCalloutRelationship::Description() const { return *entity->getArgument(1); }
void IfcDraughtingCalloutRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcDraughtingCallout* IfcDraughtingCalloutRelationship::RelatingDraughtingCallout() const { return (IfcDraughtingCallout*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcDraughtingCalloutRelationship::setRelatingDraughtingCallout(IfcDraughtingCallout* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcDraughtingCallout* IfcDraughtingCalloutRelationship::RelatedDraughtingCallout() const { return (IfcDraughtingCallout*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcDraughtingCalloutRelationship::setRelatedDraughtingCallout(IfcDraughtingCallout* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcDraughtingCalloutRelationship::is(Type::Enum v) const { return v == Type::IfcDraughtingCalloutRelationship; }
Type::Enum IfcDraughtingCalloutRelationship::type() const { return Type::IfcDraughtingCalloutRelationship; }
Type::Enum IfcDraughtingCalloutRelationship::Class() { return Type::IfcDraughtingCalloutRelationship; }
IfcDraughtingCalloutRelationship::IfcDraughtingCalloutRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcDraughtingCalloutRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingCalloutRelationship::IfcDraughtingCalloutRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));entity->setArgument(3,attr);} }

// Function implementations for IfcDraughtingPreDefinedColour
bool IfcDraughtingPreDefinedColour::is(Type::Enum v) const { return v == Type::IfcDraughtingPreDefinedColour || IfcPreDefinedColour::is(v); }
Type::Enum IfcDraughtingPreDefinedColour::type() const { return Type::IfcDraughtingPreDefinedColour; }
Type::Enum IfcDraughtingPreDefinedColour::Class() { return Type::IfcDraughtingPreDefinedColour; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedColour((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDraughtingPreDefinedColour) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(std::string v1_Name) : IfcPreDefinedColour((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcDraughtingPreDefinedCurveFont
bool IfcDraughtingPreDefinedCurveFont::is(Type::Enum v) const { return v == Type::IfcDraughtingPreDefinedCurveFont || IfcPreDefinedCurveFont::is(v); }
Type::Enum IfcDraughtingPreDefinedCurveFont::type() const { return Type::IfcDraughtingPreDefinedCurveFont; }
Type::Enum IfcDraughtingPreDefinedCurveFont::Class() { return Type::IfcDraughtingPreDefinedCurveFont; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDraughtingPreDefinedCurveFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcDraughtingPreDefinedTextFont
bool IfcDraughtingPreDefinedTextFont::is(Type::Enum v) const { return v == Type::IfcDraughtingPreDefinedTextFont || IfcPreDefinedTextFont::is(v); }
Type::Enum IfcDraughtingPreDefinedTextFont::type() const { return Type::IfcDraughtingPreDefinedTextFont; }
Type::Enum IfcDraughtingPreDefinedTextFont::Class() { return Type::IfcDraughtingPreDefinedTextFont; }
IfcDraughtingPreDefinedTextFont::IfcDraughtingPreDefinedTextFont(IfcEntityInstanceData* e) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDraughtingPreDefinedTextFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingPreDefinedTextFont::IfcDraughtingPreDefinedTextFont(std::string v1_Name) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcDuctFittingType
IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingType::PredefinedType() const { return IfcDuctFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctFittingType::setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctFittingTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDuctFittingType::is(Type::Enum v) const { return v == Type::IfcDuctFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcDuctFittingType::type() const { return Type::IfcDuctFittingType; }
Type::Enum IfcDuctFittingType::Class() { return Type::IfcDuctFittingType; }
IfcDuctFittingType::IfcDuctFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDuctFittingType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctFittingType::IfcDuctFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctFittingTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcDuctSegmentType
IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentType::PredefinedType() const { return IfcDuctSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctSegmentType::setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSegmentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDuctSegmentType::is(Type::Enum v) const { return v == Type::IfcDuctSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcDuctSegmentType::type() const { return Type::IfcDuctSegmentType; }
Type::Enum IfcDuctSegmentType::Class() { return Type::IfcDuctSegmentType; }
IfcDuctSegmentType::IfcDuctSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDuctSegmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSegmentType::IfcDuctSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctSegmentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcDuctSilencerType
IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerType::PredefinedType() const { return IfcDuctSilencerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctSilencerType::setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDuctSilencerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcDuctSilencerType::is(Type::Enum v) const { return v == Type::IfcDuctSilencerType || IfcFlowTreatmentDeviceType::is(v); }
Type::Enum IfcDuctSilencerType::type() const { return Type::IfcDuctSilencerType; }
Type::Enum IfcDuctSilencerType::Class() { return Type::IfcDuctSilencerType; }
IfcDuctSilencerType::IfcDuctSilencerType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcDuctSilencerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSilencerType::IfcDuctSilencerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcDuctSilencerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcEdge
IfcVertex* IfcEdge::EdgeStart() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcEdge::setEdgeStart(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcVertex* IfcEdge::EdgeEnd() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcEdge::setEdgeEnd(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcEdge::is(Type::Enum v) const { return v == Type::IfcEdge || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcEdge::type() const { return Type::IfcEdge; }
Type::Enum IfcEdge::Class() { return Type::IfcEdge; }
IfcEdge::IfcEdge(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEdge) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdge::IfcEdge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));entity->setArgument(1,attr);} }

// Function implementations for IfcEdgeCurve
IfcCurve* IfcEdgeCurve::EdgeGeometry() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcEdgeCurve::setEdgeGeometry(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcEdgeCurve::SameSense() const { return *entity->getArgument(3); }
void IfcEdgeCurve::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcEdgeCurve::is(Type::Enum v) const { return v == Type::IfcEdgeCurve || IfcEdge::is(v); }
Type::Enum IfcEdgeCurve::type() const { return Type::IfcEdgeCurve; }
Type::Enum IfcEdgeCurve::Class() { return Type::IfcEdgeCurve; }
IfcEdgeCurve::IfcEdgeCurve(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEdgeCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdgeCurve::IfcEdgeCurve(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcCurve* v3_EdgeGeometry, bool v4_SameSense) : IfcEdge((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeGeometry));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SameSense));entity->setArgument(3,attr);} }

// Function implementations for IfcEdgeFeature
bool IfcEdgeFeature::hasFeatureLength() const { return !entity->getArgument(8)->isNull(); }
double IfcEdgeFeature::FeatureLength() const { return *entity->getArgument(8); }
void IfcEdgeFeature::setFeatureLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcEdgeFeature::is(Type::Enum v) const { return v == Type::IfcEdgeFeature || IfcFeatureElementSubtraction::is(v); }
Type::Enum IfcEdgeFeature::type() const { return Type::IfcEdgeFeature; }
Type::Enum IfcEdgeFeature::Class() { return Type::IfcEdgeFeature; }
IfcEdgeFeature::IfcEdgeFeature(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEdgeFeature) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdgeFeature::IfcEdgeFeature(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcEdgeLoop
IfcTemplatedEntityList< IfcOrientedEdge >::ptr IfcEdgeLoop::EdgeList() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcOrientedEdge>(); }
void IfcEdgeLoop::setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcEdgeLoop::is(Type::Enum v) const { return v == Type::IfcEdgeLoop || IfcLoop::is(v); }
Type::Enum IfcEdgeLoop::type() const { return Type::IfcEdgeLoop; }
Type::Enum IfcEdgeLoop::Class() { return Type::IfcEdgeLoop; }
IfcEdgeLoop::IfcEdgeLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEdgeLoop) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdgeLoop::IfcEdgeLoop(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList) : IfcLoop((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcElectricApplianceType
IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceType::PredefinedType() const { return IfcElectricApplianceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricApplianceType::setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricApplianceTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricApplianceType::is(Type::Enum v) const { return v == Type::IfcElectricApplianceType || IfcFlowTerminalType::is(v); }
Type::Enum IfcElectricApplianceType::type() const { return Type::IfcElectricApplianceType; }
Type::Enum IfcElectricApplianceType::Class() { return Type::IfcElectricApplianceType; }
IfcElectricApplianceType::IfcElectricApplianceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricApplianceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricApplianceType::IfcElectricApplianceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricApplianceTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricDistributionPoint
IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum IfcElectricDistributionPoint::DistributionPointFunction() const { return IfcElectricDistributionPointFunctionEnum::FromString(*entity->getArgument(8)); }
void IfcElectricDistributionPoint::setDistributionPointFunction(IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricDistributionPointFunctionEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcElectricDistributionPoint::hasUserDefinedFunction() const { return !entity->getArgument(9)->isNull(); }
std::string IfcElectricDistributionPoint::UserDefinedFunction() const { return *entity->getArgument(9); }
void IfcElectricDistributionPoint::setUserDefinedFunction(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcElectricDistributionPoint::is(Type::Enum v) const { return v == Type::IfcElectricDistributionPoint || IfcFlowController::is(v); }
Type::Enum IfcElectricDistributionPoint::type() const { return Type::IfcElectricDistributionPoint; }
Type::Enum IfcElectricDistributionPoint::Class() { return Type::IfcElectricDistributionPoint; }
IfcElectricDistributionPoint::IfcElectricDistributionPoint(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricDistributionPoint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricDistributionPoint::IfcElectricDistributionPoint(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum v9_DistributionPointFunction, boost::optional< std::string > v10_UserDefinedFunction) : IfcFlowController((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_DistributionPointFunction,IfcElectricDistributionPointFunctionEnum::ToString(v9_DistributionPointFunction))));entity->setArgument(8,attr);} if (v10_UserDefinedFunction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedFunction));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcElectricFlowStorageDeviceType
IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceType::PredefinedType() const { return IfcElectricFlowStorageDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricFlowStorageDeviceType::setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricFlowStorageDeviceTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricFlowStorageDeviceType::is(Type::Enum v) const { return v == Type::IfcElectricFlowStorageDeviceType || IfcFlowStorageDeviceType::is(v); }
Type::Enum IfcElectricFlowStorageDeviceType::type() const { return Type::IfcElectricFlowStorageDeviceType; }
Type::Enum IfcElectricFlowStorageDeviceType::Class() { return Type::IfcElectricFlowStorageDeviceType; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricFlowStorageDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricFlowStorageDeviceTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricGeneratorType
IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorType::PredefinedType() const { return IfcElectricGeneratorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricGeneratorType::setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricGeneratorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricGeneratorType::is(Type::Enum v) const { return v == Type::IfcElectricGeneratorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcElectricGeneratorType::type() const { return Type::IfcElectricGeneratorType; }
Type::Enum IfcElectricGeneratorType::Class() { return Type::IfcElectricGeneratorType; }
IfcElectricGeneratorType::IfcElectricGeneratorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricGeneratorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricGeneratorType::IfcElectricGeneratorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricGeneratorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricHeaterType
IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum IfcElectricHeaterType::PredefinedType() const { return IfcElectricHeaterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricHeaterType::setPredefinedType(IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricHeaterTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricHeaterType::is(Type::Enum v) const { return v == Type::IfcElectricHeaterType || IfcFlowTerminalType::is(v); }
Type::Enum IfcElectricHeaterType::type() const { return Type::IfcElectricHeaterType; }
Type::Enum IfcElectricHeaterType::Class() { return Type::IfcElectricHeaterType; }
IfcElectricHeaterType::IfcElectricHeaterType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricHeaterType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricHeaterType::IfcElectricHeaterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricHeaterTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricMotorType
IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorType::PredefinedType() const { return IfcElectricMotorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricMotorType::setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricMotorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricMotorType::is(Type::Enum v) const { return v == Type::IfcElectricMotorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcElectricMotorType::type() const { return Type::IfcElectricMotorType; }
Type::Enum IfcElectricMotorType::Class() { return Type::IfcElectricMotorType; }
IfcElectricMotorType::IfcElectricMotorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricMotorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricMotorType::IfcElectricMotorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricMotorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricTimeControlType
IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlType::PredefinedType() const { return IfcElectricTimeControlTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricTimeControlType::setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricTimeControlTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElectricTimeControlType::is(Type::Enum v) const { return v == Type::IfcElectricTimeControlType || IfcFlowControllerType::is(v); }
Type::Enum IfcElectricTimeControlType::type() const { return Type::IfcElectricTimeControlType; }
Type::Enum IfcElectricTimeControlType::Class() { return Type::IfcElectricTimeControlType; }
IfcElectricTimeControlType::IfcElectricTimeControlType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricTimeControlType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricTimeControlType::IfcElectricTimeControlType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElectricTimeControlTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElectricalBaseProperties
bool IfcElectricalBaseProperties::hasElectricCurrentType() const { return !entity->getArgument(6)->isNull(); }
IfcElectricCurrentEnum::IfcElectricCurrentEnum IfcElectricalBaseProperties::ElectricCurrentType() const { return IfcElectricCurrentEnum::FromString(*entity->getArgument(6)); }
void IfcElectricalBaseProperties::setElectricCurrentType(IfcElectricCurrentEnum::IfcElectricCurrentEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElectricCurrentEnum::ToString(v)));entity->setArgument(6,attr);} }
double IfcElectricalBaseProperties::InputVoltage() const { return *entity->getArgument(7); }
void IfcElectricalBaseProperties::setInputVoltage(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
double IfcElectricalBaseProperties::InputFrequency() const { return *entity->getArgument(8); }
void IfcElectricalBaseProperties::setInputFrequency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcElectricalBaseProperties::hasFullLoadCurrent() const { return !entity->getArgument(9)->isNull(); }
double IfcElectricalBaseProperties::FullLoadCurrent() const { return *entity->getArgument(9); }
void IfcElectricalBaseProperties::setFullLoadCurrent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcElectricalBaseProperties::hasMinimumCircuitCurrent() const { return !entity->getArgument(10)->isNull(); }
double IfcElectricalBaseProperties::MinimumCircuitCurrent() const { return *entity->getArgument(10); }
void IfcElectricalBaseProperties::setMinimumCircuitCurrent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcElectricalBaseProperties::hasMaximumPowerInput() const { return !entity->getArgument(11)->isNull(); }
double IfcElectricalBaseProperties::MaximumPowerInput() const { return *entity->getArgument(11); }
void IfcElectricalBaseProperties::setMaximumPowerInput(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcElectricalBaseProperties::hasRatedPowerInput() const { return !entity->getArgument(12)->isNull(); }
double IfcElectricalBaseProperties::RatedPowerInput() const { return *entity->getArgument(12); }
void IfcElectricalBaseProperties::setRatedPowerInput(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
int IfcElectricalBaseProperties::InputPhase() const { return *entity->getArgument(13); }
void IfcElectricalBaseProperties::setInputPhase(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcElectricalBaseProperties::is(Type::Enum v) const { return v == Type::IfcElectricalBaseProperties || IfcEnergyProperties::is(v); }
Type::Enum IfcElectricalBaseProperties::type() const { return Type::IfcElectricalBaseProperties; }
Type::Enum IfcElectricalBaseProperties::Class() { return Type::IfcElectricalBaseProperties; }
IfcElectricalBaseProperties::IfcElectricalBaseProperties(IfcEntityInstanceData* e) : IfcEnergyProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricalBaseProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricalBaseProperties::IfcElectricalBaseProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcEnergySequenceEnum::IfcEnergySequenceEnum > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence, boost::optional< IfcElectricCurrentEnum::IfcElectricCurrentEnum > v7_ElectricCurrentType, double v8_InputVoltage, double v9_InputFrequency, boost::optional< double > v10_FullLoadCurrent, boost::optional< double > v11_MinimumCircuitCurrent, boost::optional< double > v12_MaximumPowerInput, boost::optional< double > v13_RatedPowerInput, int v14_InputPhase) : IfcEnergyProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_EnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_EnergySequence,IfcEnergySequenceEnum::ToString(*v5_EnergySequence))));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_UserDefinedEnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_UserDefinedEnergySequence));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ElectricCurrentType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_ElectricCurrentType,IfcElectricCurrentEnum::ToString(*v7_ElectricCurrentType))));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_InputVoltage));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_InputFrequency));entity->setArgument(8,attr);} if (v10_FullLoadCurrent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FullLoadCurrent));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_MinimumCircuitCurrent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MinimumCircuitCurrent));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_MaximumPowerInput) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_MaximumPowerInput));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_RatedPowerInput) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_RatedPowerInput));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_InputPhase));entity->setArgument(13,attr);} }

// Function implementations for IfcElectricalCircuit
bool IfcElectricalCircuit::is(Type::Enum v) const { return v == Type::IfcElectricalCircuit || IfcSystem::is(v); }
Type::Enum IfcElectricalCircuit::type() const { return Type::IfcElectricalCircuit; }
Type::Enum IfcElectricalCircuit::Class() { return Type::IfcElectricalCircuit; }
IfcElectricalCircuit::IfcElectricalCircuit(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricalCircuit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricalCircuit::IfcElectricalCircuit(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcSystem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcElectricalElement
bool IfcElectricalElement::is(Type::Enum v) const { return v == Type::IfcElectricalElement || IfcElement::is(v); }
Type::Enum IfcElectricalElement::type() const { return Type::IfcElectricalElement; }
Type::Enum IfcElectricalElement::Class() { return Type::IfcElectricalElement; }
IfcElectricalElement::IfcElectricalElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElectricalElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricalElement::IfcElectricalElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcElement
bool IfcElement::hasTag() const { return !entity->getArgument(7)->isNull(); }
std::string IfcElement::Tag() const { return *entity->getArgument(7); }
void IfcElement::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcRelConnectsStructuralElement::list::ptr IfcElement::HasStructuralMember() const { return entity->getInverse(Type::IfcRelConnectsStructuralElement, 4)->as<IfcRelConnectsStructuralElement>(); }
IfcRelFillsElement::list::ptr IfcElement::FillsVoids() const { return entity->getInverse(Type::IfcRelFillsElement, 5)->as<IfcRelFillsElement>(); }
IfcRelConnectsElements::list::ptr IfcElement::ConnectedTo() const { return entity->getInverse(Type::IfcRelConnectsElements, 5)->as<IfcRelConnectsElements>(); }
IfcRelCoversBldgElements::list::ptr IfcElement::HasCoverings() const { return entity->getInverse(Type::IfcRelCoversBldgElements, 4)->as<IfcRelCoversBldgElements>(); }
IfcRelProjectsElement::list::ptr IfcElement::HasProjections() const { return entity->getInverse(Type::IfcRelProjectsElement, 4)->as<IfcRelProjectsElement>(); }
IfcRelReferencedInSpatialStructure::list::ptr IfcElement::ReferencedInStructures() const { return entity->getInverse(Type::IfcRelReferencedInSpatialStructure, 4)->as<IfcRelReferencedInSpatialStructure>(); }
IfcRelConnectsPortToElement::list::ptr IfcElement::HasPorts() const { return entity->getInverse(Type::IfcRelConnectsPortToElement, 5)->as<IfcRelConnectsPortToElement>(); }
IfcRelVoidsElement::list::ptr IfcElement::HasOpenings() const { return entity->getInverse(Type::IfcRelVoidsElement, 4)->as<IfcRelVoidsElement>(); }
IfcRelConnectsWithRealizingElements::list::ptr IfcElement::IsConnectionRealization() const { return entity->getInverse(Type::IfcRelConnectsWithRealizingElements, 7)->as<IfcRelConnectsWithRealizingElements>(); }
IfcRelSpaceBoundary::list::ptr IfcElement::ProvidesBoundaries() const { return entity->getInverse(Type::IfcRelSpaceBoundary, 5)->as<IfcRelSpaceBoundary>(); }
IfcRelConnectsElements::list::ptr IfcElement::ConnectedFrom() const { return entity->getInverse(Type::IfcRelConnectsElements, 6)->as<IfcRelConnectsElements>(); }
IfcRelContainedInSpatialStructure::list::ptr IfcElement::ContainedInStructure() const { return entity->getInverse(Type::IfcRelContainedInSpatialStructure, 4)->as<IfcRelContainedInSpatialStructure>(); }
bool IfcElement::is(Type::Enum v) const { return v == Type::IfcElement || IfcProduct::is(v); }
Type::Enum IfcElement::type() const { return Type::IfcElement; }
Type::Enum IfcElement::Class() { return Type::IfcElement; }
IfcElement::IfcElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElement::IfcElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcElementAssembly
bool IfcElementAssembly::hasAssemblyPlace() const { return !entity->getArgument(8)->isNull(); }
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcElementAssembly::AssemblyPlace() const { return IfcAssemblyPlaceEnum::FromString(*entity->getArgument(8)); }
void IfcElementAssembly::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAssemblyPlaceEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssembly::PredefinedType() const { return IfcElementAssemblyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElementAssembly::setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementAssemblyTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcElementAssembly::is(Type::Enum v) const { return v == Type::IfcElementAssembly || IfcElement::is(v); }
Type::Enum IfcElementAssembly::type() const { return Type::IfcElementAssembly; }
Type::Enum IfcElementAssembly::Class() { return Type::IfcElementAssembly; }
IfcElementAssembly::IfcElementAssembly(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementAssembly) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementAssembly::IfcElementAssembly(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum > v9_AssemblyPlace, IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v10_PredefinedType) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_AssemblyPlace) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(*v9_AssemblyPlace))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcElementAssemblyTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcElementComponent
bool IfcElementComponent::is(Type::Enum v) const { return v == Type::IfcElementComponent || IfcElement::is(v); }
Type::Enum IfcElementComponent::type() const { return Type::IfcElementComponent; }
Type::Enum IfcElementComponent::Class() { return Type::IfcElementComponent; }
IfcElementComponent::IfcElementComponent(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementComponent) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementComponent::IfcElementComponent(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcElementComponentType
bool IfcElementComponentType::is(Type::Enum v) const { return v == Type::IfcElementComponentType || IfcElementType::is(v); }
Type::Enum IfcElementComponentType::type() const { return Type::IfcElementComponentType; }
Type::Enum IfcElementComponentType::Class() { return Type::IfcElementComponentType; }
IfcElementComponentType::IfcElementComponentType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementComponentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementComponentType::IfcElementComponentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcElementQuantity
bool IfcElementQuantity::hasMethodOfMeasurement() const { return !entity->getArgument(4)->isNull(); }
std::string IfcElementQuantity::MethodOfMeasurement() const { return *entity->getArgument(4); }
void IfcElementQuantity::setMethodOfMeasurement(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr IfcElementQuantity::Quantities() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcPhysicalQuantity>(); }
void IfcElementQuantity::setQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcElementQuantity::is(Type::Enum v) const { return v == Type::IfcElementQuantity || IfcPropertySetDefinition::is(v); }
Type::Enum IfcElementQuantity::type() const { return Type::IfcElementQuantity; }
Type::Enum IfcElementQuantity::Class() { return Type::IfcElementQuantity; }
IfcElementQuantity::IfcElementQuantity(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementQuantity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementQuantity::IfcElementQuantity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_MethodOfMeasurement, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v6_Quantities) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MethodOfMeasurement) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MethodOfMeasurement));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Quantities)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcElementType
bool IfcElementType::hasElementType() const { return !entity->getArgument(8)->isNull(); }
std::string IfcElementType::ElementType() const { return *entity->getArgument(8); }
void IfcElementType::setElementType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcElementType::is(Type::Enum v) const { return v == Type::IfcElementType || IfcTypeProduct::is(v); }
Type::Enum IfcElementType::type() const { return Type::IfcElementType; }
Type::Enum IfcElementType::Class() { return Type::IfcElementType; }
IfcElementType::IfcElementType(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementType::IfcElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcTypeProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcElementarySurface
IfcAxis2Placement3D* IfcElementarySurface::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcElementarySurface::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcElementarySurface::is(Type::Enum v) const { return v == Type::IfcElementarySurface || IfcSurface::is(v); }
Type::Enum IfcElementarySurface::type() const { return Type::IfcElementarySurface; }
Type::Enum IfcElementarySurface::Class() { return Type::IfcElementarySurface; }
IfcElementarySurface::IfcElementarySurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcElementarySurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementarySurface::IfcElementarySurface(IfcAxis2Placement3D* v1_Position) : IfcSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);} }

// Function implementations for IfcEllipse
double IfcEllipse::SemiAxis1() const { return *entity->getArgument(1); }
void IfcEllipse::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcEllipse::SemiAxis2() const { return *entity->getArgument(2); }
void IfcEllipse::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcEllipse::is(Type::Enum v) const { return v == Type::IfcEllipse || IfcConic::is(v); }
Type::Enum IfcEllipse::type() const { return Type::IfcEllipse; }
Type::Enum IfcEllipse::Class() { return Type::IfcEllipse; }
IfcEllipse::IfcEllipse(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEllipse) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEllipse::IfcEllipse(IfcAxis2Placement* v1_Position, double v2_SemiAxis1, double v3_SemiAxis2) : IfcConic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SemiAxis1));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SemiAxis2));entity->setArgument(2,attr);} }

// Function implementations for IfcEllipseProfileDef
double IfcEllipseProfileDef::SemiAxis1() const { return *entity->getArgument(3); }
void IfcEllipseProfileDef::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcEllipseProfileDef::SemiAxis2() const { return *entity->getArgument(4); }
void IfcEllipseProfileDef::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcEllipseProfileDef::is(Type::Enum v) const { return v == Type::IfcEllipseProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcEllipseProfileDef::type() const { return Type::IfcEllipseProfileDef; }
Type::Enum IfcEllipseProfileDef::Class() { return Type::IfcEllipseProfileDef; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEllipseProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_SemiAxis1, double v5_SemiAxis2) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SemiAxis1));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SemiAxis2));entity->setArgument(4,attr);} }

// Function implementations for IfcEnergyConversionDevice
bool IfcEnergyConversionDevice::is(Type::Enum v) const { return v == Type::IfcEnergyConversionDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcEnergyConversionDevice::type() const { return Type::IfcEnergyConversionDevice; }
Type::Enum IfcEnergyConversionDevice::Class() { return Type::IfcEnergyConversionDevice; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEnergyConversionDevice) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcEnergyConversionDeviceType
bool IfcEnergyConversionDeviceType::is(Type::Enum v) const { return v == Type::IfcEnergyConversionDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcEnergyConversionDeviceType::type() const { return Type::IfcEnergyConversionDeviceType; }
Type::Enum IfcEnergyConversionDeviceType::Class() { return Type::IfcEnergyConversionDeviceType; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEnergyConversionDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcEnergyProperties
bool IfcEnergyProperties::hasEnergySequence() const { return !entity->getArgument(4)->isNull(); }
IfcEnergySequenceEnum::IfcEnergySequenceEnum IfcEnergyProperties::EnergySequence() const { return IfcEnergySequenceEnum::FromString(*entity->getArgument(4)); }
void IfcEnergyProperties::setEnergySequence(IfcEnergySequenceEnum::IfcEnergySequenceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEnergySequenceEnum::ToString(v)));entity->setArgument(4,attr);} }
bool IfcEnergyProperties::hasUserDefinedEnergySequence() const { return !entity->getArgument(5)->isNull(); }
std::string IfcEnergyProperties::UserDefinedEnergySequence() const { return *entity->getArgument(5); }
void IfcEnergyProperties::setUserDefinedEnergySequence(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcEnergyProperties::is(Type::Enum v) const { return v == Type::IfcEnergyProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcEnergyProperties::type() const { return Type::IfcEnergyProperties; }
Type::Enum IfcEnergyProperties::Class() { return Type::IfcEnergyProperties; }
IfcEnergyProperties::IfcEnergyProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEnergyProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnergyProperties::IfcEnergyProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcEnergySequenceEnum::IfcEnergySequenceEnum > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_EnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_EnergySequence,IfcEnergySequenceEnum::ToString(*v5_EnergySequence))));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_UserDefinedEnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_UserDefinedEnergySequence));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcEnvironmentalImpactValue
std::string IfcEnvironmentalImpactValue::ImpactType() const { return *entity->getArgument(6); }
void IfcEnvironmentalImpactValue::setImpactType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum IfcEnvironmentalImpactValue::Category() const { return IfcEnvironmentalImpactCategoryEnum::FromString(*entity->getArgument(7)); }
void IfcEnvironmentalImpactValue::setCategory(IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEnvironmentalImpactCategoryEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcEnvironmentalImpactValue::hasUserDefinedCategory() const { return !entity->getArgument(8)->isNull(); }
std::string IfcEnvironmentalImpactValue::UserDefinedCategory() const { return *entity->getArgument(8); }
void IfcEnvironmentalImpactValue::setUserDefinedCategory(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcEnvironmentalImpactValue::is(Type::Enum v) const { return v == Type::IfcEnvironmentalImpactValue || IfcAppliedValue::is(v); }
Type::Enum IfcEnvironmentalImpactValue::type() const { return Type::IfcEnvironmentalImpactValue; }
Type::Enum IfcEnvironmentalImpactValue::Class() { return Type::IfcEnvironmentalImpactValue; }
IfcEnvironmentalImpactValue::IfcEnvironmentalImpactValue(IfcEntityInstanceData* e) : IfcAppliedValue((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEnvironmentalImpactValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnvironmentalImpactValue::IfcEnvironmentalImpactValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_ImpactType, IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum v8_Category, boost::optional< std::string > v9_UserDefinedCategory) : IfcAppliedValue((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ImpactType));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_Category,IfcEnvironmentalImpactCategoryEnum::ToString(v8_Category))));entity->setArgument(7,attr);} if (v9_UserDefinedCategory) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_UserDefinedCategory));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcEquipmentElement
bool IfcEquipmentElement::is(Type::Enum v) const { return v == Type::IfcEquipmentElement || IfcElement::is(v); }
Type::Enum IfcEquipmentElement::type() const { return Type::IfcEquipmentElement; }
Type::Enum IfcEquipmentElement::Class() { return Type::IfcEquipmentElement; }
IfcEquipmentElement::IfcEquipmentElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEquipmentElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEquipmentElement::IfcEquipmentElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcEquipmentStandard
bool IfcEquipmentStandard::is(Type::Enum v) const { return v == Type::IfcEquipmentStandard || IfcControl::is(v); }
Type::Enum IfcEquipmentStandard::type() const { return Type::IfcEquipmentStandard; }
Type::Enum IfcEquipmentStandard::Class() { return Type::IfcEquipmentStandard; }
IfcEquipmentStandard::IfcEquipmentStandard(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEquipmentStandard) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEquipmentStandard::IfcEquipmentStandard(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcEvaporativeCoolerType
IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerType::PredefinedType() const { return IfcEvaporativeCoolerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEvaporativeCoolerType::setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporativeCoolerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcEvaporativeCoolerType::is(Type::Enum v) const { return v == Type::IfcEvaporativeCoolerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcEvaporativeCoolerType::type() const { return Type::IfcEvaporativeCoolerType; }
Type::Enum IfcEvaporativeCoolerType::Class() { return Type::IfcEvaporativeCoolerType; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEvaporativeCoolerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEvaporativeCoolerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcEvaporatorType
IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorType::PredefinedType() const { return IfcEvaporatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEvaporatorType::setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcEvaporatorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcEvaporatorType::is(Type::Enum v) const { return v == Type::IfcEvaporatorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcEvaporatorType::type() const { return Type::IfcEvaporatorType; }
Type::Enum IfcEvaporatorType::Class() { return Type::IfcEvaporatorType; }
IfcEvaporatorType::IfcEvaporatorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcEvaporatorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporatorType::IfcEvaporatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcEvaporatorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcExtendedMaterialProperties
IfcTemplatedEntityList< IfcProperty >::ptr IfcExtendedMaterialProperties::ExtendedProperties() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcProperty>(); }
void IfcExtendedMaterialProperties::setExtendedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcExtendedMaterialProperties::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcExtendedMaterialProperties::Description() const { return *entity->getArgument(2); }
void IfcExtendedMaterialProperties::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
std::string IfcExtendedMaterialProperties::Name() const { return *entity->getArgument(3); }
void IfcExtendedMaterialProperties::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcExtendedMaterialProperties::is(Type::Enum v) const { return v == Type::IfcExtendedMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcExtendedMaterialProperties::type() const { return Type::IfcExtendedMaterialProperties; }
Type::Enum IfcExtendedMaterialProperties::Class() { return Type::IfcExtendedMaterialProperties; }
IfcExtendedMaterialProperties::IfcExtendedMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExtendedMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExtendedMaterialProperties::IfcExtendedMaterialProperties(IfcMaterial* v1_Material, IfcTemplatedEntityList< IfcProperty >::ptr v2_ExtendedProperties, boost::optional< std::string > v3_Description, std::string v4_Name) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ExtendedProperties)->generalize());entity->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));entity->setArgument(3,attr);} }

// Function implementations for IfcExternalReference
bool IfcExternalReference::hasLocation() const { return !entity->getArgument(0)->isNull(); }
std::string IfcExternalReference::Location() const { return *entity->getArgument(0); }
void IfcExternalReference::setLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcExternalReference::hasItemReference() const { return !entity->getArgument(1)->isNull(); }
std::string IfcExternalReference::ItemReference() const { return *entity->getArgument(1); }
void IfcExternalReference::setItemReference(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcExternalReference::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcExternalReference::Name() const { return *entity->getArgument(2); }
void IfcExternalReference::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcExternalReference::is(Type::Enum v) const { return v == Type::IfcExternalReference; }
Type::Enum IfcExternalReference::type() const { return Type::IfcExternalReference; }
Type::Enum IfcExternalReference::Class() { return Type::IfcExternalReference; }
IfcExternalReference::IfcExternalReference(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcExternalReference) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalReference::IfcExternalReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedHatchStyle
bool IfcExternallyDefinedHatchStyle::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedHatchStyle || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedHatchStyle::type() const { return Type::IfcExternallyDefinedHatchStyle; }
Type::Enum IfcExternallyDefinedHatchStyle::Class() { return Type::IfcExternallyDefinedHatchStyle; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExternallyDefinedHatchStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedSurfaceStyle
bool IfcExternallyDefinedSurfaceStyle::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedSurfaceStyle || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedSurfaceStyle::type() const { return Type::IfcExternallyDefinedSurfaceStyle; }
Type::Enum IfcExternallyDefinedSurfaceStyle::Class() { return Type::IfcExternallyDefinedSurfaceStyle; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExternallyDefinedSurfaceStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedSymbol
bool IfcExternallyDefinedSymbol::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedSymbol || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedSymbol::type() const { return Type::IfcExternallyDefinedSymbol; }
Type::Enum IfcExternallyDefinedSymbol::Class() { return Type::IfcExternallyDefinedSymbol; }
IfcExternallyDefinedSymbol::IfcExternallyDefinedSymbol(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExternallyDefinedSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedSymbol::IfcExternallyDefinedSymbol(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedTextFont
bool IfcExternallyDefinedTextFont::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedTextFont || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedTextFont::type() const { return Type::IfcExternallyDefinedTextFont; }
Type::Enum IfcExternallyDefinedTextFont::Class() { return Type::IfcExternallyDefinedTextFont; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExternallyDefinedTextFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcExtrudedAreaSolid
IfcDirection* IfcExtrudedAreaSolid::ExtrudedDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcExtrudedAreaSolid::setExtrudedDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcExtrudedAreaSolid::Depth() const { return *entity->getArgument(3); }
void IfcExtrudedAreaSolid::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcExtrudedAreaSolid::is(Type::Enum v) const { return v == Type::IfcExtrudedAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcExtrudedAreaSolid::type() const { return Type::IfcExtrudedAreaSolid; }
Type::Enum IfcExtrudedAreaSolid::Class() { return Type::IfcExtrudedAreaSolid; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcExtrudedAreaSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);} }

// Function implementations for IfcFace
IfcTemplatedEntityList< IfcFaceBound >::ptr IfcFace::Bounds() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcFaceBound>(); }
void IfcFace::setBounds(IfcTemplatedEntityList< IfcFaceBound >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcFace::is(Type::Enum v) const { return v == Type::IfcFace || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcFace::type() const { return Type::IfcFace; }
Type::Enum IfcFace::Class() { return Type::IfcFace; }
IfcFace::IfcFace(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFace) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFace::IfcFace(IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcFaceBasedSurfaceModel
IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr IfcFaceBasedSurfaceModel::FbsmFaces() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcConnectedFaceSet>(); }
void IfcFaceBasedSurfaceModel::setFbsmFaces(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcFaceBasedSurfaceModel::is(Type::Enum v) const { return v == Type::IfcFaceBasedSurfaceModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFaceBasedSurfaceModel::type() const { return Type::IfcFaceBasedSurfaceModel; }
Type::Enum IfcFaceBasedSurfaceModel::Class() { return Type::IfcFaceBasedSurfaceModel; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFaceBasedSurfaceModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v1_FbsmFaces) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_FbsmFaces)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcFaceBound
IfcLoop* IfcFaceBound::Bound() const { return (IfcLoop*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcFaceBound::setBound(IfcLoop* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcFaceBound::Orientation() const { return *entity->getArgument(1); }
void IfcFaceBound::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFaceBound::is(Type::Enum v) const { return v == Type::IfcFaceBound || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcFaceBound::type() const { return Type::IfcFaceBound; }
Type::Enum IfcFaceBound::Class() { return Type::IfcFaceBound; }
IfcFaceBound::IfcFaceBound(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFaceBound) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceBound::IfcFaceBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));entity->setArgument(1,attr);} }

// Function implementations for IfcFaceOuterBound
bool IfcFaceOuterBound::is(Type::Enum v) const { return v == Type::IfcFaceOuterBound || IfcFaceBound::is(v); }
Type::Enum IfcFaceOuterBound::type() const { return Type::IfcFaceOuterBound; }
Type::Enum IfcFaceOuterBound::Class() { return Type::IfcFaceOuterBound; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcEntityInstanceData* e) : IfcFaceBound((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFaceOuterBound) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcFaceBound((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));entity->setArgument(1,attr);} }

// Function implementations for IfcFaceSurface
IfcSurface* IfcFaceSurface::FaceSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcFaceSurface::setFaceSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFaceSurface::SameSense() const { return *entity->getArgument(2); }
void IfcFaceSurface::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcFaceSurface::is(Type::Enum v) const { return v == Type::IfcFaceSurface || IfcFace::is(v); }
Type::Enum IfcFaceSurface::type() const { return Type::IfcFaceSurface; }
Type::Enum IfcFaceSurface::Class() { return Type::IfcFaceSurface; }
IfcFaceSurface::IfcFaceSurface(IfcEntityInstanceData* e) : IfcFace((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFaceSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceSurface::IfcFaceSurface(IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFace((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FaceSurface));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));entity->setArgument(2,attr);} }

// Function implementations for IfcFacetedBrep
bool IfcFacetedBrep::is(Type::Enum v) const { return v == Type::IfcFacetedBrep || IfcManifoldSolidBrep::is(v); }
Type::Enum IfcFacetedBrep::type() const { return Type::IfcFacetedBrep; }
Type::Enum IfcFacetedBrep::Class() { return Type::IfcFacetedBrep; }
IfcFacetedBrep::IfcFacetedBrep(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFacetedBrep) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFacetedBrep::IfcFacetedBrep(IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));entity->setArgument(0,attr);} }

// Function implementations for IfcFacetedBrepWithVoids
IfcTemplatedEntityList< IfcClosedShell >::ptr IfcFacetedBrepWithVoids::Voids() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcClosedShell>(); }
void IfcFacetedBrepWithVoids::setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcFacetedBrepWithVoids::is(Type::Enum v) const { return v == Type::IfcFacetedBrepWithVoids || IfcManifoldSolidBrep::is(v); }
Type::Enum IfcFacetedBrepWithVoids::type() const { return Type::IfcFacetedBrepWithVoids; }
Type::Enum IfcFacetedBrepWithVoids::Class() { return Type::IfcFacetedBrepWithVoids; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFacetedBrepWithVoids) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Voids)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcFailureConnectionCondition
bool IfcFailureConnectionCondition::hasTensionFailureX() const { return !entity->getArgument(1)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureX() const { return *entity->getArgument(1); }
void IfcFailureConnectionCondition::setTensionFailureX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFailureConnectionCondition::hasTensionFailureY() const { return !entity->getArgument(2)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureY() const { return *entity->getArgument(2); }
void IfcFailureConnectionCondition::setTensionFailureY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcFailureConnectionCondition::hasTensionFailureZ() const { return !entity->getArgument(3)->isNull(); }
double IfcFailureConnectionCondition::TensionFailureZ() const { return *entity->getArgument(3); }
void IfcFailureConnectionCondition::setTensionFailureZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureX() const { return !entity->getArgument(4)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureX() const { return *entity->getArgument(4); }
void IfcFailureConnectionCondition::setCompressionFailureX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureY() const { return !entity->getArgument(5)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureY() const { return *entity->getArgument(5); }
void IfcFailureConnectionCondition::setCompressionFailureY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcFailureConnectionCondition::hasCompressionFailureZ() const { return !entity->getArgument(6)->isNull(); }
double IfcFailureConnectionCondition::CompressionFailureZ() const { return *entity->getArgument(6); }
void IfcFailureConnectionCondition::setCompressionFailureZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcFailureConnectionCondition::is(Type::Enum v) const { return v == Type::IfcFailureConnectionCondition || IfcStructuralConnectionCondition::is(v); }
Type::Enum IfcFailureConnectionCondition::type() const { return Type::IfcFailureConnectionCondition; }
Type::Enum IfcFailureConnectionCondition::Class() { return Type::IfcFailureConnectionCondition; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFailureConnectionCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_TensionFailureX, boost::optional< double > v3_TensionFailureY, boost::optional< double > v4_TensionFailureZ, boost::optional< double > v5_CompressionFailureX, boost::optional< double > v6_CompressionFailureY, boost::optional< double > v7_CompressionFailureZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_TensionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TensionFailureX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_TensionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TensionFailureY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_TensionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TensionFailureZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_CompressionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CompressionFailureX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_CompressionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CompressionFailureY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_CompressionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CompressionFailureZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcFanType
IfcFanTypeEnum::IfcFanTypeEnum IfcFanType::PredefinedType() const { return IfcFanTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFanType::setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFanTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFanType::is(Type::Enum v) const { return v == Type::IfcFanType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcFanType::type() const { return Type::IfcFanType; }
Type::Enum IfcFanType::Class() { return Type::IfcFanType; }
IfcFanType::IfcFanType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFanType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFanType::IfcFanType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFanTypeEnum::IfcFanTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFanTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcFastener
bool IfcFastener::is(Type::Enum v) const { return v == Type::IfcFastener || IfcElementComponent::is(v); }
Type::Enum IfcFastener::type() const { return Type::IfcFastener; }
Type::Enum IfcFastener::Class() { return Type::IfcFastener; }
IfcFastener::IfcFastener(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFastener) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFastener::IfcFastener(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElementComponent((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFastenerType
bool IfcFastenerType::is(Type::Enum v) const { return v == Type::IfcFastenerType || IfcElementComponentType::is(v); }
Type::Enum IfcFastenerType::type() const { return Type::IfcFastenerType; }
Type::Enum IfcFastenerType::Class() { return Type::IfcFastenerType; }
IfcFastenerType::IfcFastenerType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFastenerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFastenerType::IfcFastenerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementComponentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFeatureElement
bool IfcFeatureElement::is(Type::Enum v) const { return v == Type::IfcFeatureElement || IfcElement::is(v); }
Type::Enum IfcFeatureElement::type() const { return Type::IfcFeatureElement; }
Type::Enum IfcFeatureElement::Class() { return Type::IfcFeatureElement; }
IfcFeatureElement::IfcFeatureElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFeatureElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElement::IfcFeatureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementAddition
IfcRelProjectsElement::list::ptr IfcFeatureElementAddition::ProjectsElements() const { return entity->getInverse(Type::IfcRelProjectsElement, 5)->as<IfcRelProjectsElement>(); }
bool IfcFeatureElementAddition::is(Type::Enum v) const { return v == Type::IfcFeatureElementAddition || IfcFeatureElement::is(v); }
Type::Enum IfcFeatureElementAddition::type() const { return Type::IfcFeatureElementAddition; }
Type::Enum IfcFeatureElementAddition::Class() { return Type::IfcFeatureElementAddition; }
IfcFeatureElementAddition::IfcFeatureElementAddition(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFeatureElementAddition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElementAddition::IfcFeatureElementAddition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementSubtraction
IfcRelVoidsElement::list::ptr IfcFeatureElementSubtraction::VoidsElements() const { return entity->getInverse(Type::IfcRelVoidsElement, 5)->as<IfcRelVoidsElement>(); }
bool IfcFeatureElementSubtraction::is(Type::Enum v) const { return v == Type::IfcFeatureElementSubtraction || IfcFeatureElement::is(v); }
Type::Enum IfcFeatureElementSubtraction::type() const { return Type::IfcFeatureElementSubtraction; }
Type::Enum IfcFeatureElementSubtraction::Class() { return Type::IfcFeatureElementSubtraction; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFeatureElementSubtraction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFillAreaStyle
IfcEntityList::ptr IfcFillAreaStyle::FillStyles() const { return *entity->getArgument(1); }
void IfcFillAreaStyle::setFillStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFillAreaStyle::is(Type::Enum v) const { return v == Type::IfcFillAreaStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcFillAreaStyle::type() const { return Type::IfcFillAreaStyle; }
Type::Enum IfcFillAreaStyle::Class() { return Type::IfcFillAreaStyle; }
IfcFillAreaStyle::IfcFillAreaStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFillAreaStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyle::IfcFillAreaStyle(boost::optional< std::string > v1_Name, IfcEntityList::ptr v2_FillStyles) : IfcPresentationStyle((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FillStyles));entity->setArgument(1,attr);} }

// Function implementations for IfcFillAreaStyleHatching
IfcCurveStyle* IfcFillAreaStyleHatching::HatchLineAppearance() const { return (IfcCurveStyle*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcFillAreaStyleHatching::setHatchLineAppearance(IfcCurveStyle* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcHatchLineDistanceSelect* IfcFillAreaStyleHatching::StartOfNextHatchLine() const { return (IfcHatchLineDistanceSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcFillAreaStyleHatching::setStartOfNextHatchLine(IfcHatchLineDistanceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFillAreaStyleHatching::hasPointOfReferenceHatchLine() const { return !entity->getArgument(2)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PointOfReferenceHatchLine() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcFillAreaStyleHatching::setPointOfReferenceHatchLine(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcFillAreaStyleHatching::hasPatternStart() const { return !entity->getArgument(3)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PatternStart() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcFillAreaStyleHatching::setPatternStart(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcFillAreaStyleHatching::HatchLineAngle() const { return *entity->getArgument(4); }
void IfcFillAreaStyleHatching::setHatchLineAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcFillAreaStyleHatching::is(Type::Enum v) const { return v == Type::IfcFillAreaStyleHatching || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFillAreaStyleHatching::type() const { return Type::IfcFillAreaStyleHatching; }
Type::Enum IfcFillAreaStyleHatching::Class() { return Type::IfcFillAreaStyleHatching; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFillAreaStyleHatching) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcCurveStyle* v1_HatchLineAppearance, IfcHatchLineDistanceSelect* v2_StartOfNextHatchLine, IfcCartesianPoint* v3_PointOfReferenceHatchLine, IfcCartesianPoint* v4_PatternStart, double v5_HatchLineAngle) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HatchLineAppearance));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartOfNextHatchLine));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointOfReferenceHatchLine));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PatternStart));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HatchLineAngle));entity->setArgument(4,attr);} }

// Function implementations for IfcFillAreaStyleTileSymbolWithStyle
IfcAnnotationSymbolOccurrence* IfcFillAreaStyleTileSymbolWithStyle::Symbol() const { return (IfcAnnotationSymbolOccurrence*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcFillAreaStyleTileSymbolWithStyle::setSymbol(IfcAnnotationSymbolOccurrence* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcFillAreaStyleTileSymbolWithStyle::is(Type::Enum v) const { return v == Type::IfcFillAreaStyleTileSymbolWithStyle || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFillAreaStyleTileSymbolWithStyle::type() const { return Type::IfcFillAreaStyleTileSymbolWithStyle; }
Type::Enum IfcFillAreaStyleTileSymbolWithStyle::Class() { return Type::IfcFillAreaStyleTileSymbolWithStyle; }
IfcFillAreaStyleTileSymbolWithStyle::IfcFillAreaStyleTileSymbolWithStyle(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFillAreaStyleTileSymbolWithStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyleTileSymbolWithStyle::IfcFillAreaStyleTileSymbolWithStyle(IfcAnnotationSymbolOccurrence* v1_Symbol) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Symbol));entity->setArgument(0,attr);} }

// Function implementations for IfcFillAreaStyleTiles
IfcOneDirectionRepeatFactor* IfcFillAreaStyleTiles::TilingPattern() const { return (IfcOneDirectionRepeatFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcFillAreaStyleTiles::setTilingPattern(IfcOneDirectionRepeatFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcFillAreaStyleTiles::Tiles() const { return *entity->getArgument(1); }
void IfcFillAreaStyleTiles::setTiles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcFillAreaStyleTiles::TilingScale() const { return *entity->getArgument(2); }
void IfcFillAreaStyleTiles::setTilingScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcFillAreaStyleTiles::is(Type::Enum v) const { return v == Type::IfcFillAreaStyleTiles || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFillAreaStyleTiles::type() const { return Type::IfcFillAreaStyleTiles; }
Type::Enum IfcFillAreaStyleTiles::Class() { return Type::IfcFillAreaStyleTiles; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFillAreaStyleTiles) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcOneDirectionRepeatFactor* v1_TilingPattern, IfcEntityList::ptr v2_Tiles, double v3_TilingScale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TilingPattern));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Tiles));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TilingScale));entity->setArgument(2,attr);} }

// Function implementations for IfcFilterType
IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterType::PredefinedType() const { return IfcFilterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFilterType::setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFilterTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFilterType::is(Type::Enum v) const { return v == Type::IfcFilterType || IfcFlowTreatmentDeviceType::is(v); }
Type::Enum IfcFilterType::type() const { return Type::IfcFilterType; }
Type::Enum IfcFilterType::Class() { return Type::IfcFilterType; }
IfcFilterType::IfcFilterType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFilterType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFilterType::IfcFilterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFilterTypeEnum::IfcFilterTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFilterTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcFireSuppressionTerminalType
IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalType::PredefinedType() const { return IfcFireSuppressionTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFireSuppressionTerminalType::setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFireSuppressionTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFireSuppressionTerminalType::is(Type::Enum v) const { return v == Type::IfcFireSuppressionTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcFireSuppressionTerminalType::type() const { return Type::IfcFireSuppressionTerminalType; }
Type::Enum IfcFireSuppressionTerminalType::Class() { return Type::IfcFireSuppressionTerminalType; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFireSuppressionTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFireSuppressionTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcFlowController
bool IfcFlowController::is(Type::Enum v) const { return v == Type::IfcFlowController || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowController::type() const { return Type::IfcFlowController; }
Type::Enum IfcFlowController::Class() { return Type::IfcFlowController; }
IfcFlowController::IfcFlowController(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowController) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowController::IfcFlowController(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowControllerType
bool IfcFlowControllerType::is(Type::Enum v) const { return v == Type::IfcFlowControllerType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowControllerType::type() const { return Type::IfcFlowControllerType; }
Type::Enum IfcFlowControllerType::Class() { return Type::IfcFlowControllerType; }
IfcFlowControllerType::IfcFlowControllerType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowControllerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowControllerType::IfcFlowControllerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowFitting
bool IfcFlowFitting::is(Type::Enum v) const { return v == Type::IfcFlowFitting || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowFitting::type() const { return Type::IfcFlowFitting; }
Type::Enum IfcFlowFitting::Class() { return Type::IfcFlowFitting; }
IfcFlowFitting::IfcFlowFitting(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowFitting) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowFitting::IfcFlowFitting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowFittingType
bool IfcFlowFittingType::is(Type::Enum v) const { return v == Type::IfcFlowFittingType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowFittingType::type() const { return Type::IfcFlowFittingType; }
Type::Enum IfcFlowFittingType::Class() { return Type::IfcFlowFittingType; }
IfcFlowFittingType::IfcFlowFittingType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowFittingType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowFittingType::IfcFlowFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowInstrumentType
IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentType::PredefinedType() const { return IfcFlowInstrumentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFlowInstrumentType::setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowInstrumentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFlowInstrumentType::is(Type::Enum v) const { return v == Type::IfcFlowInstrumentType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcFlowInstrumentType::type() const { return Type::IfcFlowInstrumentType; }
Type::Enum IfcFlowInstrumentType::Class() { return Type::IfcFlowInstrumentType; }
IfcFlowInstrumentType::IfcFlowInstrumentType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowInstrumentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowInstrumentType::IfcFlowInstrumentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFlowInstrumentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcFlowMeterType
IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterType::PredefinedType() const { return IfcFlowMeterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFlowMeterType::setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFlowMeterTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFlowMeterType::is(Type::Enum v) const { return v == Type::IfcFlowMeterType || IfcFlowControllerType::is(v); }
Type::Enum IfcFlowMeterType::type() const { return Type::IfcFlowMeterType; }
Type::Enum IfcFlowMeterType::Class() { return Type::IfcFlowMeterType; }
IfcFlowMeterType::IfcFlowMeterType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowMeterType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMeterType::IfcFlowMeterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcFlowMeterTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcFlowMovingDevice
bool IfcFlowMovingDevice::is(Type::Enum v) const { return v == Type::IfcFlowMovingDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowMovingDevice::type() const { return Type::IfcFlowMovingDevice; }
Type::Enum IfcFlowMovingDevice::Class() { return Type::IfcFlowMovingDevice; }
IfcFlowMovingDevice::IfcFlowMovingDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowMovingDevice) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMovingDevice::IfcFlowMovingDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowMovingDeviceType
bool IfcFlowMovingDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowMovingDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowMovingDeviceType::type() const { return Type::IfcFlowMovingDeviceType; }
Type::Enum IfcFlowMovingDeviceType::Class() { return Type::IfcFlowMovingDeviceType; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowMovingDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowSegment
bool IfcFlowSegment::is(Type::Enum v) const { return v == Type::IfcFlowSegment || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowSegment::type() const { return Type::IfcFlowSegment; }
Type::Enum IfcFlowSegment::Class() { return Type::IfcFlowSegment; }
IfcFlowSegment::IfcFlowSegment(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowSegment) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowSegment::IfcFlowSegment(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowSegmentType
bool IfcFlowSegmentType::is(Type::Enum v) const { return v == Type::IfcFlowSegmentType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowSegmentType::type() const { return Type::IfcFlowSegmentType; }
Type::Enum IfcFlowSegmentType::Class() { return Type::IfcFlowSegmentType; }
IfcFlowSegmentType::IfcFlowSegmentType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowSegmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowSegmentType::IfcFlowSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowStorageDevice
bool IfcFlowStorageDevice::is(Type::Enum v) const { return v == Type::IfcFlowStorageDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowStorageDevice::type() const { return Type::IfcFlowStorageDevice; }
Type::Enum IfcFlowStorageDevice::Class() { return Type::IfcFlowStorageDevice; }
IfcFlowStorageDevice::IfcFlowStorageDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowStorageDevice) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowStorageDevice::IfcFlowStorageDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowStorageDeviceType
bool IfcFlowStorageDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowStorageDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowStorageDeviceType::type() const { return Type::IfcFlowStorageDeviceType; }
Type::Enum IfcFlowStorageDeviceType::Class() { return Type::IfcFlowStorageDeviceType; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowStorageDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowTerminal
bool IfcFlowTerminal::is(Type::Enum v) const { return v == Type::IfcFlowTerminal || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowTerminal::type() const { return Type::IfcFlowTerminal; }
Type::Enum IfcFlowTerminal::Class() { return Type::IfcFlowTerminal; }
IfcFlowTerminal::IfcFlowTerminal(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowTerminal) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTerminal::IfcFlowTerminal(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowTerminalType
bool IfcFlowTerminalType::is(Type::Enum v) const { return v == Type::IfcFlowTerminalType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowTerminalType::type() const { return Type::IfcFlowTerminalType; }
Type::Enum IfcFlowTerminalType::Class() { return Type::IfcFlowTerminalType; }
IfcFlowTerminalType::IfcFlowTerminalType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTerminalType::IfcFlowTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFlowTreatmentDevice
bool IfcFlowTreatmentDevice::is(Type::Enum v) const { return v == Type::IfcFlowTreatmentDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowTreatmentDevice::type() const { return Type::IfcFlowTreatmentDevice; }
Type::Enum IfcFlowTreatmentDevice::Class() { return Type::IfcFlowTreatmentDevice; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowTreatmentDevice) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFlowTreatmentDeviceType
bool IfcFlowTreatmentDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowTreatmentDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowTreatmentDeviceType::type() const { return Type::IfcFlowTreatmentDeviceType; }
Type::Enum IfcFlowTreatmentDeviceType::Class() { return Type::IfcFlowTreatmentDeviceType; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFlowTreatmentDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFluidFlowProperties
IfcPropertySourceEnum::IfcPropertySourceEnum IfcFluidFlowProperties::PropertySource() const { return IfcPropertySourceEnum::FromString(*entity->getArgument(4)); }
void IfcFluidFlowProperties::setPropertySource(IfcPropertySourceEnum::IfcPropertySourceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPropertySourceEnum::ToString(v)));entity->setArgument(4,attr);} }
bool IfcFluidFlowProperties::hasFlowConditionTimeSeries() const { return !entity->getArgument(5)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::FlowConditionTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcFluidFlowProperties::setFlowConditionTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcFluidFlowProperties::hasVelocityTimeSeries() const { return !entity->getArgument(6)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::VelocityTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcFluidFlowProperties::setVelocityTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcFluidFlowProperties::hasFlowrateTimeSeries() const { return !entity->getArgument(7)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::FlowrateTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcFluidFlowProperties::setFlowrateTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcMaterial* IfcFluidFlowProperties::Fluid() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcFluidFlowProperties::setFluid(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcFluidFlowProperties::hasPressureTimeSeries() const { return !entity->getArgument(9)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::PressureTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcFluidFlowProperties::setPressureTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcFluidFlowProperties::hasUserDefinedPropertySource() const { return !entity->getArgument(10)->isNull(); }
std::string IfcFluidFlowProperties::UserDefinedPropertySource() const { return *entity->getArgument(10); }
void IfcFluidFlowProperties::setUserDefinedPropertySource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcFluidFlowProperties::hasTemperatureSingleValue() const { return !entity->getArgument(11)->isNull(); }
double IfcFluidFlowProperties::TemperatureSingleValue() const { return *entity->getArgument(11); }
void IfcFluidFlowProperties::setTemperatureSingleValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcFluidFlowProperties::hasWetBulbTemperatureSingleValue() const { return !entity->getArgument(12)->isNull(); }
double IfcFluidFlowProperties::WetBulbTemperatureSingleValue() const { return *entity->getArgument(12); }
void IfcFluidFlowProperties::setWetBulbTemperatureSingleValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcFluidFlowProperties::hasWetBulbTemperatureTimeSeries() const { return !entity->getArgument(13)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::WetBulbTemperatureTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(13))); }
void IfcFluidFlowProperties::setWetBulbTemperatureTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcFluidFlowProperties::hasTemperatureTimeSeries() const { return !entity->getArgument(14)->isNull(); }
IfcTimeSeries* IfcFluidFlowProperties::TemperatureTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(14))); }
void IfcFluidFlowProperties::setTemperatureTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcFluidFlowProperties::hasFlowrateSingleValue() const { return !entity->getArgument(15)->isNull(); }
IfcDerivedMeasureValue* IfcFluidFlowProperties::FlowrateSingleValue() const { return (IfcDerivedMeasureValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(15))); }
void IfcFluidFlowProperties::setFlowrateSingleValue(IfcDerivedMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(15,attr);} }
bool IfcFluidFlowProperties::hasFlowConditionSingleValue() const { return !entity->getArgument(16)->isNull(); }
double IfcFluidFlowProperties::FlowConditionSingleValue() const { return *entity->getArgument(16); }
void IfcFluidFlowProperties::setFlowConditionSingleValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(16,attr);} }
bool IfcFluidFlowProperties::hasVelocitySingleValue() const { return !entity->getArgument(17)->isNull(); }
double IfcFluidFlowProperties::VelocitySingleValue() const { return *entity->getArgument(17); }
void IfcFluidFlowProperties::setVelocitySingleValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(17,attr);} }
bool IfcFluidFlowProperties::hasPressureSingleValue() const { return !entity->getArgument(18)->isNull(); }
double IfcFluidFlowProperties::PressureSingleValue() const { return *entity->getArgument(18); }
void IfcFluidFlowProperties::setPressureSingleValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(18,attr);} }
bool IfcFluidFlowProperties::is(Type::Enum v) const { return v == Type::IfcFluidFlowProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcFluidFlowProperties::type() const { return Type::IfcFluidFlowProperties; }
Type::Enum IfcFluidFlowProperties::Class() { return Type::IfcFluidFlowProperties; }
IfcFluidFlowProperties::IfcFluidFlowProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFluidFlowProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFluidFlowProperties::IfcFluidFlowProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPropertySourceEnum::IfcPropertySourceEnum v5_PropertySource, IfcTimeSeries* v6_FlowConditionTimeSeries, IfcTimeSeries* v7_VelocityTimeSeries, IfcTimeSeries* v8_FlowrateTimeSeries, IfcMaterial* v9_Fluid, IfcTimeSeries* v10_PressureTimeSeries, boost::optional< std::string > v11_UserDefinedPropertySource, boost::optional< double > v12_TemperatureSingleValue, boost::optional< double > v13_WetBulbTemperatureSingleValue, IfcTimeSeries* v14_WetBulbTemperatureTimeSeries, IfcTimeSeries* v15_TemperatureTimeSeries, IfcDerivedMeasureValue* v16_FlowrateSingleValue, boost::optional< double > v17_FlowConditionSingleValue, boost::optional< double > v18_VelocitySingleValue, boost::optional< double > v19_PressureSingleValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_PropertySource,IfcPropertySourceEnum::ToString(v5_PropertySource))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FlowConditionTimeSeries));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_VelocityTimeSeries));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_FlowrateTimeSeries));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Fluid));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_PressureTimeSeries));entity->setArgument(9,attr);} if (v11_UserDefinedPropertySource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UserDefinedPropertySource));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_TemperatureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_TemperatureSingleValue));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_WetBulbTemperatureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_WetBulbTemperatureSingleValue));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_WetBulbTemperatureTimeSeries));entity->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_TemperatureTimeSeries));entity->setArgument(14,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v16_FlowrateSingleValue));entity->setArgument(15,attr);} if (v17_FlowConditionSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_FlowConditionSingleValue));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } if (v18_VelocitySingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_VelocitySingleValue));entity->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(17, attr); } if (v19_PressureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_PressureSingleValue));entity->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(18, attr); } }

// Function implementations for IfcFooting
IfcFootingTypeEnum::IfcFootingTypeEnum IfcFooting::PredefinedType() const { return IfcFootingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFooting::setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcFootingTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcFooting::is(Type::Enum v) const { return v == Type::IfcFooting || IfcBuildingElement::is(v); }
Type::Enum IfcFooting::type() const { return Type::IfcFooting; }
Type::Enum IfcFooting::Class() { return Type::IfcFooting; }
IfcFooting::IfcFooting(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFooting) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFooting::IfcFooting(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcFootingTypeEnum::IfcFootingTypeEnum v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_PredefinedType,IfcFootingTypeEnum::ToString(v9_PredefinedType))));entity->setArgument(8,attr);} }

// Function implementations for IfcFuelProperties
bool IfcFuelProperties::hasCombustionTemperature() const { return !entity->getArgument(1)->isNull(); }
double IfcFuelProperties::CombustionTemperature() const { return *entity->getArgument(1); }
void IfcFuelProperties::setCombustionTemperature(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcFuelProperties::hasCarbonContent() const { return !entity->getArgument(2)->isNull(); }
double IfcFuelProperties::CarbonContent() const { return *entity->getArgument(2); }
void IfcFuelProperties::setCarbonContent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcFuelProperties::hasLowerHeatingValue() const { return !entity->getArgument(3)->isNull(); }
double IfcFuelProperties::LowerHeatingValue() const { return *entity->getArgument(3); }
void IfcFuelProperties::setLowerHeatingValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcFuelProperties::hasHigherHeatingValue() const { return !entity->getArgument(4)->isNull(); }
double IfcFuelProperties::HigherHeatingValue() const { return *entity->getArgument(4); }
void IfcFuelProperties::setHigherHeatingValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcFuelProperties::is(Type::Enum v) const { return v == Type::IfcFuelProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcFuelProperties::type() const { return Type::IfcFuelProperties; }
Type::Enum IfcFuelProperties::Class() { return Type::IfcFuelProperties; }
IfcFuelProperties::IfcFuelProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFuelProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFuelProperties::IfcFuelProperties(IfcMaterial* v1_Material, boost::optional< double > v2_CombustionTemperature, boost::optional< double > v3_CarbonContent, boost::optional< double > v4_LowerHeatingValue, boost::optional< double > v5_HigherHeatingValue) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_CombustionTemperature) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_CombustionTemperature));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_CarbonContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_CarbonContent));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LowerHeatingValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LowerHeatingValue));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_HigherHeatingValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_HigherHeatingValue));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcFurnishingElement
bool IfcFurnishingElement::is(Type::Enum v) const { return v == Type::IfcFurnishingElement || IfcElement::is(v); }
Type::Enum IfcFurnishingElement::type() const { return Type::IfcFurnishingElement; }
Type::Enum IfcFurnishingElement::Class() { return Type::IfcFurnishingElement; }
IfcFurnishingElement::IfcFurnishingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFurnishingElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnishingElement::IfcFurnishingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcFurnishingElementType
bool IfcFurnishingElementType::is(Type::Enum v) const { return v == Type::IfcFurnishingElementType || IfcElementType::is(v); }
Type::Enum IfcFurnishingElementType::type() const { return Type::IfcFurnishingElementType; }
Type::Enum IfcFurnishingElementType::Class() { return Type::IfcFurnishingElementType; }
IfcFurnishingElementType::IfcFurnishingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFurnishingElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnishingElementType::IfcFurnishingElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcFurnitureStandard
bool IfcFurnitureStandard::is(Type::Enum v) const { return v == Type::IfcFurnitureStandard || IfcControl::is(v); }
Type::Enum IfcFurnitureStandard::type() const { return Type::IfcFurnitureStandard; }
Type::Enum IfcFurnitureStandard::Class() { return Type::IfcFurnitureStandard; }
IfcFurnitureStandard::IfcFurnitureStandard(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFurnitureStandard) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnitureStandard::IfcFurnitureStandard(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcFurnitureType
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcFurnitureType::AssemblyPlace() const { return IfcAssemblyPlaceEnum::FromString(*entity->getArgument(9)); }
void IfcFurnitureType::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAssemblyPlaceEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcFurnitureType::is(Type::Enum v) const { return v == Type::IfcFurnitureType || IfcFurnishingElementType::is(v); }
Type::Enum IfcFurnitureType::type() const { return Type::IfcFurnitureType; }
Type::Enum IfcFurnitureType::Class() { return Type::IfcFurnitureType; }
IfcFurnitureType::IfcFurnitureType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcFurnitureType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnitureType::IfcFurnitureType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v10_AssemblyPlace) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(v10_AssemblyPlace))));entity->setArgument(9,attr);} }

// Function implementations for IfcGasTerminalType
IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum IfcGasTerminalType::PredefinedType() const { return IfcGasTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcGasTerminalType::setPredefinedType(IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGasTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcGasTerminalType::is(Type::Enum v) const { return v == Type::IfcGasTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcGasTerminalType::type() const { return Type::IfcGasTerminalType; }
Type::Enum IfcGasTerminalType::Class() { return Type::IfcGasTerminalType; }
IfcGasTerminalType::IfcGasTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGasTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGasTerminalType::IfcGasTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcGasTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcGeneralMaterialProperties
bool IfcGeneralMaterialProperties::hasMolecularWeight() const { return !entity->getArgument(1)->isNull(); }
double IfcGeneralMaterialProperties::MolecularWeight() const { return *entity->getArgument(1); }
void IfcGeneralMaterialProperties::setMolecularWeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcGeneralMaterialProperties::hasPorosity() const { return !entity->getArgument(2)->isNull(); }
double IfcGeneralMaterialProperties::Porosity() const { return *entity->getArgument(2); }
void IfcGeneralMaterialProperties::setPorosity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcGeneralMaterialProperties::hasMassDensity() const { return !entity->getArgument(3)->isNull(); }
double IfcGeneralMaterialProperties::MassDensity() const { return *entity->getArgument(3); }
void IfcGeneralMaterialProperties::setMassDensity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcGeneralMaterialProperties::is(Type::Enum v) const { return v == Type::IfcGeneralMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcGeneralMaterialProperties::type() const { return Type::IfcGeneralMaterialProperties; }
Type::Enum IfcGeneralMaterialProperties::Class() { return Type::IfcGeneralMaterialProperties; }
IfcGeneralMaterialProperties::IfcGeneralMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeneralMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeneralMaterialProperties::IfcGeneralMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_MolecularWeight, boost::optional< double > v3_Porosity, boost::optional< double > v4_MassDensity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_MolecularWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MolecularWeight));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Porosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Porosity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_MassDensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MassDensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcGeneralProfileProperties
bool IfcGeneralProfileProperties::hasPhysicalWeight() const { return !entity->getArgument(2)->isNull(); }
double IfcGeneralProfileProperties::PhysicalWeight() const { return *entity->getArgument(2); }
void IfcGeneralProfileProperties::setPhysicalWeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcGeneralProfileProperties::hasPerimeter() const { return !entity->getArgument(3)->isNull(); }
double IfcGeneralProfileProperties::Perimeter() const { return *entity->getArgument(3); }
void IfcGeneralProfileProperties::setPerimeter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcGeneralProfileProperties::hasMinimumPlateThickness() const { return !entity->getArgument(4)->isNull(); }
double IfcGeneralProfileProperties::MinimumPlateThickness() const { return *entity->getArgument(4); }
void IfcGeneralProfileProperties::setMinimumPlateThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcGeneralProfileProperties::hasMaximumPlateThickness() const { return !entity->getArgument(5)->isNull(); }
double IfcGeneralProfileProperties::MaximumPlateThickness() const { return *entity->getArgument(5); }
void IfcGeneralProfileProperties::setMaximumPlateThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcGeneralProfileProperties::hasCrossSectionArea() const { return !entity->getArgument(6)->isNull(); }
double IfcGeneralProfileProperties::CrossSectionArea() const { return *entity->getArgument(6); }
void IfcGeneralProfileProperties::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcGeneralProfileProperties::is(Type::Enum v) const { return v == Type::IfcGeneralProfileProperties || IfcProfileProperties::is(v); }
Type::Enum IfcGeneralProfileProperties::type() const { return Type::IfcGeneralProfileProperties; }
Type::Enum IfcGeneralProfileProperties::Class() { return Type::IfcGeneralProfileProperties; }
IfcGeneralProfileProperties::IfcGeneralProfileProperties(IfcEntityInstanceData* e) : IfcProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeneralProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeneralProfileProperties::IfcGeneralProfileProperties(boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea) : IfcProfileProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));entity->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcGeometricCurveSet
bool IfcGeometricCurveSet::is(Type::Enum v) const { return v == Type::IfcGeometricCurveSet || IfcGeometricSet::is(v); }
Type::Enum IfcGeometricCurveSet::type() const { return Type::IfcGeometricCurveSet; }
Type::Enum IfcGeometricCurveSet::Class() { return Type::IfcGeometricCurveSet; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntityInstanceData* e) : IfcGeometricSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeometricCurveSet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntityList::ptr v1_Elements) : IfcGeometricSet((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));entity->setArgument(0,attr);} }

// Function implementations for IfcGeometricRepresentationContext
int IfcGeometricRepresentationContext::CoordinateSpaceDimension() const { return *entity->getArgument(2); }
void IfcGeometricRepresentationContext::setCoordinateSpaceDimension(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcGeometricRepresentationContext::hasPrecision() const { return !entity->getArgument(3)->isNull(); }
double IfcGeometricRepresentationContext::Precision() const { return *entity->getArgument(3); }
void IfcGeometricRepresentationContext::setPrecision(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
IfcAxis2Placement* IfcGeometricRepresentationContext::WorldCoordinateSystem() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcGeometricRepresentationContext::setWorldCoordinateSystem(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcGeometricRepresentationContext::hasTrueNorth() const { return !entity->getArgument(5)->isNull(); }
IfcDirection* IfcGeometricRepresentationContext::TrueNorth() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcGeometricRepresentationContext::setTrueNorth(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcGeometricRepresentationSubContext::list::ptr IfcGeometricRepresentationContext::HasSubContexts() const { return entity->getInverse(Type::IfcGeometricRepresentationSubContext, 6)->as<IfcGeometricRepresentationSubContext>(); }
bool IfcGeometricRepresentationContext::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationContext || IfcRepresentationContext::is(v); }
Type::Enum IfcGeometricRepresentationContext::type() const { return Type::IfcGeometricRepresentationContext; }
Type::Enum IfcGeometricRepresentationContext::Class() { return Type::IfcGeometricRepresentationContext; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(IfcEntityInstanceData* e) : IfcRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeometricRepresentationContext) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, int v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, IfcAxis2Placement* v5_WorldCoordinateSystem, IfcDirection* v6_TrueNorth) : IfcRepresentationContext((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CoordinateSpaceDimension));entity->setArgument(2,attr);} if (v4_Precision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Precision));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WorldCoordinateSystem));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TrueNorth));entity->setArgument(5,attr);} }

// Function implementations for IfcGeometricRepresentationItem
bool IfcGeometricRepresentationItem::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationItem || IfcRepresentationItem::is(v); }
Type::Enum IfcGeometricRepresentationItem::type() const { return Type::IfcGeometricRepresentationItem; }
Type::Enum IfcGeometricRepresentationItem::Class() { return Type::IfcGeometricRepresentationItem; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeometricRepresentationItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcGeometricRepresentationSubContext
IfcGeometricRepresentationContext* IfcGeometricRepresentationSubContext::ParentContext() const { return (IfcGeometricRepresentationContext*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcGeometricRepresentationSubContext::setParentContext(IfcGeometricRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcGeometricRepresentationSubContext::hasTargetScale() const { return !entity->getArgument(7)->isNull(); }
double IfcGeometricRepresentationSubContext::TargetScale() const { return *entity->getArgument(7); }
void IfcGeometricRepresentationSubContext::setTargetScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricRepresentationSubContext::TargetView() const { return IfcGeometricProjectionEnum::FromString(*entity->getArgument(8)); }
void IfcGeometricRepresentationSubContext::setTargetView(IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGeometricProjectionEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcGeometricRepresentationSubContext::hasUserDefinedTargetView() const { return !entity->getArgument(9)->isNull(); }
std::string IfcGeometricRepresentationSubContext::UserDefinedTargetView() const { return *entity->getArgument(9); }
void IfcGeometricRepresentationSubContext::setUserDefinedTargetView(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcGeometricRepresentationSubContext::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationSubContext || IfcGeometricRepresentationContext::is(v); }
Type::Enum IfcGeometricRepresentationSubContext::type() const { return Type::IfcGeometricRepresentationSubContext; }
Type::Enum IfcGeometricRepresentationSubContext::Class() { return Type::IfcGeometricRepresentationSubContext; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(IfcEntityInstanceData* e) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeometricRepresentationSubContext) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< double > v8_TargetScale, IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v9_TargetView, boost::optional< std::string > v10_UserDefinedTargetView) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ParentContext));entity->setArgument(6,attr);} if (v8_TargetScale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TargetScale));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_TargetView,IfcGeometricProjectionEnum::ToString(v9_TargetView))));entity->setArgument(8,attr);} if (v10_UserDefinedTargetView) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedTargetView));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcGeometricSet
IfcEntityList::ptr IfcGeometricSet::Elements() const { return *entity->getArgument(0); }
void IfcGeometricSet::setElements(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcGeometricSet::is(Type::Enum v) const { return v == Type::IfcGeometricSet || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcGeometricSet::type() const { return Type::IfcGeometricSet; }
Type::Enum IfcGeometricSet::Class() { return Type::IfcGeometricSet; }
IfcGeometricSet::IfcGeometricSet(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGeometricSet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricSet::IfcGeometricSet(IfcEntityList::ptr v1_Elements) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));entity->setArgument(0,attr);} }

// Function implementations for IfcGrid
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::UAxes() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcGridAxis>(); }
void IfcGrid::setUAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::VAxes() const { IfcEntityList::ptr es = *entity->getArgument(8); return es->as<IfcGridAxis>(); }
void IfcGrid::setVAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(8,attr);} }
bool IfcGrid::hasWAxes() const { return !entity->getArgument(9)->isNull(); }
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcGrid::WAxes() const { IfcEntityList::ptr es = *entity->getArgument(9); return es->as<IfcGridAxis>(); }
void IfcGrid::setWAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(9,attr);} }
IfcRelContainedInSpatialStructure::list::ptr IfcGrid::ContainedInStructure() const { return entity->getInverse(Type::IfcRelContainedInSpatialStructure, 4)->as<IfcRelContainedInSpatialStructure>(); }
bool IfcGrid::is(Type::Enum v) const { return v == Type::IfcGrid || IfcProduct::is(v); }
Type::Enum IfcGrid::type() const { return Type::IfcGrid; }
Type::Enum IfcGrid::Class() { return Type::IfcGrid; }
IfcGrid::IfcGrid(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGrid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGrid::IfcGrid(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcTemplatedEntityList< IfcGridAxis >::ptr v8_UAxes, IfcTemplatedEntityList< IfcGridAxis >::ptr v9_VAxes, boost::optional< IfcTemplatedEntityList< IfcGridAxis >::ptr > v10_WAxes) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_UAxes)->generalize());entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_VAxes)->generalize());entity->setArgument(8,attr);} if (v10_WAxes) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WAxes)->generalize());entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcGridAxis
bool IfcGridAxis::hasAxisTag() const { return !entity->getArgument(0)->isNull(); }
std::string IfcGridAxis::AxisTag() const { return *entity->getArgument(0); }
void IfcGridAxis::setAxisTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcCurve* IfcGridAxis::AxisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcGridAxis::setAxisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcGridAxis::SameSense() const { return *entity->getArgument(2); }
void IfcGridAxis::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcGrid::list::ptr IfcGridAxis::PartOfW() const { return entity->getInverse(Type::IfcGrid, 9)->as<IfcGrid>(); }
IfcGrid::list::ptr IfcGridAxis::PartOfV() const { return entity->getInverse(Type::IfcGrid, 8)->as<IfcGrid>(); }
IfcGrid::list::ptr IfcGridAxis::PartOfU() const { return entity->getInverse(Type::IfcGrid, 7)->as<IfcGrid>(); }
IfcVirtualGridIntersection::list::ptr IfcGridAxis::HasIntersections() const { return entity->getInverse(Type::IfcVirtualGridIntersection, 0)->as<IfcVirtualGridIntersection>(); }
bool IfcGridAxis::is(Type::Enum v) const { return v == Type::IfcGridAxis; }
Type::Enum IfcGridAxis::type() const { return Type::IfcGridAxis; }
Type::Enum IfcGridAxis::Class() { return Type::IfcGridAxis; }
IfcGridAxis::IfcGridAxis(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcGridAxis) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGridAxis::IfcGridAxis(boost::optional< std::string > v1_AxisTag, IfcCurve* v2_AxisCurve, bool v3_SameSense) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_AxisTag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_AxisTag));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AxisCurve));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));entity->setArgument(2,attr);} }

// Function implementations for IfcGridPlacement
IfcVirtualGridIntersection* IfcGridPlacement::PlacementLocation() const { return (IfcVirtualGridIntersection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcGridPlacement::setPlacementLocation(IfcVirtualGridIntersection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcGridPlacement::hasPlacementRefDirection() const { return !entity->getArgument(1)->isNull(); }
IfcVirtualGridIntersection* IfcGridPlacement::PlacementRefDirection() const { return (IfcVirtualGridIntersection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcGridPlacement::setPlacementRefDirection(IfcVirtualGridIntersection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcGridPlacement::is(Type::Enum v) const { return v == Type::IfcGridPlacement || IfcObjectPlacement::is(v); }
Type::Enum IfcGridPlacement::type() const { return Type::IfcGridPlacement; }
Type::Enum IfcGridPlacement::Class() { return Type::IfcGridPlacement; }
IfcGridPlacement::IfcGridPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGridPlacement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGridPlacement::IfcGridPlacement(IfcVirtualGridIntersection* v1_PlacementLocation, IfcVirtualGridIntersection* v2_PlacementRefDirection) : IfcObjectPlacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementLocation));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PlacementRefDirection));entity->setArgument(1,attr);} }

// Function implementations for IfcGroup
IfcRelAssignsToGroup::list::ptr IfcGroup::IsGroupedBy() const { return entity->getInverse(Type::IfcRelAssignsToGroup, 6)->as<IfcRelAssignsToGroup>(); }
bool IfcGroup::is(Type::Enum v) const { return v == Type::IfcGroup || IfcObject::is(v); }
Type::Enum IfcGroup::type() const { return Type::IfcGroup; }
Type::Enum IfcGroup::Class() { return Type::IfcGroup; }
IfcGroup::IfcGroup(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcGroup) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGroup::IfcGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcHalfSpaceSolid
IfcSurface* IfcHalfSpaceSolid::BaseSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcHalfSpaceSolid::setBaseSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcHalfSpaceSolid::AgreementFlag() const { return *entity->getArgument(1); }
void IfcHalfSpaceSolid::setAgreementFlag(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcHalfSpaceSolid::is(Type::Enum v) const { return v == Type::IfcHalfSpaceSolid || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcHalfSpaceSolid::type() const { return Type::IfcHalfSpaceSolid; }
Type::Enum IfcHalfSpaceSolid::Class() { return Type::IfcHalfSpaceSolid; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcHalfSpaceSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));entity->setArgument(1,attr);} }

// Function implementations for IfcHeatExchangerType
IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerType::PredefinedType() const { return IfcHeatExchangerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcHeatExchangerType::setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHeatExchangerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcHeatExchangerType::is(Type::Enum v) const { return v == Type::IfcHeatExchangerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcHeatExchangerType::type() const { return Type::IfcHeatExchangerType; }
Type::Enum IfcHeatExchangerType::Class() { return Type::IfcHeatExchangerType; }
IfcHeatExchangerType::IfcHeatExchangerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcHeatExchangerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHeatExchangerType::IfcHeatExchangerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcHeatExchangerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcHumidifierType
IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierType::PredefinedType() const { return IfcHumidifierTypeEnum::FromString(*entity->getArgument(9)); }
void IfcHumidifierType::setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcHumidifierTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcHumidifierType::is(Type::Enum v) const { return v == Type::IfcHumidifierType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcHumidifierType::type() const { return Type::IfcHumidifierType; }
Type::Enum IfcHumidifierType::Class() { return Type::IfcHumidifierType; }
IfcHumidifierType::IfcHumidifierType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcHumidifierType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHumidifierType::IfcHumidifierType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcHumidifierTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcHygroscopicMaterialProperties
bool IfcHygroscopicMaterialProperties::hasUpperVaporResistanceFactor() const { return !entity->getArgument(1)->isNull(); }
double IfcHygroscopicMaterialProperties::UpperVaporResistanceFactor() const { return *entity->getArgument(1); }
void IfcHygroscopicMaterialProperties::setUpperVaporResistanceFactor(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcHygroscopicMaterialProperties::hasLowerVaporResistanceFactor() const { return !entity->getArgument(2)->isNull(); }
double IfcHygroscopicMaterialProperties::LowerVaporResistanceFactor() const { return *entity->getArgument(2); }
void IfcHygroscopicMaterialProperties::setLowerVaporResistanceFactor(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcHygroscopicMaterialProperties::hasIsothermalMoistureCapacity() const { return !entity->getArgument(3)->isNull(); }
double IfcHygroscopicMaterialProperties::IsothermalMoistureCapacity() const { return *entity->getArgument(3); }
void IfcHygroscopicMaterialProperties::setIsothermalMoistureCapacity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcHygroscopicMaterialProperties::hasVaporPermeability() const { return !entity->getArgument(4)->isNull(); }
double IfcHygroscopicMaterialProperties::VaporPermeability() const { return *entity->getArgument(4); }
void IfcHygroscopicMaterialProperties::setVaporPermeability(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcHygroscopicMaterialProperties::hasMoistureDiffusivity() const { return !entity->getArgument(5)->isNull(); }
double IfcHygroscopicMaterialProperties::MoistureDiffusivity() const { return *entity->getArgument(5); }
void IfcHygroscopicMaterialProperties::setMoistureDiffusivity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcHygroscopicMaterialProperties::is(Type::Enum v) const { return v == Type::IfcHygroscopicMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcHygroscopicMaterialProperties::type() const { return Type::IfcHygroscopicMaterialProperties; }
Type::Enum IfcHygroscopicMaterialProperties::Class() { return Type::IfcHygroscopicMaterialProperties; }
IfcHygroscopicMaterialProperties::IfcHygroscopicMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcHygroscopicMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHygroscopicMaterialProperties::IfcHygroscopicMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_UpperVaporResistanceFactor, boost::optional< double > v3_LowerVaporResistanceFactor, boost::optional< double > v4_IsothermalMoistureCapacity, boost::optional< double > v5_VaporPermeability, boost::optional< double > v6_MoistureDiffusivity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_UpperVaporResistanceFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_UpperVaporResistanceFactor));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LowerVaporResistanceFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LowerVaporResistanceFactor));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_IsothermalMoistureCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_IsothermalMoistureCapacity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_VaporPermeability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_VaporPermeability));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MoistureDiffusivity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MoistureDiffusivity));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcIShapeProfileDef
double IfcIShapeProfileDef::OverallWidth() const { return *entity->getArgument(3); }
void IfcIShapeProfileDef::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcIShapeProfileDef::OverallDepth() const { return *entity->getArgument(4); }
void IfcIShapeProfileDef::setOverallDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcIShapeProfileDef::WebThickness() const { return *entity->getArgument(5); }
void IfcIShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcIShapeProfileDef::FlangeThickness() const { return *entity->getArgument(6); }
void IfcIShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcIShapeProfileDef::hasFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcIShapeProfileDef::FilletRadius() const { return *entity->getArgument(7); }
void IfcIShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcIShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcIShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcIShapeProfileDef::type() const { return Type::IfcIShapeProfileDef; }
Type::Enum IfcIShapeProfileDef::Class() { return Type::IfcIShapeProfileDef; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcIShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallWidth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));entity->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcImageTexture
std::string IfcImageTexture::UrlReference() const { return *entity->getArgument(4); }
void IfcImageTexture::setUrlReference(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcImageTexture::is(Type::Enum v) const { return v == Type::IfcImageTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcImageTexture::type() const { return Type::IfcImageTexture; }
Type::Enum IfcImageTexture::Class() { return Type::IfcImageTexture; }
IfcImageTexture::IfcImageTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcImageTexture) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcImageTexture::IfcImageTexture(bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_UrlReference) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,IfcSurfaceTextureEnum::ToString(v3_TextureType))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_UrlReference));entity->setArgument(4,attr);} }

// Function implementations for IfcInventory
IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventory::InventoryType() const { return IfcInventoryTypeEnum::FromString(*entity->getArgument(5)); }
void IfcInventory::setInventoryType(IfcInventoryTypeEnum::IfcInventoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInventoryTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
IfcActorSelect* IfcInventory::Jurisdiction() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcInventory::setJurisdiction(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcTemplatedEntityList< IfcPerson >::ptr IfcInventory::ResponsiblePersons() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcPerson>(); }
void IfcInventory::setResponsiblePersons(IfcTemplatedEntityList< IfcPerson >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
IfcCalendarDate* IfcInventory::LastUpdateDate() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcInventory::setLastUpdateDate(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcInventory::hasCurrentValue() const { return !entity->getArgument(9)->isNull(); }
IfcCostValue* IfcInventory::CurrentValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcInventory::setCurrentValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcInventory::hasOriginalValue() const { return !entity->getArgument(10)->isNull(); }
IfcCostValue* IfcInventory::OriginalValue() const { return (IfcCostValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcInventory::setOriginalValue(IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcInventory::is(Type::Enum v) const { return v == Type::IfcInventory || IfcGroup::is(v); }
Type::Enum IfcInventory::type() const { return Type::IfcInventory; }
Type::Enum IfcInventory::Class() { return Type::IfcInventory; }
IfcInventory::IfcInventory(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcInventory) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcInventory::IfcInventory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcInventoryTypeEnum::IfcInventoryTypeEnum v6_InventoryType, IfcActorSelect* v7_Jurisdiction, IfcTemplatedEntityList< IfcPerson >::ptr v8_ResponsiblePersons, IfcCalendarDate* v9_LastUpdateDate, IfcCostValue* v10_CurrentValue, IfcCostValue* v11_OriginalValue) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_InventoryType,IfcInventoryTypeEnum::ToString(v6_InventoryType))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Jurisdiction));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ResponsiblePersons)->generalize());entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_LastUpdateDate));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_CurrentValue));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_OriginalValue));entity->setArgument(10,attr);} }

// Function implementations for IfcIrregularTimeSeries
IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr IfcIrregularTimeSeries::Values() const { IfcEntityList::ptr es = *entity->getArgument(8); return es->as<IfcIrregularTimeSeriesValue>(); }
void IfcIrregularTimeSeries::setValues(IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(8,attr);} }
bool IfcIrregularTimeSeries::is(Type::Enum v) const { return v == Type::IfcIrregularTimeSeries || IfcTimeSeries::is(v); }
Type::Enum IfcIrregularTimeSeries::type() const { return Type::IfcIrregularTimeSeries; }
Type::Enum IfcIrregularTimeSeries::Class() { return Type::IfcIrregularTimeSeries; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcIrregularTimeSeries) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v9_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));entity->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Values)->generalize());entity->setArgument(8,attr);} }

// Function implementations for IfcIrregularTimeSeriesValue
IfcDateTimeSelect* IfcIrregularTimeSeriesValue::TimeStamp() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcIrregularTimeSeriesValue::setTimeStamp(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcIrregularTimeSeriesValue::ListValues() const { return *entity->getArgument(1); }
void IfcIrregularTimeSeriesValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcIrregularTimeSeriesValue::is(Type::Enum v) const { return v == Type::IfcIrregularTimeSeriesValue; }
Type::Enum IfcIrregularTimeSeriesValue::type() const { return Type::IfcIrregularTimeSeriesValue; }
Type::Enum IfcIrregularTimeSeriesValue::Class() { return Type::IfcIrregularTimeSeriesValue; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcIrregularTimeSeriesValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcDateTimeSelect* v1_TimeStamp, IfcEntityList::ptr v2_ListValues) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TimeStamp));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ListValues));entity->setArgument(1,attr);} }

// Function implementations for IfcJunctionBoxType
IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxType::PredefinedType() const { return IfcJunctionBoxTypeEnum::FromString(*entity->getArgument(9)); }
void IfcJunctionBoxType::setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcJunctionBoxTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcJunctionBoxType::is(Type::Enum v) const { return v == Type::IfcJunctionBoxType || IfcFlowFittingType::is(v); }
Type::Enum IfcJunctionBoxType::type() const { return Type::IfcJunctionBoxType; }
Type::Enum IfcJunctionBoxType::Class() { return Type::IfcJunctionBoxType; }
IfcJunctionBoxType::IfcJunctionBoxType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcJunctionBoxType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcJunctionBoxType::IfcJunctionBoxType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcJunctionBoxTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcLShapeProfileDef
double IfcLShapeProfileDef::Depth() const { return *entity->getArgument(3); }
void IfcLShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcLShapeProfileDef::hasWidth() const { return !entity->getArgument(4)->isNull(); }
double IfcLShapeProfileDef::Width() const { return *entity->getArgument(4); }
void IfcLShapeProfileDef::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcLShapeProfileDef::Thickness() const { return *entity->getArgument(5); }
void IfcLShapeProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcLShapeProfileDef::hasFilletRadius() const { return !entity->getArgument(6)->isNull(); }
double IfcLShapeProfileDef::FilletRadius() const { return *entity->getArgument(6); }
void IfcLShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcLShapeProfileDef::hasEdgeRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcLShapeProfileDef::EdgeRadius() const { return *entity->getArgument(7); }
void IfcLShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcLShapeProfileDef::hasLegSlope() const { return !entity->getArgument(8)->isNull(); }
double IfcLShapeProfileDef::LegSlope() const { return *entity->getArgument(8); }
void IfcLShapeProfileDef::setLegSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcLShapeProfileDef::hasCentreOfGravityInX() const { return !entity->getArgument(9)->isNull(); }
double IfcLShapeProfileDef::CentreOfGravityInX() const { return *entity->getArgument(9); }
void IfcLShapeProfileDef::setCentreOfGravityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcLShapeProfileDef::hasCentreOfGravityInY() const { return !entity->getArgument(10)->isNull(); }
double IfcLShapeProfileDef::CentreOfGravityInY() const { return *entity->getArgument(10); }
void IfcLShapeProfileDef::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcLShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcLShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcLShapeProfileDef::type() const { return Type::IfcLShapeProfileDef; }
Type::Enum IfcLShapeProfileDef::Class() { return Type::IfcLShapeProfileDef; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, boost::optional< double > v5_Width, double v6_Thickness, boost::optional< double > v7_FilletRadius, boost::optional< double > v8_EdgeRadius, boost::optional< double > v9_LegSlope, boost::optional< double > v10_CentreOfGravityInX, boost::optional< double > v11_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);} if (v5_Width) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Width));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Thickness));entity->setArgument(5,attr);} if (v7_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FilletRadius));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_EdgeRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_LegSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LegSlope));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_CentreOfGravityInX));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CentreOfGravityInY));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcLaborResource
bool IfcLaborResource::hasSkillSet() const { return !entity->getArgument(9)->isNull(); }
std::string IfcLaborResource::SkillSet() const { return *entity->getArgument(9); }
void IfcLaborResource::setSkillSet(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcLaborResource::is(Type::Enum v) const { return v == Type::IfcLaborResource || IfcConstructionResource::is(v); }
Type::Enum IfcLaborResource::type() const { return Type::IfcLaborResource; }
Type::Enum IfcLaborResource::Class() { return Type::IfcLaborResource; }
IfcLaborResource::IfcLaborResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLaborResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLaborResource::IfcLaborResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< std::string > v10_SkillSet) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);} if (v10_SkillSet) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SkillSet));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcLampType
IfcLampTypeEnum::IfcLampTypeEnum IfcLampType::PredefinedType() const { return IfcLampTypeEnum::FromString(*entity->getArgument(9)); }
void IfcLampType::setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLampTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcLampType::is(Type::Enum v) const { return v == Type::IfcLampType || IfcFlowTerminalType::is(v); }
Type::Enum IfcLampType::type() const { return Type::IfcLampType; }
Type::Enum IfcLampType::Class() { return Type::IfcLampType; }
IfcLampType::IfcLampType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLampType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLampType::IfcLampType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLampTypeEnum::IfcLampTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcLampTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcLibraryInformation
std::string IfcLibraryInformation::Name() const { return *entity->getArgument(0); }
void IfcLibraryInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcLibraryInformation::hasVersion() const { return !entity->getArgument(1)->isNull(); }
std::string IfcLibraryInformation::Version() const { return *entity->getArgument(1); }
void IfcLibraryInformation::setVersion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcLibraryInformation::hasPublisher() const { return !entity->getArgument(2)->isNull(); }
IfcOrganization* IfcLibraryInformation::Publisher() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcLibraryInformation::setPublisher(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcLibraryInformation::hasVersionDate() const { return !entity->getArgument(3)->isNull(); }
IfcCalendarDate* IfcLibraryInformation::VersionDate() const { return (IfcCalendarDate*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcLibraryInformation::setVersionDate(IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcLibraryInformation::hasLibraryReference() const { return !entity->getArgument(4)->isNull(); }
IfcTemplatedEntityList< IfcLibraryReference >::ptr IfcLibraryInformation::LibraryReference() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcLibraryReference>(); }
void IfcLibraryInformation::setLibraryReference(IfcTemplatedEntityList< IfcLibraryReference >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
bool IfcLibraryInformation::is(Type::Enum v) const { return v == Type::IfcLibraryInformation; }
Type::Enum IfcLibraryInformation::type() const { return Type::IfcLibraryInformation; }
Type::Enum IfcLibraryInformation::Class() { return Type::IfcLibraryInformation; }
IfcLibraryInformation::IfcLibraryInformation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcLibraryInformation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLibraryInformation::IfcLibraryInformation(std::string v1_Name, boost::optional< std::string > v2_Version, IfcOrganization* v3_Publisher, IfcCalendarDate* v4_VersionDate, boost::optional< IfcTemplatedEntityList< IfcLibraryReference >::ptr > v5_LibraryReference) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Version) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Version));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Publisher));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_VersionDate));entity->setArgument(3,attr);} if (v5_LibraryReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LibraryReference)->generalize());entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcLibraryReference
IfcLibraryInformation::list::ptr IfcLibraryReference::ReferenceIntoLibrary() const { return entity->getInverse(Type::IfcLibraryInformation, 4)->as<IfcLibraryInformation>(); }
bool IfcLibraryReference::is(Type::Enum v) const { return v == Type::IfcLibraryReference || IfcExternalReference::is(v); }
Type::Enum IfcLibraryReference::type() const { return Type::IfcLibraryReference; }
Type::Enum IfcLibraryReference::Class() { return Type::IfcLibraryReference; }
IfcLibraryReference::IfcLibraryReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLibraryReference) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLibraryReference::IfcLibraryReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcLightDistributionData
double IfcLightDistributionData::MainPlaneAngle() const { return *entity->getArgument(0); }
void IfcLightDistributionData::setMainPlaneAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::vector< double > /*[1:?]*/ IfcLightDistributionData::SecondaryPlaneAngle() const { return *entity->getArgument(1); }
void IfcLightDistributionData::setSecondaryPlaneAngle(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
std::vector< double > /*[1:?]*/ IfcLightDistributionData::LuminousIntensity() const { return *entity->getArgument(2); }
void IfcLightDistributionData::setLuminousIntensity(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcLightDistributionData::is(Type::Enum v) const { return v == Type::IfcLightDistributionData; }
Type::Enum IfcLightDistributionData::type() const { return Type::IfcLightDistributionData; }
Type::Enum IfcLightDistributionData::Class() { return Type::IfcLightDistributionData; }
IfcLightDistributionData::IfcLightDistributionData(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcLightDistributionData) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightDistributionData::IfcLightDistributionData(double v1_MainPlaneAngle, std::vector< double > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< double > /*[1:?]*/ v3_LuminousIntensity) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MainPlaneAngle));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SecondaryPlaneAngle));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LuminousIntensity));entity->setArgument(2,attr);} }

// Function implementations for IfcLightFixtureType
IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureType::PredefinedType() const { return IfcLightFixtureTypeEnum::FromString(*entity->getArgument(9)); }
void IfcLightFixtureType::setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightFixtureTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcLightFixtureType::is(Type::Enum v) const { return v == Type::IfcLightFixtureType || IfcFlowTerminalType::is(v); }
Type::Enum IfcLightFixtureType::type() const { return Type::IfcLightFixtureType; }
Type::Enum IfcLightFixtureType::Class() { return Type::IfcLightFixtureType; }
IfcLightFixtureType::IfcLightFixtureType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightFixtureType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightFixtureType::IfcLightFixtureType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcLightFixtureTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcLightIntensityDistribution
IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightIntensityDistribution::LightDistributionCurve() const { return IfcLightDistributionCurveEnum::FromString(*entity->getArgument(0)); }
void IfcLightIntensityDistribution::setLightDistributionCurve(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightDistributionCurveEnum::ToString(v)));entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcLightDistributionData >::ptr IfcLightIntensityDistribution::DistributionData() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcLightDistributionData>(); }
void IfcLightIntensityDistribution::setDistributionData(IfcTemplatedEntityList< IfcLightDistributionData >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcLightIntensityDistribution::is(Type::Enum v) const { return v == Type::IfcLightIntensityDistribution; }
Type::Enum IfcLightIntensityDistribution::type() const { return Type::IfcLightIntensityDistribution; }
Type::Enum IfcLightIntensityDistribution::Class() { return Type::IfcLightIntensityDistribution; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcLightIntensityDistribution) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v1_LightDistributionCurve, IfcTemplatedEntityList< IfcLightDistributionData >::ptr v2_DistributionData) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_LightDistributionCurve,IfcLightDistributionCurveEnum::ToString(v1_LightDistributionCurve))));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DistributionData)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcLightSource
bool IfcLightSource::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcLightSource::Name() const { return *entity->getArgument(0); }
void IfcLightSource::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcColourRgb* IfcLightSource::LightColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcLightSource::setLightColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcLightSource::hasAmbientIntensity() const { return !entity->getArgument(2)->isNull(); }
double IfcLightSource::AmbientIntensity() const { return *entity->getArgument(2); }
void IfcLightSource::setAmbientIntensity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcLightSource::hasIntensity() const { return !entity->getArgument(3)->isNull(); }
double IfcLightSource::Intensity() const { return *entity->getArgument(3); }
void IfcLightSource::setIntensity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcLightSource::is(Type::Enum v) const { return v == Type::IfcLightSource || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcLightSource::type() const { return Type::IfcLightSource; }
Type::Enum IfcLightSource::Class() { return Type::IfcLightSource; }
IfcLightSource::IfcLightSource(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSource::IfcLightSource(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcLightSourceAmbient
bool IfcLightSourceAmbient::is(Type::Enum v) const { return v == Type::IfcLightSourceAmbient || IfcLightSource::is(v); }
Type::Enum IfcLightSourceAmbient::type() const { return Type::IfcLightSourceAmbient; }
Type::Enum IfcLightSourceAmbient::Class() { return Type::IfcLightSourceAmbient; }
IfcLightSourceAmbient::IfcLightSourceAmbient(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSourceAmbient) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceAmbient::IfcLightSourceAmbient(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcLightSource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcLightSourceDirectional
IfcDirection* IfcLightSourceDirectional::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcLightSourceDirectional::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcLightSourceDirectional::is(Type::Enum v) const { return v == Type::IfcLightSourceDirectional || IfcLightSource::is(v); }
Type::Enum IfcLightSourceDirectional::type() const { return Type::IfcLightSourceDirectional; }
Type::Enum IfcLightSourceDirectional::Class() { return Type::IfcLightSourceDirectional; }
IfcLightSourceDirectional::IfcLightSourceDirectional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSourceDirectional) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceDirectional::IfcLightSourceDirectional(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcDirection* v5_Orientation) : IfcLightSource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Orientation));entity->setArgument(4,attr);} }

// Function implementations for IfcLightSourceGoniometric
IfcAxis2Placement3D* IfcLightSourceGoniometric::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcLightSourceGoniometric::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcLightSourceGoniometric::hasColourAppearance() const { return !entity->getArgument(5)->isNull(); }
IfcColourRgb* IfcLightSourceGoniometric::ColourAppearance() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcLightSourceGoniometric::setColourAppearance(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcLightSourceGoniometric::ColourTemperature() const { return *entity->getArgument(6); }
void IfcLightSourceGoniometric::setColourTemperature(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
double IfcLightSourceGoniometric::LuminousFlux() const { return *entity->getArgument(7); }
void IfcLightSourceGoniometric::setLuminousFlux(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightSourceGoniometric::LightEmissionSource() const { return IfcLightEmissionSourceEnum::FromString(*entity->getArgument(8)); }
void IfcLightSourceGoniometric::setLightEmissionSource(IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLightEmissionSourceEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcLightDistributionDataSourceSelect* IfcLightSourceGoniometric::LightDistributionDataSource() const { return (IfcLightDistributionDataSourceSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcLightSourceGoniometric::setLightDistributionDataSource(IfcLightDistributionDataSourceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcLightSourceGoniometric::is(Type::Enum v) const { return v == Type::IfcLightSourceGoniometric || IfcLightSource::is(v); }
Type::Enum IfcLightSourceGoniometric::type() const { return Type::IfcLightSourceGoniometric; }
Type::Enum IfcLightSourceGoniometric::Class() { return Type::IfcLightSourceGoniometric; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSourceGoniometric) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcAxis2Placement3D* v5_Position, IfcColourRgb* v6_ColourAppearance, double v7_ColourTemperature, double v8_LuminousFlux, IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v9_LightEmissionSource, IfcLightDistributionDataSourceSelect* v10_LightDistributionDataSource) : IfcLightSource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ColourAppearance));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ColourTemperature));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LuminousFlux));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_LightEmissionSource,IfcLightEmissionSourceEnum::ToString(v9_LightEmissionSource))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_LightDistributionDataSource));entity->setArgument(9,attr);} }

// Function implementations for IfcLightSourcePositional
IfcCartesianPoint* IfcLightSourcePositional::Position() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcLightSourcePositional::setPosition(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcLightSourcePositional::Radius() const { return *entity->getArgument(5); }
void IfcLightSourcePositional::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcLightSourcePositional::ConstantAttenuation() const { return *entity->getArgument(6); }
void IfcLightSourcePositional::setConstantAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
double IfcLightSourcePositional::DistanceAttenuation() const { return *entity->getArgument(7); }
void IfcLightSourcePositional::setDistanceAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
double IfcLightSourcePositional::QuadricAttenuation() const { return *entity->getArgument(8); }
void IfcLightSourcePositional::setQuadricAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcLightSourcePositional::is(Type::Enum v) const { return v == Type::IfcLightSourcePositional || IfcLightSource::is(v); }
Type::Enum IfcLightSourcePositional::type() const { return Type::IfcLightSourcePositional; }
Type::Enum IfcLightSourcePositional::Class() { return Type::IfcLightSourcePositional; }
IfcLightSourcePositional::IfcLightSourcePositional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSourcePositional) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourcePositional::IfcLightSourcePositional(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation) : IfcLightSource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));entity->setArgument(8,attr);} }

// Function implementations for IfcLightSourceSpot
IfcDirection* IfcLightSourceSpot::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcLightSourceSpot::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcLightSourceSpot::hasConcentrationExponent() const { return !entity->getArgument(10)->isNull(); }
double IfcLightSourceSpot::ConcentrationExponent() const { return *entity->getArgument(10); }
void IfcLightSourceSpot::setConcentrationExponent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
double IfcLightSourceSpot::SpreadAngle() const { return *entity->getArgument(11); }
void IfcLightSourceSpot::setSpreadAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
double IfcLightSourceSpot::BeamWidthAngle() const { return *entity->getArgument(12); }
void IfcLightSourceSpot::setBeamWidthAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcLightSourceSpot::is(Type::Enum v) const { return v == Type::IfcLightSourceSpot || IfcLightSourcePositional::is(v); }
Type::Enum IfcLightSourceSpot::type() const { return Type::IfcLightSourceSpot; }
Type::Enum IfcLightSourceSpot::Class() { return Type::IfcLightSourceSpot; }
IfcLightSourceSpot::IfcLightSourceSpot(IfcEntityInstanceData* e) : IfcLightSourcePositional((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLightSourceSpot) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceSpot::IfcLightSourceSpot(boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation, IfcDirection* v10_Orientation, boost::optional< double > v11_ConcentrationExponent, double v12_SpreadAngle, double v13_BeamWidthAngle) : IfcLightSourcePositional((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));entity->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Orientation));entity->setArgument(9,attr);} if (v11_ConcentrationExponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ConcentrationExponent));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_SpreadAngle));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_BeamWidthAngle));entity->setArgument(12,attr);} }

// Function implementations for IfcLine
IfcCartesianPoint* IfcLine::Pnt() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcLine::setPnt(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcVector* IfcLine::Dir() const { return (IfcVector*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcLine::setDir(IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcLine::is(Type::Enum v) const { return v == Type::IfcLine || IfcCurve::is(v); }
Type::Enum IfcLine::type() const { return Type::IfcLine; }
Type::Enum IfcLine::Class() { return Type::IfcLine; }
IfcLine::IfcLine(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLine) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLine::IfcLine(IfcCartesianPoint* v1_Pnt, IfcVector* v2_Dir) : IfcCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Pnt));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Dir));entity->setArgument(1,attr);} }

// Function implementations for IfcLinearDimension
bool IfcLinearDimension::is(Type::Enum v) const { return v == Type::IfcLinearDimension || IfcDimensionCurveDirectedCallout::is(v); }
Type::Enum IfcLinearDimension::type() const { return Type::IfcLinearDimension; }
Type::Enum IfcLinearDimension::Class() { return Type::IfcLinearDimension; }
IfcLinearDimension::IfcLinearDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLinearDimension) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLinearDimension::IfcLinearDimension(IfcEntityList::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcLocalPlacement
bool IfcLocalPlacement::hasPlacementRelTo() const { return !entity->getArgument(0)->isNull(); }
IfcObjectPlacement* IfcLocalPlacement::PlacementRelTo() const { return (IfcObjectPlacement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcLocalPlacement::setPlacementRelTo(IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcAxis2Placement* IfcLocalPlacement::RelativePlacement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcLocalPlacement::setRelativePlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcLocalPlacement::is(Type::Enum v) const { return v == Type::IfcLocalPlacement || IfcObjectPlacement::is(v); }
Type::Enum IfcLocalPlacement::type() const { return Type::IfcLocalPlacement; }
Type::Enum IfcLocalPlacement::Class() { return Type::IfcLocalPlacement; }
IfcLocalPlacement::IfcLocalPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLocalPlacement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLocalPlacement::IfcLocalPlacement(IfcObjectPlacement* v1_PlacementRelTo, IfcAxis2Placement* v2_RelativePlacement) : IfcObjectPlacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementRelTo));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelativePlacement));entity->setArgument(1,attr);} }

// Function implementations for IfcLocalTime
int IfcLocalTime::HourComponent() const { return *entity->getArgument(0); }
void IfcLocalTime::setHourComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcLocalTime::hasMinuteComponent() const { return !entity->getArgument(1)->isNull(); }
int IfcLocalTime::MinuteComponent() const { return *entity->getArgument(1); }
void IfcLocalTime::setMinuteComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcLocalTime::hasSecondComponent() const { return !entity->getArgument(2)->isNull(); }
double IfcLocalTime::SecondComponent() const { return *entity->getArgument(2); }
void IfcLocalTime::setSecondComponent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcLocalTime::hasZone() const { return !entity->getArgument(3)->isNull(); }
IfcCoordinatedUniversalTimeOffset* IfcLocalTime::Zone() const { return (IfcCoordinatedUniversalTimeOffset*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcLocalTime::setZone(IfcCoordinatedUniversalTimeOffset* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcLocalTime::hasDaylightSavingOffset() const { return !entity->getArgument(4)->isNull(); }
int IfcLocalTime::DaylightSavingOffset() const { return *entity->getArgument(4); }
void IfcLocalTime::setDaylightSavingOffset(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcLocalTime::is(Type::Enum v) const { return v == Type::IfcLocalTime; }
Type::Enum IfcLocalTime::type() const { return Type::IfcLocalTime; }
Type::Enum IfcLocalTime::Class() { return Type::IfcLocalTime; }
IfcLocalTime::IfcLocalTime(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcLocalTime) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLocalTime::IfcLocalTime(int v1_HourComponent, boost::optional< int > v2_MinuteComponent, boost::optional< double > v3_SecondComponent, IfcCoordinatedUniversalTimeOffset* v4_Zone, boost::optional< int > v5_DaylightSavingOffset) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HourComponent));entity->setArgument(0,attr);} if (v2_MinuteComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MinuteComponent));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_SecondComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SecondComponent));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Zone));entity->setArgument(3,attr);} if (v5_DaylightSavingOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DaylightSavingOffset));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcLoop
bool IfcLoop::is(Type::Enum v) const { return v == Type::IfcLoop || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcLoop::type() const { return Type::IfcLoop; }
Type::Enum IfcLoop::Class() { return Type::IfcLoop; }
IfcLoop::IfcLoop(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcLoop) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLoop::IfcLoop() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcManifoldSolidBrep
IfcClosedShell* IfcManifoldSolidBrep::Outer() const { return (IfcClosedShell*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcManifoldSolidBrep::setOuter(IfcClosedShell* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcManifoldSolidBrep::is(Type::Enum v) const { return v == Type::IfcManifoldSolidBrep || IfcSolidModel::is(v); }
Type::Enum IfcManifoldSolidBrep::type() const { return Type::IfcManifoldSolidBrep; }
Type::Enum IfcManifoldSolidBrep::Class() { return Type::IfcManifoldSolidBrep; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcManifoldSolidBrep) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcClosedShell* v1_Outer) : IfcSolidModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));entity->setArgument(0,attr);} }

// Function implementations for IfcMappedItem
IfcRepresentationMap* IfcMappedItem::MappingSource() const { return (IfcRepresentationMap*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcMappedItem::setMappingSource(IfcRepresentationMap* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcCartesianTransformationOperator* IfcMappedItem::MappingTarget() const { return (IfcCartesianTransformationOperator*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcMappedItem::setMappingTarget(IfcCartesianTransformationOperator* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMappedItem::is(Type::Enum v) const { return v == Type::IfcMappedItem || IfcRepresentationItem::is(v); }
Type::Enum IfcMappedItem::type() const { return Type::IfcMappedItem; }
Type::Enum IfcMappedItem::Class() { return Type::IfcMappedItem; }
IfcMappedItem::IfcMappedItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMappedItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMappedItem::IfcMappedItem(IfcRepresentationMap* v1_MappingSource, IfcCartesianTransformationOperator* v2_MappingTarget) : IfcRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingSource));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappingTarget));entity->setArgument(1,attr);} }

// Function implementations for IfcMaterial
std::string IfcMaterial::Name() const { return *entity->getArgument(0); }
void IfcMaterial::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcMaterialDefinitionRepresentation::list::ptr IfcMaterial::HasRepresentation() const { return entity->getInverse(Type::IfcMaterialDefinitionRepresentation, 3)->as<IfcMaterialDefinitionRepresentation>(); }
IfcMaterialClassificationRelationship::list::ptr IfcMaterial::ClassifiedAs() const { return entity->getInverse(Type::IfcMaterialClassificationRelationship, 1)->as<IfcMaterialClassificationRelationship>(); }
bool IfcMaterial::is(Type::Enum v) const { return v == Type::IfcMaterial; }
Type::Enum IfcMaterial::type() const { return Type::IfcMaterial; }
Type::Enum IfcMaterial::Class() { return Type::IfcMaterial; }
IfcMaterial::IfcMaterial(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterial) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterial::IfcMaterial(std::string v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcMaterialClassificationRelationship
IfcEntityList::ptr IfcMaterialClassificationRelationship::MaterialClassifications() const { return *entity->getArgument(0); }
void IfcMaterialClassificationRelationship::setMaterialClassifications(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcMaterial* IfcMaterialClassificationRelationship::ClassifiedMaterial() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcMaterialClassificationRelationship::setClassifiedMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMaterialClassificationRelationship::is(Type::Enum v) const { return v == Type::IfcMaterialClassificationRelationship; }
Type::Enum IfcMaterialClassificationRelationship::type() const { return Type::IfcMaterialClassificationRelationship; }
Type::Enum IfcMaterialClassificationRelationship::Class() { return Type::IfcMaterialClassificationRelationship; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialClassificationRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntityList::ptr v1_MaterialClassifications, IfcMaterial* v2_ClassifiedMaterial) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialClassifications));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ClassifiedMaterial));entity->setArgument(1,attr);} }

// Function implementations for IfcMaterialDefinitionRepresentation
IfcMaterial* IfcMaterialDefinitionRepresentation::RepresentedMaterial() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcMaterialDefinitionRepresentation::setRepresentedMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcMaterialDefinitionRepresentation::is(Type::Enum v) const { return v == Type::IfcMaterialDefinitionRepresentation || IfcProductRepresentation::is(v); }
Type::Enum IfcMaterialDefinitionRepresentation::type() const { return Type::IfcMaterialDefinitionRepresentation; }
Type::Enum IfcMaterialDefinitionRepresentation::Class() { return Type::IfcMaterialDefinitionRepresentation; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMaterialDefinitionRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations, IfcMaterial* v4_RepresentedMaterial) : IfcProductRepresentation((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RepresentedMaterial));entity->setArgument(3,attr);} }

// Function implementations for IfcMaterialLayer
bool IfcMaterialLayer::hasMaterial() const { return !entity->getArgument(0)->isNull(); }
IfcMaterial* IfcMaterialLayer::Material() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcMaterialLayer::setMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcMaterialLayer::LayerThickness() const { return *entity->getArgument(1); }
void IfcMaterialLayer::setLayerThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMaterialLayer::hasIsVentilated() const { return !entity->getArgument(2)->isNull(); }
bool IfcMaterialLayer::IsVentilated() const { return *entity->getArgument(2); }
void IfcMaterialLayer::setIsVentilated(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcMaterialLayerSet::list::ptr IfcMaterialLayer::ToMaterialLayerSet() const { return entity->getInverse(Type::IfcMaterialLayerSet, 0)->as<IfcMaterialLayerSet>(); }
bool IfcMaterialLayer::is(Type::Enum v) const { return v == Type::IfcMaterialLayer; }
Type::Enum IfcMaterialLayer::type() const { return Type::IfcMaterialLayer; }
Type::Enum IfcMaterialLayer::Class() { return Type::IfcMaterialLayer; }
IfcMaterialLayer::IfcMaterialLayer(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialLayer) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayer::IfcMaterialLayer(IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LayerThickness));entity->setArgument(1,attr);} if (v3_IsVentilated) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_IsVentilated));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcMaterialLayerSet
IfcTemplatedEntityList< IfcMaterialLayer >::ptr IfcMaterialLayerSet::MaterialLayers() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcMaterialLayer>(); }
void IfcMaterialLayerSet::setMaterialLayers(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcMaterialLayerSet::hasLayerSetName() const { return !entity->getArgument(1)->isNull(); }
std::string IfcMaterialLayerSet::LayerSetName() const { return *entity->getArgument(1); }
void IfcMaterialLayerSet::setLayerSetName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMaterialLayerSet::is(Type::Enum v) const { return v == Type::IfcMaterialLayerSet; }
Type::Enum IfcMaterialLayerSet::type() const { return Type::IfcMaterialLayerSet; }
Type::Enum IfcMaterialLayerSet::Class() { return Type::IfcMaterialLayerSet; }
IfcMaterialLayerSet::IfcMaterialLayerSet(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialLayerSet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayerSet::IfcMaterialLayerSet(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v1_MaterialLayers, boost::optional< std::string > v2_LayerSetName) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialLayers)->generalize());entity->setArgument(0,attr);} if (v2_LayerSetName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LayerSetName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcMaterialLayerSetUsage
IfcMaterialLayerSet* IfcMaterialLayerSetUsage::ForLayerSet() const { return (IfcMaterialLayerSet*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcMaterialLayerSetUsage::setForLayerSet(IfcMaterialLayerSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcMaterialLayerSetUsage::LayerSetDirection() const { return IfcLayerSetDirectionEnum::FromString(*entity->getArgument(1)); }
void IfcMaterialLayerSetUsage::setLayerSetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLayerSetDirectionEnum::ToString(v)));entity->setArgument(1,attr);} }
IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcMaterialLayerSetUsage::DirectionSense() const { return IfcDirectionSenseEnum::FromString(*entity->getArgument(2)); }
void IfcMaterialLayerSetUsage::setDirectionSense(IfcDirectionSenseEnum::IfcDirectionSenseEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDirectionSenseEnum::ToString(v)));entity->setArgument(2,attr);} }
double IfcMaterialLayerSetUsage::OffsetFromReferenceLine() const { return *entity->getArgument(3); }
void IfcMaterialLayerSetUsage::setOffsetFromReferenceLine(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcMaterialLayerSetUsage::is(Type::Enum v) const { return v == Type::IfcMaterialLayerSetUsage; }
Type::Enum IfcMaterialLayerSetUsage::type() const { return Type::IfcMaterialLayerSetUsage; }
Type::Enum IfcMaterialLayerSetUsage::Class() { return Type::IfcMaterialLayerSetUsage; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialLayerSetUsage) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcMaterialLayerSet* v1_ForLayerSet, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v2_LayerSetDirection, IfcDirectionSenseEnum::IfcDirectionSenseEnum v3_DirectionSense, double v4_OffsetFromReferenceLine) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ForLayerSet));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_LayerSetDirection,IfcLayerSetDirectionEnum::ToString(v2_LayerSetDirection))));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_DirectionSense,IfcDirectionSenseEnum::ToString(v3_DirectionSense))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OffsetFromReferenceLine));entity->setArgument(3,attr);} }

// Function implementations for IfcMaterialList
IfcTemplatedEntityList< IfcMaterial >::ptr IfcMaterialList::Materials() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcMaterial>(); }
void IfcMaterialList::setMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcMaterialList::is(Type::Enum v) const { return v == Type::IfcMaterialList; }
Type::Enum IfcMaterialList::type() const { return Type::IfcMaterialList; }
Type::Enum IfcMaterialList::Class() { return Type::IfcMaterialList; }
IfcMaterialList::IfcMaterialList(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialList) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialList::IfcMaterialList(IfcTemplatedEntityList< IfcMaterial >::ptr v1_Materials) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Materials)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcMaterialProperties
IfcMaterial* IfcMaterialProperties::Material() const { return (IfcMaterial*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcMaterialProperties::setMaterial(IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcMaterialProperties::is(Type::Enum v) const { return v == Type::IfcMaterialProperties; }
Type::Enum IfcMaterialProperties::type() const { return Type::IfcMaterialProperties; }
Type::Enum IfcMaterialProperties::Class() { return Type::IfcMaterialProperties; }
IfcMaterialProperties::IfcMaterialProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProperties::IfcMaterialProperties(IfcMaterial* v1_Material) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} }

// Function implementations for IfcMeasureWithUnit
IfcValue* IfcMeasureWithUnit::ValueComponent() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcMeasureWithUnit::setValueComponent(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcUnit* IfcMeasureWithUnit::UnitComponent() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcMeasureWithUnit::setUnitComponent(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMeasureWithUnit::is(Type::Enum v) const { return v == Type::IfcMeasureWithUnit; }
Type::Enum IfcMeasureWithUnit::type() const { return Type::IfcMeasureWithUnit; }
Type::Enum IfcMeasureWithUnit::Class() { return Type::IfcMeasureWithUnit; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMeasureWithUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcValue* v1_ValueComponent, IfcUnit* v2_UnitComponent) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ValueComponent));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_UnitComponent));entity->setArgument(1,attr);} }

// Function implementations for IfcMechanicalConcreteMaterialProperties
bool IfcMechanicalConcreteMaterialProperties::hasCompressiveStrength() const { return !entity->getArgument(6)->isNull(); }
double IfcMechanicalConcreteMaterialProperties::CompressiveStrength() const { return *entity->getArgument(6); }
void IfcMechanicalConcreteMaterialProperties::setCompressiveStrength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcMechanicalConcreteMaterialProperties::hasMaxAggregateSize() const { return !entity->getArgument(7)->isNull(); }
double IfcMechanicalConcreteMaterialProperties::MaxAggregateSize() const { return *entity->getArgument(7); }
void IfcMechanicalConcreteMaterialProperties::setMaxAggregateSize(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcMechanicalConcreteMaterialProperties::hasAdmixturesDescription() const { return !entity->getArgument(8)->isNull(); }
std::string IfcMechanicalConcreteMaterialProperties::AdmixturesDescription() const { return *entity->getArgument(8); }
void IfcMechanicalConcreteMaterialProperties::setAdmixturesDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcMechanicalConcreteMaterialProperties::hasWorkability() const { return !entity->getArgument(9)->isNull(); }
std::string IfcMechanicalConcreteMaterialProperties::Workability() const { return *entity->getArgument(9); }
void IfcMechanicalConcreteMaterialProperties::setWorkability(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcMechanicalConcreteMaterialProperties::hasProtectivePoreRatio() const { return !entity->getArgument(10)->isNull(); }
double IfcMechanicalConcreteMaterialProperties::ProtectivePoreRatio() const { return *entity->getArgument(10); }
void IfcMechanicalConcreteMaterialProperties::setProtectivePoreRatio(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcMechanicalConcreteMaterialProperties::hasWaterImpermeability() const { return !entity->getArgument(11)->isNull(); }
std::string IfcMechanicalConcreteMaterialProperties::WaterImpermeability() const { return *entity->getArgument(11); }
void IfcMechanicalConcreteMaterialProperties::setWaterImpermeability(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcMechanicalConcreteMaterialProperties::is(Type::Enum v) const { return v == Type::IfcMechanicalConcreteMaterialProperties || IfcMechanicalMaterialProperties::is(v); }
Type::Enum IfcMechanicalConcreteMaterialProperties::type() const { return Type::IfcMechanicalConcreteMaterialProperties; }
Type::Enum IfcMechanicalConcreteMaterialProperties::Class() { return Type::IfcMechanicalConcreteMaterialProperties; }
IfcMechanicalConcreteMaterialProperties::IfcMechanicalConcreteMaterialProperties(IfcEntityInstanceData* e) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMechanicalConcreteMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalConcreteMaterialProperties::IfcMechanicalConcreteMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_CompressiveStrength, boost::optional< double > v8_MaxAggregateSize, boost::optional< std::string > v9_AdmixturesDescription, boost::optional< std::string > v10_Workability, boost::optional< double > v11_ProtectivePoreRatio, boost::optional< std::string > v12_WaterImpermeability) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_CompressiveStrength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CompressiveStrength));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_MaxAggregateSize) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MaxAggregateSize));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_AdmixturesDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_AdmixturesDescription));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Workability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Workability));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_ProtectivePoreRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ProtectivePoreRatio));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_WaterImpermeability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WaterImpermeability));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } }

// Function implementations for IfcMechanicalFastener
bool IfcMechanicalFastener::hasNominalDiameter() const { return !entity->getArgument(8)->isNull(); }
double IfcMechanicalFastener::NominalDiameter() const { return *entity->getArgument(8); }
void IfcMechanicalFastener::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcMechanicalFastener::hasNominalLength() const { return !entity->getArgument(9)->isNull(); }
double IfcMechanicalFastener::NominalLength() const { return *entity->getArgument(9); }
void IfcMechanicalFastener::setNominalLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcMechanicalFastener::is(Type::Enum v) const { return v == Type::IfcMechanicalFastener || IfcFastener::is(v); }
Type::Enum IfcMechanicalFastener::type() const { return Type::IfcMechanicalFastener; }
Type::Enum IfcMechanicalFastener::Class() { return Type::IfcMechanicalFastener; }
IfcMechanicalFastener::IfcMechanicalFastener(IfcEntityInstanceData* e) : IfcFastener((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMechanicalFastener) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalFastener::IfcMechanicalFastener(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_NominalDiameter, boost::optional< double > v10_NominalLength) : IfcFastener((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NominalDiameter));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_NominalLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NominalLength));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcMechanicalFastenerType
bool IfcMechanicalFastenerType::is(Type::Enum v) const { return v == Type::IfcMechanicalFastenerType || IfcFastenerType::is(v); }
Type::Enum IfcMechanicalFastenerType::type() const { return Type::IfcMechanicalFastenerType; }
Type::Enum IfcMechanicalFastenerType::Class() { return Type::IfcMechanicalFastenerType; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(IfcEntityInstanceData* e) : IfcFastenerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMechanicalFastenerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcFastenerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcMechanicalMaterialProperties
bool IfcMechanicalMaterialProperties::hasDynamicViscosity() const { return !entity->getArgument(1)->isNull(); }
double IfcMechanicalMaterialProperties::DynamicViscosity() const { return *entity->getArgument(1); }
void IfcMechanicalMaterialProperties::setDynamicViscosity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcMechanicalMaterialProperties::hasYoungModulus() const { return !entity->getArgument(2)->isNull(); }
double IfcMechanicalMaterialProperties::YoungModulus() const { return *entity->getArgument(2); }
void IfcMechanicalMaterialProperties::setYoungModulus(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcMechanicalMaterialProperties::hasShearModulus() const { return !entity->getArgument(3)->isNull(); }
double IfcMechanicalMaterialProperties::ShearModulus() const { return *entity->getArgument(3); }
void IfcMechanicalMaterialProperties::setShearModulus(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcMechanicalMaterialProperties::hasPoissonRatio() const { return !entity->getArgument(4)->isNull(); }
double IfcMechanicalMaterialProperties::PoissonRatio() const { return *entity->getArgument(4); }
void IfcMechanicalMaterialProperties::setPoissonRatio(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcMechanicalMaterialProperties::hasThermalExpansionCoefficient() const { return !entity->getArgument(5)->isNull(); }
double IfcMechanicalMaterialProperties::ThermalExpansionCoefficient() const { return *entity->getArgument(5); }
void IfcMechanicalMaterialProperties::setThermalExpansionCoefficient(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcMechanicalMaterialProperties::is(Type::Enum v) const { return v == Type::IfcMechanicalMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcMechanicalMaterialProperties::type() const { return Type::IfcMechanicalMaterialProperties; }
Type::Enum IfcMechanicalMaterialProperties::Class() { return Type::IfcMechanicalMaterialProperties; }
IfcMechanicalMaterialProperties::IfcMechanicalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMechanicalMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalMaterialProperties::IfcMechanicalMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcMechanicalSteelMaterialProperties
bool IfcMechanicalSteelMaterialProperties::hasYieldStress() const { return !entity->getArgument(6)->isNull(); }
double IfcMechanicalSteelMaterialProperties::YieldStress() const { return *entity->getArgument(6); }
void IfcMechanicalSteelMaterialProperties::setYieldStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasUltimateStress() const { return !entity->getArgument(7)->isNull(); }
double IfcMechanicalSteelMaterialProperties::UltimateStress() const { return *entity->getArgument(7); }
void IfcMechanicalSteelMaterialProperties::setUltimateStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasUltimateStrain() const { return !entity->getArgument(8)->isNull(); }
double IfcMechanicalSteelMaterialProperties::UltimateStrain() const { return *entity->getArgument(8); }
void IfcMechanicalSteelMaterialProperties::setUltimateStrain(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasHardeningModule() const { return !entity->getArgument(9)->isNull(); }
double IfcMechanicalSteelMaterialProperties::HardeningModule() const { return *entity->getArgument(9); }
void IfcMechanicalSteelMaterialProperties::setHardeningModule(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasProportionalStress() const { return !entity->getArgument(10)->isNull(); }
double IfcMechanicalSteelMaterialProperties::ProportionalStress() const { return *entity->getArgument(10); }
void IfcMechanicalSteelMaterialProperties::setProportionalStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasPlasticStrain() const { return !entity->getArgument(11)->isNull(); }
double IfcMechanicalSteelMaterialProperties::PlasticStrain() const { return *entity->getArgument(11); }
void IfcMechanicalSteelMaterialProperties::setPlasticStrain(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcMechanicalSteelMaterialProperties::hasRelaxations() const { return !entity->getArgument(12)->isNull(); }
IfcTemplatedEntityList< IfcRelaxation >::ptr IfcMechanicalSteelMaterialProperties::Relaxations() const { IfcEntityList::ptr es = *entity->getArgument(12); return es->as<IfcRelaxation>(); }
void IfcMechanicalSteelMaterialProperties::setRelaxations(IfcTemplatedEntityList< IfcRelaxation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(12,attr);} }
bool IfcMechanicalSteelMaterialProperties::is(Type::Enum v) const { return v == Type::IfcMechanicalSteelMaterialProperties || IfcMechanicalMaterialProperties::is(v); }
Type::Enum IfcMechanicalSteelMaterialProperties::type() const { return Type::IfcMechanicalSteelMaterialProperties; }
Type::Enum IfcMechanicalSteelMaterialProperties::Class() { return Type::IfcMechanicalSteelMaterialProperties; }
IfcMechanicalSteelMaterialProperties::IfcMechanicalSteelMaterialProperties(IfcEntityInstanceData* e) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMechanicalSteelMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalSteelMaterialProperties::IfcMechanicalSteelMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_YieldStress, boost::optional< double > v8_UltimateStress, boost::optional< double > v9_UltimateStrain, boost::optional< double > v10_HardeningModule, boost::optional< double > v11_ProportionalStress, boost::optional< double > v12_PlasticStrain, boost::optional< IfcTemplatedEntityList< IfcRelaxation >::ptr > v13_Relaxations) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_YieldStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_YieldStress));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_UltimateStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_UltimateStress));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_UltimateStrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_UltimateStrain));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_HardeningModule) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_HardeningModule));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_ProportionalStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ProportionalStress));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_PlasticStrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_PlasticStrain));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_Relaxations) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_Relaxations)->generalize());entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } }

// Function implementations for IfcMember
bool IfcMember::is(Type::Enum v) const { return v == Type::IfcMember || IfcBuildingElement::is(v); }
Type::Enum IfcMember::type() const { return Type::IfcMember; }
Type::Enum IfcMember::Class() { return Type::IfcMember; }
IfcMember::IfcMember(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMember) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMember::IfcMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcMemberType
IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberType::PredefinedType() const { return IfcMemberTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMemberType::setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMemberTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcMemberType::is(Type::Enum v) const { return v == Type::IfcMemberType || IfcBuildingElementType::is(v); }
Type::Enum IfcMemberType::type() const { return Type::IfcMemberType; }
Type::Enum IfcMemberType::Class() { return Type::IfcMemberType; }
IfcMemberType::IfcMemberType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMemberType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMemberType::IfcMemberType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMemberTypeEnum::IfcMemberTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMemberTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcMetric
IfcBenchmarkEnum::IfcBenchmarkEnum IfcMetric::Benchmark() const { return IfcBenchmarkEnum::FromString(*entity->getArgument(7)); }
void IfcMetric::setBenchmark(IfcBenchmarkEnum::IfcBenchmarkEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcBenchmarkEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcMetric::hasValueSource() const { return !entity->getArgument(8)->isNull(); }
std::string IfcMetric::ValueSource() const { return *entity->getArgument(8); }
void IfcMetric::setValueSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcMetricValueSelect* IfcMetric::DataValue() const { return (IfcMetricValueSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcMetric::setDataValue(IfcMetricValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcMetric::is(Type::Enum v) const { return v == Type::IfcMetric || IfcConstraint::is(v); }
Type::Enum IfcMetric::type() const { return Type::IfcMetric; }
Type::Enum IfcMetric::Class() { return Type::IfcMetric; }
IfcMetric::IfcMetric(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMetric) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMetric::IfcMetric(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcBenchmarkEnum::IfcBenchmarkEnum v8_Benchmark, boost::optional< std::string > v9_ValueSource, IfcMetricValueSelect* v10_DataValue) : IfcConstraint((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));entity->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));entity->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_Benchmark,IfcBenchmarkEnum::ToString(v8_Benchmark))));entity->setArgument(7,attr);} if (v9_ValueSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ValueSource));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DataValue));entity->setArgument(9,attr);} }

// Function implementations for IfcMonetaryUnit
IfcCurrencyEnum::IfcCurrencyEnum IfcMonetaryUnit::Currency() const { return IfcCurrencyEnum::FromString(*entity->getArgument(0)); }
void IfcMonetaryUnit::setCurrency(IfcCurrencyEnum::IfcCurrencyEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcCurrencyEnum::ToString(v)));entity->setArgument(0,attr);} }
bool IfcMonetaryUnit::is(Type::Enum v) const { return v == Type::IfcMonetaryUnit; }
Type::Enum IfcMonetaryUnit::type() const { return Type::IfcMonetaryUnit; }
Type::Enum IfcMonetaryUnit::Class() { return Type::IfcMonetaryUnit; }
IfcMonetaryUnit::IfcMonetaryUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcMonetaryUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMonetaryUnit::IfcMonetaryUnit(IfcCurrencyEnum::IfcCurrencyEnum v1_Currency) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Currency,IfcCurrencyEnum::ToString(v1_Currency))));entity->setArgument(0,attr);} }

// Function implementations for IfcMotorConnectionType
IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionType::PredefinedType() const { return IfcMotorConnectionTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMotorConnectionType::setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcMotorConnectionTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcMotorConnectionType::is(Type::Enum v) const { return v == Type::IfcMotorConnectionType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcMotorConnectionType::type() const { return Type::IfcMotorConnectionType; }
Type::Enum IfcMotorConnectionType::Class() { return Type::IfcMotorConnectionType; }
IfcMotorConnectionType::IfcMotorConnectionType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMotorConnectionType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMotorConnectionType::IfcMotorConnectionType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcMotorConnectionTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcMove
IfcSpatialStructureElement* IfcMove::MoveFrom() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcMove::setMoveFrom(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
IfcSpatialStructureElement* IfcMove::MoveTo() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcMove::setMoveTo(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcMove::hasPunchList() const { return !entity->getArgument(12)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcMove::PunchList() const { return *entity->getArgument(12); }
void IfcMove::setPunchList(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcMove::is(Type::Enum v) const { return v == Type::IfcMove || IfcTask::is(v); }
Type::Enum IfcMove::type() const { return Type::IfcMove; }
Type::Enum IfcMove::Class() { return Type::IfcMove; }
IfcMove::IfcMove(IfcEntityInstanceData* e) : IfcTask((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcMove) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMove::IfcMove(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, IfcSpatialStructureElement* v11_MoveFrom, IfcSpatialStructureElement* v12_MoveTo, boost::optional< std::vector< std::string > /*[1:?]*/ > v13_PunchList) : IfcTask((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));entity->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));entity->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_MoveFrom));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_MoveTo));entity->setArgument(11,attr);} if (v13_PunchList) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_PunchList));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } }

// Function implementations for IfcNamedUnit
IfcDimensionalExponents* IfcNamedUnit::Dimensions() const { return (IfcDimensionalExponents*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcNamedUnit::setDimensions(IfcDimensionalExponents* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcUnitEnum::IfcUnitEnum IfcNamedUnit::UnitType() const { return IfcUnitEnum::FromString(*entity->getArgument(1)); }
void IfcNamedUnit::setUnitType(IfcUnitEnum::IfcUnitEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitEnum::ToString(v)));entity->setArgument(1,attr);} }
bool IfcNamedUnit::is(Type::Enum v) const { return v == Type::IfcNamedUnit; }
Type::Enum IfcNamedUnit::type() const { return Type::IfcNamedUnit; }
Type::Enum IfcNamedUnit::Class() { return Type::IfcNamedUnit; }
IfcNamedUnit::IfcNamedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcNamedUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcNamedUnit::IfcNamedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));entity->setArgument(1,attr);} }

// Function implementations for IfcObject
bool IfcObject::hasObjectType() const { return !entity->getArgument(4)->isNull(); }
std::string IfcObject::ObjectType() const { return *entity->getArgument(4); }
void IfcObject::setObjectType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcRelDefines::list::ptr IfcObject::IsDefinedBy() const { return entity->getInverse(Type::IfcRelDefines, 4)->as<IfcRelDefines>(); }
bool IfcObject::is(Type::Enum v) const { return v == Type::IfcObject || IfcObjectDefinition::is(v); }
Type::Enum IfcObject::type() const { return Type::IfcObject; }
Type::Enum IfcObject::Class() { return Type::IfcObject; }
IfcObject::IfcObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcObject) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObject::IfcObject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObjectDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcObjectDefinition
IfcRelAssigns::list::ptr IfcObjectDefinition::HasAssignments() const { return entity->getInverse(Type::IfcRelAssigns, 4)->as<IfcRelAssigns>(); }
IfcRelDecomposes::list::ptr IfcObjectDefinition::IsDecomposedBy() const { return entity->getInverse(Type::IfcRelDecomposes, 4)->as<IfcRelDecomposes>(); }
IfcRelDecomposes::list::ptr IfcObjectDefinition::Decomposes() const { return entity->getInverse(Type::IfcRelDecomposes, 5)->as<IfcRelDecomposes>(); }
IfcRelAssociates::list::ptr IfcObjectDefinition::HasAssociations() const { return entity->getInverse(Type::IfcRelAssociates, 4)->as<IfcRelAssociates>(); }
bool IfcObjectDefinition::is(Type::Enum v) const { return v == Type::IfcObjectDefinition || IfcRoot::is(v); }
Type::Enum IfcObjectDefinition::type() const { return Type::IfcObjectDefinition; }
Type::Enum IfcObjectDefinition::Class() { return Type::IfcObjectDefinition; }
IfcObjectDefinition::IfcObjectDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcObjectDefinition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjectDefinition::IfcObjectDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcObjectPlacement
IfcProduct::list::ptr IfcObjectPlacement::PlacesObject() const { return entity->getInverse(Type::IfcProduct, 5)->as<IfcProduct>(); }
IfcLocalPlacement::list::ptr IfcObjectPlacement::ReferencedByPlacements() const { return entity->getInverse(Type::IfcLocalPlacement, 0)->as<IfcLocalPlacement>(); }
bool IfcObjectPlacement::is(Type::Enum v) const { return v == Type::IfcObjectPlacement; }
Type::Enum IfcObjectPlacement::type() const { return Type::IfcObjectPlacement; }
Type::Enum IfcObjectPlacement::Class() { return Type::IfcObjectPlacement; }
IfcObjectPlacement::IfcObjectPlacement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcObjectPlacement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjectPlacement::IfcObjectPlacement() : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcObjective
bool IfcObjective::hasBenchmarkValues() const { return !entity->getArgument(7)->isNull(); }
IfcMetric* IfcObjective::BenchmarkValues() const { return (IfcMetric*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcObjective::setBenchmarkValues(IfcMetric* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcObjective::hasResultValues() const { return !entity->getArgument(8)->isNull(); }
IfcMetric* IfcObjective::ResultValues() const { return (IfcMetric*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcObjective::setResultValues(IfcMetric* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcObjectiveEnum::IfcObjectiveEnum IfcObjective::ObjectiveQualifier() const { return IfcObjectiveEnum::FromString(*entity->getArgument(9)); }
void IfcObjective::setObjectiveQualifier(IfcObjectiveEnum::IfcObjectiveEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectiveEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcObjective::hasUserDefinedQualifier() const { return !entity->getArgument(10)->isNull(); }
std::string IfcObjective::UserDefinedQualifier() const { return *entity->getArgument(10); }
void IfcObjective::setUserDefinedQualifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcObjective::is(Type::Enum v) const { return v == Type::IfcObjective || IfcConstraint::is(v); }
Type::Enum IfcObjective::type() const { return Type::IfcObjective; }
Type::Enum IfcObjective::Class() { return Type::IfcObjective; }
IfcObjective::IfcObjective(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcObjective) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjective::IfcObjective(std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcMetric* v8_BenchmarkValues, IfcMetric* v9_ResultValues, IfcObjectiveEnum::IfcObjectiveEnum v10_ObjectiveQualifier, boost::optional< std::string > v11_UserDefinedQualifier) : IfcConstraint((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade))));entity->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));entity->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_BenchmarkValues));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ResultValues));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ObjectiveQualifier,IfcObjectiveEnum::ToString(v10_ObjectiveQualifier))));entity->setArgument(9,attr);} if (v11_UserDefinedQualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UserDefinedQualifier));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcOccupant
IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupant::PredefinedType() const { return IfcOccupantTypeEnum::FromString(*entity->getArgument(6)); }
void IfcOccupant::setPredefinedType(IfcOccupantTypeEnum::IfcOccupantTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOccupantTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcOccupant::is(Type::Enum v) const { return v == Type::IfcOccupant || IfcActor::is(v); }
Type::Enum IfcOccupant::type() const { return Type::IfcOccupant; }
Type::Enum IfcOccupant::Class() { return Type::IfcOccupant; }
IfcOccupant::IfcOccupant(IfcEntityInstanceData* e) : IfcActor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOccupant) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOccupant::IfcOccupant(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor, IfcOccupantTypeEnum::IfcOccupantTypeEnum v7_PredefinedType) : IfcActor((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,IfcOccupantTypeEnum::ToString(v7_PredefinedType))));entity->setArgument(6,attr);} }

// Function implementations for IfcOffsetCurve2D
IfcCurve* IfcOffsetCurve2D::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcOffsetCurve2D::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcOffsetCurve2D::Distance() const { return *entity->getArgument(1); }
void IfcOffsetCurve2D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcOffsetCurve2D::SelfIntersect() const { return *entity->getArgument(2); }
void IfcOffsetCurve2D::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcOffsetCurve2D::is(Type::Enum v) const { return v == Type::IfcOffsetCurve2D || IfcCurve::is(v); }
Type::Enum IfcOffsetCurve2D::type() const { return Type::IfcOffsetCurve2D; }
Type::Enum IfcOffsetCurve2D::Class() { return Type::IfcOffsetCurve2D; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOffsetCurve2D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect) : IfcCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));entity->setArgument(2,attr);} }

// Function implementations for IfcOffsetCurve3D
IfcCurve* IfcOffsetCurve3D::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcOffsetCurve3D::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcOffsetCurve3D::Distance() const { return *entity->getArgument(1); }
void IfcOffsetCurve3D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcOffsetCurve3D::SelfIntersect() const { return *entity->getArgument(2); }
void IfcOffsetCurve3D::setSelfIntersect(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcDirection* IfcOffsetCurve3D::RefDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcOffsetCurve3D::setRefDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcOffsetCurve3D::is(Type::Enum v) const { return v == Type::IfcOffsetCurve3D || IfcCurve::is(v); }
Type::Enum IfcOffsetCurve3D::type() const { return Type::IfcOffsetCurve3D; }
Type::Enum IfcOffsetCurve3D::Class() { return Type::IfcOffsetCurve3D; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOffsetCurve3D) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect, IfcDirection* v4_RefDirection) : IfcCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RefDirection));entity->setArgument(3,attr);} }

// Function implementations for IfcOneDirectionRepeatFactor
IfcVector* IfcOneDirectionRepeatFactor::RepeatFactor() const { return (IfcVector*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcOneDirectionRepeatFactor::setRepeatFactor(IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcOneDirectionRepeatFactor::is(Type::Enum v) const { return v == Type::IfcOneDirectionRepeatFactor || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcOneDirectionRepeatFactor::type() const { return Type::IfcOneDirectionRepeatFactor; }
Type::Enum IfcOneDirectionRepeatFactor::Class() { return Type::IfcOneDirectionRepeatFactor; }
IfcOneDirectionRepeatFactor::IfcOneDirectionRepeatFactor(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOneDirectionRepeatFactor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOneDirectionRepeatFactor::IfcOneDirectionRepeatFactor(IfcVector* v1_RepeatFactor) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatFactor));entity->setArgument(0,attr);} }

// Function implementations for IfcOpenShell
bool IfcOpenShell::is(Type::Enum v) const { return v == Type::IfcOpenShell || IfcConnectedFaceSet::is(v); }
Type::Enum IfcOpenShell::type() const { return Type::IfcOpenShell; }
Type::Enum IfcOpenShell::Class() { return Type::IfcOpenShell; }
IfcOpenShell::IfcOpenShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOpenShell) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpenShell::IfcOpenShell(IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcOpeningElement
IfcRelFillsElement::list::ptr IfcOpeningElement::HasFillings() const { return entity->getInverse(Type::IfcRelFillsElement, 4)->as<IfcRelFillsElement>(); }
bool IfcOpeningElement::is(Type::Enum v) const { return v == Type::IfcOpeningElement || IfcFeatureElementSubtraction::is(v); }
Type::Enum IfcOpeningElement::type() const { return Type::IfcOpeningElement; }
Type::Enum IfcOpeningElement::Class() { return Type::IfcOpeningElement; }
IfcOpeningElement::IfcOpeningElement(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOpeningElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpeningElement::IfcOpeningElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcOpticalMaterialProperties
bool IfcOpticalMaterialProperties::hasVisibleTransmittance() const { return !entity->getArgument(1)->isNull(); }
double IfcOpticalMaterialProperties::VisibleTransmittance() const { return *entity->getArgument(1); }
void IfcOpticalMaterialProperties::setVisibleTransmittance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcOpticalMaterialProperties::hasSolarTransmittance() const { return !entity->getArgument(2)->isNull(); }
double IfcOpticalMaterialProperties::SolarTransmittance() const { return *entity->getArgument(2); }
void IfcOpticalMaterialProperties::setSolarTransmittance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcOpticalMaterialProperties::hasThermalIrTransmittance() const { return !entity->getArgument(3)->isNull(); }
double IfcOpticalMaterialProperties::ThermalIrTransmittance() const { return *entity->getArgument(3); }
void IfcOpticalMaterialProperties::setThermalIrTransmittance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcOpticalMaterialProperties::hasThermalIrEmissivityBack() const { return !entity->getArgument(4)->isNull(); }
double IfcOpticalMaterialProperties::ThermalIrEmissivityBack() const { return *entity->getArgument(4); }
void IfcOpticalMaterialProperties::setThermalIrEmissivityBack(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcOpticalMaterialProperties::hasThermalIrEmissivityFront() const { return !entity->getArgument(5)->isNull(); }
double IfcOpticalMaterialProperties::ThermalIrEmissivityFront() const { return *entity->getArgument(5); }
void IfcOpticalMaterialProperties::setThermalIrEmissivityFront(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcOpticalMaterialProperties::hasVisibleReflectanceBack() const { return !entity->getArgument(6)->isNull(); }
double IfcOpticalMaterialProperties::VisibleReflectanceBack() const { return *entity->getArgument(6); }
void IfcOpticalMaterialProperties::setVisibleReflectanceBack(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcOpticalMaterialProperties::hasVisibleReflectanceFront() const { return !entity->getArgument(7)->isNull(); }
double IfcOpticalMaterialProperties::VisibleReflectanceFront() const { return *entity->getArgument(7); }
void IfcOpticalMaterialProperties::setVisibleReflectanceFront(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcOpticalMaterialProperties::hasSolarReflectanceFront() const { return !entity->getArgument(8)->isNull(); }
double IfcOpticalMaterialProperties::SolarReflectanceFront() const { return *entity->getArgument(8); }
void IfcOpticalMaterialProperties::setSolarReflectanceFront(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcOpticalMaterialProperties::hasSolarReflectanceBack() const { return !entity->getArgument(9)->isNull(); }
double IfcOpticalMaterialProperties::SolarReflectanceBack() const { return *entity->getArgument(9); }
void IfcOpticalMaterialProperties::setSolarReflectanceBack(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcOpticalMaterialProperties::is(Type::Enum v) const { return v == Type::IfcOpticalMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcOpticalMaterialProperties::type() const { return Type::IfcOpticalMaterialProperties; }
Type::Enum IfcOpticalMaterialProperties::Class() { return Type::IfcOpticalMaterialProperties; }
IfcOpticalMaterialProperties::IfcOpticalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOpticalMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpticalMaterialProperties::IfcOpticalMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_VisibleTransmittance, boost::optional< double > v3_SolarTransmittance, boost::optional< double > v4_ThermalIrTransmittance, boost::optional< double > v5_ThermalIrEmissivityBack, boost::optional< double > v6_ThermalIrEmissivityFront, boost::optional< double > v7_VisibleReflectanceBack, boost::optional< double > v8_VisibleReflectanceFront, boost::optional< double > v9_SolarReflectanceFront, boost::optional< double > v10_SolarReflectanceBack) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_VisibleTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_VisibleTransmittance));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_SolarTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SolarTransmittance));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ThermalIrTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ThermalIrTransmittance));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ThermalIrEmissivityBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ThermalIrEmissivityBack));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ThermalIrEmissivityFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalIrEmissivityFront));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_VisibleReflectanceBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_VisibleReflectanceBack));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_VisibleReflectanceFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_VisibleReflectanceFront));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SolarReflectanceFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SolarReflectanceFront));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_SolarReflectanceBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SolarReflectanceBack));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcOrderAction
std::string IfcOrderAction::ActionID() const { return *entity->getArgument(10); }
void IfcOrderAction::setActionID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcOrderAction::is(Type::Enum v) const { return v == Type::IfcOrderAction || IfcTask::is(v); }
Type::Enum IfcOrderAction::type() const { return Type::IfcOrderAction; }
Type::Enum IfcOrderAction::Class() { return Type::IfcOrderAction; }
IfcOrderAction::IfcOrderAction(IfcEntityInstanceData* e) : IfcTask((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOrderAction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrderAction::IfcOrderAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, std::string v11_ActionID) : IfcTask((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));entity->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));entity->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ActionID));entity->setArgument(10,attr);} }

// Function implementations for IfcOrganization
bool IfcOrganization::hasId() const { return !entity->getArgument(0)->isNull(); }
std::string IfcOrganization::Id() const { return *entity->getArgument(0); }
void IfcOrganization::setId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::string IfcOrganization::Name() const { return *entity->getArgument(1); }
void IfcOrganization::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcOrganization::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcOrganization::Description() const { return *entity->getArgument(2); }
void IfcOrganization::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcOrganization::hasRoles() const { return !entity->getArgument(3)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcOrganization::Roles() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcActorRole>(); }
void IfcOrganization::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcOrganization::hasAddresses() const { return !entity->getArgument(4)->isNull(); }
IfcTemplatedEntityList< IfcAddress >::ptr IfcOrganization::Addresses() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcAddress>(); }
void IfcOrganization::setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
IfcOrganizationRelationship::list::ptr IfcOrganization::IsRelatedBy() const { return entity->getInverse(Type::IfcOrganizationRelationship, 3)->as<IfcOrganizationRelationship>(); }
IfcOrganizationRelationship::list::ptr IfcOrganization::Relates() const { return entity->getInverse(Type::IfcOrganizationRelationship, 2)->as<IfcOrganizationRelationship>(); }
IfcPersonAndOrganization::list::ptr IfcOrganization::Engages() const { return entity->getInverse(Type::IfcPersonAndOrganization, 1)->as<IfcPersonAndOrganization>(); }
bool IfcOrganization::is(Type::Enum v) const { return v == Type::IfcOrganization; }
Type::Enum IfcOrganization::type() const { return Type::IfcOrganization; }
Type::Enum IfcOrganization::Class() { return Type::IfcOrganization; }
IfcOrganization::IfcOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcOrganization) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrganization::IfcOrganization(boost::optional< std::string > v1_Id, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v4_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v5_Addresses) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Id) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Id));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));entity->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Roles)->generalize());entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Addresses)->generalize());entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcOrganizationRelationship
std::string IfcOrganizationRelationship::Name() const { return *entity->getArgument(0); }
void IfcOrganizationRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcOrganizationRelationship::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcOrganizationRelationship::Description() const { return *entity->getArgument(1); }
void IfcOrganizationRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcOrganization* IfcOrganizationRelationship::RelatingOrganization() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcOrganizationRelationship::setRelatingOrganization(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcOrganization >::ptr IfcOrganizationRelationship::RelatedOrganizations() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcOrganization>(); }
void IfcOrganizationRelationship::setRelatedOrganizations(IfcTemplatedEntityList< IfcOrganization >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
bool IfcOrganizationRelationship::is(Type::Enum v) const { return v == Type::IfcOrganizationRelationship; }
Type::Enum IfcOrganizationRelationship::type() const { return Type::IfcOrganizationRelationship; }
Type::Enum IfcOrganizationRelationship::Class() { return Type::IfcOrganizationRelationship; }
IfcOrganizationRelationship::IfcOrganizationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcOrganizationRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrganizationRelationship::IfcOrganizationRelationship(std::string v1_Name, boost::optional< std::string > v2_Description, IfcOrganization* v3_RelatingOrganization, IfcTemplatedEntityList< IfcOrganization >::ptr v4_RelatedOrganizations) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingOrganization));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedOrganizations)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcOrientedEdge
IfcEdge* IfcOrientedEdge::EdgeElement() const { return (IfcEdge*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcOrientedEdge::setEdgeElement(IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcOrientedEdge::Orientation() const { return *entity->getArgument(3); }
void IfcOrientedEdge::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcOrientedEdge::is(Type::Enum v) const { return v == Type::IfcOrientedEdge || IfcEdge::is(v); }
Type::Enum IfcOrientedEdge::type() const { return Type::IfcOrientedEdge; }
Type::Enum IfcOrientedEdge::Class() { return Type::IfcOrientedEdge; }
IfcOrientedEdge::IfcOrientedEdge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOrientedEdge) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrientedEdge::IfcOrientedEdge(IfcEdge* v3_EdgeElement, bool v4_Orientation) : IfcEdge((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeElement));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Orientation));entity->setArgument(3,attr);} }

// Function implementations for IfcOutletType
IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletType::PredefinedType() const { return IfcOutletTypeEnum::FromString(*entity->getArgument(9)); }
void IfcOutletType::setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcOutletTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcOutletType::is(Type::Enum v) const { return v == Type::IfcOutletType || IfcFlowTerminalType::is(v); }
Type::Enum IfcOutletType::type() const { return Type::IfcOutletType; }
Type::Enum IfcOutletType::Class() { return Type::IfcOutletType; }
IfcOutletType::IfcOutletType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcOutletType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOutletType::IfcOutletType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcOutletTypeEnum::IfcOutletTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcOutletTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcOwnerHistory
IfcPersonAndOrganization* IfcOwnerHistory::OwningUser() const { return (IfcPersonAndOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcOwnerHistory::setOwningUser(IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcApplication* IfcOwnerHistory::OwningApplication() const { return (IfcApplication*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcOwnerHistory::setOwningApplication(IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcOwnerHistory::hasState() const { return !entity->getArgument(2)->isNull(); }
IfcStateEnum::IfcStateEnum IfcOwnerHistory::State() const { return IfcStateEnum::FromString(*entity->getArgument(2)); }
void IfcOwnerHistory::setState(IfcStateEnum::IfcStateEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStateEnum::ToString(v)));entity->setArgument(2,attr);} }
IfcChangeActionEnum::IfcChangeActionEnum IfcOwnerHistory::ChangeAction() const { return IfcChangeActionEnum::FromString(*entity->getArgument(3)); }
void IfcOwnerHistory::setChangeAction(IfcChangeActionEnum::IfcChangeActionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcChangeActionEnum::ToString(v)));entity->setArgument(3,attr);} }
bool IfcOwnerHistory::hasLastModifiedDate() const { return !entity->getArgument(4)->isNull(); }
int IfcOwnerHistory::LastModifiedDate() const { return *entity->getArgument(4); }
void IfcOwnerHistory::setLastModifiedDate(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcOwnerHistory::hasLastModifyingUser() const { return !entity->getArgument(5)->isNull(); }
IfcPersonAndOrganization* IfcOwnerHistory::LastModifyingUser() const { return (IfcPersonAndOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcOwnerHistory::setLastModifyingUser(IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcOwnerHistory::hasLastModifyingApplication() const { return !entity->getArgument(6)->isNull(); }
IfcApplication* IfcOwnerHistory::LastModifyingApplication() const { return (IfcApplication*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcOwnerHistory::setLastModifyingApplication(IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
int IfcOwnerHistory::CreationDate() const { return *entity->getArgument(7); }
void IfcOwnerHistory::setCreationDate(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcOwnerHistory::is(Type::Enum v) const { return v == Type::IfcOwnerHistory; }
Type::Enum IfcOwnerHistory::type() const { return Type::IfcOwnerHistory; }
Type::Enum IfcOwnerHistory::Class() { return Type::IfcOwnerHistory; }
IfcOwnerHistory::IfcOwnerHistory(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcOwnerHistory) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOwnerHistory::IfcOwnerHistory(IfcPersonAndOrganization* v1_OwningUser, IfcApplication* v2_OwningApplication, boost::optional< IfcStateEnum::IfcStateEnum > v3_State, IfcChangeActionEnum::IfcChangeActionEnum v4_ChangeAction, boost::optional< int > v5_LastModifiedDate, IfcPersonAndOrganization* v6_LastModifyingUser, IfcApplication* v7_LastModifyingApplication, int v8_CreationDate) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OwningUser));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwningApplication));entity->setArgument(1,attr);} if (v3_State) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_State,IfcStateEnum::ToString(*v3_State))));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_ChangeAction,IfcChangeActionEnum::ToString(v4_ChangeAction))));entity->setArgument(3,attr);} if (v5_LastModifiedDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LastModifiedDate));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LastModifyingUser));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LastModifyingApplication));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CreationDate));entity->setArgument(7,attr);} }

// Function implementations for IfcParameterizedProfileDef
IfcAxis2Placement2D* IfcParameterizedProfileDef::Position() const { return (IfcAxis2Placement2D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcParameterizedProfileDef::setPosition(IfcAxis2Placement2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcParameterizedProfileDef::is(Type::Enum v) const { return v == Type::IfcParameterizedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcParameterizedProfileDef::type() const { return Type::IfcParameterizedProfileDef; }
Type::Enum IfcParameterizedProfileDef::Class() { return Type::IfcParameterizedProfileDef; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcParameterizedProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position) : IfcProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);} }

// Function implementations for IfcPath
IfcTemplatedEntityList< IfcOrientedEdge >::ptr IfcPath::EdgeList() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcOrientedEdge>(); }
void IfcPath::setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcPath::is(Type::Enum v) const { return v == Type::IfcPath || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcPath::type() const { return Type::IfcPath; }
Type::Enum IfcPath::Class() { return Type::IfcPath; }
IfcPath::IfcPath(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPath) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPath::IfcPath(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcPerformanceHistory
std::string IfcPerformanceHistory::LifeCyclePhase() const { return *entity->getArgument(5); }
void IfcPerformanceHistory::setLifeCyclePhase(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPerformanceHistory::is(Type::Enum v) const { return v == Type::IfcPerformanceHistory || IfcControl::is(v); }
Type::Enum IfcPerformanceHistory::type() const { return Type::IfcPerformanceHistory; }
Type::Enum IfcPerformanceHistory::Class() { return Type::IfcPerformanceHistory; }
IfcPerformanceHistory::IfcPerformanceHistory(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPerformanceHistory) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPerformanceHistory::IfcPerformanceHistory(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_LifeCyclePhase) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LifeCyclePhase));entity->setArgument(5,attr);} }

// Function implementations for IfcPermeableCoveringProperties
IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringProperties::OperationType() const { return IfcPermeableCoveringOperationEnum::FromString(*entity->getArgument(4)); }
void IfcPermeableCoveringProperties::setOperationType(IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPermeableCoveringOperationEnum::ToString(v)));entity->setArgument(4,attr);} }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcPermeableCoveringProperties::PanelPosition() const { return IfcWindowPanelPositionEnum::FromString(*entity->getArgument(5)); }
void IfcPermeableCoveringProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelPositionEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcPermeableCoveringProperties::hasFrameDepth() const { return !entity->getArgument(6)->isNull(); }
double IfcPermeableCoveringProperties::FrameDepth() const { return *entity->getArgument(6); }
void IfcPermeableCoveringProperties::setFrameDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcPermeableCoveringProperties::hasFrameThickness() const { return !entity->getArgument(7)->isNull(); }
double IfcPermeableCoveringProperties::FrameThickness() const { return *entity->getArgument(7); }
void IfcPermeableCoveringProperties::setFrameThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcPermeableCoveringProperties::hasShapeAspectStyle() const { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcPermeableCoveringProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcPermeableCoveringProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcPermeableCoveringProperties::is(Type::Enum v) const { return v == Type::IfcPermeableCoveringProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcPermeableCoveringProperties::type() const { return Type::IfcPermeableCoveringProperties; }
Type::Enum IfcPermeableCoveringProperties::Class() { return Type::IfcPermeableCoveringProperties; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPermeableCoveringProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,IfcPermeableCoveringOperationEnum::ToString(v5_OperationType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));entity->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));entity->setArgument(8,attr);} }

// Function implementations for IfcPermit
std::string IfcPermit::PermitID() const { return *entity->getArgument(5); }
void IfcPermit::setPermitID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPermit::is(Type::Enum v) const { return v == Type::IfcPermit || IfcControl::is(v); }
Type::Enum IfcPermit::type() const { return Type::IfcPermit; }
Type::Enum IfcPermit::Class() { return Type::IfcPermit; }
IfcPermit::IfcPermit(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPermit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPermit::IfcPermit(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_PermitID) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_PermitID));entity->setArgument(5,attr);} }

// Function implementations for IfcPerson
bool IfcPerson::hasId() const { return !entity->getArgument(0)->isNull(); }
std::string IfcPerson::Id() const { return *entity->getArgument(0); }
void IfcPerson::setId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPerson::hasFamilyName() const { return !entity->getArgument(1)->isNull(); }
std::string IfcPerson::FamilyName() const { return *entity->getArgument(1); }
void IfcPerson::setFamilyName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPerson::hasGivenName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcPerson::GivenName() const { return *entity->getArgument(2); }
void IfcPerson::setGivenName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPerson::hasMiddleNames() const { return !entity->getArgument(3)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::MiddleNames() const { return *entity->getArgument(3); }
void IfcPerson::setMiddleNames(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPerson::hasPrefixTitles() const { return !entity->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::PrefixTitles() const { return *entity->getArgument(4); }
void IfcPerson::setPrefixTitles(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPerson::hasSuffixTitles() const { return !entity->getArgument(5)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPerson::SuffixTitles() const { return *entity->getArgument(5); }
void IfcPerson::setSuffixTitles(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPerson::hasRoles() const { return !entity->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcPerson::Roles() const { IfcEntityList::ptr es = *entity->getArgument(6); return es->as<IfcActorRole>(); }
void IfcPerson::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(6,attr);} }
bool IfcPerson::hasAddresses() const { return !entity->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcAddress >::ptr IfcPerson::Addresses() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcAddress>(); }
void IfcPerson::setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
IfcPersonAndOrganization::list::ptr IfcPerson::EngagedIn() const { return entity->getInverse(Type::IfcPersonAndOrganization, 0)->as<IfcPersonAndOrganization>(); }
bool IfcPerson::is(Type::Enum v) const { return v == Type::IfcPerson; }
Type::Enum IfcPerson::type() const { return Type::IfcPerson; }
Type::Enum IfcPerson::Class() { return Type::IfcPerson; }
IfcPerson::IfcPerson(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPerson) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPerson::IfcPerson(boost::optional< std::string > v1_Id, boost::optional< std::string > v2_FamilyName, boost::optional< std::string > v3_GivenName, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< std::string > /*[1:?]*/ > v6_SuffixTitles, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v7_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v8_Addresses) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Id) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Id));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_FamilyName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_FamilyName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_GivenName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_GivenName));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_MiddleNames) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MiddleNames));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_PrefixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PrefixTitles));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_SuffixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_SuffixTitles));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Roles)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Addresses)->generalize());entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcPersonAndOrganization
IfcPerson* IfcPersonAndOrganization::ThePerson() const { return (IfcPerson*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPersonAndOrganization::setThePerson(IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcOrganization* IfcPersonAndOrganization::TheOrganization() const { return (IfcOrganization*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcPersonAndOrganization::setTheOrganization(IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPersonAndOrganization::hasRoles() const { return !entity->getArgument(2)->isNull(); }
IfcTemplatedEntityList< IfcActorRole >::ptr IfcPersonAndOrganization::Roles() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcActorRole>(); }
void IfcPersonAndOrganization::setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
bool IfcPersonAndOrganization::is(Type::Enum v) const { return v == Type::IfcPersonAndOrganization; }
Type::Enum IfcPersonAndOrganization::type() const { return Type::IfcPersonAndOrganization; }
Type::Enum IfcPersonAndOrganization::Class() { return Type::IfcPersonAndOrganization; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPersonAndOrganization) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcPerson* v1_ThePerson, IfcOrganization* v2_TheOrganization, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v3_Roles) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ThePerson));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TheOrganization));entity->setArgument(1,attr);} if (v3_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Roles)->generalize());entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcPhysicalComplexQuantity
IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr IfcPhysicalComplexQuantity::HasQuantities() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcPhysicalQuantity>(); }
void IfcPhysicalComplexQuantity::setHasQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
std::string IfcPhysicalComplexQuantity::Discrimination() const { return *entity->getArgument(3); }
void IfcPhysicalComplexQuantity::setDiscrimination(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPhysicalComplexQuantity::hasQuality() const { return !entity->getArgument(4)->isNull(); }
std::string IfcPhysicalComplexQuantity::Quality() const { return *entity->getArgument(4); }
void IfcPhysicalComplexQuantity::setQuality(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPhysicalComplexQuantity::hasUsage() const { return !entity->getArgument(5)->isNull(); }
std::string IfcPhysicalComplexQuantity::Usage() const { return *entity->getArgument(5); }
void IfcPhysicalComplexQuantity::setUsage(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPhysicalComplexQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalComplexQuantity || IfcPhysicalQuantity::is(v); }
Type::Enum IfcPhysicalComplexQuantity::type() const { return Type::IfcPhysicalComplexQuantity; }
Type::Enum IfcPhysicalComplexQuantity::Class() { return Type::IfcPhysicalComplexQuantity; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPhysicalComplexQuantity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v3_HasQuantities, std::string v4_Discrimination, boost::optional< std::string > v5_Quality, boost::optional< std::string > v6_Usage) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_HasQuantities)->generalize());entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Discrimination));entity->setArgument(3,attr);} if (v5_Quality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Quality));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_Usage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Usage));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcPhysicalQuantity
std::string IfcPhysicalQuantity::Name() const { return *entity->getArgument(0); }
void IfcPhysicalQuantity::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPhysicalQuantity::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcPhysicalQuantity::Description() const { return *entity->getArgument(1); }
void IfcPhysicalQuantity::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcPhysicalComplexQuantity::list::ptr IfcPhysicalQuantity::PartOfComplex() const { return entity->getInverse(Type::IfcPhysicalComplexQuantity, 2)->as<IfcPhysicalComplexQuantity>(); }
bool IfcPhysicalQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalQuantity; }
Type::Enum IfcPhysicalQuantity::type() const { return Type::IfcPhysicalQuantity; }
Type::Enum IfcPhysicalQuantity::Class() { return Type::IfcPhysicalQuantity; }
IfcPhysicalQuantity::IfcPhysicalQuantity(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPhysicalQuantity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalQuantity::IfcPhysicalQuantity(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcPhysicalSimpleQuantity
bool IfcPhysicalSimpleQuantity::hasUnit() const { return !entity->getArgument(2)->isNull(); }
IfcNamedUnit* IfcPhysicalSimpleQuantity::Unit() const { return (IfcNamedUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPhysicalSimpleQuantity::setUnit(IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPhysicalSimpleQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalSimpleQuantity || IfcPhysicalQuantity::is(v); }
Type::Enum IfcPhysicalSimpleQuantity::type() const { return Type::IfcPhysicalSimpleQuantity; }
Type::Enum IfcPhysicalSimpleQuantity::Class() { return Type::IfcPhysicalSimpleQuantity; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPhysicalSimpleQuantity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);} }

// Function implementations for IfcPile
IfcPileTypeEnum::IfcPileTypeEnum IfcPile::PredefinedType() const { return IfcPileTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPile::setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPileTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcPile::hasConstructionType() const { return !entity->getArgument(9)->isNull(); }
IfcPileConstructionEnum::IfcPileConstructionEnum IfcPile::ConstructionType() const { return IfcPileConstructionEnum::FromString(*entity->getArgument(9)); }
void IfcPile::setConstructionType(IfcPileConstructionEnum::IfcPileConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPileConstructionEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcPile::is(Type::Enum v) const { return v == Type::IfcPile || IfcBuildingElement::is(v); }
Type::Enum IfcPile::type() const { return Type::IfcPile; }
Type::Enum IfcPile::Class() { return Type::IfcPile; }
IfcPile::IfcPile(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPile) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPile::IfcPile(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcPileTypeEnum::IfcPileTypeEnum v9_PredefinedType, boost::optional< IfcPileConstructionEnum::IfcPileConstructionEnum > v10_ConstructionType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_PredefinedType,IfcPileTypeEnum::ToString(v9_PredefinedType))));entity->setArgument(8,attr);} if (v10_ConstructionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_ConstructionType,IfcPileConstructionEnum::ToString(*v10_ConstructionType))));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcPipeFittingType
IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingType::PredefinedType() const { return IfcPipeFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPipeFittingType::setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeFittingTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcPipeFittingType::is(Type::Enum v) const { return v == Type::IfcPipeFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcPipeFittingType::type() const { return Type::IfcPipeFittingType; }
Type::Enum IfcPipeFittingType::Class() { return Type::IfcPipeFittingType; }
IfcPipeFittingType::IfcPipeFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPipeFittingType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeFittingType::IfcPipeFittingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPipeFittingTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcPipeSegmentType
IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentType::PredefinedType() const { return IfcPipeSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPipeSegmentType::setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPipeSegmentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcPipeSegmentType::is(Type::Enum v) const { return v == Type::IfcPipeSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcPipeSegmentType::type() const { return Type::IfcPipeSegmentType; }
Type::Enum IfcPipeSegmentType::Class() { return Type::IfcPipeSegmentType; }
IfcPipeSegmentType::IfcPipeSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPipeSegmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeSegmentType::IfcPipeSegmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPipeSegmentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcPixelTexture
int IfcPixelTexture::Width() const { return *entity->getArgument(4); }
void IfcPixelTexture::setWidth(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
int IfcPixelTexture::Height() const { return *entity->getArgument(5); }
void IfcPixelTexture::setHeight(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
int IfcPixelTexture::ColourComponents() const { return *entity->getArgument(6); }
void IfcPixelTexture::setColourComponents(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
std::vector< boost::dynamic_bitset<> > /*[1:?]*/ IfcPixelTexture::Pixel() const { return *entity->getArgument(7); }
void IfcPixelTexture::setPixel(std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcPixelTexture::is(Type::Enum v) const { return v == Type::IfcPixelTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcPixelTexture::type() const { return Type::IfcPixelTexture; }
Type::Enum IfcPixelTexture::Class() { return Type::IfcPixelTexture; }
IfcPixelTexture::IfcPixelTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPixelTexture) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPixelTexture::IfcPixelTexture(bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, int v5_Width, int v6_Height, int v7_ColourComponents, std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v8_Pixel) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,IfcSurfaceTextureEnum::ToString(v3_TextureType))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Width));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Height));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ColourComponents));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Pixel));entity->setArgument(7,attr);} }

// Function implementations for IfcPlacement
IfcCartesianPoint* IfcPlacement::Location() const { return (IfcCartesianPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPlacement::setLocation(IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPlacement::is(Type::Enum v) const { return v == Type::IfcPlacement || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPlacement::type() const { return Type::IfcPlacement; }
Type::Enum IfcPlacement::Class() { return Type::IfcPlacement; }
IfcPlacement::IfcPlacement(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlacement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlacement::IfcPlacement(IfcCartesianPoint* v1_Location) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));entity->setArgument(0,attr);} }

// Function implementations for IfcPlanarBox
IfcAxis2Placement* IfcPlanarBox::Placement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPlanarBox::setPlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPlanarBox::is(Type::Enum v) const { return v == Type::IfcPlanarBox || IfcPlanarExtent::is(v); }
Type::Enum IfcPlanarBox::type() const { return Type::IfcPlanarBox; }
Type::Enum IfcPlanarBox::Class() { return Type::IfcPlanarBox; }
IfcPlanarBox::IfcPlanarBox(IfcEntityInstanceData* e) : IfcPlanarExtent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlanarBox) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlanarBox::IfcPlanarBox(double v1_SizeInX, double v2_SizeInY, IfcAxis2Placement* v3_Placement) : IfcPlanarExtent((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Placement));entity->setArgument(2,attr);} }

// Function implementations for IfcPlanarExtent
double IfcPlanarExtent::SizeInX() const { return *entity->getArgument(0); }
void IfcPlanarExtent::setSizeInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcPlanarExtent::SizeInY() const { return *entity->getArgument(1); }
void IfcPlanarExtent::setSizeInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPlanarExtent::is(Type::Enum v) const { return v == Type::IfcPlanarExtent || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPlanarExtent::type() const { return Type::IfcPlanarExtent; }
Type::Enum IfcPlanarExtent::Class() { return Type::IfcPlanarExtent; }
IfcPlanarExtent::IfcPlanarExtent(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlanarExtent) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlanarExtent::IfcPlanarExtent(double v1_SizeInX, double v2_SizeInY) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));entity->setArgument(1,attr);} }

// Function implementations for IfcPlane
bool IfcPlane::is(Type::Enum v) const { return v == Type::IfcPlane || IfcElementarySurface::is(v); }
Type::Enum IfcPlane::type() const { return Type::IfcPlane; }
Type::Enum IfcPlane::Class() { return Type::IfcPlane; }
IfcPlane::IfcPlane(IfcEntityInstanceData* e) : IfcElementarySurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlane) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlane::IfcPlane(IfcAxis2Placement3D* v1_Position) : IfcElementarySurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);} }

// Function implementations for IfcPlate
bool IfcPlate::is(Type::Enum v) const { return v == Type::IfcPlate || IfcBuildingElement::is(v); }
Type::Enum IfcPlate::type() const { return Type::IfcPlate; }
Type::Enum IfcPlate::Class() { return Type::IfcPlate; }
IfcPlate::IfcPlate(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlate) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlate::IfcPlate(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcPlateType
IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateType::PredefinedType() const { return IfcPlateTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPlateType::setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPlateTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcPlateType::is(Type::Enum v) const { return v == Type::IfcPlateType || IfcBuildingElementType::is(v); }
Type::Enum IfcPlateType::type() const { return Type::IfcPlateType; }
Type::Enum IfcPlateType::Class() { return Type::IfcPlateType; }
IfcPlateType::IfcPlateType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPlateType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlateType::IfcPlateType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPlateTypeEnum::IfcPlateTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPlateTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcPoint
bool IfcPoint::is(Type::Enum v) const { return v == Type::IfcPoint || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPoint::type() const { return Type::IfcPoint; }
Type::Enum IfcPoint::Class() { return Type::IfcPoint; }
IfcPoint::IfcPoint(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPoint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPoint::IfcPoint() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcPointOnCurve
IfcCurve* IfcPointOnCurve::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPointOnCurve::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcPointOnCurve::PointParameter() const { return *entity->getArgument(1); }
void IfcPointOnCurve::setPointParameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPointOnCurve::is(Type::Enum v) const { return v == Type::IfcPointOnCurve || IfcPoint::is(v); }
Type::Enum IfcPointOnCurve::type() const { return Type::IfcPointOnCurve; }
Type::Enum IfcPointOnCurve::Class() { return Type::IfcPointOnCurve; }
IfcPointOnCurve::IfcPointOnCurve(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPointOnCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPointOnCurve::IfcPointOnCurve(IfcCurve* v1_BasisCurve, double v2_PointParameter) : IfcPoint((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameter));entity->setArgument(1,attr);} }

// Function implementations for IfcPointOnSurface
IfcSurface* IfcPointOnSurface::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPointOnSurface::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcPointOnSurface::PointParameterU() const { return *entity->getArgument(1); }
void IfcPointOnSurface::setPointParameterU(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcPointOnSurface::PointParameterV() const { return *entity->getArgument(2); }
void IfcPointOnSurface::setPointParameterV(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPointOnSurface::is(Type::Enum v) const { return v == Type::IfcPointOnSurface || IfcPoint::is(v); }
Type::Enum IfcPointOnSurface::type() const { return Type::IfcPointOnSurface; }
Type::Enum IfcPointOnSurface::Class() { return Type::IfcPointOnSurface; }
IfcPointOnSurface::IfcPointOnSurface(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPointOnSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPointOnSurface::IfcPointOnSurface(IfcSurface* v1_BasisSurface, double v2_PointParameterU, double v3_PointParameterV) : IfcPoint((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameterU));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointParameterV));entity->setArgument(2,attr);} }

// Function implementations for IfcPolyLoop
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcPolyLoop::Polygon() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcCartesianPoint>(); }
void IfcPolyLoop::setPolygon(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcPolyLoop::is(Type::Enum v) const { return v == Type::IfcPolyLoop || IfcLoop::is(v); }
Type::Enum IfcPolyLoop::type() const { return Type::IfcPolyLoop; }
Type::Enum IfcPolyLoop::Class() { return Type::IfcPolyLoop; }
IfcPolyLoop::IfcPolyLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPolyLoop) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolyLoop::IfcPolyLoop(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Polygon) : IfcLoop((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Polygon)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcPolygonalBoundedHalfSpace
IfcAxis2Placement3D* IfcPolygonalBoundedHalfSpace::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPolygonalBoundedHalfSpace::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcBoundedCurve* IfcPolygonalBoundedHalfSpace::PolygonalBoundary() const { return (IfcBoundedCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPolygonalBoundedHalfSpace::setPolygonalBoundary(IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPolygonalBoundedHalfSpace::is(Type::Enum v) const { return v == Type::IfcPolygonalBoundedHalfSpace || IfcHalfSpaceSolid::is(v); }
Type::Enum IfcPolygonalBoundedHalfSpace::type() const { return Type::IfcPolygonalBoundedHalfSpace; }
Type::Enum IfcPolygonalBoundedHalfSpace::Class() { return Type::IfcPolygonalBoundedHalfSpace; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPolygonalBoundedHalfSpace) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcAxis2Placement3D* v3_Position, IfcBoundedCurve* v4_PolygonalBoundary) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PolygonalBoundary));entity->setArgument(3,attr);} }

// Function implementations for IfcPolyline
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcPolyline::Points() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcCartesianPoint>(); }
void IfcPolyline::setPoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcPolyline::is(Type::Enum v) const { return v == Type::IfcPolyline || IfcBoundedCurve::is(v); }
Type::Enum IfcPolyline::type() const { return Type::IfcPolyline; }
Type::Enum IfcPolyline::Class() { return Type::IfcPolyline; }
IfcPolyline::IfcPolyline(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPolyline) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolyline::IfcPolyline(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Points) : IfcBoundedCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Points)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcPort
IfcRelConnectsPortToElement::list::ptr IfcPort::ContainedIn() const { return entity->getInverse(Type::IfcRelConnectsPortToElement, 4)->as<IfcRelConnectsPortToElement>(); }
IfcRelConnectsPorts::list::ptr IfcPort::ConnectedFrom() const { return entity->getInverse(Type::IfcRelConnectsPorts, 5)->as<IfcRelConnectsPorts>(); }
IfcRelConnectsPorts::list::ptr IfcPort::ConnectedTo() const { return entity->getInverse(Type::IfcRelConnectsPorts, 4)->as<IfcRelConnectsPorts>(); }
bool IfcPort::is(Type::Enum v) const { return v == Type::IfcPort || IfcProduct::is(v); }
Type::Enum IfcPort::type() const { return Type::IfcPort; }
Type::Enum IfcPort::Class() { return Type::IfcPort; }
IfcPort::IfcPort(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPort) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPort::IfcPort(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} }

// Function implementations for IfcPostalAddress
bool IfcPostalAddress::hasInternalLocation() const { return !entity->getArgument(3)->isNull(); }
std::string IfcPostalAddress::InternalLocation() const { return *entity->getArgument(3); }
void IfcPostalAddress::setInternalLocation(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPostalAddress::hasAddressLines() const { return !entity->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcPostalAddress::AddressLines() const { return *entity->getArgument(4); }
void IfcPostalAddress::setAddressLines(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPostalAddress::hasPostalBox() const { return !entity->getArgument(5)->isNull(); }
std::string IfcPostalAddress::PostalBox() const { return *entity->getArgument(5); }
void IfcPostalAddress::setPostalBox(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPostalAddress::hasTown() const { return !entity->getArgument(6)->isNull(); }
std::string IfcPostalAddress::Town() const { return *entity->getArgument(6); }
void IfcPostalAddress::setTown(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcPostalAddress::hasRegion() const { return !entity->getArgument(7)->isNull(); }
std::string IfcPostalAddress::Region() const { return *entity->getArgument(7); }
void IfcPostalAddress::setRegion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcPostalAddress::hasPostalCode() const { return !entity->getArgument(8)->isNull(); }
std::string IfcPostalAddress::PostalCode() const { return *entity->getArgument(8); }
void IfcPostalAddress::setPostalCode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcPostalAddress::hasCountry() const { return !entity->getArgument(9)->isNull(); }
std::string IfcPostalAddress::Country() const { return *entity->getArgument(9); }
void IfcPostalAddress::setCountry(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcPostalAddress::is(Type::Enum v) const { return v == Type::IfcPostalAddress || IfcAddress::is(v); }
Type::Enum IfcPostalAddress::type() const { return Type::IfcPostalAddress; }
Type::Enum IfcPostalAddress::Class() { return Type::IfcPostalAddress; }
IfcPostalAddress::IfcPostalAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPostalAddress) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPostalAddress::IfcPostalAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::string > v4_InternalLocation, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_AddressLines, boost::optional< std::string > v6_PostalBox, boost::optional< std::string > v7_Town, boost::optional< std::string > v8_Region, boost::optional< std::string > v9_PostalCode, boost::optional< std::string > v10_Country) : IfcAddress((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_InternalLocation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_InternalLocation));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_AddressLines) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_AddressLines));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_PostalBox) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PostalBox));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_Town) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Town));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Region) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Region));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_PostalCode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_PostalCode));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Country) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Country));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcPreDefinedColour
bool IfcPreDefinedColour::is(Type::Enum v) const { return v == Type::IfcPreDefinedColour || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedColour::type() const { return Type::IfcPreDefinedColour; }
Type::Enum IfcPreDefinedColour::Class() { return Type::IfcPreDefinedColour; }
IfcPreDefinedColour::IfcPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedColour) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedColour::IfcPreDefinedColour(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedCurveFont
bool IfcPreDefinedCurveFont::is(Type::Enum v) const { return v == Type::IfcPreDefinedCurveFont || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedCurveFont::type() const { return Type::IfcPreDefinedCurveFont; }
Type::Enum IfcPreDefinedCurveFont::Class() { return Type::IfcPreDefinedCurveFont; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedCurveFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedDimensionSymbol
bool IfcPreDefinedDimensionSymbol::is(Type::Enum v) const { return v == Type::IfcPreDefinedDimensionSymbol || IfcPreDefinedSymbol::is(v); }
Type::Enum IfcPreDefinedDimensionSymbol::type() const { return Type::IfcPreDefinedDimensionSymbol; }
Type::Enum IfcPreDefinedDimensionSymbol::Class() { return Type::IfcPreDefinedDimensionSymbol; }
IfcPreDefinedDimensionSymbol::IfcPreDefinedDimensionSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedDimensionSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedDimensionSymbol::IfcPreDefinedDimensionSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedItem
std::string IfcPreDefinedItem::Name() const { return *entity->getArgument(0); }
void IfcPreDefinedItem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPreDefinedItem::is(Type::Enum v) const { return v == Type::IfcPreDefinedItem; }
Type::Enum IfcPreDefinedItem::type() const { return Type::IfcPreDefinedItem; }
Type::Enum IfcPreDefinedItem::Class() { return Type::IfcPreDefinedItem; }
IfcPreDefinedItem::IfcPreDefinedItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPreDefinedItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedItem::IfcPreDefinedItem(std::string v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedPointMarkerSymbol
bool IfcPreDefinedPointMarkerSymbol::is(Type::Enum v) const { return v == Type::IfcPreDefinedPointMarkerSymbol || IfcPreDefinedSymbol::is(v); }
Type::Enum IfcPreDefinedPointMarkerSymbol::type() const { return Type::IfcPreDefinedPointMarkerSymbol; }
Type::Enum IfcPreDefinedPointMarkerSymbol::Class() { return Type::IfcPreDefinedPointMarkerSymbol; }
IfcPreDefinedPointMarkerSymbol::IfcPreDefinedPointMarkerSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedPointMarkerSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedPointMarkerSymbol::IfcPreDefinedPointMarkerSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedSymbol
bool IfcPreDefinedSymbol::is(Type::Enum v) const { return v == Type::IfcPreDefinedSymbol || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedSymbol::type() const { return Type::IfcPreDefinedSymbol; }
Type::Enum IfcPreDefinedSymbol::Class() { return Type::IfcPreDefinedSymbol; }
IfcPreDefinedSymbol::IfcPreDefinedSymbol(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedSymbol::IfcPreDefinedSymbol(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedTerminatorSymbol
bool IfcPreDefinedTerminatorSymbol::is(Type::Enum v) const { return v == Type::IfcPreDefinedTerminatorSymbol || IfcPreDefinedSymbol::is(v); }
Type::Enum IfcPreDefinedTerminatorSymbol::type() const { return Type::IfcPreDefinedTerminatorSymbol; }
Type::Enum IfcPreDefinedTerminatorSymbol::Class() { return Type::IfcPreDefinedTerminatorSymbol; }
IfcPreDefinedTerminatorSymbol::IfcPreDefinedTerminatorSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedTerminatorSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedTerminatorSymbol::IfcPreDefinedTerminatorSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedTextFont
bool IfcPreDefinedTextFont::is(Type::Enum v) const { return v == Type::IfcPreDefinedTextFont || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedTextFont::type() const { return Type::IfcPreDefinedTextFont; }
Type::Enum IfcPreDefinedTextFont::Class() { return Type::IfcPreDefinedTextFont; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPreDefinedTextFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} }

// Function implementations for IfcPresentationLayerAssignment
std::string IfcPresentationLayerAssignment::Name() const { return *entity->getArgument(0); }
void IfcPresentationLayerAssignment::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPresentationLayerAssignment::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcPresentationLayerAssignment::Description() const { return *entity->getArgument(1); }
void IfcPresentationLayerAssignment::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcEntityList::ptr IfcPresentationLayerAssignment::AssignedItems() const { return *entity->getArgument(2); }
void IfcPresentationLayerAssignment::setAssignedItems(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPresentationLayerAssignment::hasIdentifier() const { return !entity->getArgument(3)->isNull(); }
std::string IfcPresentationLayerAssignment::Identifier() const { return *entity->getArgument(3); }
void IfcPresentationLayerAssignment::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPresentationLayerAssignment::is(Type::Enum v) const { return v == Type::IfcPresentationLayerAssignment; }
Type::Enum IfcPresentationLayerAssignment::type() const { return Type::IfcPresentationLayerAssignment; }
Type::Enum IfcPresentationLayerAssignment::Class() { return Type::IfcPresentationLayerAssignment; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPresentationLayerAssignment) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));entity->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcPresentationLayerWithStyle
bool IfcPresentationLayerWithStyle::LayerOn() const { return *entity->getArgument(4); }
void IfcPresentationLayerWithStyle::setLayerOn(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPresentationLayerWithStyle::LayerFrozen() const { return *entity->getArgument(5); }
void IfcPresentationLayerWithStyle::setLayerFrozen(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPresentationLayerWithStyle::LayerBlocked() const { return *entity->getArgument(6); }
void IfcPresentationLayerWithStyle::setLayerBlocked(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcEntityList::ptr IfcPresentationLayerWithStyle::LayerStyles() const { return *entity->getArgument(7); }
void IfcPresentationLayerWithStyle::setLayerStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcPresentationLayerWithStyle::is(Type::Enum v) const { return v == Type::IfcPresentationLayerWithStyle || IfcPresentationLayerAssignment::is(v); }
Type::Enum IfcPresentationLayerWithStyle::type() const { return Type::IfcPresentationLayerWithStyle; }
Type::Enum IfcPresentationLayerWithStyle::Class() { return Type::IfcPresentationLayerWithStyle; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(IfcEntityInstanceData* e) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPresentationLayerWithStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier, bool v5_LayerOn, bool v6_LayerFrozen, bool v7_LayerBlocked, IfcEntityList::ptr v8_LayerStyles) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));entity->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_LayerOn));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LayerFrozen));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LayerBlocked));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LayerStyles));entity->setArgument(7,attr);} }

// Function implementations for IfcPresentationStyle
bool IfcPresentationStyle::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcPresentationStyle::Name() const { return *entity->getArgument(0); }
void IfcPresentationStyle::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPresentationStyle::is(Type::Enum v) const { return v == Type::IfcPresentationStyle; }
Type::Enum IfcPresentationStyle::type() const { return Type::IfcPresentationStyle; }
Type::Enum IfcPresentationStyle::Class() { return Type::IfcPresentationStyle; }
IfcPresentationStyle::IfcPresentationStyle(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPresentationStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationStyle::IfcPresentationStyle(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcPresentationStyleAssignment
IfcEntityList::ptr IfcPresentationStyleAssignment::Styles() const { return *entity->getArgument(0); }
void IfcPresentationStyleAssignment::setStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcPresentationStyleAssignment::is(Type::Enum v) const { return v == Type::IfcPresentationStyleAssignment; }
Type::Enum IfcPresentationStyleAssignment::type() const { return Type::IfcPresentationStyleAssignment; }
Type::Enum IfcPresentationStyleAssignment::Class() { return Type::IfcPresentationStyleAssignment; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPresentationStyleAssignment) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntityList::ptr v1_Styles) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Styles));entity->setArgument(0,attr);} }

// Function implementations for IfcProcedure
std::string IfcProcedure::ProcedureID() const { return *entity->getArgument(5); }
void IfcProcedure::setProcedureID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedure::ProcedureType() const { return IfcProcedureTypeEnum::FromString(*entity->getArgument(6)); }
void IfcProcedure::setProcedureType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProcedureTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcProcedure::hasUserDefinedProcedureType() const { return !entity->getArgument(7)->isNull(); }
std::string IfcProcedure::UserDefinedProcedureType() const { return *entity->getArgument(7); }
void IfcProcedure::setUserDefinedProcedureType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcProcedure::is(Type::Enum v) const { return v == Type::IfcProcedure || IfcProcess::is(v); }
Type::Enum IfcProcedure::type() const { return Type::IfcProcedure; }
Type::Enum IfcProcedure::Class() { return Type::IfcProcedure; }
IfcProcedure::IfcProcedure(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProcedure) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProcedure::IfcProcedure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ProcedureID, IfcProcedureTypeEnum::IfcProcedureTypeEnum v7_ProcedureType, boost::optional< std::string > v8_UserDefinedProcedureType) : IfcProcess((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ProcedureID));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ProcedureType,IfcProcedureTypeEnum::ToString(v7_ProcedureType))));entity->setArgument(6,attr);} if (v8_UserDefinedProcedureType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_UserDefinedProcedureType));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcProcess
IfcRelAssignsToProcess::list::ptr IfcProcess::OperatesOn() const { return entity->getInverse(Type::IfcRelAssignsToProcess, 6)->as<IfcRelAssignsToProcess>(); }
IfcRelSequence::list::ptr IfcProcess::IsSuccessorFrom() const { return entity->getInverse(Type::IfcRelSequence, 5)->as<IfcRelSequence>(); }
IfcRelSequence::list::ptr IfcProcess::IsPredecessorTo() const { return entity->getInverse(Type::IfcRelSequence, 4)->as<IfcRelSequence>(); }
bool IfcProcess::is(Type::Enum v) const { return v == Type::IfcProcess || IfcObject::is(v); }
Type::Enum IfcProcess::type() const { return Type::IfcProcess; }
Type::Enum IfcProcess::Class() { return Type::IfcProcess; }
IfcProcess::IfcProcess(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProcess) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProcess::IfcProcess(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcProduct
bool IfcProduct::hasObjectPlacement() const { return !entity->getArgument(5)->isNull(); }
IfcObjectPlacement* IfcProduct::ObjectPlacement() const { return (IfcObjectPlacement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcProduct::setObjectPlacement(IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcProduct::hasRepresentation() const { return !entity->getArgument(6)->isNull(); }
IfcProductRepresentation* IfcProduct::Representation() const { return (IfcProductRepresentation*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcProduct::setRepresentation(IfcProductRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcRelAssignsToProduct::list::ptr IfcProduct::ReferencedBy() const { return entity->getInverse(Type::IfcRelAssignsToProduct, 6)->as<IfcRelAssignsToProduct>(); }
bool IfcProduct::is(Type::Enum v) const { return v == Type::IfcProduct || IfcObject::is(v); }
Type::Enum IfcProduct::type() const { return Type::IfcProduct; }
Type::Enum IfcProduct::Class() { return Type::IfcProduct; }
IfcProduct::IfcProduct(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProduct) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProduct::IfcProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} }

// Function implementations for IfcProductDefinitionShape
IfcProduct::list::ptr IfcProductDefinitionShape::ShapeOfProduct() const { return entity->getInverse(Type::IfcProduct, 6)->as<IfcProduct>(); }
IfcShapeAspect::list::ptr IfcProductDefinitionShape::HasShapeAspects() const { return entity->getInverse(Type::IfcShapeAspect, 4)->as<IfcShapeAspect>(); }
bool IfcProductDefinitionShape::is(Type::Enum v) const { return v == Type::IfcProductDefinitionShape || IfcProductRepresentation::is(v); }
Type::Enum IfcProductDefinitionShape::type() const { return Type::IfcProductDefinitionShape; }
Type::Enum IfcProductDefinitionShape::Class() { return Type::IfcProductDefinitionShape; }
IfcProductDefinitionShape::IfcProductDefinitionShape(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProductDefinitionShape) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProductDefinitionShape::IfcProductDefinitionShape(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations) : IfcProductRepresentation((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());entity->setArgument(2,attr);} }

// Function implementations for IfcProductRepresentation
bool IfcProductRepresentation::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcProductRepresentation::Name() const { return *entity->getArgument(0); }
void IfcProductRepresentation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcProductRepresentation::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcProductRepresentation::Description() const { return *entity->getArgument(1); }
void IfcProductRepresentation::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcRepresentation >::ptr IfcProductRepresentation::Representations() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcRepresentation>(); }
void IfcProductRepresentation::setRepresentations(IfcTemplatedEntityList< IfcRepresentation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
bool IfcProductRepresentation::is(Type::Enum v) const { return v == Type::IfcProductRepresentation; }
Type::Enum IfcProductRepresentation::type() const { return Type::IfcProductRepresentation; }
Type::Enum IfcProductRepresentation::Class() { return Type::IfcProductRepresentation; }
IfcProductRepresentation::IfcProductRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcProductRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProductRepresentation::IfcProductRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());entity->setArgument(2,attr);} }

// Function implementations for IfcProductsOfCombustionProperties
bool IfcProductsOfCombustionProperties::hasSpecificHeatCapacity() const { return !entity->getArgument(1)->isNull(); }
double IfcProductsOfCombustionProperties::SpecificHeatCapacity() const { return *entity->getArgument(1); }
void IfcProductsOfCombustionProperties::setSpecificHeatCapacity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcProductsOfCombustionProperties::hasN20Content() const { return !entity->getArgument(2)->isNull(); }
double IfcProductsOfCombustionProperties::N20Content() const { return *entity->getArgument(2); }
void IfcProductsOfCombustionProperties::setN20Content(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcProductsOfCombustionProperties::hasCOContent() const { return !entity->getArgument(3)->isNull(); }
double IfcProductsOfCombustionProperties::COContent() const { return *entity->getArgument(3); }
void IfcProductsOfCombustionProperties::setCOContent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcProductsOfCombustionProperties::hasCO2Content() const { return !entity->getArgument(4)->isNull(); }
double IfcProductsOfCombustionProperties::CO2Content() const { return *entity->getArgument(4); }
void IfcProductsOfCombustionProperties::setCO2Content(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcProductsOfCombustionProperties::is(Type::Enum v) const { return v == Type::IfcProductsOfCombustionProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcProductsOfCombustionProperties::type() const { return Type::IfcProductsOfCombustionProperties; }
Type::Enum IfcProductsOfCombustionProperties::Class() { return Type::IfcProductsOfCombustionProperties; }
IfcProductsOfCombustionProperties::IfcProductsOfCombustionProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProductsOfCombustionProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProductsOfCombustionProperties::IfcProductsOfCombustionProperties(IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_N20Content, boost::optional< double > v4_COContent, boost::optional< double > v5_CO2Content) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_SpecificHeatCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SpecificHeatCapacity));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_N20Content) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_N20Content));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_COContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_COContent));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_CO2Content) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CO2Content));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcProfileDef
IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileDef::ProfileType() const { return IfcProfileTypeEnum::FromString(*entity->getArgument(0)); }
void IfcProfileDef::setProfileType(IfcProfileTypeEnum::IfcProfileTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProfileTypeEnum::ToString(v)));entity->setArgument(0,attr);} }
bool IfcProfileDef::hasProfileName() const { return !entity->getArgument(1)->isNull(); }
std::string IfcProfileDef::ProfileName() const { return *entity->getArgument(1); }
void IfcProfileDef::setProfileName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcProfileDef::is(Type::Enum v) const { return v == Type::IfcProfileDef; }
Type::Enum IfcProfileDef::type() const { return Type::IfcProfileDef; }
Type::Enum IfcProfileDef::Class() { return Type::IfcProfileDef; }
IfcProfileDef::IfcProfileDef(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProfileDef::IfcProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcProfileProperties
bool IfcProfileProperties::hasProfileName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcProfileProperties::ProfileName() const { return *entity->getArgument(0); }
void IfcProfileProperties::setProfileName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcProfileProperties::hasProfileDefinition() const { return !entity->getArgument(1)->isNull(); }
IfcProfileDef* IfcProfileProperties::ProfileDefinition() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcProfileProperties::setProfileDefinition(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcProfileProperties::is(Type::Enum v) const { return v == Type::IfcProfileProperties; }
Type::Enum IfcProfileProperties::type() const { return Type::IfcProfileProperties; }
Type::Enum IfcProfileProperties::Class() { return Type::IfcProfileProperties; }
IfcProfileProperties::IfcProfileProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProfileProperties::IfcProfileProperties(boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));entity->setArgument(1,attr);} }

// Function implementations for IfcProject
bool IfcProject::hasLongName() const { return !entity->getArgument(5)->isNull(); }
std::string IfcProject::LongName() const { return *entity->getArgument(5); }
void IfcProject::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcProject::hasPhase() const { return !entity->getArgument(6)->isNull(); }
std::string IfcProject::Phase() const { return *entity->getArgument(6); }
void IfcProject::setPhase(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcTemplatedEntityList< IfcRepresentationContext >::ptr IfcProject::RepresentationContexts() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcRepresentationContext>(); }
void IfcProject::setRepresentationContexts(IfcTemplatedEntityList< IfcRepresentationContext >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
IfcUnitAssignment* IfcProject::UnitsInContext() const { return (IfcUnitAssignment*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcProject::setUnitsInContext(IfcUnitAssignment* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcProject::is(Type::Enum v) const { return v == Type::IfcProject || IfcObject::is(v); }
Type::Enum IfcProject::type() const { return Type::IfcProject; }
Type::Enum IfcProject::Class() { return Type::IfcProject; }
IfcProject::IfcProject(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProject) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProject::IfcProject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, IfcTemplatedEntityList< IfcRepresentationContext >::ptr v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_Phase) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Phase));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RepresentationContexts)->generalize());entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_UnitsInContext));entity->setArgument(8,attr);} }

// Function implementations for IfcProjectOrder
std::string IfcProjectOrder::ID() const { return *entity->getArgument(5); }
void IfcProjectOrder::setID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrder::PredefinedType() const { return IfcProjectOrderTypeEnum::FromString(*entity->getArgument(6)); }
void IfcProjectOrder::setPredefinedType(IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectOrderTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcProjectOrder::hasStatus() const { return !entity->getArgument(7)->isNull(); }
std::string IfcProjectOrder::Status() const { return *entity->getArgument(7); }
void IfcProjectOrder::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcProjectOrder::is(Type::Enum v) const { return v == Type::IfcProjectOrder || IfcControl::is(v); }
Type::Enum IfcProjectOrder::type() const { return Type::IfcProjectOrder; }
Type::Enum IfcProjectOrder::Class() { return Type::IfcProjectOrder; }
IfcProjectOrder::IfcProjectOrder(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProjectOrder) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectOrder::IfcProjectOrder(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ID, IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v7_PredefinedType, boost::optional< std::string > v8_Status) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ID));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,IfcProjectOrderTypeEnum::ToString(v7_PredefinedType))));entity->setArgument(6,attr);} if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcProjectOrderRecord
IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr IfcProjectOrderRecord::Records() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcRelAssignsToProjectOrder>(); }
void IfcProjectOrderRecord::setRecords(IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum IfcProjectOrderRecord::PredefinedType() const { return IfcProjectOrderRecordTypeEnum::FromString(*entity->getArgument(6)); }
void IfcProjectOrderRecord::setPredefinedType(IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectOrderRecordTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcProjectOrderRecord::is(Type::Enum v) const { return v == Type::IfcProjectOrderRecord || IfcControl::is(v); }
Type::Enum IfcProjectOrderRecord::type() const { return Type::IfcProjectOrderRecord; }
Type::Enum IfcProjectOrderRecord::Class() { return Type::IfcProjectOrderRecord; }
IfcProjectOrderRecord::IfcProjectOrderRecord(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProjectOrderRecord) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectOrderRecord::IfcProjectOrderRecord(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr v6_Records, IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum v7_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Records)->generalize());entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,IfcProjectOrderRecordTypeEnum::ToString(v7_PredefinedType))));entity->setArgument(6,attr);} }

// Function implementations for IfcProjectionCurve
bool IfcProjectionCurve::is(Type::Enum v) const { return v == Type::IfcProjectionCurve || IfcAnnotationCurveOccurrence::is(v); }
Type::Enum IfcProjectionCurve::type() const { return Type::IfcProjectionCurve; }
Type::Enum IfcProjectionCurve::Class() { return Type::IfcProjectionCurve; }
IfcProjectionCurve::IfcProjectionCurve(IfcEntityInstanceData* e) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProjectionCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectionCurve::IfcProjectionCurve(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcProjectionElement
bool IfcProjectionElement::is(Type::Enum v) const { return v == Type::IfcProjectionElement || IfcFeatureElementAddition::is(v); }
Type::Enum IfcProjectionElement::type() const { return Type::IfcProjectionElement; }
Type::Enum IfcProjectionElement::Class() { return Type::IfcProjectionElement; }
IfcProjectionElement::IfcProjectionElement(IfcEntityInstanceData* e) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProjectionElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectionElement::IfcProjectionElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcProperty
std::string IfcProperty::Name() const { return *entity->getArgument(0); }
void IfcProperty::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcProperty::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcProperty::Description() const { return *entity->getArgument(1); }
void IfcProperty::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcPropertyDependencyRelationship::list::ptr IfcProperty::PropertyForDependance() const { return entity->getInverse(Type::IfcPropertyDependencyRelationship, 0)->as<IfcPropertyDependencyRelationship>(); }
IfcPropertyDependencyRelationship::list::ptr IfcProperty::PropertyDependsOn() const { return entity->getInverse(Type::IfcPropertyDependencyRelationship, 1)->as<IfcPropertyDependencyRelationship>(); }
IfcComplexProperty::list::ptr IfcProperty::PartOfComplex() const { return entity->getInverse(Type::IfcComplexProperty, 3)->as<IfcComplexProperty>(); }
bool IfcProperty::is(Type::Enum v) const { return v == Type::IfcProperty; }
Type::Enum IfcProperty::type() const { return Type::IfcProperty; }
Type::Enum IfcProperty::Class() { return Type::IfcProperty; }
IfcProperty::IfcProperty(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcProperty) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProperty::IfcProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcPropertyBoundedValue
bool IfcPropertyBoundedValue::hasUpperBoundValue() const { return !entity->getArgument(2)->isNull(); }
IfcValue* IfcPropertyBoundedValue::UpperBoundValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPropertyBoundedValue::setUpperBoundValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyBoundedValue::hasLowerBoundValue() const { return !entity->getArgument(3)->isNull(); }
IfcValue* IfcPropertyBoundedValue::LowerBoundValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPropertyBoundedValue::setLowerBoundValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyBoundedValue::hasUnit() const { return !entity->getArgument(4)->isNull(); }
IfcUnit* IfcPropertyBoundedValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcPropertyBoundedValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPropertyBoundedValue::is(Type::Enum v) const { return v == Type::IfcPropertyBoundedValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyBoundedValue::type() const { return Type::IfcPropertyBoundedValue; }
Type::Enum IfcPropertyBoundedValue::Class() { return Type::IfcPropertyBoundedValue; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyBoundedValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_UpperBoundValue, IfcValue* v4_LowerBoundValue, IfcUnit* v5_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UpperBoundValue));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LowerBoundValue));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Unit));entity->setArgument(4,attr);} }

// Function implementations for IfcPropertyConstraintRelationship
IfcConstraint* IfcPropertyConstraintRelationship::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPropertyConstraintRelationship::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcProperty >::ptr IfcPropertyConstraintRelationship::RelatedProperties() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcProperty>(); }
void IfcPropertyConstraintRelationship::setRelatedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcPropertyConstraintRelationship::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcPropertyConstraintRelationship::Name() const { return *entity->getArgument(2); }
void IfcPropertyConstraintRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyConstraintRelationship::hasDescription() const { return !entity->getArgument(3)->isNull(); }
std::string IfcPropertyConstraintRelationship::Description() const { return *entity->getArgument(3); }
void IfcPropertyConstraintRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyConstraintRelationship::is(Type::Enum v) const { return v == Type::IfcPropertyConstraintRelationship; }
Type::Enum IfcPropertyConstraintRelationship::type() const { return Type::IfcPropertyConstraintRelationship; }
Type::Enum IfcPropertyConstraintRelationship::Class() { return Type::IfcPropertyConstraintRelationship; }
IfcPropertyConstraintRelationship::IfcPropertyConstraintRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPropertyConstraintRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyConstraintRelationship::IfcPropertyConstraintRelationship(IfcConstraint* v1_RelatingConstraint, IfcTemplatedEntityList< IfcProperty >::ptr v2_RelatedProperties, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingConstraint));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedProperties)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcPropertyDefinition
IfcRelAssociates::list::ptr IfcPropertyDefinition::HasAssociations() const { return entity->getInverse(Type::IfcRelAssociates, 4)->as<IfcRelAssociates>(); }
bool IfcPropertyDefinition::is(Type::Enum v) const { return v == Type::IfcPropertyDefinition || IfcRoot::is(v); }
Type::Enum IfcPropertyDefinition::type() const { return Type::IfcPropertyDefinition; }
Type::Enum IfcPropertyDefinition::Class() { return Type::IfcPropertyDefinition; }
IfcPropertyDefinition::IfcPropertyDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyDefinition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyDefinition::IfcPropertyDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcPropertyDependencyRelationship
IfcProperty* IfcPropertyDependencyRelationship::DependingProperty() const { return (IfcProperty*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcPropertyDependencyRelationship::setDependingProperty(IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcProperty* IfcPropertyDependencyRelationship::DependantProperty() const { return (IfcProperty*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcPropertyDependencyRelationship::setDependantProperty(IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPropertyDependencyRelationship::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcPropertyDependencyRelationship::Name() const { return *entity->getArgument(2); }
void IfcPropertyDependencyRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyDependencyRelationship::hasDescription() const { return !entity->getArgument(3)->isNull(); }
std::string IfcPropertyDependencyRelationship::Description() const { return *entity->getArgument(3); }
void IfcPropertyDependencyRelationship::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyDependencyRelationship::hasExpression() const { return !entity->getArgument(4)->isNull(); }
std::string IfcPropertyDependencyRelationship::Expression() const { return *entity->getArgument(4); }
void IfcPropertyDependencyRelationship::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPropertyDependencyRelationship::is(Type::Enum v) const { return v == Type::IfcPropertyDependencyRelationship; }
Type::Enum IfcPropertyDependencyRelationship::type() const { return Type::IfcPropertyDependencyRelationship; }
Type::Enum IfcPropertyDependencyRelationship::Class() { return Type::IfcPropertyDependencyRelationship; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPropertyDependencyRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(IfcProperty* v1_DependingProperty, IfcProperty* v2_DependantProperty, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_Expression) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DependingProperty));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DependantProperty));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcPropertyEnumeratedValue
IfcEntityList::ptr IfcPropertyEnumeratedValue::EnumerationValues() const { return *entity->getArgument(2); }
void IfcPropertyEnumeratedValue::setEnumerationValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyEnumeratedValue::hasEnumerationReference() const { return !entity->getArgument(3)->isNull(); }
IfcPropertyEnumeration* IfcPropertyEnumeratedValue::EnumerationReference() const { return (IfcPropertyEnumeration*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPropertyEnumeratedValue::setEnumerationReference(IfcPropertyEnumeration* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyEnumeratedValue::is(Type::Enum v) const { return v == Type::IfcPropertyEnumeratedValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyEnumeratedValue::type() const { return Type::IfcPropertyEnumeratedValue; }
Type::Enum IfcPropertyEnumeratedValue::Class() { return Type::IfcPropertyEnumeratedValue; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyEnumeratedValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_EnumerationValues, IfcPropertyEnumeration* v4_EnumerationReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EnumerationValues));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EnumerationReference));entity->setArgument(3,attr);} }

// Function implementations for IfcPropertyEnumeration
std::string IfcPropertyEnumeration::Name() const { return *entity->getArgument(0); }
void IfcPropertyEnumeration::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcPropertyEnumeration::EnumerationValues() const { return *entity->getArgument(1); }
void IfcPropertyEnumeration::setEnumerationValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcPropertyEnumeration::hasUnit() const { return !entity->getArgument(2)->isNull(); }
IfcUnit* IfcPropertyEnumeration::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPropertyEnumeration::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyEnumeration::is(Type::Enum v) const { return v == Type::IfcPropertyEnumeration; }
Type::Enum IfcPropertyEnumeration::type() const { return Type::IfcPropertyEnumeration; }
Type::Enum IfcPropertyEnumeration::Class() { return Type::IfcPropertyEnumeration; }
IfcPropertyEnumeration::IfcPropertyEnumeration(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcPropertyEnumeration) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyEnumeration::IfcPropertyEnumeration(std::string v1_Name, IfcEntityList::ptr v2_EnumerationValues, IfcUnit* v3_Unit) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EnumerationValues));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);} }

// Function implementations for IfcPropertyListValue
IfcEntityList::ptr IfcPropertyListValue::ListValues() const { return *entity->getArgument(2); }
void IfcPropertyListValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertyListValue::hasUnit() const { return !entity->getArgument(3)->isNull(); }
IfcUnit* IfcPropertyListValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPropertyListValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyListValue::is(Type::Enum v) const { return v == Type::IfcPropertyListValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyListValue::type() const { return Type::IfcPropertyListValue; }
Type::Enum IfcPropertyListValue::Class() { return Type::IfcPropertyListValue; }
IfcPropertyListValue::IfcPropertyListValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyListValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyListValue::IfcPropertyListValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_ListValues, IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ListValues));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));entity->setArgument(3,attr);} }

// Function implementations for IfcPropertyReferenceValue
bool IfcPropertyReferenceValue::hasUsageName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcPropertyReferenceValue::UsageName() const { return *entity->getArgument(2); }
void IfcPropertyReferenceValue::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcObjectReferenceSelect* IfcPropertyReferenceValue::PropertyReference() const { return (IfcObjectReferenceSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPropertyReferenceValue::setPropertyReference(IfcObjectReferenceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyReferenceValue::is(Type::Enum v) const { return v == Type::IfcPropertyReferenceValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyReferenceValue::type() const { return Type::IfcPropertyReferenceValue; }
Type::Enum IfcPropertyReferenceValue::Class() { return Type::IfcPropertyReferenceValue; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyReferenceValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UsageName, IfcObjectReferenceSelect* v4_PropertyReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_UsageName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UsageName));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PropertyReference));entity->setArgument(3,attr);} }

// Function implementations for IfcPropertySet
IfcTemplatedEntityList< IfcProperty >::ptr IfcPropertySet::HasProperties() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcProperty>(); }
void IfcPropertySet::setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
bool IfcPropertySet::is(Type::Enum v) const { return v == Type::IfcPropertySet || IfcPropertySetDefinition::is(v); }
Type::Enum IfcPropertySet::type() const { return Type::IfcPropertySet; }
Type::Enum IfcPropertySet::Class() { return Type::IfcPropertySet; }
IfcPropertySet::IfcPropertySet(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertySet) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySet::IfcPropertySet(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProperty >::ptr v5_HasProperties) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HasProperties)->generalize());entity->setArgument(4,attr);} }

// Function implementations for IfcPropertySetDefinition
IfcRelDefinesByProperties::list::ptr IfcPropertySetDefinition::PropertyDefinitionOf() const { return entity->getInverse(Type::IfcRelDefinesByProperties, 5)->as<IfcRelDefinesByProperties>(); }
IfcTypeObject::list::ptr IfcPropertySetDefinition::DefinesType() const { return entity->getInverse(Type::IfcTypeObject, 5)->as<IfcTypeObject>(); }
bool IfcPropertySetDefinition::is(Type::Enum v) const { return v == Type::IfcPropertySetDefinition || IfcPropertyDefinition::is(v); }
Type::Enum IfcPropertySetDefinition::type() const { return Type::IfcPropertySetDefinition; }
Type::Enum IfcPropertySetDefinition::Class() { return Type::IfcPropertySetDefinition; }
IfcPropertySetDefinition::IfcPropertySetDefinition(IfcEntityInstanceData* e) : IfcPropertyDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertySetDefinition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySetDefinition::IfcPropertySetDefinition(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertyDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcPropertySingleValue
bool IfcPropertySingleValue::hasNominalValue() const { return !entity->getArgument(2)->isNull(); }
IfcValue* IfcPropertySingleValue::NominalValue() const { return (IfcValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcPropertySingleValue::setNominalValue(IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcPropertySingleValue::hasUnit() const { return !entity->getArgument(3)->isNull(); }
IfcUnit* IfcPropertySingleValue::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcPropertySingleValue::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertySingleValue::is(Type::Enum v) const { return v == Type::IfcPropertySingleValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertySingleValue::type() const { return Type::IfcPropertySingleValue; }
Type::Enum IfcPropertySingleValue::Class() { return Type::IfcPropertySingleValue; }
IfcPropertySingleValue::IfcPropertySingleValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertySingleValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySingleValue::IfcPropertySingleValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_NominalValue, IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_NominalValue));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));entity->setArgument(3,attr);} }

// Function implementations for IfcPropertyTableValue
IfcEntityList::ptr IfcPropertyTableValue::DefiningValues() const { return *entity->getArgument(2); }
void IfcPropertyTableValue::setDefiningValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcEntityList::ptr IfcPropertyTableValue::DefinedValues() const { return *entity->getArgument(3); }
void IfcPropertyTableValue::setDefinedValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcPropertyTableValue::hasExpression() const { return !entity->getArgument(4)->isNull(); }
std::string IfcPropertyTableValue::Expression() const { return *entity->getArgument(4); }
void IfcPropertyTableValue::setExpression(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcPropertyTableValue::hasDefiningUnit() const { return !entity->getArgument(5)->isNull(); }
IfcUnit* IfcPropertyTableValue::DefiningUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcPropertyTableValue::setDefiningUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcPropertyTableValue::hasDefinedUnit() const { return !entity->getArgument(6)->isNull(); }
IfcUnit* IfcPropertyTableValue::DefinedUnit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcPropertyTableValue::setDefinedUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcPropertyTableValue::is(Type::Enum v) const { return v == Type::IfcPropertyTableValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyTableValue::type() const { return Type::IfcPropertyTableValue; }
Type::Enum IfcPropertyTableValue::Class() { return Type::IfcPropertyTableValue; }
IfcPropertyTableValue::IfcPropertyTableValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPropertyTableValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyTableValue::IfcPropertyTableValue(std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_DefiningValues, IfcEntityList::ptr v4_DefinedValues, boost::optional< std::string > v5_Expression, IfcUnit* v6_DefiningUnit, IfcUnit* v7_DefinedUnit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DefiningValues));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_DefinedValues));entity->setArgument(3,attr);} if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_DefiningUnit));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_DefinedUnit));entity->setArgument(6,attr);} }

// Function implementations for IfcProtectiveDeviceType
IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceType::PredefinedType() const { return IfcProtectiveDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcProtectiveDeviceType::setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProtectiveDeviceTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcProtectiveDeviceType::is(Type::Enum v) const { return v == Type::IfcProtectiveDeviceType || IfcFlowControllerType::is(v); }
Type::Enum IfcProtectiveDeviceType::type() const { return Type::IfcProtectiveDeviceType; }
Type::Enum IfcProtectiveDeviceType::Class() { return Type::IfcProtectiveDeviceType; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProtectiveDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcProtectiveDeviceTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcProxy
IfcObjectTypeEnum::IfcObjectTypeEnum IfcProxy::ProxyType() const { return IfcObjectTypeEnum::FromString(*entity->getArgument(7)); }
void IfcProxy::setProxyType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectTypeEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcProxy::hasTag() const { return !entity->getArgument(8)->isNull(); }
std::string IfcProxy::Tag() const { return *entity->getArgument(8); }
void IfcProxy::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcProxy::is(Type::Enum v) const { return v == Type::IfcProxy || IfcProduct::is(v); }
Type::Enum IfcProxy::type() const { return Type::IfcProxy; }
Type::Enum IfcProxy::Class() { return Type::IfcProxy; }
IfcProxy::IfcProxy(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcProxy) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProxy::IfcProxy(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcObjectTypeEnum::IfcObjectTypeEnum v8_ProxyType, boost::optional< std::string > v9_Tag) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ProxyType,IfcObjectTypeEnum::ToString(v8_ProxyType))));entity->setArgument(7,attr);} if (v9_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Tag));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcPumpType
IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpType::PredefinedType() const { return IfcPumpTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPumpType::setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPumpTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcPumpType::is(Type::Enum v) const { return v == Type::IfcPumpType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcPumpType::type() const { return Type::IfcPumpType; }
Type::Enum IfcPumpType::Class() { return Type::IfcPumpType; }
IfcPumpType::IfcPumpType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcPumpType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPumpType::IfcPumpType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPumpTypeEnum::IfcPumpTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcPumpTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcQuantityArea
double IfcQuantityArea::AreaValue() const { return *entity->getArgument(3); }
void IfcQuantityArea::setAreaValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityArea::is(Type::Enum v) const { return v == Type::IfcQuantityArea || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityArea::type() const { return Type::IfcQuantityArea; }
Type::Enum IfcQuantityArea::Class() { return Type::IfcQuantityArea; }
IfcQuantityArea::IfcQuantityArea(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityArea) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityArea::IfcQuantityArea(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_AreaValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AreaValue));entity->setArgument(3,attr);} }

// Function implementations for IfcQuantityCount
double IfcQuantityCount::CountValue() const { return *entity->getArgument(3); }
void IfcQuantityCount::setCountValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityCount::is(Type::Enum v) const { return v == Type::IfcQuantityCount || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityCount::type() const { return Type::IfcQuantityCount; }
Type::Enum IfcQuantityCount::Class() { return Type::IfcQuantityCount; }
IfcQuantityCount::IfcQuantityCount(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityCount) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityCount::IfcQuantityCount(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_CountValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CountValue));entity->setArgument(3,attr);} }

// Function implementations for IfcQuantityLength
double IfcQuantityLength::LengthValue() const { return *entity->getArgument(3); }
void IfcQuantityLength::setLengthValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityLength::is(Type::Enum v) const { return v == Type::IfcQuantityLength || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityLength::type() const { return Type::IfcQuantityLength; }
Type::Enum IfcQuantityLength::Class() { return Type::IfcQuantityLength; }
IfcQuantityLength::IfcQuantityLength(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityLength) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityLength::IfcQuantityLength(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_LengthValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LengthValue));entity->setArgument(3,attr);} }

// Function implementations for IfcQuantityTime
double IfcQuantityTime::TimeValue() const { return *entity->getArgument(3); }
void IfcQuantityTime::setTimeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityTime::is(Type::Enum v) const { return v == Type::IfcQuantityTime || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityTime::type() const { return Type::IfcQuantityTime; }
Type::Enum IfcQuantityTime::Class() { return Type::IfcQuantityTime; }
IfcQuantityTime::IfcQuantityTime(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityTime) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityTime::IfcQuantityTime(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_TimeValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TimeValue));entity->setArgument(3,attr);} }

// Function implementations for IfcQuantityVolume
double IfcQuantityVolume::VolumeValue() const { return *entity->getArgument(3); }
void IfcQuantityVolume::setVolumeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityVolume::is(Type::Enum v) const { return v == Type::IfcQuantityVolume || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityVolume::type() const { return Type::IfcQuantityVolume; }
Type::Enum IfcQuantityVolume::Class() { return Type::IfcQuantityVolume; }
IfcQuantityVolume::IfcQuantityVolume(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityVolume) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityVolume::IfcQuantityVolume(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_VolumeValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_VolumeValue));entity->setArgument(3,attr);} }

// Function implementations for IfcQuantityWeight
double IfcQuantityWeight::WeightValue() const { return *entity->getArgument(3); }
void IfcQuantityWeight::setWeightValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcQuantityWeight::is(Type::Enum v) const { return v == Type::IfcQuantityWeight || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityWeight::type() const { return Type::IfcQuantityWeight; }
Type::Enum IfcQuantityWeight::Class() { return Type::IfcQuantityWeight; }
IfcQuantityWeight::IfcQuantityWeight(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcQuantityWeight) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityWeight::IfcQuantityWeight(std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_WeightValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_WeightValue));entity->setArgument(3,attr);} }

// Function implementations for IfcRadiusDimension
bool IfcRadiusDimension::is(Type::Enum v) const { return v == Type::IfcRadiusDimension || IfcDimensionCurveDirectedCallout::is(v); }
Type::Enum IfcRadiusDimension::type() const { return Type::IfcRadiusDimension; }
Type::Enum IfcRadiusDimension::Class() { return Type::IfcRadiusDimension; }
IfcRadiusDimension::IfcRadiusDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRadiusDimension) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRadiusDimension::IfcRadiusDimension(IfcEntityList::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcRailing
bool IfcRailing::hasPredefinedType() const { return !entity->getArgument(8)->isNull(); }
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailing::PredefinedType() const { return IfcRailingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRailing::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRailingTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcRailing::is(Type::Enum v) const { return v == Type::IfcRailing || IfcBuildingElement::is(v); }
Type::Enum IfcRailing::type() const { return Type::IfcRailing; }
Type::Enum IfcRailing::Class() { return Type::IfcRailing; }
IfcRailing::IfcRailing(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRailing) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRailing::IfcRailing(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRailingTypeEnum::IfcRailingTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcRailingTypeEnum::ToString(*v9_PredefinedType))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcRailingType
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingType::PredefinedType() const { return IfcRailingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRailingType::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRailingTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcRailingType::is(Type::Enum v) const { return v == Type::IfcRailingType || IfcBuildingElementType::is(v); }
Type::Enum IfcRailingType::type() const { return Type::IfcRailingType; }
Type::Enum IfcRailingType::Class() { return Type::IfcRailingType; }
IfcRailingType::IfcRailingType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRailingType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRailingType::IfcRailingType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRailingTypeEnum::IfcRailingTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRailingTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcRamp
IfcRampTypeEnum::IfcRampTypeEnum IfcRamp::ShapeType() const { return IfcRampTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRamp::setShapeType(IfcRampTypeEnum::IfcRampTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcRamp::is(Type::Enum v) const { return v == Type::IfcRamp || IfcBuildingElement::is(v); }
Type::Enum IfcRamp::type() const { return Type::IfcRamp; }
Type::Enum IfcRamp::Class() { return Type::IfcRamp; }
IfcRamp::IfcRamp(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRamp) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRamp::IfcRamp(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcRampTypeEnum::IfcRampTypeEnum v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,IfcRampTypeEnum::ToString(v9_ShapeType))));entity->setArgument(8,attr);} }

// Function implementations for IfcRampFlight
bool IfcRampFlight::is(Type::Enum v) const { return v == Type::IfcRampFlight || IfcBuildingElement::is(v); }
Type::Enum IfcRampFlight::type() const { return Type::IfcRampFlight; }
Type::Enum IfcRampFlight::Class() { return Type::IfcRampFlight; }
IfcRampFlight::IfcRampFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRampFlight) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRampFlight::IfcRampFlight(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcRampFlightType
IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightType::PredefinedType() const { return IfcRampFlightTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRampFlightType::setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRampFlightTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcRampFlightType::is(Type::Enum v) const { return v == Type::IfcRampFlightType || IfcBuildingElementType::is(v); }
Type::Enum IfcRampFlightType::type() const { return Type::IfcRampFlightType; }
Type::Enum IfcRampFlightType::Class() { return Type::IfcRampFlightType; }
IfcRampFlightType::IfcRampFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRampFlightType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRampFlightType::IfcRampFlightType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcRampFlightTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcRationalBezierCurve
std::vector< double > /*[2:?]*/ IfcRationalBezierCurve::WeightsData() const { return *entity->getArgument(5); }
void IfcRationalBezierCurve::setWeightsData(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRationalBezierCurve::is(Type::Enum v) const { return v == Type::IfcRationalBezierCurve || IfcBezierCurve::is(v); }
Type::Enum IfcRationalBezierCurve::type() const { return Type::IfcRationalBezierCurve; }
Type::Enum IfcRationalBezierCurve::Class() { return Type::IfcRationalBezierCurve; }
IfcRationalBezierCurve::IfcRationalBezierCurve(IfcEntityInstanceData* e) : IfcBezierCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRationalBezierCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRationalBezierCurve::IfcRationalBezierCurve(int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< double > /*[2:?]*/ v6_WeightsData) : IfcBezierCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WeightsData));entity->setArgument(5,attr);} }

// Function implementations for IfcRectangleHollowProfileDef
double IfcRectangleHollowProfileDef::WallThickness() const { return *entity->getArgument(5); }
void IfcRectangleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRectangleHollowProfileDef::hasInnerFilletRadius() const { return !entity->getArgument(6)->isNull(); }
double IfcRectangleHollowProfileDef::InnerFilletRadius() const { return *entity->getArgument(6); }
void IfcRectangleHollowProfileDef::setInnerFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRectangleHollowProfileDef::hasOuterFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcRectangleHollowProfileDef::OuterFilletRadius() const { return *entity->getArgument(7); }
void IfcRectangleHollowProfileDef::setOuterFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRectangleHollowProfileDef::is(Type::Enum v) const { return v == Type::IfcRectangleHollowProfileDef || IfcRectangleProfileDef::is(v); }
Type::Enum IfcRectangleHollowProfileDef::type() const { return Type::IfcRectangleHollowProfileDef; }
Type::Enum IfcRectangleHollowProfileDef::Class() { return Type::IfcRectangleHollowProfileDef; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRectangleHollowProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_WallThickness, boost::optional< double > v7_InnerFilletRadius, boost::optional< double > v8_OuterFilletRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));entity->setArgument(5,attr);} if (v7_InnerFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_InnerFilletRadius));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_OuterFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_OuterFilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcRectangleProfileDef
double IfcRectangleProfileDef::XDim() const { return *entity->getArgument(3); }
void IfcRectangleProfileDef::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcRectangleProfileDef::YDim() const { return *entity->getArgument(4); }
void IfcRectangleProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcRectangleProfileDef::is(Type::Enum v) const { return v == Type::IfcRectangleProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcRectangleProfileDef::type() const { return Type::IfcRectangleProfileDef; }
Type::Enum IfcRectangleProfileDef::Class() { return Type::IfcRectangleProfileDef; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRectangleProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));entity->setArgument(4,attr);} }

// Function implementations for IfcRectangularPyramid
double IfcRectangularPyramid::XLength() const { return *entity->getArgument(1); }
void IfcRectangularPyramid::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcRectangularPyramid::YLength() const { return *entity->getArgument(2); }
void IfcRectangularPyramid::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcRectangularPyramid::Height() const { return *entity->getArgument(3); }
void IfcRectangularPyramid::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcRectangularPyramid::is(Type::Enum v) const { return v == Type::IfcRectangularPyramid || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRectangularPyramid::type() const { return Type::IfcRectangularPyramid; }
Type::Enum IfcRectangularPyramid::Class() { return Type::IfcRectangularPyramid; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRectangularPyramid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_Height) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Height));entity->setArgument(3,attr);} }

// Function implementations for IfcRectangularTrimmedSurface
IfcSurface* IfcRectangularTrimmedSurface::BasisSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcRectangularTrimmedSurface::setBasisSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcRectangularTrimmedSurface::U1() const { return *entity->getArgument(1); }
void IfcRectangularTrimmedSurface::setU1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcRectangularTrimmedSurface::V1() const { return *entity->getArgument(2); }
void IfcRectangularTrimmedSurface::setV1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcRectangularTrimmedSurface::U2() const { return *entity->getArgument(3); }
void IfcRectangularTrimmedSurface::setU2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcRectangularTrimmedSurface::V2() const { return *entity->getArgument(4); }
void IfcRectangularTrimmedSurface::setV2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcRectangularTrimmedSurface::Usense() const { return *entity->getArgument(5); }
void IfcRectangularTrimmedSurface::setUsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRectangularTrimmedSurface::Vsense() const { return *entity->getArgument(6); }
void IfcRectangularTrimmedSurface::setVsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRectangularTrimmedSurface::is(Type::Enum v) const { return v == Type::IfcRectangularTrimmedSurface || IfcBoundedSurface::is(v); }
Type::Enum IfcRectangularTrimmedSurface::type() const { return Type::IfcRectangularTrimmedSurface; }
Type::Enum IfcRectangularTrimmedSurface::Class() { return Type::IfcRectangularTrimmedSurface; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRectangularTrimmedSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcSurface* v1_BasisSurface, double v2_U1, double v3_V1, double v4_U2, double v5_V2, bool v6_Usense, bool v7_Vsense) : IfcBoundedSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_U1));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_V1));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_U2));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_V2));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Usense));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Vsense));entity->setArgument(6,attr);} }

// Function implementations for IfcReferencesValueDocument
IfcDocumentSelect* IfcReferencesValueDocument::ReferencedDocument() const { return (IfcDocumentSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcReferencesValueDocument::setReferencedDocument(IfcDocumentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcAppliedValue >::ptr IfcReferencesValueDocument::ReferencingValues() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcAppliedValue>(); }
void IfcReferencesValueDocument::setReferencingValues(IfcTemplatedEntityList< IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcReferencesValueDocument::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcReferencesValueDocument::Name() const { return *entity->getArgument(2); }
void IfcReferencesValueDocument::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcReferencesValueDocument::hasDescription() const { return !entity->getArgument(3)->isNull(); }
std::string IfcReferencesValueDocument::Description() const { return *entity->getArgument(3); }
void IfcReferencesValueDocument::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcReferencesValueDocument::is(Type::Enum v) const { return v == Type::IfcReferencesValueDocument; }
Type::Enum IfcReferencesValueDocument::type() const { return Type::IfcReferencesValueDocument; }
Type::Enum IfcReferencesValueDocument::Class() { return Type::IfcReferencesValueDocument; }
IfcReferencesValueDocument::IfcReferencesValueDocument(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcReferencesValueDocument) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReferencesValueDocument::IfcReferencesValueDocument(IfcDocumentSelect* v1_ReferencedDocument, IfcTemplatedEntityList< IfcAppliedValue >::ptr v2_ReferencingValues, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ReferencedDocument));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ReferencingValues)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcRegularTimeSeries
double IfcRegularTimeSeries::TimeStep() const { return *entity->getArgument(8); }
void IfcRegularTimeSeries::setTimeStep(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr IfcRegularTimeSeries::Values() const { IfcEntityList::ptr es = *entity->getArgument(9); return es->as<IfcTimeSeriesValue>(); }
void IfcRegularTimeSeries::setValues(IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(9,attr);} }
bool IfcRegularTimeSeries::is(Type::Enum v) const { return v == Type::IfcRegularTimeSeries || IfcTimeSeries::is(v); }
Type::Enum IfcRegularTimeSeries::type() const { return Type::IfcRegularTimeSeries; }
Type::Enum IfcRegularTimeSeries::Class() { return Type::IfcRegularTimeSeries; }
IfcRegularTimeSeries::IfcRegularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRegularTimeSeries) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRegularTimeSeries::IfcRegularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, double v9_TimeStep, IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v10_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));entity->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TimeStep));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Values)->generalize());entity->setArgument(9,attr);} }

// Function implementations for IfcReinforcementBarProperties
double IfcReinforcementBarProperties::TotalCrossSectionArea() const { return *entity->getArgument(0); }
void IfcReinforcementBarProperties::setTotalCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
std::string IfcReinforcementBarProperties::SteelGrade() const { return *entity->getArgument(1); }
void IfcReinforcementBarProperties::setSteelGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcReinforcementBarProperties::hasBarSurface() const { return !entity->getArgument(2)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcementBarProperties::BarSurface() const { return IfcReinforcingBarSurfaceEnum::FromString(*entity->getArgument(2)); }
void IfcReinforcementBarProperties::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarSurfaceEnum::ToString(v)));entity->setArgument(2,attr);} }
bool IfcReinforcementBarProperties::hasEffectiveDepth() const { return !entity->getArgument(3)->isNull(); }
double IfcReinforcementBarProperties::EffectiveDepth() const { return *entity->getArgument(3); }
void IfcReinforcementBarProperties::setEffectiveDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcReinforcementBarProperties::hasNominalBarDiameter() const { return !entity->getArgument(4)->isNull(); }
double IfcReinforcementBarProperties::NominalBarDiameter() const { return *entity->getArgument(4); }
void IfcReinforcementBarProperties::setNominalBarDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcReinforcementBarProperties::hasBarCount() const { return !entity->getArgument(5)->isNull(); }
double IfcReinforcementBarProperties::BarCount() const { return *entity->getArgument(5); }
void IfcReinforcementBarProperties::setBarCount(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcReinforcementBarProperties::is(Type::Enum v) const { return v == Type::IfcReinforcementBarProperties; }
Type::Enum IfcReinforcementBarProperties::type() const { return Type::IfcReinforcementBarProperties; }
Type::Enum IfcReinforcementBarProperties::Class() { return Type::IfcReinforcementBarProperties; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcReinforcementBarProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(double v1_TotalCrossSectionArea, std::string v2_SteelGrade, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v3_BarSurface, boost::optional< double > v4_EffectiveDepth, boost::optional< double > v5_NominalBarDiameter, boost::optional< double > v6_BarCount) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TotalCrossSectionArea));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SteelGrade));entity->setArgument(1,attr);} if (v3_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v3_BarSurface))));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_EffectiveDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EffectiveDepth));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_NominalBarDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_NominalBarDiameter));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_BarCount) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_BarCount));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcReinforcementDefinitionProperties
bool IfcReinforcementDefinitionProperties::hasDefinitionType() const { return !entity->getArgument(4)->isNull(); }
std::string IfcReinforcementDefinitionProperties::DefinitionType() const { return *entity->getArgument(4); }
void IfcReinforcementDefinitionProperties::setDefinitionType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr IfcReinforcementDefinitionProperties::ReinforcementSectionDefinitions() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcSectionReinforcementProperties>(); }
void IfcReinforcementDefinitionProperties::setReinforcementSectionDefinitions(IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcReinforcementDefinitionProperties::is(Type::Enum v) const { return v == Type::IfcReinforcementDefinitionProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcReinforcementDefinitionProperties::type() const { return Type::IfcReinforcementDefinitionProperties; }
Type::Enum IfcReinforcementDefinitionProperties::Class() { return Type::IfcReinforcementDefinitionProperties; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcReinforcementDefinitionProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_DefinitionType, IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v6_ReinforcementSectionDefinitions) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_DefinitionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DefinitionType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReinforcementSectionDefinitions)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcReinforcingBar
double IfcReinforcingBar::NominalDiameter() const { return *entity->getArgument(9); }
void IfcReinforcingBar::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
double IfcReinforcingBar::CrossSectionArea() const { return *entity->getArgument(10); }
void IfcReinforcingBar::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcReinforcingBar::hasBarLength() const { return !entity->getArgument(11)->isNull(); }
double IfcReinforcingBar::BarLength() const { return *entity->getArgument(11); }
void IfcReinforcingBar::setBarLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcReinforcingBar::BarRole() const { return IfcReinforcingBarRoleEnum::FromString(*entity->getArgument(12)); }
void IfcReinforcingBar::setBarRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarRoleEnum::ToString(v)));entity->setArgument(12,attr);} }
bool IfcReinforcingBar::hasBarSurface() const { return !entity->getArgument(13)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBar::BarSurface() const { return IfcReinforcingBarSurfaceEnum::FromString(*entity->getArgument(13)); }
void IfcReinforcingBar::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarSurfaceEnum::ToString(v)));entity->setArgument(13,attr);} }
bool IfcReinforcingBar::is(Type::Enum v) const { return v == Type::IfcReinforcingBar || IfcReinforcingElement::is(v); }
Type::Enum IfcReinforcingBar::type() const { return Type::IfcReinforcingBar; }
Type::Enum IfcReinforcingBar::Class() { return Type::IfcReinforcingBar; }
IfcReinforcingBar::IfcReinforcingBar(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcReinforcingBar) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingBar::IfcReinforcingBar(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, double v10_NominalDiameter, double v11_CrossSectionArea, boost::optional< double > v12_BarLength, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v13_BarRole, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface) : IfcReinforcingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_NominalDiameter));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CrossSectionArea));entity->setArgument(10,attr);} if (v12_BarLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_BarLength));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v13_BarRole,IfcReinforcingBarRoleEnum::ToString(v13_BarRole))));entity->setArgument(12,attr);} if (v14_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface))));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } }

// Function implementations for IfcReinforcingElement
bool IfcReinforcingElement::hasSteelGrade() const { return !entity->getArgument(8)->isNull(); }
std::string IfcReinforcingElement::SteelGrade() const { return *entity->getArgument(8); }
void IfcReinforcingElement::setSteelGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcReinforcingElement::is(Type::Enum v) const { return v == Type::IfcReinforcingElement || IfcBuildingElementComponent::is(v); }
Type::Enum IfcReinforcingElement::type() const { return Type::IfcReinforcingElement; }
Type::Enum IfcReinforcingElement::Class() { return Type::IfcReinforcingElement; }
IfcReinforcingElement::IfcReinforcingElement(IfcEntityInstanceData* e) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcReinforcingElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingElement::IfcReinforcingElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcReinforcingMesh
bool IfcReinforcingMesh::hasMeshLength() const { return !entity->getArgument(9)->isNull(); }
double IfcReinforcingMesh::MeshLength() const { return *entity->getArgument(9); }
void IfcReinforcingMesh::setMeshLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcReinforcingMesh::hasMeshWidth() const { return !entity->getArgument(10)->isNull(); }
double IfcReinforcingMesh::MeshWidth() const { return *entity->getArgument(10); }
void IfcReinforcingMesh::setMeshWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
double IfcReinforcingMesh::LongitudinalBarNominalDiameter() const { return *entity->getArgument(11); }
void IfcReinforcingMesh::setLongitudinalBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
double IfcReinforcingMesh::TransverseBarNominalDiameter() const { return *entity->getArgument(12); }
void IfcReinforcingMesh::setTransverseBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
double IfcReinforcingMesh::LongitudinalBarCrossSectionArea() const { return *entity->getArgument(13); }
void IfcReinforcingMesh::setLongitudinalBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
double IfcReinforcingMesh::TransverseBarCrossSectionArea() const { return *entity->getArgument(14); }
void IfcReinforcingMesh::setTransverseBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
double IfcReinforcingMesh::LongitudinalBarSpacing() const { return *entity->getArgument(15); }
void IfcReinforcingMesh::setLongitudinalBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(15,attr);} }
double IfcReinforcingMesh::TransverseBarSpacing() const { return *entity->getArgument(16); }
void IfcReinforcingMesh::setTransverseBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(16,attr);} }
bool IfcReinforcingMesh::is(Type::Enum v) const { return v == Type::IfcReinforcingMesh || IfcReinforcingElement::is(v); }
Type::Enum IfcReinforcingMesh::type() const { return Type::IfcReinforcingMesh; }
Type::Enum IfcReinforcingMesh::Class() { return Type::IfcReinforcingMesh; }
IfcReinforcingMesh::IfcReinforcingMesh(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcReinforcingMesh) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingMesh::IfcReinforcingMesh(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_MeshLength, boost::optional< double > v11_MeshWidth, double v12_LongitudinalBarNominalDiameter, double v13_TransverseBarNominalDiameter, double v14_LongitudinalBarCrossSectionArea, double v15_TransverseBarCrossSectionArea, double v16_LongitudinalBarSpacing, double v17_TransverseBarSpacing) : IfcReinforcingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_MeshLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MeshLength));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_MeshWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MeshWidth));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LongitudinalBarNominalDiameter));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_TransverseBarNominalDiameter));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_LongitudinalBarCrossSectionArea));entity->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_TransverseBarCrossSectionArea));entity->setArgument(14,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v16_LongitudinalBarSpacing));entity->setArgument(15,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v17_TransverseBarSpacing));entity->setArgument(16,attr);} }

// Function implementations for IfcRelAggregates
bool IfcRelAggregates::is(Type::Enum v) const { return v == Type::IfcRelAggregates || IfcRelDecomposes::is(v); }
Type::Enum IfcRelAggregates::type() const { return Type::IfcRelAggregates; }
Type::Enum IfcRelAggregates::Class() { return Type::IfcRelAggregates; }
IfcRelAggregates::IfcRelAggregates(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAggregates) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAggregates::IfcRelAggregates(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssigns
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelAssigns::RelatedObjects() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcObjectDefinition>(); }
void IfcRelAssigns::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
bool IfcRelAssigns::hasRelatedObjectsType() const { return !entity->getArgument(5)->isNull(); }
IfcObjectTypeEnum::IfcObjectTypeEnum IfcRelAssigns::RelatedObjectsType() const { return IfcObjectTypeEnum::FromString(*entity->getArgument(5)); }
void IfcRelAssigns::setRelatedObjectsType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcObjectTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcRelAssigns::is(Type::Enum v) const { return v == Type::IfcRelAssigns || IfcRelationship::is(v); }
Type::Enum IfcRelAssigns::type() const { return Type::IfcRelAssigns; }
Type::Enum IfcRelAssigns::Class() { return Type::IfcRelAssigns; }
IfcRelAssigns::IfcRelAssigns(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssigns) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssigns::IfcRelAssigns(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType) : IfcRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcRelAssignsTasks
bool IfcRelAssignsTasks::hasTimeForTask() const { return !entity->getArgument(7)->isNull(); }
IfcScheduleTimeControl* IfcRelAssignsTasks::TimeForTask() const { return (IfcScheduleTimeControl*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelAssignsTasks::setTimeForTask(IfcScheduleTimeControl* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRelAssignsTasks::is(Type::Enum v) const { return v == Type::IfcRelAssignsTasks || IfcRelAssignsToControl::is(v); }
Type::Enum IfcRelAssignsTasks::type() const { return Type::IfcRelAssignsTasks; }
Type::Enum IfcRelAssignsTasks::Class() { return Type::IfcRelAssignsTasks; }
IfcRelAssignsTasks::IfcRelAssignsTasks(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsTasks) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsTasks::IfcRelAssignsTasks(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl, IfcScheduleTimeControl* v8_TimeForTask) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_TimeForTask));entity->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToActor
IfcActor* IfcRelAssignsToActor::RelatingActor() const { return (IfcActor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToActor::setRelatingActor(IfcActor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToActor::hasActingRole() const { return !entity->getArgument(7)->isNull(); }
IfcActorRole* IfcRelAssignsToActor::ActingRole() const { return (IfcActorRole*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelAssignsToActor::setActingRole(IfcActorRole* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRelAssignsToActor::is(Type::Enum v) const { return v == Type::IfcRelAssignsToActor || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToActor::type() const { return Type::IfcRelAssignsToActor; }
Type::Enum IfcRelAssignsToActor::Class() { return Type::IfcRelAssignsToActor; }
IfcRelAssignsToActor::IfcRelAssignsToActor(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToActor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToActor::IfcRelAssignsToActor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingActor));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ActingRole));entity->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToControl
IfcControl* IfcRelAssignsToControl::RelatingControl() const { return (IfcControl*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToControl::setRelatingControl(IfcControl* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToControl::is(Type::Enum v) const { return v == Type::IfcRelAssignsToControl || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToControl::type() const { return Type::IfcRelAssignsToControl; }
Type::Enum IfcRelAssignsToControl::Class() { return Type::IfcRelAssignsToControl; }
IfcRelAssignsToControl::IfcRelAssignsToControl(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToControl) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToControl::IfcRelAssignsToControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToGroup
IfcGroup* IfcRelAssignsToGroup::RelatingGroup() const { return (IfcGroup*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToGroup::setRelatingGroup(IfcGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToGroup::is(Type::Enum v) const { return v == Type::IfcRelAssignsToGroup || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToGroup::type() const { return Type::IfcRelAssignsToGroup; }
Type::Enum IfcRelAssignsToGroup::Class() { return Type::IfcRelAssignsToGroup; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToGroup) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingGroup));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToProcess
IfcProcess* IfcRelAssignsToProcess::RelatingProcess() const { return (IfcProcess*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToProcess::setRelatingProcess(IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToProcess::hasQuantityInProcess() const { return !entity->getArgument(7)->isNull(); }
IfcMeasureWithUnit* IfcRelAssignsToProcess::QuantityInProcess() const { return (IfcMeasureWithUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelAssignsToProcess::setQuantityInProcess(IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRelAssignsToProcess::is(Type::Enum v) const { return v == Type::IfcRelAssignsToProcess || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToProcess::type() const { return Type::IfcRelAssignsToProcess; }
Type::Enum IfcRelAssignsToProcess::Class() { return Type::IfcRelAssignsToProcess; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToProcess) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProcess* v7_RelatingProcess, IfcMeasureWithUnit* v8_QuantityInProcess) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProcess));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_QuantityInProcess));entity->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToProduct
IfcProduct* IfcRelAssignsToProduct::RelatingProduct() const { return (IfcProduct*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToProduct::setRelatingProduct(IfcProduct* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToProduct::is(Type::Enum v) const { return v == Type::IfcRelAssignsToProduct || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToProduct::type() const { return Type::IfcRelAssignsToProduct; }
Type::Enum IfcRelAssignsToProduct::Class() { return Type::IfcRelAssignsToProduct; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToProduct) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProduct* v7_RelatingProduct) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProduct));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToProjectOrder
bool IfcRelAssignsToProjectOrder::is(Type::Enum v) const { return v == Type::IfcRelAssignsToProjectOrder || IfcRelAssignsToControl::is(v); }
Type::Enum IfcRelAssignsToProjectOrder::type() const { return Type::IfcRelAssignsToProjectOrder; }
Type::Enum IfcRelAssignsToProjectOrder::Class() { return Type::IfcRelAssignsToProjectOrder; }
IfcRelAssignsToProjectOrder::IfcRelAssignsToProjectOrder(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToProjectOrder) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToProjectOrder::IfcRelAssignsToProjectOrder(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToResource
IfcResource* IfcRelAssignsToResource::RelatingResource() const { return (IfcResource*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssignsToResource::setRelatingResource(IfcResource* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssignsToResource::is(Type::Enum v) const { return v == Type::IfcRelAssignsToResource || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToResource::type() const { return Type::IfcRelAssignsToResource; }
Type::Enum IfcRelAssignsToResource::Class() { return Type::IfcRelAssignsToResource; }
IfcRelAssignsToResource::IfcRelAssignsToResource(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssignsToResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToResource::IfcRelAssignsToResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcResource* v7_RelatingResource) : IfcRelAssigns((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingResource));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssociates
IfcTemplatedEntityList< IfcRoot >::ptr IfcRelAssociates::RelatedObjects() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcRoot>(); }
void IfcRelAssociates::setRelatedObjects(IfcTemplatedEntityList< IfcRoot >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
bool IfcRelAssociates::is(Type::Enum v) const { return v == Type::IfcRelAssociates || IfcRelationship::is(v); }
Type::Enum IfcRelAssociates::type() const { return Type::IfcRelAssociates; }
Type::Enum IfcRelAssociates::Class() { return Type::IfcRelAssociates; }
IfcRelAssociates::IfcRelAssociates(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociates) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociates::IfcRelAssociates(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} }

// Function implementations for IfcRelAssociatesAppliedValue
IfcAppliedValue* IfcRelAssociatesAppliedValue::RelatingAppliedValue() const { return (IfcAppliedValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesAppliedValue::setRelatingAppliedValue(IfcAppliedValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesAppliedValue::is(Type::Enum v) const { return v == Type::IfcRelAssociatesAppliedValue || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesAppliedValue::type() const { return Type::IfcRelAssociatesAppliedValue; }
Type::Enum IfcRelAssociatesAppliedValue::Class() { return Type::IfcRelAssociatesAppliedValue; }
IfcRelAssociatesAppliedValue::IfcRelAssociatesAppliedValue(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesAppliedValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesAppliedValue::IfcRelAssociatesAppliedValue(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcAppliedValue* v6_RelatingAppliedValue) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingAppliedValue));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesApproval
IfcApproval* IfcRelAssociatesApproval::RelatingApproval() const { return (IfcApproval*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesApproval::setRelatingApproval(IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesApproval::is(Type::Enum v) const { return v == Type::IfcRelAssociatesApproval || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesApproval::type() const { return Type::IfcRelAssociatesApproval; }
Type::Enum IfcRelAssociatesApproval::Class() { return Type::IfcRelAssociatesApproval; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesApproval) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcApproval* v6_RelatingApproval) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingApproval));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesClassification
IfcClassificationNotationSelect* IfcRelAssociatesClassification::RelatingClassification() const { return (IfcClassificationNotationSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesClassification::setRelatingClassification(IfcClassificationNotationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesClassification::is(Type::Enum v) const { return v == Type::IfcRelAssociatesClassification || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesClassification::type() const { return Type::IfcRelAssociatesClassification; }
Type::Enum IfcRelAssociatesClassification::Class() { return Type::IfcRelAssociatesClassification; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesClassification) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcClassificationNotationSelect* v6_RelatingClassification) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingClassification));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesConstraint
std::string IfcRelAssociatesConstraint::Intent() const { return *entity->getArgument(5); }
void IfcRelAssociatesConstraint::setIntent(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcConstraint* IfcRelAssociatesConstraint::RelatingConstraint() const { return (IfcConstraint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssociatesConstraint::setRelatingConstraint(IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssociatesConstraint::is(Type::Enum v) const { return v == Type::IfcRelAssociatesConstraint || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesConstraint::type() const { return Type::IfcRelAssociatesConstraint; }
Type::Enum IfcRelAssociatesConstraint::Class() { return Type::IfcRelAssociatesConstraint; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesConstraint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, std::string v6_Intent, IfcConstraint* v7_RelatingConstraint) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Intent));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingConstraint));entity->setArgument(6,attr);} }

// Function implementations for IfcRelAssociatesDocument
IfcDocumentSelect* IfcRelAssociatesDocument::RelatingDocument() const { return (IfcDocumentSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesDocument::setRelatingDocument(IfcDocumentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesDocument::is(Type::Enum v) const { return v == Type::IfcRelAssociatesDocument || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesDocument::type() const { return Type::IfcRelAssociatesDocument; }
Type::Enum IfcRelAssociatesDocument::Class() { return Type::IfcRelAssociatesDocument; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesDocument) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcDocumentSelect* v6_RelatingDocument) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingDocument));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesLibrary
IfcLibrarySelect* IfcRelAssociatesLibrary::RelatingLibrary() const { return (IfcLibrarySelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesLibrary::setRelatingLibrary(IfcLibrarySelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesLibrary::is(Type::Enum v) const { return v == Type::IfcRelAssociatesLibrary || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesLibrary::type() const { return Type::IfcRelAssociatesLibrary; }
Type::Enum IfcRelAssociatesLibrary::Class() { return Type::IfcRelAssociatesLibrary; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesLibrary) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcLibrarySelect* v6_RelatingLibrary) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingLibrary));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesMaterial
IfcMaterialSelect* IfcRelAssociatesMaterial::RelatingMaterial() const { return (IfcMaterialSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesMaterial::setRelatingMaterial(IfcMaterialSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesMaterial::is(Type::Enum v) const { return v == Type::IfcRelAssociatesMaterial || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesMaterial::type() const { return Type::IfcRelAssociatesMaterial; }
Type::Enum IfcRelAssociatesMaterial::Class() { return Type::IfcRelAssociatesMaterial; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesMaterial) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcMaterialSelect* v6_RelatingMaterial) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingMaterial));entity->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesProfileProperties
IfcProfileProperties* IfcRelAssociatesProfileProperties::RelatingProfileProperties() const { return (IfcProfileProperties*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelAssociatesProfileProperties::setRelatingProfileProperties(IfcProfileProperties* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelAssociatesProfileProperties::hasProfileSectionLocation() const { return !entity->getArgument(6)->isNull(); }
IfcShapeAspect* IfcRelAssociatesProfileProperties::ProfileSectionLocation() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelAssociatesProfileProperties::setProfileSectionLocation(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelAssociatesProfileProperties::hasProfileOrientation() const { return !entity->getArgument(7)->isNull(); }
IfcOrientationSelect* IfcRelAssociatesProfileProperties::ProfileOrientation() const { return (IfcOrientationSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelAssociatesProfileProperties::setProfileOrientation(IfcOrientationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRelAssociatesProfileProperties::is(Type::Enum v) const { return v == Type::IfcRelAssociatesProfileProperties || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesProfileProperties::type() const { return Type::IfcRelAssociatesProfileProperties; }
Type::Enum IfcRelAssociatesProfileProperties::Class() { return Type::IfcRelAssociatesProfileProperties; }
IfcRelAssociatesProfileProperties::IfcRelAssociatesProfileProperties(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelAssociatesProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesProfileProperties::IfcRelAssociatesProfileProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcProfileProperties* v6_RelatingProfileProperties, IfcShapeAspect* v7_ProfileSectionLocation, IfcOrientationSelect* v8_ProfileOrientation) : IfcRelAssociates((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingProfileProperties));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ProfileSectionLocation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ProfileOrientation));entity->setArgument(7,attr);} }

// Function implementations for IfcRelConnects
bool IfcRelConnects::is(Type::Enum v) const { return v == Type::IfcRelConnects || IfcRelationship::is(v); }
Type::Enum IfcRelConnects::type() const { return Type::IfcRelConnects; }
Type::Enum IfcRelConnects::Class() { return Type::IfcRelConnects; }
IfcRelConnects::IfcRelConnects(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnects) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnects::IfcRelConnects(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcRelConnectsElements
bool IfcRelConnectsElements::hasConnectionGeometry() const { return !entity->getArgument(4)->isNull(); }
IfcConnectionGeometry* IfcRelConnectsElements::ConnectionGeometry() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsElements::setConnectionGeometry(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcElement* IfcRelConnectsElements::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsElements::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcElement* IfcRelConnectsElements::RelatedElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelConnectsElements::setRelatedElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelConnectsElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsElements || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsElements::type() const { return Type::IfcRelConnectsElements; }
Type::Enum IfcRelConnectsElements::Class() { return Type::IfcRelConnectsElements; }
IfcRelConnectsElements::IfcRelConnectsElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsElements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsElements::IfcRelConnectsElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));entity->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsPathElements
std::vector< int > /*[0:?]*/ IfcRelConnectsPathElements::RelatingPriorities() const { return *entity->getArgument(7); }
void IfcRelConnectsPathElements::setRelatingPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
std::vector< int > /*[0:?]*/ IfcRelConnectsPathElements::RelatedPriorities() const { return *entity->getArgument(8); }
void IfcRelConnectsPathElements::setRelatedPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatedConnectionType() const { return IfcConnectionTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRelConnectsPathElements::setRelatedConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConnectionTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatingConnectionType() const { return IfcConnectionTypeEnum::FromString(*entity->getArgument(10)); }
void IfcRelConnectsPathElements::setRelatingConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcConnectionTypeEnum::ToString(v)));entity->setArgument(10,attr);} }
bool IfcRelConnectsPathElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsPathElements || IfcRelConnectsElements::is(v); }
Type::Enum IfcRelConnectsPathElements::type() const { return Type::IfcRelConnectsPathElements; }
Type::Enum IfcRelConnectsPathElements::Class() { return Type::IfcRelConnectsPathElements; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsPathElements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, std::vector< int > /*[0:?]*/ v8_RelatingPriorities, std::vector< int > /*[0:?]*/ v9_RelatedPriorities, IfcConnectionTypeEnum::IfcConnectionTypeEnum v10_RelatedConnectionType, IfcConnectionTypeEnum::IfcConnectionTypeEnum v11_RelatingConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RelatingPriorities));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RelatedPriorities));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_RelatedConnectionType,IfcConnectionTypeEnum::ToString(v10_RelatedConnectionType))));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_RelatingConnectionType,IfcConnectionTypeEnum::ToString(v11_RelatingConnectionType))));entity->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsPortToElement
IfcPort* IfcRelConnectsPortToElement::RelatingPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsPortToElement::setRelatingPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcElement* IfcRelConnectsPortToElement::RelatedElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsPortToElement::setRelatedElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelConnectsPortToElement::is(Type::Enum v) const { return v == Type::IfcRelConnectsPortToElement || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsPortToElement::type() const { return Type::IfcRelConnectsPortToElement; }
Type::Enum IfcRelConnectsPortToElement::Class() { return Type::IfcRelConnectsPortToElement; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsPortToElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcElement* v6_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedElement));entity->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsPorts
IfcPort* IfcRelConnectsPorts::RelatingPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsPorts::setRelatingPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcPort* IfcRelConnectsPorts::RelatedPort() const { return (IfcPort*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsPorts::setRelatedPort(IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelConnectsPorts::hasRealizingElement() const { return !entity->getArgument(6)->isNull(); }
IfcElement* IfcRelConnectsPorts::RealizingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelConnectsPorts::setRealizingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelConnectsPorts::is(Type::Enum v) const { return v == Type::IfcRelConnectsPorts || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsPorts::type() const { return Type::IfcRelConnectsPorts; }
Type::Enum IfcRelConnectsPorts::Class() { return Type::IfcRelConnectsPorts; }
IfcRelConnectsPorts::IfcRelConnectsPorts(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsPorts) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPorts::IfcRelConnectsPorts(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcPort* v6_RelatedPort, IfcElement* v7_RealizingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedPort));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RealizingElement));entity->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsStructuralActivity
IfcStructuralActivityAssignmentSelect* IfcRelConnectsStructuralActivity::RelatingElement() const { return (IfcStructuralActivityAssignmentSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsStructuralActivity::setRelatingElement(IfcStructuralActivityAssignmentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcStructuralActivity* IfcRelConnectsStructuralActivity::RelatedStructuralActivity() const { return (IfcStructuralActivity*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsStructuralActivity::setRelatedStructuralActivity(IfcStructuralActivity* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelConnectsStructuralActivity::is(Type::Enum v) const { return v == Type::IfcRelConnectsStructuralActivity || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsStructuralActivity::type() const { return Type::IfcRelConnectsStructuralActivity; }
Type::Enum IfcRelConnectsStructuralActivity::Class() { return Type::IfcRelConnectsStructuralActivity; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsStructuralActivity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralActivityAssignmentSelect* v5_RelatingElement, IfcStructuralActivity* v6_RelatedStructuralActivity) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralActivity));entity->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsStructuralElement
IfcElement* IfcRelConnectsStructuralElement::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsStructuralElement::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcStructuralMember* IfcRelConnectsStructuralElement::RelatedStructuralMember() const { return (IfcStructuralMember*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsStructuralElement::setRelatedStructuralMember(IfcStructuralMember* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelConnectsStructuralElement::is(Type::Enum v) const { return v == Type::IfcRelConnectsStructuralElement || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsStructuralElement::type() const { return Type::IfcRelConnectsStructuralElement; }
Type::Enum IfcRelConnectsStructuralElement::Class() { return Type::IfcRelConnectsStructuralElement; }
IfcRelConnectsStructuralElement::IfcRelConnectsStructuralElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsStructuralElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsStructuralElement::IfcRelConnectsStructuralElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcStructuralMember* v6_RelatedStructuralMember) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralMember));entity->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsStructuralMember
IfcStructuralMember* IfcRelConnectsStructuralMember::RelatingStructuralMember() const { return (IfcStructuralMember*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelConnectsStructuralMember::setRelatingStructuralMember(IfcStructuralMember* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcStructuralConnection* IfcRelConnectsStructuralMember::RelatedStructuralConnection() const { return (IfcStructuralConnection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelConnectsStructuralMember::setRelatedStructuralConnection(IfcStructuralConnection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelConnectsStructuralMember::hasAppliedCondition() const { return !entity->getArgument(6)->isNull(); }
IfcBoundaryCondition* IfcRelConnectsStructuralMember::AppliedCondition() const { return (IfcBoundaryCondition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelConnectsStructuralMember::setAppliedCondition(IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcRelConnectsStructuralMember::hasAdditionalConditions() const { return !entity->getArgument(7)->isNull(); }
IfcStructuralConnectionCondition* IfcRelConnectsStructuralMember::AdditionalConditions() const { return (IfcStructuralConnectionCondition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelConnectsStructuralMember::setAdditionalConditions(IfcStructuralConnectionCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcRelConnectsStructuralMember::hasSupportedLength() const { return !entity->getArgument(8)->isNull(); }
double IfcRelConnectsStructuralMember::SupportedLength() const { return *entity->getArgument(8); }
void IfcRelConnectsStructuralMember::setSupportedLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcRelConnectsStructuralMember::hasConditionCoordinateSystem() const { return !entity->getArgument(9)->isNull(); }
IfcAxis2Placement3D* IfcRelConnectsStructuralMember::ConditionCoordinateSystem() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcRelConnectsStructuralMember::setConditionCoordinateSystem(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcRelConnectsStructuralMember::is(Type::Enum v) const { return v == Type::IfcRelConnectsStructuralMember || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsStructuralMember::type() const { return Type::IfcRelConnectsStructuralMember; }
Type::Enum IfcRelConnectsStructuralMember::Class() { return Type::IfcRelConnectsStructuralMember; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsStructuralMember) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));entity->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));entity->setArgument(9,attr);} }

// Function implementations for IfcRelConnectsWithEccentricity
IfcConnectionGeometry* IfcRelConnectsWithEccentricity::ConnectionConstraint() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcRelConnectsWithEccentricity::setConnectionConstraint(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcRelConnectsWithEccentricity::is(Type::Enum v) const { return v == Type::IfcRelConnectsWithEccentricity || IfcRelConnectsStructuralMember::is(v); }
Type::Enum IfcRelConnectsWithEccentricity::type() const { return Type::IfcRelConnectsWithEccentricity; }
Type::Enum IfcRelConnectsWithEccentricity::Class() { return Type::IfcRelConnectsWithEccentricity; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(IfcEntityInstanceData* e) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsWithEccentricity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem, IfcConnectionGeometry* v11_ConnectionConstraint) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));entity->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ConnectionConstraint));entity->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsWithRealizingElements
IfcTemplatedEntityList< IfcElement >::ptr IfcRelConnectsWithRealizingElements::RealizingElements() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcElement>(); }
void IfcRelConnectsWithRealizingElements::setRealizingElements(IfcTemplatedEntityList< IfcElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
bool IfcRelConnectsWithRealizingElements::hasConnectionType() const { return !entity->getArgument(8)->isNull(); }
std::string IfcRelConnectsWithRealizingElements::ConnectionType() const { return *entity->getArgument(8); }
void IfcRelConnectsWithRealizingElements::setConnectionType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcRelConnectsWithRealizingElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsWithRealizingElements || IfcRelConnectsElements::is(v); }
Type::Enum IfcRelConnectsWithRealizingElements::type() const { return Type::IfcRelConnectsWithRealizingElements; }
Type::Enum IfcRelConnectsWithRealizingElements::Class() { return Type::IfcRelConnectsWithRealizingElements; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelConnectsWithRealizingElements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, IfcTemplatedEntityList< IfcElement >::ptr v8_RealizingElements, boost::optional< std::string > v9_ConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RealizingElements)->generalize());entity->setArgument(7,attr);} if (v9_ConnectionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ConnectionType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcRelContainedInSpatialStructure
IfcTemplatedEntityList< IfcProduct >::ptr IfcRelContainedInSpatialStructure::RelatedElements() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcProduct>(); }
void IfcRelContainedInSpatialStructure::setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
IfcSpatialStructureElement* IfcRelContainedInSpatialStructure::RelatingStructure() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelContainedInSpatialStructure::setRelatingStructure(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelContainedInSpatialStructure::is(Type::Enum v) const { return v == Type::IfcRelContainedInSpatialStructure || IfcRelConnects::is(v); }
Type::Enum IfcRelContainedInSpatialStructure::type() const { return Type::IfcRelContainedInSpatialStructure; }
Type::Enum IfcRelContainedInSpatialStructure::Class() { return Type::IfcRelContainedInSpatialStructure; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelContainedInSpatialStructure) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialStructureElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));entity->setArgument(5,attr);} }

// Function implementations for IfcRelCoversBldgElements
IfcElement* IfcRelCoversBldgElements::RelatingBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelCoversBldgElements::setRelatingBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcCovering >::ptr IfcRelCoversBldgElements::RelatedCoverings() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcCovering>(); }
void IfcRelCoversBldgElements::setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcRelCoversBldgElements::is(Type::Enum v) const { return v == Type::IfcRelCoversBldgElements || IfcRelConnects::is(v); }
Type::Enum IfcRelCoversBldgElements::type() const { return Type::IfcRelCoversBldgElements; }
Type::Enum IfcRelCoversBldgElements::Class() { return Type::IfcRelCoversBldgElements; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelCoversBldgElements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelCoversSpaces
IfcSpace* IfcRelCoversSpaces::RelatedSpace() const { return (IfcSpace*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelCoversSpaces::setRelatedSpace(IfcSpace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcCovering >::ptr IfcRelCoversSpaces::RelatedCoverings() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcCovering>(); }
void IfcRelCoversSpaces::setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcRelCoversSpaces::is(Type::Enum v) const { return v == Type::IfcRelCoversSpaces || IfcRelConnects::is(v); }
Type::Enum IfcRelCoversSpaces::type() const { return Type::IfcRelCoversSpaces; }
Type::Enum IfcRelCoversSpaces::Class() { return Type::IfcRelCoversSpaces; }
IfcRelCoversSpaces::IfcRelCoversSpaces(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelCoversSpaces) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelCoversSpaces::IfcRelCoversSpaces(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatedSpace, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedSpace));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelDecomposes
IfcObjectDefinition* IfcRelDecomposes::RelatingObject() const { return (IfcObjectDefinition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelDecomposes::setRelatingObject(IfcObjectDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcObjectDefinition >::ptr IfcRelDecomposes::RelatedObjects() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcObjectDefinition>(); }
void IfcRelDecomposes::setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcRelDecomposes::is(Type::Enum v) const { return v == Type::IfcRelDecomposes || IfcRelationship::is(v); }
Type::Enum IfcRelDecomposes::type() const { return Type::IfcRelDecomposes; }
Type::Enum IfcRelDecomposes::Class() { return Type::IfcRelDecomposes; }
IfcRelDecomposes::IfcRelDecomposes(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelDecomposes) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDecomposes::IfcRelDecomposes(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelDefines
IfcTemplatedEntityList< IfcObject >::ptr IfcRelDefines::RelatedObjects() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcObject>(); }
void IfcRelDefines::setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
bool IfcRelDefines::is(Type::Enum v) const { return v == Type::IfcRelDefines || IfcRelationship::is(v); }
Type::Enum IfcRelDefines::type() const { return Type::IfcRelDefines; }
Type::Enum IfcRelDefines::Class() { return Type::IfcRelDefines; }
IfcRelDefines::IfcRelDefines(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelDefines) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefines::IfcRelDefines(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} }

// Function implementations for IfcRelDefinesByProperties
IfcPropertySetDefinition* IfcRelDefinesByProperties::RelatingPropertyDefinition() const { return (IfcPropertySetDefinition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelDefinesByProperties::setRelatingPropertyDefinition(IfcPropertySetDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelDefinesByProperties::is(Type::Enum v) const { return v == Type::IfcRelDefinesByProperties || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByProperties::type() const { return Type::IfcRelDefinesByProperties; }
Type::Enum IfcRelDefinesByProperties::Class() { return Type::IfcRelDefinesByProperties; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelDefinesByProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcPropertySetDefinition* v6_RelatingPropertyDefinition) : IfcRelDefines((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingPropertyDefinition));entity->setArgument(5,attr);} }

// Function implementations for IfcRelDefinesByType
IfcTypeObject* IfcRelDefinesByType::RelatingType() const { return (IfcTypeObject*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelDefinesByType::setRelatingType(IfcTypeObject* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelDefinesByType::is(Type::Enum v) const { return v == Type::IfcRelDefinesByType || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByType::type() const { return Type::IfcRelDefinesByType; }
Type::Enum IfcRelDefinesByType::Class() { return Type::IfcRelDefinesByType; }
IfcRelDefinesByType::IfcRelDefinesByType(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelDefinesByType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByType::IfcRelDefinesByType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcTypeObject* v6_RelatingType) : IfcRelDefines((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingType));entity->setArgument(5,attr);} }

// Function implementations for IfcRelFillsElement
IfcOpeningElement* IfcRelFillsElement::RelatingOpeningElement() const { return (IfcOpeningElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelFillsElement::setRelatingOpeningElement(IfcOpeningElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcElement* IfcRelFillsElement::RelatedBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelFillsElement::setRelatedBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelFillsElement::is(Type::Enum v) const { return v == Type::IfcRelFillsElement || IfcRelConnects::is(v); }
Type::Enum IfcRelFillsElement::type() const { return Type::IfcRelFillsElement; }
Type::Enum IfcRelFillsElement::Class() { return Type::IfcRelFillsElement; }
IfcRelFillsElement::IfcRelFillsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelFillsElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelFillsElement::IfcRelFillsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcOpeningElement* v5_RelatingOpeningElement, IfcElement* v6_RelatedBuildingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingOpeningElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));entity->setArgument(5,attr);} }

// Function implementations for IfcRelFlowControlElements
IfcTemplatedEntityList< IfcDistributionControlElement >::ptr IfcRelFlowControlElements::RelatedControlElements() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcDistributionControlElement>(); }
void IfcRelFlowControlElements::setRelatedControlElements(IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
IfcDistributionFlowElement* IfcRelFlowControlElements::RelatingFlowElement() const { return (IfcDistributionFlowElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelFlowControlElements::setRelatingFlowElement(IfcDistributionFlowElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelFlowControlElements::is(Type::Enum v) const { return v == Type::IfcRelFlowControlElements || IfcRelConnects::is(v); }
Type::Enum IfcRelFlowControlElements::type() const { return Type::IfcRelFlowControlElements; }
Type::Enum IfcRelFlowControlElements::Class() { return Type::IfcRelFlowControlElements; }
IfcRelFlowControlElements::IfcRelFlowControlElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelFlowControlElements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelFlowControlElements::IfcRelFlowControlElements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v5_RelatedControlElements, IfcDistributionFlowElement* v6_RelatingFlowElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedControlElements)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingFlowElement));entity->setArgument(5,attr);} }

// Function implementations for IfcRelInteractionRequirements
bool IfcRelInteractionRequirements::hasDailyInteraction() const { return !entity->getArgument(4)->isNull(); }
double IfcRelInteractionRequirements::DailyInteraction() const { return *entity->getArgument(4); }
void IfcRelInteractionRequirements::setDailyInteraction(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcRelInteractionRequirements::hasImportanceRating() const { return !entity->getArgument(5)->isNull(); }
double IfcRelInteractionRequirements::ImportanceRating() const { return *entity->getArgument(5); }
void IfcRelInteractionRequirements::setImportanceRating(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelInteractionRequirements::hasLocationOfInteraction() const { return !entity->getArgument(6)->isNull(); }
IfcSpatialStructureElement* IfcRelInteractionRequirements::LocationOfInteraction() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelInteractionRequirements::setLocationOfInteraction(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcSpaceProgram* IfcRelInteractionRequirements::RelatedSpaceProgram() const { return (IfcSpaceProgram*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcRelInteractionRequirements::setRelatedSpaceProgram(IfcSpaceProgram* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcSpaceProgram* IfcRelInteractionRequirements::RelatingSpaceProgram() const { return (IfcSpaceProgram*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcRelInteractionRequirements::setRelatingSpaceProgram(IfcSpaceProgram* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcRelInteractionRequirements::is(Type::Enum v) const { return v == Type::IfcRelInteractionRequirements || IfcRelConnects::is(v); }
Type::Enum IfcRelInteractionRequirements::type() const { return Type::IfcRelInteractionRequirements; }
Type::Enum IfcRelInteractionRequirements::Class() { return Type::IfcRelInteractionRequirements; }
IfcRelInteractionRequirements::IfcRelInteractionRequirements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelInteractionRequirements) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelInteractionRequirements::IfcRelInteractionRequirements(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_DailyInteraction, boost::optional< double > v6_ImportanceRating, IfcSpatialStructureElement* v7_LocationOfInteraction, IfcSpaceProgram* v8_RelatedSpaceProgram, IfcSpaceProgram* v9_RelatingSpaceProgram) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_DailyInteraction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DailyInteraction));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ImportanceRating) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ImportanceRating));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LocationOfInteraction));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RelatedSpaceProgram));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RelatingSpaceProgram));entity->setArgument(8,attr);} }

// Function implementations for IfcRelNests
bool IfcRelNests::is(Type::Enum v) const { return v == Type::IfcRelNests || IfcRelDecomposes::is(v); }
Type::Enum IfcRelNests::type() const { return Type::IfcRelNests; }
Type::Enum IfcRelNests::Class() { return Type::IfcRelNests; }
IfcRelNests::IfcRelNests(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelNests) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelNests::IfcRelNests(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelOccupiesSpaces
bool IfcRelOccupiesSpaces::is(Type::Enum v) const { return v == Type::IfcRelOccupiesSpaces || IfcRelAssignsToActor::is(v); }
Type::Enum IfcRelOccupiesSpaces::type() const { return Type::IfcRelOccupiesSpaces; }
Type::Enum IfcRelOccupiesSpaces::Class() { return Type::IfcRelOccupiesSpaces; }
IfcRelOccupiesSpaces::IfcRelOccupiesSpaces(IfcEntityInstanceData* e) : IfcRelAssignsToActor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelOccupiesSpaces) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelOccupiesSpaces::IfcRelOccupiesSpaces(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole) : IfcRelAssignsToActor((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingActor));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ActingRole));entity->setArgument(7,attr);} }

// Function implementations for IfcRelOverridesProperties
IfcTemplatedEntityList< IfcProperty >::ptr IfcRelOverridesProperties::OverridingProperties() const { IfcEntityList::ptr es = *entity->getArgument(6); return es->as<IfcProperty>(); }
void IfcRelOverridesProperties::setOverridingProperties(IfcTemplatedEntityList< IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(6,attr);} }
bool IfcRelOverridesProperties::is(Type::Enum v) const { return v == Type::IfcRelOverridesProperties || IfcRelDefinesByProperties::is(v); }
Type::Enum IfcRelOverridesProperties::type() const { return Type::IfcRelOverridesProperties; }
Type::Enum IfcRelOverridesProperties::Class() { return Type::IfcRelOverridesProperties; }
IfcRelOverridesProperties::IfcRelOverridesProperties(IfcEntityInstanceData* e) : IfcRelDefinesByProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelOverridesProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelOverridesProperties::IfcRelOverridesProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcPropertySetDefinition* v6_RelatingPropertyDefinition, IfcTemplatedEntityList< IfcProperty >::ptr v7_OverridingProperties) : IfcRelDefinesByProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingPropertyDefinition));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OverridingProperties)->generalize());entity->setArgument(6,attr);} }

// Function implementations for IfcRelProjectsElement
IfcElement* IfcRelProjectsElement::RelatingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelProjectsElement::setRelatingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcFeatureElementAddition* IfcRelProjectsElement::RelatedFeatureElement() const { return (IfcFeatureElementAddition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelProjectsElement::setRelatedFeatureElement(IfcFeatureElementAddition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelProjectsElement::is(Type::Enum v) const { return v == Type::IfcRelProjectsElement || IfcRelConnects::is(v); }
Type::Enum IfcRelProjectsElement::type() const { return Type::IfcRelProjectsElement; }
Type::Enum IfcRelProjectsElement::Class() { return Type::IfcRelProjectsElement; }
IfcRelProjectsElement::IfcRelProjectsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelProjectsElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelProjectsElement::IfcRelProjectsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcFeatureElementAddition* v6_RelatedFeatureElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedFeatureElement));entity->setArgument(5,attr);} }

// Function implementations for IfcRelReferencedInSpatialStructure
IfcTemplatedEntityList< IfcProduct >::ptr IfcRelReferencedInSpatialStructure::RelatedElements() const { IfcEntityList::ptr es = *entity->getArgument(4); return es->as<IfcProduct>(); }
void IfcRelReferencedInSpatialStructure::setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(4,attr);} }
IfcSpatialStructureElement* IfcRelReferencedInSpatialStructure::RelatingStructure() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelReferencedInSpatialStructure::setRelatingStructure(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelReferencedInSpatialStructure::is(Type::Enum v) const { return v == Type::IfcRelReferencedInSpatialStructure || IfcRelConnects::is(v); }
Type::Enum IfcRelReferencedInSpatialStructure::type() const { return Type::IfcRelReferencedInSpatialStructure; }
Type::Enum IfcRelReferencedInSpatialStructure::Class() { return Type::IfcRelReferencedInSpatialStructure; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelReferencedInSpatialStructure) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialStructureElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));entity->setArgument(5,attr);} }

// Function implementations for IfcRelSchedulesCostItems
bool IfcRelSchedulesCostItems::is(Type::Enum v) const { return v == Type::IfcRelSchedulesCostItems || IfcRelAssignsToControl::is(v); }
Type::Enum IfcRelSchedulesCostItems::type() const { return Type::IfcRelSchedulesCostItems; }
Type::Enum IfcRelSchedulesCostItems::Class() { return Type::IfcRelSchedulesCostItems; }
IfcRelSchedulesCostItems::IfcRelSchedulesCostItems(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelSchedulesCostItems) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSchedulesCostItems::IfcRelSchedulesCostItems(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());entity->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));entity->setArgument(6,attr);} }

// Function implementations for IfcRelSequence
IfcProcess* IfcRelSequence::RelatingProcess() const { return (IfcProcess*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelSequence::setRelatingProcess(IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcProcess* IfcRelSequence::RelatedProcess() const { return (IfcProcess*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelSequence::setRelatedProcess(IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcRelSequence::TimeLag() const { return *entity->getArgument(6); }
void IfcRelSequence::setTimeLag(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcSequenceEnum::IfcSequenceEnum IfcRelSequence::SequenceType() const { return IfcSequenceEnum::FromString(*entity->getArgument(7)); }
void IfcRelSequence::setSequenceType(IfcSequenceEnum::IfcSequenceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSequenceEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcRelSequence::is(Type::Enum v) const { return v == Type::IfcRelSequence || IfcRelConnects::is(v); }
Type::Enum IfcRelSequence::type() const { return Type::IfcRelSequence; }
Type::Enum IfcRelSequence::Class() { return Type::IfcRelSequence; }
IfcRelSequence::IfcRelSequence(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelSequence) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSequence::IfcRelSequence(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcProcess* v5_RelatingProcess, IfcProcess* v6_RelatedProcess, double v7_TimeLag, IfcSequenceEnum::IfcSequenceEnum v8_SequenceType) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingProcess));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedProcess));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TimeLag));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_SequenceType,IfcSequenceEnum::ToString(v8_SequenceType))));entity->setArgument(7,attr);} }

// Function implementations for IfcRelServicesBuildings
IfcSystem* IfcRelServicesBuildings::RelatingSystem() const { return (IfcSystem*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelServicesBuildings::setRelatingSystem(IfcSystem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr IfcRelServicesBuildings::RelatedBuildings() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcSpatialStructureElement>(); }
void IfcRelServicesBuildings::setRelatedBuildings(IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcRelServicesBuildings::is(Type::Enum v) const { return v == Type::IfcRelServicesBuildings || IfcRelConnects::is(v); }
Type::Enum IfcRelServicesBuildings::type() const { return Type::IfcRelServicesBuildings; }
Type::Enum IfcRelServicesBuildings::Class() { return Type::IfcRelServicesBuildings; }
IfcRelServicesBuildings::IfcRelServicesBuildings(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelServicesBuildings) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelServicesBuildings::IfcRelServicesBuildings(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSystem* v5_RelatingSystem, IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr v6_RelatedBuildings) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSystem));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildings)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcRelSpaceBoundary
IfcSpace* IfcRelSpaceBoundary::RelatingSpace() const { return (IfcSpace*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelSpaceBoundary::setRelatingSpace(IfcSpace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcRelSpaceBoundary::hasRelatedBuildingElement() const { return !entity->getArgument(5)->isNull(); }
IfcElement* IfcRelSpaceBoundary::RelatedBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelSpaceBoundary::setRelatedBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelSpaceBoundary::hasConnectionGeometry() const { return !entity->getArgument(6)->isNull(); }
IfcConnectionGeometry* IfcRelSpaceBoundary::ConnectionGeometry() const { return (IfcConnectionGeometry*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcRelSpaceBoundary::setConnectionGeometry(IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcRelSpaceBoundary::PhysicalOrVirtualBoundary() const { return IfcPhysicalOrVirtualEnum::FromString(*entity->getArgument(7)); }
void IfcRelSpaceBoundary::setPhysicalOrVirtualBoundary(IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPhysicalOrVirtualEnum::ToString(v)));entity->setArgument(7,attr);} }
IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcRelSpaceBoundary::InternalOrExternalBoundary() const { return IfcInternalOrExternalEnum::FromString(*entity->getArgument(8)); }
void IfcRelSpaceBoundary::setInternalOrExternalBoundary(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInternalOrExternalEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcRelSpaceBoundary::is(Type::Enum v) const { return v == Type::IfcRelSpaceBoundary || IfcRelConnects::is(v); }
Type::Enum IfcRelSpaceBoundary::type() const { return Type::IfcRelSpaceBoundary; }
Type::Enum IfcRelSpaceBoundary::Class() { return Type::IfcRelSpaceBoundary; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelSpaceBoundary) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConnectionGeometry));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary))));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary))));entity->setArgument(8,attr);} }

// Function implementations for IfcRelVoidsElement
IfcElement* IfcRelVoidsElement::RelatingBuildingElement() const { return (IfcElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcRelVoidsElement::setRelatingBuildingElement(IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcFeatureElementSubtraction* IfcRelVoidsElement::RelatedOpeningElement() const { return (IfcFeatureElementSubtraction*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcRelVoidsElement::setRelatedOpeningElement(IfcFeatureElementSubtraction* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRelVoidsElement::is(Type::Enum v) const { return v == Type::IfcRelVoidsElement || IfcRelConnects::is(v); }
Type::Enum IfcRelVoidsElement::type() const { return Type::IfcRelVoidsElement; }
Type::Enum IfcRelVoidsElement::Class() { return Type::IfcRelVoidsElement; }
IfcRelVoidsElement::IfcRelVoidsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelVoidsElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelVoidsElement::IfcRelVoidsElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcFeatureElementSubtraction* v6_RelatedOpeningElement) : IfcRelConnects((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedOpeningElement));entity->setArgument(5,attr);} }

// Function implementations for IfcRelationship
bool IfcRelationship::is(Type::Enum v) const { return v == Type::IfcRelationship || IfcRoot::is(v); }
Type::Enum IfcRelationship::type() const { return Type::IfcRelationship; }
Type::Enum IfcRelationship::Class() { return Type::IfcRelationship; }
IfcRelationship::IfcRelationship(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelationship::IfcRelationship(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcRelaxation
double IfcRelaxation::RelaxationValue() const { return *entity->getArgument(0); }
void IfcRelaxation::setRelaxationValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcRelaxation::InitialStress() const { return *entity->getArgument(1); }
void IfcRelaxation::setInitialStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcRelaxation::is(Type::Enum v) const { return v == Type::IfcRelaxation; }
Type::Enum IfcRelaxation::type() const { return Type::IfcRelaxation; }
Type::Enum IfcRelaxation::Class() { return Type::IfcRelaxation; }
IfcRelaxation::IfcRelaxation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRelaxation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelaxation::IfcRelaxation(double v1_RelaxationValue, double v2_InitialStress) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelaxationValue));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_InitialStress));entity->setArgument(1,attr);} }

// Function implementations for IfcRepresentation
IfcRepresentationContext* IfcRepresentation::ContextOfItems() const { return (IfcRepresentationContext*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcRepresentation::setContextOfItems(IfcRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcRepresentation::hasRepresentationIdentifier() const { return !entity->getArgument(1)->isNull(); }
std::string IfcRepresentation::RepresentationIdentifier() const { return *entity->getArgument(1); }
void IfcRepresentation::setRepresentationIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcRepresentation::hasRepresentationType() const { return !entity->getArgument(2)->isNull(); }
std::string IfcRepresentation::RepresentationType() const { return *entity->getArgument(2); }
void IfcRepresentation::setRepresentationType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTemplatedEntityList< IfcRepresentationItem >::ptr IfcRepresentation::Items() const { IfcEntityList::ptr es = *entity->getArgument(3); return es->as<IfcRepresentationItem>(); }
void IfcRepresentation::setItems(IfcTemplatedEntityList< IfcRepresentationItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(3,attr);} }
IfcRepresentationMap::list::ptr IfcRepresentation::RepresentationMap() const { return entity->getInverse(Type::IfcRepresentationMap, 1)->as<IfcRepresentationMap>(); }
IfcPresentationLayerAssignment::list::ptr IfcRepresentation::LayerAssignments() const { return entity->getInverse(Type::IfcPresentationLayerAssignment, 2)->as<IfcPresentationLayerAssignment>(); }
IfcProductRepresentation::list::ptr IfcRepresentation::OfProductRepresentation() const { return entity->getInverse(Type::IfcProductRepresentation, 2)->as<IfcProductRepresentation>(); }
bool IfcRepresentation::is(Type::Enum v) const { return v == Type::IfcRepresentation; }
Type::Enum IfcRepresentation::type() const { return Type::IfcRepresentation; }
Type::Enum IfcRepresentation::Class() { return Type::IfcRepresentation; }
IfcRepresentation::IfcRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentation::IfcRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcRepresentationContext
bool IfcRepresentationContext::hasContextIdentifier() const { return !entity->getArgument(0)->isNull(); }
std::string IfcRepresentationContext::ContextIdentifier() const { return *entity->getArgument(0); }
void IfcRepresentationContext::setContextIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcRepresentationContext::hasContextType() const { return !entity->getArgument(1)->isNull(); }
std::string IfcRepresentationContext::ContextType() const { return *entity->getArgument(1); }
void IfcRepresentationContext::setContextType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcRepresentation::list::ptr IfcRepresentationContext::RepresentationsInContext() const { return entity->getInverse(Type::IfcRepresentation, 0)->as<IfcRepresentation>(); }
bool IfcRepresentationContext::is(Type::Enum v) const { return v == Type::IfcRepresentationContext; }
Type::Enum IfcRepresentationContext::type() const { return Type::IfcRepresentationContext; }
Type::Enum IfcRepresentationContext::Class() { return Type::IfcRepresentationContext; }
IfcRepresentationContext::IfcRepresentationContext(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRepresentationContext) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationContext::IfcRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcRepresentationItem
IfcPresentationLayerAssignment::list::ptr IfcRepresentationItem::LayerAssignments() const { return entity->getInverse(Type::IfcPresentationLayerAssignment, 2)->as<IfcPresentationLayerAssignment>(); }
IfcStyledItem::list::ptr IfcRepresentationItem::StyledByItem() const { return entity->getInverse(Type::IfcStyledItem, 0)->as<IfcStyledItem>(); }
bool IfcRepresentationItem::is(Type::Enum v) const { return v == Type::IfcRepresentationItem; }
Type::Enum IfcRepresentationItem::type() const { return Type::IfcRepresentationItem; }
Type::Enum IfcRepresentationItem::Class() { return Type::IfcRepresentationItem; }
IfcRepresentationItem::IfcRepresentationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRepresentationItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationItem::IfcRepresentationItem() : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcRepresentationMap
IfcAxis2Placement* IfcRepresentationMap::MappingOrigin() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcRepresentationMap::setMappingOrigin(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcRepresentation* IfcRepresentationMap::MappedRepresentation() const { return (IfcRepresentation*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcRepresentationMap::setMappedRepresentation(IfcRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcMappedItem::list::ptr IfcRepresentationMap::MapUsage() const { return entity->getInverse(Type::IfcMappedItem, 0)->as<IfcMappedItem>(); }
bool IfcRepresentationMap::is(Type::Enum v) const { return v == Type::IfcRepresentationMap; }
Type::Enum IfcRepresentationMap::type() const { return Type::IfcRepresentationMap; }
Type::Enum IfcRepresentationMap::Class() { return Type::IfcRepresentationMap; }
IfcRepresentationMap::IfcRepresentationMap(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRepresentationMap) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationMap::IfcRepresentationMap(IfcAxis2Placement* v1_MappingOrigin, IfcRepresentation* v2_MappedRepresentation) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingOrigin));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappedRepresentation));entity->setArgument(1,attr);} }

// Function implementations for IfcResource
IfcRelAssignsToResource::list::ptr IfcResource::ResourceOf() const { return entity->getInverse(Type::IfcRelAssignsToResource, 6)->as<IfcRelAssignsToResource>(); }
bool IfcResource::is(Type::Enum v) const { return v == Type::IfcResource || IfcObject::is(v); }
Type::Enum IfcResource::type() const { return Type::IfcResource; }
Type::Enum IfcResource::Class() { return Type::IfcResource; }
IfcResource::IfcResource(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResource::IfcResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcRevolvedAreaSolid
IfcAxis1Placement* IfcRevolvedAreaSolid::Axis() const { return (IfcAxis1Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcRevolvedAreaSolid::setAxis(IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcRevolvedAreaSolid::Angle() const { return *entity->getArgument(3); }
void IfcRevolvedAreaSolid::setAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcRevolvedAreaSolid::is(Type::Enum v) const { return v == Type::IfcRevolvedAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcRevolvedAreaSolid::type() const { return Type::IfcRevolvedAreaSolid; }
Type::Enum IfcRevolvedAreaSolid::Class() { return Type::IfcRevolvedAreaSolid; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRevolvedAreaSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Axis));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Angle));entity->setArgument(3,attr);} }

// Function implementations for IfcRibPlateProfileProperties
bool IfcRibPlateProfileProperties::hasThickness() const { return !entity->getArgument(2)->isNull(); }
double IfcRibPlateProfileProperties::Thickness() const { return *entity->getArgument(2); }
void IfcRibPlateProfileProperties::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcRibPlateProfileProperties::hasRibHeight() const { return !entity->getArgument(3)->isNull(); }
double IfcRibPlateProfileProperties::RibHeight() const { return *entity->getArgument(3); }
void IfcRibPlateProfileProperties::setRibHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcRibPlateProfileProperties::hasRibWidth() const { return !entity->getArgument(4)->isNull(); }
double IfcRibPlateProfileProperties::RibWidth() const { return *entity->getArgument(4); }
void IfcRibPlateProfileProperties::setRibWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcRibPlateProfileProperties::hasRibSpacing() const { return !entity->getArgument(5)->isNull(); }
double IfcRibPlateProfileProperties::RibSpacing() const { return *entity->getArgument(5); }
void IfcRibPlateProfileProperties::setRibSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum IfcRibPlateProfileProperties::Direction() const { return IfcRibPlateDirectionEnum::FromString(*entity->getArgument(6)); }
void IfcRibPlateProfileProperties::setDirection(IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRibPlateDirectionEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcRibPlateProfileProperties::is(Type::Enum v) const { return v == Type::IfcRibPlateProfileProperties || IfcProfileProperties::is(v); }
Type::Enum IfcRibPlateProfileProperties::type() const { return Type::IfcRibPlateProfileProperties; }
Type::Enum IfcRibPlateProfileProperties::Class() { return Type::IfcRibPlateProfileProperties; }
IfcRibPlateProfileProperties::IfcRibPlateProfileProperties(IfcEntityInstanceData* e) : IfcProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRibPlateProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRibPlateProfileProperties::IfcRibPlateProfileProperties(boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_Thickness, boost::optional< double > v4_RibHeight, boost::optional< double > v5_RibWidth, boost::optional< double > v6_RibSpacing, IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum v7_Direction) : IfcProfileProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));entity->setArgument(1,attr);} if (v3_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Thickness));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_RibHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_RibHeight));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RibWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RibWidth));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RibSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RibSpacing));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_Direction,IfcRibPlateDirectionEnum::ToString(v7_Direction))));entity->setArgument(6,attr);} }

// Function implementations for IfcRightCircularCone
double IfcRightCircularCone::Height() const { return *entity->getArgument(1); }
void IfcRightCircularCone::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcRightCircularCone::BottomRadius() const { return *entity->getArgument(2); }
void IfcRightCircularCone::setBottomRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcRightCircularCone::is(Type::Enum v) const { return v == Type::IfcRightCircularCone || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRightCircularCone::type() const { return Type::IfcRightCircularCone; }
Type::Enum IfcRightCircularCone::Class() { return Type::IfcRightCircularCone; }
IfcRightCircularCone::IfcRightCircularCone(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRightCircularCone) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRightCircularCone::IfcRightCircularCone(IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_BottomRadius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_BottomRadius));entity->setArgument(2,attr);} }

// Function implementations for IfcRightCircularCylinder
double IfcRightCircularCylinder::Height() const { return *entity->getArgument(1); }
void IfcRightCircularCylinder::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
double IfcRightCircularCylinder::Radius() const { return *entity->getArgument(2); }
void IfcRightCircularCylinder::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcRightCircularCylinder::is(Type::Enum v) const { return v == Type::IfcRightCircularCylinder || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRightCircularCylinder::type() const { return Type::IfcRightCircularCylinder; }
Type::Enum IfcRightCircularCylinder::Class() { return Type::IfcRightCircularCylinder; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRightCircularCylinder) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Radius));entity->setArgument(2,attr);} }

// Function implementations for IfcRoof
IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoof::ShapeType() const { return IfcRoofTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRoof::setShapeType(IfcRoofTypeEnum::IfcRoofTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcRoofTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcRoof::is(Type::Enum v) const { return v == Type::IfcRoof || IfcBuildingElement::is(v); }
Type::Enum IfcRoof::type() const { return Type::IfcRoof; }
Type::Enum IfcRoof::Class() { return Type::IfcRoof; }
IfcRoof::IfcRoof(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRoof) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoof::IfcRoof(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcRoofTypeEnum::IfcRoofTypeEnum v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,IfcRoofTypeEnum::ToString(v9_ShapeType))));entity->setArgument(8,attr);} }

// Function implementations for IfcRoot
std::string IfcRoot::GlobalId() const { return *entity->getArgument(0); }
void IfcRoot::setGlobalId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcOwnerHistory* IfcRoot::OwnerHistory() const { return (IfcOwnerHistory*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcRoot::setOwnerHistory(IfcOwnerHistory* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcRoot::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcRoot::Name() const { return *entity->getArgument(2); }
void IfcRoot::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcRoot::hasDescription() const { return !entity->getArgument(3)->isNull(); }
std::string IfcRoot::Description() const { return *entity->getArgument(3); }
void IfcRoot::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcRoot::is(Type::Enum v) const { return v == Type::IfcRoot; }
Type::Enum IfcRoot::type() const { return Type::IfcRoot; }
Type::Enum IfcRoot::Class() { return Type::IfcRoot; }
IfcRoot::IfcRoot(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcRoot) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoot::IfcRoot(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcRoundedEdgeFeature
bool IfcRoundedEdgeFeature::hasRadius() const { return !entity->getArgument(9)->isNull(); }
double IfcRoundedEdgeFeature::Radius() const { return *entity->getArgument(9); }
void IfcRoundedEdgeFeature::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcRoundedEdgeFeature::is(Type::Enum v) const { return v == Type::IfcRoundedEdgeFeature || IfcEdgeFeature::is(v); }
Type::Enum IfcRoundedEdgeFeature::type() const { return Type::IfcRoundedEdgeFeature; }
Type::Enum IfcRoundedEdgeFeature::Class() { return Type::IfcRoundedEdgeFeature; }
IfcRoundedEdgeFeature::IfcRoundedEdgeFeature(IfcEntityInstanceData* e) : IfcEdgeFeature((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRoundedEdgeFeature) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoundedEdgeFeature::IfcRoundedEdgeFeature(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Radius) : IfcEdgeFeature((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Radius));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcRoundedRectangleProfileDef
double IfcRoundedRectangleProfileDef::RoundingRadius() const { return *entity->getArgument(5); }
void IfcRoundedRectangleProfileDef::setRoundingRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcRoundedRectangleProfileDef::is(Type::Enum v) const { return v == Type::IfcRoundedRectangleProfileDef || IfcRectangleProfileDef::is(v); }
Type::Enum IfcRoundedRectangleProfileDef::type() const { return Type::IfcRoundedRectangleProfileDef; }
Type::Enum IfcRoundedRectangleProfileDef::Class() { return Type::IfcRoundedRectangleProfileDef; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcRoundedRectangleProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_RoundingRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RoundingRadius));entity->setArgument(5,attr);} }

// Function implementations for IfcSIUnit
bool IfcSIUnit::hasPrefix() const { return !entity->getArgument(2)->isNull(); }
IfcSIPrefix::IfcSIPrefix IfcSIUnit::Prefix() const { return IfcSIPrefix::FromString(*entity->getArgument(2)); }
void IfcSIUnit::setPrefix(IfcSIPrefix::IfcSIPrefix v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSIPrefix::ToString(v)));entity->setArgument(2,attr);} }
IfcSIUnitName::IfcSIUnitName IfcSIUnit::Name() const { return IfcSIUnitName::FromString(*entity->getArgument(3)); }
void IfcSIUnit::setName(IfcSIUnitName::IfcSIUnitName v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSIUnitName::ToString(v)));entity->setArgument(3,attr);} }
bool IfcSIUnit::is(Type::Enum v) const { return v == Type::IfcSIUnit || IfcNamedUnit::is(v); }
Type::Enum IfcSIUnit::type() const { return Type::IfcSIUnit; }
Type::Enum IfcSIUnit::Class() { return Type::IfcSIUnit; }
IfcSIUnit::IfcSIUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSIUnit) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSIUnit::IfcSIUnit(IfcUnitEnum::IfcUnitEnum v2_UnitType, boost::optional< IfcSIPrefix::IfcSIPrefix > v3_Prefix, IfcSIUnitName::IfcSIUnitName v4_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,IfcUnitEnum::ToString(v2_UnitType))));entity->setArgument(1,attr);} if (v3_Prefix) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_Prefix,IfcSIPrefix::ToString(*v3_Prefix))));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_Name,IfcSIUnitName::ToString(v4_Name))));entity->setArgument(3,attr);} }

// Function implementations for IfcSanitaryTerminalType
IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalType::PredefinedType() const { return IfcSanitaryTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSanitaryTerminalType::setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSanitaryTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSanitaryTerminalType::is(Type::Enum v) const { return v == Type::IfcSanitaryTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcSanitaryTerminalType::type() const { return Type::IfcSanitaryTerminalType; }
Type::Enum IfcSanitaryTerminalType::Class() { return Type::IfcSanitaryTerminalType; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSanitaryTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSanitaryTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcScheduleTimeControl
bool IfcScheduleTimeControl::hasActualStart() const { return !entity->getArgument(5)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::ActualStart() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcScheduleTimeControl::setActualStart(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcScheduleTimeControl::hasEarlyStart() const { return !entity->getArgument(6)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::EarlyStart() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcScheduleTimeControl::setEarlyStart(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcScheduleTimeControl::hasLateStart() const { return !entity->getArgument(7)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::LateStart() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcScheduleTimeControl::setLateStart(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcScheduleTimeControl::hasScheduleStart() const { return !entity->getArgument(8)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::ScheduleStart() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcScheduleTimeControl::setScheduleStart(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcScheduleTimeControl::hasActualFinish() const { return !entity->getArgument(9)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::ActualFinish() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcScheduleTimeControl::setActualFinish(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcScheduleTimeControl::hasEarlyFinish() const { return !entity->getArgument(10)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::EarlyFinish() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcScheduleTimeControl::setEarlyFinish(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcScheduleTimeControl::hasLateFinish() const { return !entity->getArgument(11)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::LateFinish() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcScheduleTimeControl::setLateFinish(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcScheduleTimeControl::hasScheduleFinish() const { return !entity->getArgument(12)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::ScheduleFinish() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcScheduleTimeControl::setScheduleFinish(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcScheduleTimeControl::hasScheduleDuration() const { return !entity->getArgument(13)->isNull(); }
double IfcScheduleTimeControl::ScheduleDuration() const { return *entity->getArgument(13); }
void IfcScheduleTimeControl::setScheduleDuration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcScheduleTimeControl::hasActualDuration() const { return !entity->getArgument(14)->isNull(); }
double IfcScheduleTimeControl::ActualDuration() const { return *entity->getArgument(14); }
void IfcScheduleTimeControl::setActualDuration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcScheduleTimeControl::hasRemainingTime() const { return !entity->getArgument(15)->isNull(); }
double IfcScheduleTimeControl::RemainingTime() const { return *entity->getArgument(15); }
void IfcScheduleTimeControl::setRemainingTime(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(15,attr);} }
bool IfcScheduleTimeControl::hasFreeFloat() const { return !entity->getArgument(16)->isNull(); }
double IfcScheduleTimeControl::FreeFloat() const { return *entity->getArgument(16); }
void IfcScheduleTimeControl::setFreeFloat(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(16,attr);} }
bool IfcScheduleTimeControl::hasTotalFloat() const { return !entity->getArgument(17)->isNull(); }
double IfcScheduleTimeControl::TotalFloat() const { return *entity->getArgument(17); }
void IfcScheduleTimeControl::setTotalFloat(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(17,attr);} }
bool IfcScheduleTimeControl::hasIsCritical() const { return !entity->getArgument(18)->isNull(); }
bool IfcScheduleTimeControl::IsCritical() const { return *entity->getArgument(18); }
void IfcScheduleTimeControl::setIsCritical(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(18,attr);} }
bool IfcScheduleTimeControl::hasStatusTime() const { return !entity->getArgument(19)->isNull(); }
IfcDateTimeSelect* IfcScheduleTimeControl::StatusTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(19))); }
void IfcScheduleTimeControl::setStatusTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(19,attr);} }
bool IfcScheduleTimeControl::hasStartFloat() const { return !entity->getArgument(20)->isNull(); }
double IfcScheduleTimeControl::StartFloat() const { return *entity->getArgument(20); }
void IfcScheduleTimeControl::setStartFloat(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(20,attr);} }
bool IfcScheduleTimeControl::hasFinishFloat() const { return !entity->getArgument(21)->isNull(); }
double IfcScheduleTimeControl::FinishFloat() const { return *entity->getArgument(21); }
void IfcScheduleTimeControl::setFinishFloat(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(21,attr);} }
bool IfcScheduleTimeControl::hasCompletion() const { return !entity->getArgument(22)->isNull(); }
double IfcScheduleTimeControl::Completion() const { return *entity->getArgument(22); }
void IfcScheduleTimeControl::setCompletion(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(22,attr);} }
IfcRelAssignsTasks::list::ptr IfcScheduleTimeControl::ScheduleTimeControlAssigned() const { return entity->getInverse(Type::IfcRelAssignsTasks, 7)->as<IfcRelAssignsTasks>(); }
bool IfcScheduleTimeControl::is(Type::Enum v) const { return v == Type::IfcScheduleTimeControl || IfcControl::is(v); }
Type::Enum IfcScheduleTimeControl::type() const { return Type::IfcScheduleTimeControl; }
Type::Enum IfcScheduleTimeControl::Class() { return Type::IfcScheduleTimeControl; }
IfcScheduleTimeControl::IfcScheduleTimeControl(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcScheduleTimeControl) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcScheduleTimeControl::IfcScheduleTimeControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcDateTimeSelect* v6_ActualStart, IfcDateTimeSelect* v7_EarlyStart, IfcDateTimeSelect* v8_LateStart, IfcDateTimeSelect* v9_ScheduleStart, IfcDateTimeSelect* v10_ActualFinish, IfcDateTimeSelect* v11_EarlyFinish, IfcDateTimeSelect* v12_LateFinish, IfcDateTimeSelect* v13_ScheduleFinish, boost::optional< double > v14_ScheduleDuration, boost::optional< double > v15_ActualDuration, boost::optional< double > v16_RemainingTime, boost::optional< double > v17_FreeFloat, boost::optional< double > v18_TotalFloat, boost::optional< bool > v19_IsCritical, IfcDateTimeSelect* v20_StatusTime, boost::optional< double > v21_StartFloat, boost::optional< double > v22_FinishFloat, boost::optional< double > v23_Completion) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ActualStart));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_EarlyStart));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LateStart));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ScheduleStart));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ActualFinish));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_EarlyFinish));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LateFinish));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ScheduleFinish));entity->setArgument(12,attr);} if (v14_ScheduleDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ScheduleDuration));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_ActualDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ActualDuration));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } if (v16_RemainingTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_RemainingTime));entity->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(15, attr); } if (v17_FreeFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_FreeFloat));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } if (v18_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_TotalFloat));entity->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(17, attr); } if (v19_IsCritical) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_IsCritical));entity->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(18, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v20_StatusTime));entity->setArgument(19,attr);} if (v21_StartFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_StartFloat));entity->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(20, attr); } if (v22_FinishFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_FinishFloat));entity->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(21, attr); } if (v23_Completion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_Completion));entity->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(22, attr); } }

// Function implementations for IfcSectionProperties
IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionProperties::SectionType() const { return IfcSectionTypeEnum::FromString(*entity->getArgument(0)); }
void IfcSectionProperties::setSectionType(IfcSectionTypeEnum::IfcSectionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSectionTypeEnum::ToString(v)));entity->setArgument(0,attr);} }
IfcProfileDef* IfcSectionProperties::StartProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcSectionProperties::setStartProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSectionProperties::hasEndProfile() const { return !entity->getArgument(2)->isNull(); }
IfcProfileDef* IfcSectionProperties::EndProfile() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSectionProperties::setEndProfile(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSectionProperties::is(Type::Enum v) const { return v == Type::IfcSectionProperties; }
Type::Enum IfcSectionProperties::type() const { return Type::IfcSectionProperties; }
Type::Enum IfcSectionProperties::Class() { return Type::IfcSectionProperties; }
IfcSectionProperties::IfcSectionProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSectionProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionProperties::IfcSectionProperties(IfcSectionTypeEnum::IfcSectionTypeEnum v1_SectionType, IfcProfileDef* v2_StartProfile, IfcProfileDef* v3_EndProfile) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_SectionType,IfcSectionTypeEnum::ToString(v1_SectionType))));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartProfile));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EndProfile));entity->setArgument(2,attr);} }

// Function implementations for IfcSectionReinforcementProperties
double IfcSectionReinforcementProperties::LongitudinalStartPosition() const { return *entity->getArgument(0); }
void IfcSectionReinforcementProperties::setLongitudinalStartPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcSectionReinforcementProperties::LongitudinalEndPosition() const { return *entity->getArgument(1); }
void IfcSectionReinforcementProperties::setLongitudinalEndPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSectionReinforcementProperties::hasTransversePosition() const { return !entity->getArgument(2)->isNull(); }
double IfcSectionReinforcementProperties::TransversePosition() const { return *entity->getArgument(2); }
void IfcSectionReinforcementProperties::setTransversePosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcSectionReinforcementProperties::ReinforcementRole() const { return IfcReinforcingBarRoleEnum::FromString(*entity->getArgument(3)); }
void IfcSectionReinforcementProperties::setReinforcementRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReinforcingBarRoleEnum::ToString(v)));entity->setArgument(3,attr);} }
IfcSectionProperties* IfcSectionReinforcementProperties::SectionDefinition() const { return (IfcSectionProperties*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcSectionReinforcementProperties::setSectionDefinition(IfcSectionProperties* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr IfcSectionReinforcementProperties::CrossSectionReinforcementDefinitions() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcReinforcementBarProperties>(); }
void IfcSectionReinforcementProperties::setCrossSectionReinforcementDefinitions(IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
bool IfcSectionReinforcementProperties::is(Type::Enum v) const { return v == Type::IfcSectionReinforcementProperties; }
Type::Enum IfcSectionReinforcementProperties::type() const { return Type::IfcSectionReinforcementProperties; }
Type::Enum IfcSectionReinforcementProperties::Class() { return Type::IfcSectionReinforcementProperties; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSectionReinforcementProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(double v1_LongitudinalStartPosition, double v2_LongitudinalEndPosition, boost::optional< double > v3_TransversePosition, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v4_ReinforcementRole, IfcSectionProperties* v5_SectionDefinition, IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v6_CrossSectionReinforcementDefinitions) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LongitudinalStartPosition));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LongitudinalEndPosition));entity->setArgument(1,attr);} if (v3_TransversePosition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TransversePosition));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_ReinforcementRole,IfcReinforcingBarRoleEnum::ToString(v4_ReinforcementRole))));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SectionDefinition));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CrossSectionReinforcementDefinitions)->generalize());entity->setArgument(5,attr);} }

// Function implementations for IfcSectionedSpine
IfcCompositeCurve* IfcSectionedSpine::SpineCurve() const { return (IfcCompositeCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSectionedSpine::setSpineCurve(IfcCompositeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcProfileDef >::ptr IfcSectionedSpine::CrossSections() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcProfileDef>(); }
void IfcSectionedSpine::setCrossSections(IfcTemplatedEntityList< IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr IfcSectionedSpine::CrossSectionPositions() const { IfcEntityList::ptr es = *entity->getArgument(2); return es->as<IfcAxis2Placement3D>(); }
void IfcSectionedSpine::setCrossSectionPositions(IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(2,attr);} }
bool IfcSectionedSpine::is(Type::Enum v) const { return v == Type::IfcSectionedSpine || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSectionedSpine::type() const { return Type::IfcSectionedSpine; }
Type::Enum IfcSectionedSpine::Class() { return Type::IfcSectionedSpine; }
IfcSectionedSpine::IfcSectionedSpine(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSectionedSpine) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionedSpine::IfcSectionedSpine(IfcCompositeCurve* v1_SpineCurve, IfcTemplatedEntityList< IfcProfileDef >::ptr v2_CrossSections, IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v3_CrossSectionPositions) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SpineCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CrossSections)->generalize());entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CrossSectionPositions)->generalize());entity->setArgument(2,attr);} }

// Function implementations for IfcSensorType
IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorType::PredefinedType() const { return IfcSensorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSensorType::setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSensorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSensorType::is(Type::Enum v) const { return v == Type::IfcSensorType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcSensorType::type() const { return Type::IfcSensorType; }
Type::Enum IfcSensorType::Class() { return Type::IfcSensorType; }
IfcSensorType::IfcSensorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSensorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSensorType::IfcSensorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSensorTypeEnum::IfcSensorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSensorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcServiceLife
IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum IfcServiceLife::ServiceLifeType() const { return IfcServiceLifeTypeEnum::FromString(*entity->getArgument(5)); }
void IfcServiceLife::setServiceLifeType(IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcServiceLifeTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
double IfcServiceLife::ServiceLifeDuration() const { return *entity->getArgument(6); }
void IfcServiceLife::setServiceLifeDuration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcServiceLife::is(Type::Enum v) const { return v == Type::IfcServiceLife || IfcControl::is(v); }
Type::Enum IfcServiceLife::type() const { return Type::IfcServiceLife; }
Type::Enum IfcServiceLife::Class() { return Type::IfcServiceLife; }
IfcServiceLife::IfcServiceLife(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcServiceLife) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcServiceLife::IfcServiceLife(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum v6_ServiceLifeType, double v7_ServiceLifeDuration) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_ServiceLifeType,IfcServiceLifeTypeEnum::ToString(v6_ServiceLifeType))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ServiceLifeDuration));entity->setArgument(6,attr);} }

// Function implementations for IfcServiceLifeFactor
IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum IfcServiceLifeFactor::PredefinedType() const { return IfcServiceLifeFactorTypeEnum::FromString(*entity->getArgument(4)); }
void IfcServiceLifeFactor::setPredefinedType(IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcServiceLifeFactorTypeEnum::ToString(v)));entity->setArgument(4,attr);} }
bool IfcServiceLifeFactor::hasUpperValue() const { return !entity->getArgument(5)->isNull(); }
IfcMeasureValue* IfcServiceLifeFactor::UpperValue() const { return (IfcMeasureValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcServiceLifeFactor::setUpperValue(IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcMeasureValue* IfcServiceLifeFactor::MostUsedValue() const { return (IfcMeasureValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcServiceLifeFactor::setMostUsedValue(IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcServiceLifeFactor::hasLowerValue() const { return !entity->getArgument(7)->isNull(); }
IfcMeasureValue* IfcServiceLifeFactor::LowerValue() const { return (IfcMeasureValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcServiceLifeFactor::setLowerValue(IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcServiceLifeFactor::is(Type::Enum v) const { return v == Type::IfcServiceLifeFactor || IfcPropertySetDefinition::is(v); }
Type::Enum IfcServiceLifeFactor::type() const { return Type::IfcServiceLifeFactor; }
Type::Enum IfcServiceLifeFactor::Class() { return Type::IfcServiceLifeFactor; }
IfcServiceLifeFactor::IfcServiceLifeFactor(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcServiceLifeFactor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcServiceLifeFactor::IfcServiceLifeFactor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum v5_PredefinedType, IfcMeasureValue* v6_UpperValue, IfcMeasureValue* v7_MostUsedValue, IfcMeasureValue* v8_LowerValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_PredefinedType,IfcServiceLifeFactorTypeEnum::ToString(v5_PredefinedType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_UpperValue));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_MostUsedValue));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LowerValue));entity->setArgument(7,attr);} }

// Function implementations for IfcShapeAspect
IfcTemplatedEntityList< IfcShapeModel >::ptr IfcShapeAspect::ShapeRepresentations() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcShapeModel>(); }
void IfcShapeAspect::setShapeRepresentations(IfcTemplatedEntityList< IfcShapeModel >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcShapeAspect::hasName() const { return !entity->getArgument(1)->isNull(); }
std::string IfcShapeAspect::Name() const { return *entity->getArgument(1); }
void IfcShapeAspect::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcShapeAspect::hasDescription() const { return !entity->getArgument(2)->isNull(); }
std::string IfcShapeAspect::Description() const { return *entity->getArgument(2); }
void IfcShapeAspect::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcShapeAspect::ProductDefinitional() const { return *entity->getArgument(3); }
void IfcShapeAspect::setProductDefinitional(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
IfcProductDefinitionShape* IfcShapeAspect::PartOfProductDefinitionShape() const { return (IfcProductDefinitionShape*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcShapeAspect::setPartOfProductDefinitionShape(IfcProductDefinitionShape* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcShapeAspect::is(Type::Enum v) const { return v == Type::IfcShapeAspect; }
Type::Enum IfcShapeAspect::type() const { return Type::IfcShapeAspect; }
Type::Enum IfcShapeAspect::Class() { return Type::IfcShapeAspect; }
IfcShapeAspect::IfcShapeAspect(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcShapeAspect) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeAspect::IfcShapeAspect(IfcTemplatedEntityList< IfcShapeModel >::ptr v1_ShapeRepresentations, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, bool v4_ProductDefinitional, IfcProductDefinitionShape* v5_PartOfProductDefinitionShape) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ShapeRepresentations)->generalize());entity->setArgument(0,attr);} if (v2_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Name));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ProductDefinitional));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_PartOfProductDefinitionShape));entity->setArgument(4,attr);} }

// Function implementations for IfcShapeModel
IfcShapeAspect::list::ptr IfcShapeModel::OfShapeAspect() const { return entity->getInverse(Type::IfcShapeAspect, 0)->as<IfcShapeAspect>(); }
bool IfcShapeModel::is(Type::Enum v) const { return v == Type::IfcShapeModel || IfcRepresentation::is(v); }
Type::Enum IfcShapeModel::type() const { return Type::IfcShapeModel; }
Type::Enum IfcShapeModel::Class() { return Type::IfcShapeModel; }
IfcShapeModel::IfcShapeModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcShapeModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeModel::IfcShapeModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcShapeRepresentation
bool IfcShapeRepresentation::is(Type::Enum v) const { return v == Type::IfcShapeRepresentation || IfcShapeModel::is(v); }
Type::Enum IfcShapeRepresentation::type() const { return Type::IfcShapeRepresentation; }
Type::Enum IfcShapeRepresentation::Class() { return Type::IfcShapeRepresentation; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcShapeRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcShellBasedSurfaceModel
IfcEntityList::ptr IfcShellBasedSurfaceModel::SbsmBoundary() const { return *entity->getArgument(0); }
void IfcShellBasedSurfaceModel::setSbsmBoundary(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcShellBasedSurfaceModel::is(Type::Enum v) const { return v == Type::IfcShellBasedSurfaceModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcShellBasedSurfaceModel::type() const { return Type::IfcShellBasedSurfaceModel; }
Type::Enum IfcShellBasedSurfaceModel::Class() { return Type::IfcShellBasedSurfaceModel; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcShellBasedSurfaceModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntityList::ptr v1_SbsmBoundary) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SbsmBoundary));entity->setArgument(0,attr);} }

// Function implementations for IfcSimpleProperty
bool IfcSimpleProperty::is(Type::Enum v) const { return v == Type::IfcSimpleProperty || IfcProperty::is(v); }
Type::Enum IfcSimpleProperty::type() const { return Type::IfcSimpleProperty; }
Type::Enum IfcSimpleProperty::Class() { return Type::IfcSimpleProperty; }
IfcSimpleProperty::IfcSimpleProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSimpleProperty) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSimpleProperty::IfcSimpleProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcProperty((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcSite
bool IfcSite::hasRefLatitude() const { return !entity->getArgument(9)->isNull(); }
std::vector< int > /*[3:4]*/ IfcSite::RefLatitude() const { return *entity->getArgument(9); }
void IfcSite::setRefLatitude(std::vector< int > /*[3:4]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcSite::hasRefLongitude() const { return !entity->getArgument(10)->isNull(); }
std::vector< int > /*[3:4]*/ IfcSite::RefLongitude() const { return *entity->getArgument(10); }
void IfcSite::setRefLongitude(std::vector< int > /*[3:4]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcSite::hasRefElevation() const { return !entity->getArgument(11)->isNull(); }
double IfcSite::RefElevation() const { return *entity->getArgument(11); }
void IfcSite::setRefElevation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcSite::hasLandTitleNumber() const { return !entity->getArgument(12)->isNull(); }
std::string IfcSite::LandTitleNumber() const { return *entity->getArgument(12); }
void IfcSite::setLandTitleNumber(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcSite::hasSiteAddress() const { return !entity->getArgument(13)->isNull(); }
IfcPostalAddress* IfcSite::SiteAddress() const { return (IfcPostalAddress*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(13))); }
void IfcSite::setSiteAddress(IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcSite::is(Type::Enum v) const { return v == Type::IfcSite || IfcSpatialStructureElement::is(v); }
Type::Enum IfcSite::type() const { return Type::IfcSite; }
Type::Enum IfcSite::Class() { return Type::IfcSite; }
IfcSite::IfcSite(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSite) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSite::IfcSite(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< std::vector< int > /*[3:4]*/ > v10_RefLatitude, boost::optional< std::vector< int > /*[3:4]*/ > v11_RefLongitude, boost::optional< double > v12_RefElevation, boost::optional< std::string > v13_LandTitleNumber, IfcPostalAddress* v14_SiteAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,IfcElementCompositionEnum::ToString(v9_CompositionType))));entity->setArgument(8,attr);} if (v10_RefLatitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_RefLatitude));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_RefLongitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RefLongitude));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_RefElevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_RefElevation));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_LandTitleNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_LandTitleNumber));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SiteAddress));entity->setArgument(13,attr);} }

// Function implementations for IfcSlab
bool IfcSlab::hasPredefinedType() const { return !entity->getArgument(8)->isNull(); }
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlab::PredefinedType() const { return IfcSlabTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSlab::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSlabTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcSlab::is(Type::Enum v) const { return v == Type::IfcSlab || IfcBuildingElement::is(v); }
Type::Enum IfcSlab::type() const { return Type::IfcSlab; }
Type::Enum IfcSlab::Class() { return Type::IfcSlab; }
IfcSlab::IfcSlab(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSlab) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlab::IfcSlab(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcSlabType
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabType::PredefinedType() const { return IfcSlabTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSlabType::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSlabTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSlabType::is(Type::Enum v) const { return v == Type::IfcSlabType || IfcBuildingElementType::is(v); }
Type::Enum IfcSlabType::type() const { return Type::IfcSlabType; }
Type::Enum IfcSlabType::Class() { return Type::IfcSlabType; }
IfcSlabType::IfcSlabType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSlabType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlabType::IfcSlabType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSlabTypeEnum::IfcSlabTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSlabTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcSlippageConnectionCondition
bool IfcSlippageConnectionCondition::hasSlippageX() const { return !entity->getArgument(1)->isNull(); }
double IfcSlippageConnectionCondition::SlippageX() const { return *entity->getArgument(1); }
void IfcSlippageConnectionCondition::setSlippageX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSlippageConnectionCondition::hasSlippageY() const { return !entity->getArgument(2)->isNull(); }
double IfcSlippageConnectionCondition::SlippageY() const { return *entity->getArgument(2); }
void IfcSlippageConnectionCondition::setSlippageY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSlippageConnectionCondition::hasSlippageZ() const { return !entity->getArgument(3)->isNull(); }
double IfcSlippageConnectionCondition::SlippageZ() const { return *entity->getArgument(3); }
void IfcSlippageConnectionCondition::setSlippageZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcSlippageConnectionCondition::is(Type::Enum v) const { return v == Type::IfcSlippageConnectionCondition || IfcStructuralConnectionCondition::is(v); }
Type::Enum IfcSlippageConnectionCondition::type() const { return Type::IfcSlippageConnectionCondition; }
Type::Enum IfcSlippageConnectionCondition::Class() { return Type::IfcSlippageConnectionCondition; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSlippageConnectionCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_SlippageX, boost::optional< double > v3_SlippageY, boost::optional< double > v4_SlippageZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_SlippageX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SlippageX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_SlippageY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SlippageY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_SlippageZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_SlippageZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcSolidModel
bool IfcSolidModel::is(Type::Enum v) const { return v == Type::IfcSolidModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSolidModel::type() const { return Type::IfcSolidModel; }
Type::Enum IfcSolidModel::Class() { return Type::IfcSolidModel; }
IfcSolidModel::IfcSolidModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSolidModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSolidModel::IfcSolidModel() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcSoundProperties
bool IfcSoundProperties::IsAttenuating() const { return *entity->getArgument(4); }
void IfcSoundProperties::setIsAttenuating(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcSoundProperties::hasSoundScale() const { return !entity->getArgument(5)->isNull(); }
IfcSoundScaleEnum::IfcSoundScaleEnum IfcSoundProperties::SoundScale() const { return IfcSoundScaleEnum::FromString(*entity->getArgument(5)); }
void IfcSoundProperties::setSoundScale(IfcSoundScaleEnum::IfcSoundScaleEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSoundScaleEnum::ToString(v)));entity->setArgument(5,attr);} }
IfcTemplatedEntityList< IfcSoundValue >::ptr IfcSoundProperties::SoundValues() const { IfcEntityList::ptr es = *entity->getArgument(6); return es->as<IfcSoundValue>(); }
void IfcSoundProperties::setSoundValues(IfcTemplatedEntityList< IfcSoundValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(6,attr);} }
bool IfcSoundProperties::is(Type::Enum v) const { return v == Type::IfcSoundProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcSoundProperties::type() const { return Type::IfcSoundProperties; }
Type::Enum IfcSoundProperties::Class() { return Type::IfcSoundProperties; }
IfcSoundProperties::IfcSoundProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSoundProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSoundProperties::IfcSoundProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, bool v5_IsAttenuating, boost::optional< IfcSoundScaleEnum::IfcSoundScaleEnum > v6_SoundScale, IfcTemplatedEntityList< IfcSoundValue >::ptr v7_SoundValues) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_IsAttenuating));entity->setArgument(4,attr);} if (v6_SoundScale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_SoundScale,IfcSoundScaleEnum::ToString(*v6_SoundScale))));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SoundValues)->generalize());entity->setArgument(6,attr);} }

// Function implementations for IfcSoundValue
bool IfcSoundValue::hasSoundLevelTimeSeries() const { return !entity->getArgument(4)->isNull(); }
IfcTimeSeries* IfcSoundValue::SoundLevelTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcSoundValue::setSoundLevelTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcSoundValue::Frequency() const { return *entity->getArgument(5); }
void IfcSoundValue::setFrequency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcSoundValue::hasSoundLevelSingleValue() const { return !entity->getArgument(6)->isNull(); }
IfcDerivedMeasureValue* IfcSoundValue::SoundLevelSingleValue() const { return (IfcDerivedMeasureValue*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcSoundValue::setSoundLevelSingleValue(IfcDerivedMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcSoundValue::is(Type::Enum v) const { return v == Type::IfcSoundValue || IfcPropertySetDefinition::is(v); }
Type::Enum IfcSoundValue::type() const { return Type::IfcSoundValue; }
Type::Enum IfcSoundValue::Class() { return Type::IfcSoundValue; }
IfcSoundValue::IfcSoundValue(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSoundValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSoundValue::IfcSoundValue(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTimeSeries* v5_SoundLevelTimeSeries, double v6_Frequency, IfcDerivedMeasureValue* v7_SoundLevelSingleValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SoundLevelTimeSeries));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Frequency));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SoundLevelSingleValue));entity->setArgument(6,attr);} }

// Function implementations for IfcSpace
IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcSpace::InteriorOrExteriorSpace() const { return IfcInternalOrExternalEnum::FromString(*entity->getArgument(9)); }
void IfcSpace::setInteriorOrExteriorSpace(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcInternalOrExternalEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSpace::hasElevationWithFlooring() const { return !entity->getArgument(10)->isNull(); }
double IfcSpace::ElevationWithFlooring() const { return *entity->getArgument(10); }
void IfcSpace::setElevationWithFlooring(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
IfcRelCoversSpaces::list::ptr IfcSpace::HasCoverings() const { return entity->getInverse(Type::IfcRelCoversSpaces, 4)->as<IfcRelCoversSpaces>(); }
IfcRelSpaceBoundary::list::ptr IfcSpace::BoundedBy() const { return entity->getInverse(Type::IfcRelSpaceBoundary, 4)->as<IfcRelSpaceBoundary>(); }
bool IfcSpace::is(Type::Enum v) const { return v == Type::IfcSpace || IfcSpatialStructureElement::is(v); }
Type::Enum IfcSpace::type() const { return Type::IfcSpace; }
Type::Enum IfcSpace::Class() { return Type::IfcSpace; }
IfcSpace::IfcSpace(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpace) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpace::IfcSpace(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v10_InteriorOrExteriorSpace, boost::optional< double > v11_ElevationWithFlooring) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,IfcElementCompositionEnum::ToString(v9_CompositionType))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_InteriorOrExteriorSpace,IfcInternalOrExternalEnum::ToString(v10_InteriorOrExteriorSpace))));entity->setArgument(9,attr);} if (v11_ElevationWithFlooring) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationWithFlooring));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcSpaceHeaterType
IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterType::PredefinedType() const { return IfcSpaceHeaterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpaceHeaterType::setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceHeaterTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSpaceHeaterType::is(Type::Enum v) const { return v == Type::IfcSpaceHeaterType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcSpaceHeaterType::type() const { return Type::IfcSpaceHeaterType; }
Type::Enum IfcSpaceHeaterType::Class() { return Type::IfcSpaceHeaterType; }
IfcSpaceHeaterType::IfcSpaceHeaterType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpaceHeaterType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceHeaterType::IfcSpaceHeaterType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSpaceHeaterTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcSpaceProgram
std::string IfcSpaceProgram::SpaceProgramIdentifier() const { return *entity->getArgument(5); }
void IfcSpaceProgram::setSpaceProgramIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcSpaceProgram::hasMaxRequiredArea() const { return !entity->getArgument(6)->isNull(); }
double IfcSpaceProgram::MaxRequiredArea() const { return *entity->getArgument(6); }
void IfcSpaceProgram::setMaxRequiredArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcSpaceProgram::hasMinRequiredArea() const { return !entity->getArgument(7)->isNull(); }
double IfcSpaceProgram::MinRequiredArea() const { return *entity->getArgument(7); }
void IfcSpaceProgram::setMinRequiredArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcSpaceProgram::hasRequestedLocation() const { return !entity->getArgument(8)->isNull(); }
IfcSpatialStructureElement* IfcSpaceProgram::RequestedLocation() const { return (IfcSpatialStructureElement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcSpaceProgram::setRequestedLocation(IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
double IfcSpaceProgram::StandardRequiredArea() const { return *entity->getArgument(9); }
void IfcSpaceProgram::setStandardRequiredArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
IfcRelInteractionRequirements::list::ptr IfcSpaceProgram::HasInteractionReqsFrom() const { return entity->getInverse(Type::IfcRelInteractionRequirements, 7)->as<IfcRelInteractionRequirements>(); }
IfcRelInteractionRequirements::list::ptr IfcSpaceProgram::HasInteractionReqsTo() const { return entity->getInverse(Type::IfcRelInteractionRequirements, 8)->as<IfcRelInteractionRequirements>(); }
bool IfcSpaceProgram::is(Type::Enum v) const { return v == Type::IfcSpaceProgram || IfcControl::is(v); }
Type::Enum IfcSpaceProgram::type() const { return Type::IfcSpaceProgram; }
Type::Enum IfcSpaceProgram::Class() { return Type::IfcSpaceProgram; }
IfcSpaceProgram::IfcSpaceProgram(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpaceProgram) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceProgram::IfcSpaceProgram(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_SpaceProgramIdentifier, boost::optional< double > v7_MaxRequiredArea, boost::optional< double > v8_MinRequiredArea, IfcSpatialStructureElement* v9_RequestedLocation, double v10_StandardRequiredArea) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_SpaceProgramIdentifier));entity->setArgument(5,attr);} if (v7_MaxRequiredArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MaxRequiredArea));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_MinRequiredArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MinRequiredArea));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RequestedLocation));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_StandardRequiredArea));entity->setArgument(9,attr);} }

// Function implementations for IfcSpaceThermalLoadProperties
bool IfcSpaceThermalLoadProperties::hasApplicableValueRatio() const { return !entity->getArgument(4)->isNull(); }
double IfcSpaceThermalLoadProperties::ApplicableValueRatio() const { return *entity->getArgument(4); }
void IfcSpaceThermalLoadProperties::setApplicableValueRatio(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum IfcSpaceThermalLoadProperties::ThermalLoadSource() const { return IfcThermalLoadSourceEnum::FromString(*entity->getArgument(5)); }
void IfcSpaceThermalLoadProperties::setThermalLoadSource(IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcThermalLoadSourceEnum::ToString(v)));entity->setArgument(5,attr);} }
IfcPropertySourceEnum::IfcPropertySourceEnum IfcSpaceThermalLoadProperties::PropertySource() const { return IfcPropertySourceEnum::FromString(*entity->getArgument(6)); }
void IfcSpaceThermalLoadProperties::setPropertySource(IfcPropertySourceEnum::IfcPropertySourceEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcPropertySourceEnum::ToString(v)));entity->setArgument(6,attr);} }
bool IfcSpaceThermalLoadProperties::hasSourceDescription() const { return !entity->getArgument(7)->isNull(); }
std::string IfcSpaceThermalLoadProperties::SourceDescription() const { return *entity->getArgument(7); }
void IfcSpaceThermalLoadProperties::setSourceDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
double IfcSpaceThermalLoadProperties::MaximumValue() const { return *entity->getArgument(8); }
void IfcSpaceThermalLoadProperties::setMaximumValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcSpaceThermalLoadProperties::hasMinimumValue() const { return !entity->getArgument(9)->isNull(); }
double IfcSpaceThermalLoadProperties::MinimumValue() const { return *entity->getArgument(9); }
void IfcSpaceThermalLoadProperties::setMinimumValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcSpaceThermalLoadProperties::hasThermalLoadTimeSeriesValues() const { return !entity->getArgument(10)->isNull(); }
IfcTimeSeries* IfcSpaceThermalLoadProperties::ThermalLoadTimeSeriesValues() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcSpaceThermalLoadProperties::setThermalLoadTimeSeriesValues(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcSpaceThermalLoadProperties::hasUserDefinedThermalLoadSource() const { return !entity->getArgument(11)->isNull(); }
std::string IfcSpaceThermalLoadProperties::UserDefinedThermalLoadSource() const { return *entity->getArgument(11); }
void IfcSpaceThermalLoadProperties::setUserDefinedThermalLoadSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcSpaceThermalLoadProperties::hasUserDefinedPropertySource() const { return !entity->getArgument(12)->isNull(); }
std::string IfcSpaceThermalLoadProperties::UserDefinedPropertySource() const { return *entity->getArgument(12); }
void IfcSpaceThermalLoadProperties::setUserDefinedPropertySource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum IfcSpaceThermalLoadProperties::ThermalLoadType() const { return IfcThermalLoadTypeEnum::FromString(*entity->getArgument(13)); }
void IfcSpaceThermalLoadProperties::setThermalLoadType(IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcThermalLoadTypeEnum::ToString(v)));entity->setArgument(13,attr);} }
bool IfcSpaceThermalLoadProperties::is(Type::Enum v) const { return v == Type::IfcSpaceThermalLoadProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcSpaceThermalLoadProperties::type() const { return Type::IfcSpaceThermalLoadProperties; }
Type::Enum IfcSpaceThermalLoadProperties::Class() { return Type::IfcSpaceThermalLoadProperties; }
IfcSpaceThermalLoadProperties::IfcSpaceThermalLoadProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpaceThermalLoadProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceThermalLoadProperties::IfcSpaceThermalLoadProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_ApplicableValueRatio, IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum v6_ThermalLoadSource, IfcPropertySourceEnum::IfcPropertySourceEnum v7_PropertySource, boost::optional< std::string > v8_SourceDescription, double v9_MaximumValue, boost::optional< double > v10_MinimumValue, IfcTimeSeries* v11_ThermalLoadTimeSeriesValues, boost::optional< std::string > v12_UserDefinedThermalLoadSource, boost::optional< std::string > v13_UserDefinedPropertySource, IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum v14_ThermalLoadType) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableValueRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableValueRatio));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_ThermalLoadSource,IfcThermalLoadSourceEnum::ToString(v6_ThermalLoadSource))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PropertySource,IfcPropertySourceEnum::ToString(v7_PropertySource))));entity->setArgument(6,attr);} if (v8_SourceDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_SourceDescription));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_MaximumValue));entity->setArgument(8,attr);} if (v10_MinimumValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MinimumValue));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ThermalLoadTimeSeriesValues));entity->setArgument(10,attr);} if (v12_UserDefinedThermalLoadSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_UserDefinedThermalLoadSource));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_UserDefinedPropertySource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedPropertySource));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v14_ThermalLoadType,IfcThermalLoadTypeEnum::ToString(v14_ThermalLoadType))));entity->setArgument(13,attr);} }

// Function implementations for IfcSpaceType
IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceType::PredefinedType() const { return IfcSpaceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpaceType::setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSpaceTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSpaceType::is(Type::Enum v) const { return v == Type::IfcSpaceType || IfcSpatialStructureElementType::is(v); }
Type::Enum IfcSpaceType::type() const { return Type::IfcSpaceType; }
Type::Enum IfcSpaceType::Class() { return Type::IfcSpaceType; }
IfcSpaceType::IfcSpaceType(IfcEntityInstanceData* e) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpaceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceType::IfcSpaceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceTypeEnum::IfcSpaceTypeEnum v10_PredefinedType) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSpaceTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcSpatialStructureElement
bool IfcSpatialStructureElement::hasLongName() const { return !entity->getArgument(7)->isNull(); }
std::string IfcSpatialStructureElement::LongName() const { return *entity->getArgument(7); }
void IfcSpatialStructureElement::setLongName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcElementCompositionEnum::IfcElementCompositionEnum IfcSpatialStructureElement::CompositionType() const { return IfcElementCompositionEnum::FromString(*entity->getArgument(8)); }
void IfcSpatialStructureElement::setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcElementCompositionEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcRelReferencedInSpatialStructure::list::ptr IfcSpatialStructureElement::ReferencesElements() const { return entity->getInverse(Type::IfcRelReferencedInSpatialStructure, 5)->as<IfcRelReferencedInSpatialStructure>(); }
IfcRelServicesBuildings::list::ptr IfcSpatialStructureElement::ServicedBySystems() const { return entity->getInverse(Type::IfcRelServicesBuildings, 5)->as<IfcRelServicesBuildings>(); }
IfcRelContainedInSpatialStructure::list::ptr IfcSpatialStructureElement::ContainsElements() const { return entity->getInverse(Type::IfcRelContainedInSpatialStructure, 5)->as<IfcRelContainedInSpatialStructure>(); }
bool IfcSpatialStructureElement::is(Type::Enum v) const { return v == Type::IfcSpatialStructureElement || IfcProduct::is(v); }
Type::Enum IfcSpatialStructureElement::type() const { return Type::IfcSpatialStructureElement; }
Type::Enum IfcSpatialStructureElement::Class() { return Type::IfcSpatialStructureElement; }
IfcSpatialStructureElement::IfcSpatialStructureElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpatialStructureElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialStructureElement::IfcSpatialStructureElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,IfcElementCompositionEnum::ToString(v9_CompositionType))));entity->setArgument(8,attr);} }

// Function implementations for IfcSpatialStructureElementType
bool IfcSpatialStructureElementType::is(Type::Enum v) const { return v == Type::IfcSpatialStructureElementType || IfcElementType::is(v); }
Type::Enum IfcSpatialStructureElementType::type() const { return Type::IfcSpatialStructureElementType; }
Type::Enum IfcSpatialStructureElementType::Class() { return Type::IfcSpatialStructureElementType; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSpatialStructureElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcSphere
double IfcSphere::Radius() const { return *entity->getArgument(1); }
void IfcSphere::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSphere::is(Type::Enum v) const { return v == Type::IfcSphere || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcSphere::type() const { return Type::IfcSphere; }
Type::Enum IfcSphere::Class() { return Type::IfcSphere; }
IfcSphere::IfcSphere(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSphere) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSphere::IfcSphere(IfcAxis2Placement3D* v1_Position, double v2_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));entity->setArgument(1,attr);} }

// Function implementations for IfcStackTerminalType
IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalType::PredefinedType() const { return IfcStackTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStackTerminalType::setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStackTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcStackTerminalType::is(Type::Enum v) const { return v == Type::IfcStackTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcStackTerminalType::type() const { return Type::IfcStackTerminalType; }
Type::Enum IfcStackTerminalType::Class() { return Type::IfcStackTerminalType; }
IfcStackTerminalType::IfcStackTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStackTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStackTerminalType::IfcStackTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStackTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcStair
IfcStairTypeEnum::IfcStairTypeEnum IfcStair::ShapeType() const { return IfcStairTypeEnum::FromString(*entity->getArgument(8)); }
void IfcStair::setShapeType(IfcStairTypeEnum::IfcStairTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcStair::is(Type::Enum v) const { return v == Type::IfcStair || IfcBuildingElement::is(v); }
Type::Enum IfcStair::type() const { return Type::IfcStair; }
Type::Enum IfcStair::Class() { return Type::IfcStair; }
IfcStair::IfcStair(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStair) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStair::IfcStair(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcStairTypeEnum::IfcStairTypeEnum v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,IfcStairTypeEnum::ToString(v9_ShapeType))));entity->setArgument(8,attr);} }

// Function implementations for IfcStairFlight
bool IfcStairFlight::hasNumberOfRiser() const { return !entity->getArgument(8)->isNull(); }
int IfcStairFlight::NumberOfRiser() const { return *entity->getArgument(8); }
void IfcStairFlight::setNumberOfRiser(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcStairFlight::hasNumberOfTreads() const { return !entity->getArgument(9)->isNull(); }
int IfcStairFlight::NumberOfTreads() const { return *entity->getArgument(9); }
void IfcStairFlight::setNumberOfTreads(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcStairFlight::hasRiserHeight() const { return !entity->getArgument(10)->isNull(); }
double IfcStairFlight::RiserHeight() const { return *entity->getArgument(10); }
void IfcStairFlight::setRiserHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcStairFlight::hasTreadLength() const { return !entity->getArgument(11)->isNull(); }
double IfcStairFlight::TreadLength() const { return *entity->getArgument(11); }
void IfcStairFlight::setTreadLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcStairFlight::is(Type::Enum v) const { return v == Type::IfcStairFlight || IfcBuildingElement::is(v); }
Type::Enum IfcStairFlight::type() const { return Type::IfcStairFlight; }
Type::Enum IfcStairFlight::Class() { return Type::IfcStairFlight; }
IfcStairFlight::IfcStairFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStairFlight) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStairFlight::IfcStairFlight(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< int > v9_NumberOfRiser, boost::optional< int > v10_NumberOfTreads, boost::optional< double > v11_RiserHeight, boost::optional< double > v12_TreadLength) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_NumberOfRiser) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NumberOfRiser));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_NumberOfTreads) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NumberOfTreads));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_RiserHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RiserHeight));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_TreadLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_TreadLength));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } }

// Function implementations for IfcStairFlightType
IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightType::PredefinedType() const { return IfcStairFlightTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStairFlightType::setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStairFlightTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcStairFlightType::is(Type::Enum v) const { return v == Type::IfcStairFlightType || IfcBuildingElementType::is(v); }
Type::Enum IfcStairFlightType::type() const { return Type::IfcStairFlightType; }
Type::Enum IfcStairFlightType::Class() { return Type::IfcStairFlightType; }
IfcStairFlightType::IfcStairFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStairFlightType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStairFlightType::IfcStairFlightType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcStairFlightTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcStructuralAction
bool IfcStructuralAction::DestabilizingLoad() const { return *entity->getArgument(9); }
void IfcStructuralAction::setDestabilizingLoad(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcStructuralAction::hasCausedBy() const { return !entity->getArgument(10)->isNull(); }
IfcStructuralReaction* IfcStructuralAction::CausedBy() const { return (IfcStructuralReaction*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcStructuralAction::setCausedBy(IfcStructuralReaction* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcStructuralAction::is(Type::Enum v) const { return v == Type::IfcStructuralAction || IfcStructuralActivity::is(v); }
Type::Enum IfcStructuralAction::type() const { return Type::IfcStructuralAction; }
Type::Enum IfcStructuralAction::Class() { return Type::IfcStructuralAction; }
IfcStructuralAction::IfcStructuralAction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralAction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralAction::IfcStructuralAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy) : IfcStructuralActivity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);} }

// Function implementations for IfcStructuralActivity
IfcStructuralLoad* IfcStructuralActivity::AppliedLoad() const { return (IfcStructuralLoad*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcStructuralActivity::setAppliedLoad(IfcStructuralLoad* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcStructuralActivity::GlobalOrLocal() const { return IfcGlobalOrLocalEnum::FromString(*entity->getArgument(8)); }
void IfcStructuralActivity::setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcGlobalOrLocalEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcRelConnectsStructuralActivity::list::ptr IfcStructuralActivity::AssignedToStructuralItem() const { return entity->getInverse(Type::IfcRelConnectsStructuralActivity, 5)->as<IfcRelConnectsStructuralActivity>(); }
bool IfcStructuralActivity::is(Type::Enum v) const { return v == Type::IfcStructuralActivity || IfcProduct::is(v); }
Type::Enum IfcStructuralActivity::type() const { return Type::IfcStructuralActivity; }
Type::Enum IfcStructuralActivity::Class() { return Type::IfcStructuralActivity; }
IfcStructuralActivity::IfcStructuralActivity(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralActivity) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralActivity::IfcStructuralActivity(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);} }

// Function implementations for IfcStructuralAnalysisModel
IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcStructuralAnalysisModel::PredefinedType() const { return IfcAnalysisModelTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralAnalysisModel::setPredefinedType(IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAnalysisModelTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcStructuralAnalysisModel::hasOrientationOf2DPlane() const { return !entity->getArgument(6)->isNull(); }
IfcAxis2Placement3D* IfcStructuralAnalysisModel::OrientationOf2DPlane() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcStructuralAnalysisModel::setOrientationOf2DPlane(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcStructuralAnalysisModel::hasLoadedBy() const { return !entity->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr IfcStructuralAnalysisModel::LoadedBy() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcStructuralLoadGroup>(); }
void IfcStructuralAnalysisModel::setLoadedBy(IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
bool IfcStructuralAnalysisModel::hasHasResults() const { return !entity->getArgument(8)->isNull(); }
IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr IfcStructuralAnalysisModel::HasResults() const { IfcEntityList::ptr es = *entity->getArgument(8); return es->as<IfcStructuralResultGroup>(); }
void IfcStructuralAnalysisModel::setHasResults(IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(8,attr);} }
bool IfcStructuralAnalysisModel::is(Type::Enum v) const { return v == Type::IfcStructuralAnalysisModel || IfcSystem::is(v); }
Type::Enum IfcStructuralAnalysisModel::type() const { return Type::IfcStructuralAnalysisModel; }
Type::Enum IfcStructuralAnalysisModel::Class() { return Type::IfcStructuralAnalysisModel; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralAnalysisModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v6_PredefinedType, IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr > v8_LoadedBy, boost::optional< IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr > v9_HasResults) : IfcSystem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,IfcAnalysisModelTypeEnum::ToString(v6_PredefinedType))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OrientationOf2DPlane));entity->setArgument(6,attr);} if (v8_LoadedBy) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LoadedBy)->generalize());entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_HasResults) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_HasResults)->generalize());entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcStructuralConnection
bool IfcStructuralConnection::hasAppliedCondition() const { return !entity->getArgument(7)->isNull(); }
IfcBoundaryCondition* IfcStructuralConnection::AppliedCondition() const { return (IfcBoundaryCondition*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcStructuralConnection::setAppliedCondition(IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcRelConnectsStructuralMember::list::ptr IfcStructuralConnection::ConnectsStructuralMembers() const { return entity->getInverse(Type::IfcRelConnectsStructuralMember, 5)->as<IfcRelConnectsStructuralMember>(); }
bool IfcStructuralConnection::is(Type::Enum v) const { return v == Type::IfcStructuralConnection || IfcStructuralItem::is(v); }
Type::Enum IfcStructuralConnection::type() const { return Type::IfcStructuralConnection; }
Type::Enum IfcStructuralConnection::Class() { return Type::IfcStructuralConnection; }
IfcStructuralConnection::IfcStructuralConnection(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralConnection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralConnection::IfcStructuralConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralConnectionCondition
bool IfcStructuralConnectionCondition::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcStructuralConnectionCondition::Name() const { return *entity->getArgument(0); }
void IfcStructuralConnectionCondition::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcStructuralConnectionCondition::is(Type::Enum v) const { return v == Type::IfcStructuralConnectionCondition; }
Type::Enum IfcStructuralConnectionCondition::type() const { return Type::IfcStructuralConnectionCondition; }
Type::Enum IfcStructuralConnectionCondition::Class() { return Type::IfcStructuralConnectionCondition; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcStructuralConnectionCondition) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcStructuralCurveConnection
bool IfcStructuralCurveConnection::is(Type::Enum v) const { return v == Type::IfcStructuralCurveConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralCurveConnection::type() const { return Type::IfcStructuralCurveConnection; }
Type::Enum IfcStructuralCurveConnection::Class() { return Type::IfcStructuralCurveConnection; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralCurveConnection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralCurveMember
IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum IfcStructuralCurveMember::PredefinedType() const { return IfcStructuralCurveTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralCurveMember::setPredefinedType(IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralCurveTypeEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcStructuralCurveMember::is(Type::Enum v) const { return v == Type::IfcStructuralCurveMember || IfcStructuralMember::is(v); }
Type::Enum IfcStructuralCurveMember::type() const { return Type::IfcStructuralCurveMember; }
Type::Enum IfcStructuralCurveMember::Class() { return Type::IfcStructuralCurveMember; }
IfcStructuralCurveMember::IfcStructuralCurveMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralCurveMember) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveMember::IfcStructuralCurveMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v8_PredefinedType) : IfcStructuralMember((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralCurveTypeEnum::ToString(v8_PredefinedType))));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralCurveMemberVarying
bool IfcStructuralCurveMemberVarying::is(Type::Enum v) const { return v == Type::IfcStructuralCurveMemberVarying || IfcStructuralCurveMember::is(v); }
Type::Enum IfcStructuralCurveMemberVarying::type() const { return Type::IfcStructuralCurveMemberVarying; }
Type::Enum IfcStructuralCurveMemberVarying::Class() { return Type::IfcStructuralCurveMemberVarying; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(IfcEntityInstanceData* e) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralCurveMemberVarying) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v8_PredefinedType) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralCurveTypeEnum::ToString(v8_PredefinedType))));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralItem
IfcRelConnectsStructuralActivity::list::ptr IfcStructuralItem::AssignedStructuralActivity() const { return entity->getInverse(Type::IfcRelConnectsStructuralActivity, 4)->as<IfcRelConnectsStructuralActivity>(); }
bool IfcStructuralItem::is(Type::Enum v) const { return v == Type::IfcStructuralItem || IfcProduct::is(v); }
Type::Enum IfcStructuralItem::type() const { return Type::IfcStructuralItem; }
Type::Enum IfcStructuralItem::Class() { return Type::IfcStructuralItem; }
IfcStructuralItem::IfcStructuralItem(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralItem::IfcStructuralItem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} }

// Function implementations for IfcStructuralLinearAction
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralLinearAction::ProjectedOrTrue() const { return IfcProjectedOrTrueLengthEnum::FromString(*entity->getArgument(11)); }
void IfcStructuralLinearAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectedOrTrueLengthEnum::ToString(v)));entity->setArgument(11,attr);} }
bool IfcStructuralLinearAction::is(Type::Enum v) const { return v == Type::IfcStructuralLinearAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralLinearAction::type() const { return Type::IfcStructuralLinearAction; }
Type::Enum IfcStructuralLinearAction::Class() { return Type::IfcStructuralLinearAction; }
IfcStructuralLinearAction::IfcStructuralLinearAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLinearAction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLinearAction::IfcStructuralLinearAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue) : IfcStructuralAction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));entity->setArgument(11,attr);} }

// Function implementations for IfcStructuralLinearActionVarying
IfcShapeAspect* IfcStructuralLinearActionVarying::VaryingAppliedLoadLocation() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcStructuralLinearActionVarying::setVaryingAppliedLoadLocation(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
IfcTemplatedEntityList< IfcStructuralLoad >::ptr IfcStructuralLinearActionVarying::SubsequentAppliedLoads() const { IfcEntityList::ptr es = *entity->getArgument(13); return es->as<IfcStructuralLoad>(); }
void IfcStructuralLinearActionVarying::setSubsequentAppliedLoads(IfcTemplatedEntityList< IfcStructuralLoad >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(13,attr);} }
bool IfcStructuralLinearActionVarying::is(Type::Enum v) const { return v == Type::IfcStructuralLinearActionVarying || IfcStructuralLinearAction::is(v); }
Type::Enum IfcStructuralLinearActionVarying::type() const { return Type::IfcStructuralLinearActionVarying; }
Type::Enum IfcStructuralLinearActionVarying::Class() { return Type::IfcStructuralLinearActionVarying; }
IfcStructuralLinearActionVarying::IfcStructuralLinearActionVarying(IfcEntityInstanceData* e) : IfcStructuralLinearAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLinearActionVarying) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLinearActionVarying::IfcStructuralLinearActionVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue, IfcShapeAspect* v13_VaryingAppliedLoadLocation, IfcTemplatedEntityList< IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads) : IfcStructuralLinearAction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_VaryingAppliedLoadLocation));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SubsequentAppliedLoads)->generalize());entity->setArgument(13,attr);} }

// Function implementations for IfcStructuralLoad
bool IfcStructuralLoad::hasName() const { return !entity->getArgument(0)->isNull(); }
std::string IfcStructuralLoad::Name() const { return *entity->getArgument(0); }
void IfcStructuralLoad::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcStructuralLoad::is(Type::Enum v) const { return v == Type::IfcStructuralLoad; }
Type::Enum IfcStructuralLoad::type() const { return Type::IfcStructuralLoad; }
Type::Enum IfcStructuralLoad::Class() { return Type::IfcStructuralLoad; }
IfcStructuralLoad::IfcStructuralLoad(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcStructuralLoad) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoad::IfcStructuralLoad(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadGroup
IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcStructuralLoadGroup::PredefinedType() const { return IfcLoadGroupTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralLoadGroup::setPredefinedType(IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcLoadGroupTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
IfcActionTypeEnum::IfcActionTypeEnum IfcStructuralLoadGroup::ActionType() const { return IfcActionTypeEnum::FromString(*entity->getArgument(6)); }
void IfcStructuralLoadGroup::setActionType(IfcActionTypeEnum::IfcActionTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActionTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcStructuralLoadGroup::ActionSource() const { return IfcActionSourceTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralLoadGroup::setActionSource(IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcActionSourceTypeEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcStructuralLoadGroup::hasCoefficient() const { return !entity->getArgument(8)->isNull(); }
double IfcStructuralLoadGroup::Coefficient() const { return *entity->getArgument(8); }
void IfcStructuralLoadGroup::setCoefficient(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcStructuralLoadGroup::hasPurpose() const { return !entity->getArgument(9)->isNull(); }
std::string IfcStructuralLoadGroup::Purpose() const { return *entity->getArgument(9); }
void IfcStructuralLoadGroup::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
IfcStructuralResultGroup::list::ptr IfcStructuralLoadGroup::SourceOfResultGroup() const { return entity->getInverse(Type::IfcStructuralResultGroup, 6)->as<IfcStructuralResultGroup>(); }
IfcStructuralAnalysisModel::list::ptr IfcStructuralLoadGroup::LoadGroupFor() const { return entity->getInverse(Type::IfcStructuralAnalysisModel, 7)->as<IfcStructuralAnalysisModel>(); }
bool IfcStructuralLoadGroup::is(Type::Enum v) const { return v == Type::IfcStructuralLoadGroup || IfcGroup::is(v); }
Type::Enum IfcStructuralLoadGroup::type() const { return Type::IfcStructuralLoadGroup; }
Type::Enum IfcStructuralLoadGroup::Class() { return Type::IfcStructuralLoadGroup; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadGroup) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,IfcLoadGroupTypeEnum::ToString(v6_PredefinedType))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ActionType,IfcActionTypeEnum::ToString(v7_ActionType))));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ActionSource,IfcActionSourceTypeEnum::ToString(v8_ActionSource))));entity->setArgument(7,attr);} if (v9_Coefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Coefficient));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Purpose));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcStructuralLoadLinearForce
bool IfcStructuralLoadLinearForce::hasLinearForceX() const { return !entity->getArgument(1)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceX() const { return *entity->getArgument(1); }
void IfcStructuralLoadLinearForce::setLinearForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearForceY() const { return !entity->getArgument(2)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceY() const { return *entity->getArgument(2); }
void IfcStructuralLoadLinearForce::setLinearForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearForceZ() const { return !entity->getArgument(3)->isNull(); }
double IfcStructuralLoadLinearForce::LinearForceZ() const { return *entity->getArgument(3); }
void IfcStructuralLoadLinearForce::setLinearForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentX() const { return !entity->getArgument(4)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentX() const { return *entity->getArgument(4); }
void IfcStructuralLoadLinearForce::setLinearMomentX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentY() const { return !entity->getArgument(5)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentY() const { return *entity->getArgument(5); }
void IfcStructuralLoadLinearForce::setLinearMomentY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcStructuralLoadLinearForce::hasLinearMomentZ() const { return !entity->getArgument(6)->isNull(); }
double IfcStructuralLoadLinearForce::LinearMomentZ() const { return *entity->getArgument(6); }
void IfcStructuralLoadLinearForce::setLinearMomentZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcStructuralLoadLinearForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadLinearForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadLinearForce::type() const { return Type::IfcStructuralLoadLinearForce; }
Type::Enum IfcStructuralLoadLinearForce::Class() { return Type::IfcStructuralLoadLinearForce; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadLinearForce) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearForceX, boost::optional< double > v3_LinearForceY, boost::optional< double > v4_LinearForceZ, boost::optional< double > v5_LinearMomentX, boost::optional< double > v6_LinearMomentY, boost::optional< double > v7_LinearMomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_LinearForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearForceX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_LinearForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearForceY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_LinearForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearForceZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_LinearMomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LinearMomentX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_LinearMomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LinearMomentY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_LinearMomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LinearMomentZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadPlanarForce
bool IfcStructuralLoadPlanarForce::hasPlanarForceX() const { return !entity->getArgument(1)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceX() const { return *entity->getArgument(1); }
void IfcStructuralLoadPlanarForce::setPlanarForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcStructuralLoadPlanarForce::hasPlanarForceY() const { return !entity->getArgument(2)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceY() const { return *entity->getArgument(2); }
void IfcStructuralLoadPlanarForce::setPlanarForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStructuralLoadPlanarForce::hasPlanarForceZ() const { return !entity->getArgument(3)->isNull(); }
double IfcStructuralLoadPlanarForce::PlanarForceZ() const { return *entity->getArgument(3); }
void IfcStructuralLoadPlanarForce::setPlanarForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcStructuralLoadPlanarForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadPlanarForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadPlanarForce::type() const { return Type::IfcStructuralLoadPlanarForce; }
Type::Enum IfcStructuralLoadPlanarForce::Class() { return Type::IfcStructuralLoadPlanarForce; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadPlanarForce) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_PlanarForceX, boost::optional< double > v3_PlanarForceY, boost::optional< double > v4_PlanarForceZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_PlanarForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_PlanarForceX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_PlanarForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PlanarForceY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_PlanarForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_PlanarForceZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacement
bool IfcStructuralLoadSingleDisplacement::hasDisplacementX() const { return !entity->getArgument(1)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementX() const { return *entity->getArgument(1); }
void IfcStructuralLoadSingleDisplacement::setDisplacementX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementY() const { return !entity->getArgument(2)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementY() const { return *entity->getArgument(2); }
void IfcStructuralLoadSingleDisplacement::setDisplacementY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementZ() const { return !entity->getArgument(3)->isNull(); }
double IfcStructuralLoadSingleDisplacement::DisplacementZ() const { return *entity->getArgument(3); }
void IfcStructuralLoadSingleDisplacement::setDisplacementZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRX() const { return !entity->getArgument(4)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRX() const { return *entity->getArgument(4); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRY() const { return !entity->getArgument(5)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRY() const { return *entity->getArgument(5); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRZ() const { return !entity->getArgument(6)->isNull(); }
double IfcStructuralLoadSingleDisplacement::RotationalDisplacementRZ() const { return *entity->getArgument(6); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcStructuralLoadSingleDisplacement::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleDisplacement || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadSingleDisplacement::type() const { return Type::IfcStructuralLoadSingleDisplacement; }
Type::Enum IfcStructuralLoadSingleDisplacement::Class() { return Type::IfcStructuralLoadSingleDisplacement; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadSingleDisplacement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacementDistortion
bool IfcStructuralLoadSingleDisplacementDistortion::hasDistortion() const { return !entity->getArgument(7)->isNull(); }
double IfcStructuralLoadSingleDisplacementDistortion::Distortion() const { return *entity->getArgument(7); }
void IfcStructuralLoadSingleDisplacementDistortion::setDistortion(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcStructuralLoadSingleDisplacementDistortion::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleDisplacementDistortion || IfcStructuralLoadSingleDisplacement::is(v); }
Type::Enum IfcStructuralLoadSingleDisplacementDistortion::type() const { return Type::IfcStructuralLoadSingleDisplacementDistortion; }
Type::Enum IfcStructuralLoadSingleDisplacementDistortion::Class() { return Type::IfcStructuralLoadSingleDisplacementDistortion; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(IfcEntityInstanceData* e) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadSingleDisplacementDistortion) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ, boost::optional< double > v8_Distortion) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Distortion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Distortion));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadSingleForce
bool IfcStructuralLoadSingleForce::hasForceX() const { return !entity->getArgument(1)->isNull(); }
double IfcStructuralLoadSingleForce::ForceX() const { return *entity->getArgument(1); }
void IfcStructuralLoadSingleForce::setForceX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcStructuralLoadSingleForce::hasForceY() const { return !entity->getArgument(2)->isNull(); }
double IfcStructuralLoadSingleForce::ForceY() const { return *entity->getArgument(2); }
void IfcStructuralLoadSingleForce::setForceY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStructuralLoadSingleForce::hasForceZ() const { return !entity->getArgument(3)->isNull(); }
double IfcStructuralLoadSingleForce::ForceZ() const { return *entity->getArgument(3); }
void IfcStructuralLoadSingleForce::setForceZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentX() const { return !entity->getArgument(4)->isNull(); }
double IfcStructuralLoadSingleForce::MomentX() const { return *entity->getArgument(4); }
void IfcStructuralLoadSingleForce::setMomentX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentY() const { return !entity->getArgument(5)->isNull(); }
double IfcStructuralLoadSingleForce::MomentY() const { return *entity->getArgument(5); }
void IfcStructuralLoadSingleForce::setMomentY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcStructuralLoadSingleForce::hasMomentZ() const { return !entity->getArgument(6)->isNull(); }
double IfcStructuralLoadSingleForce::MomentZ() const { return *entity->getArgument(6); }
void IfcStructuralLoadSingleForce::setMomentZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcStructuralLoadSingleForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadSingleForce::type() const { return Type::IfcStructuralLoadSingleForce; }
Type::Enum IfcStructuralLoadSingleForce::Class() { return Type::IfcStructuralLoadSingleForce; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadSingleForce) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleForceWarping
bool IfcStructuralLoadSingleForceWarping::hasWarpingMoment() const { return !entity->getArgument(7)->isNull(); }
double IfcStructuralLoadSingleForceWarping::WarpingMoment() const { return *entity->getArgument(7); }
void IfcStructuralLoadSingleForceWarping::setWarpingMoment(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcStructuralLoadSingleForceWarping::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleForceWarping || IfcStructuralLoadSingleForce::is(v); }
Type::Enum IfcStructuralLoadSingleForceWarping::type() const { return Type::IfcStructuralLoadSingleForceWarping; }
Type::Enum IfcStructuralLoadSingleForceWarping::Class() { return Type::IfcStructuralLoadSingleForceWarping; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(IfcEntityInstanceData* e) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadSingleForceWarping) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ, boost::optional< double > v8_WarpingMoment) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WarpingMoment) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WarpingMoment));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadStatic
bool IfcStructuralLoadStatic::is(Type::Enum v) const { return v == Type::IfcStructuralLoadStatic || IfcStructuralLoad::is(v); }
Type::Enum IfcStructuralLoadStatic::type() const { return Type::IfcStructuralLoadStatic; }
Type::Enum IfcStructuralLoadStatic::Class() { return Type::IfcStructuralLoadStatic; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(IfcEntityInstanceData* e) : IfcStructuralLoad((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadStatic) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(boost::optional< std::string > v1_Name) : IfcStructuralLoad((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadTemperature
bool IfcStructuralLoadTemperature::hasDeltaT_Constant() const { return !entity->getArgument(1)->isNull(); }
double IfcStructuralLoadTemperature::DeltaT_Constant() const { return *entity->getArgument(1); }
void IfcStructuralLoadTemperature::setDeltaT_Constant(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcStructuralLoadTemperature::hasDeltaT_Y() const { return !entity->getArgument(2)->isNull(); }
double IfcStructuralLoadTemperature::DeltaT_Y() const { return *entity->getArgument(2); }
void IfcStructuralLoadTemperature::setDeltaT_Y(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStructuralLoadTemperature::hasDeltaT_Z() const { return !entity->getArgument(3)->isNull(); }
double IfcStructuralLoadTemperature::DeltaT_Z() const { return *entity->getArgument(3); }
void IfcStructuralLoadTemperature::setDeltaT_Z(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcStructuralLoadTemperature::is(Type::Enum v) const { return v == Type::IfcStructuralLoadTemperature || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadTemperature::type() const { return Type::IfcStructuralLoadTemperature; }
Type::Enum IfcStructuralLoadTemperature::Class() { return Type::IfcStructuralLoadTemperature; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralLoadTemperature) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(boost::optional< std::string > v1_Name, boost::optional< double > v2_DeltaT_Constant, boost::optional< double > v3_DeltaT_Y, boost::optional< double > v4_DeltaT_Z) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_DeltaT_Constant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DeltaT_Constant));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_DeltaT_Y) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DeltaT_Y));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_DeltaT_Z) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DeltaT_Z));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } }

// Function implementations for IfcStructuralMember
IfcRelConnectsStructuralElement::list::ptr IfcStructuralMember::ReferencesElement() const { return entity->getInverse(Type::IfcRelConnectsStructuralElement, 5)->as<IfcRelConnectsStructuralElement>(); }
IfcRelConnectsStructuralMember::list::ptr IfcStructuralMember::ConnectedBy() const { return entity->getInverse(Type::IfcRelConnectsStructuralMember, 4)->as<IfcRelConnectsStructuralMember>(); }
bool IfcStructuralMember::is(Type::Enum v) const { return v == Type::IfcStructuralMember || IfcStructuralItem::is(v); }
Type::Enum IfcStructuralMember::type() const { return Type::IfcStructuralMember; }
Type::Enum IfcStructuralMember::Class() { return Type::IfcStructuralMember; }
IfcStructuralMember::IfcStructuralMember(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralMember) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralMember::IfcStructuralMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcStructuralItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} }

// Function implementations for IfcStructuralPlanarAction
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralPlanarAction::ProjectedOrTrue() const { return IfcProjectedOrTrueLengthEnum::FromString(*entity->getArgument(11)); }
void IfcStructuralPlanarAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcProjectedOrTrueLengthEnum::ToString(v)));entity->setArgument(11,attr);} }
bool IfcStructuralPlanarAction::is(Type::Enum v) const { return v == Type::IfcStructuralPlanarAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralPlanarAction::type() const { return Type::IfcStructuralPlanarAction; }
Type::Enum IfcStructuralPlanarAction::Class() { return Type::IfcStructuralPlanarAction; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralPlanarAction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue) : IfcStructuralAction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));entity->setArgument(11,attr);} }

// Function implementations for IfcStructuralPlanarActionVarying
IfcShapeAspect* IfcStructuralPlanarActionVarying::VaryingAppliedLoadLocation() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcStructuralPlanarActionVarying::setVaryingAppliedLoadLocation(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
IfcTemplatedEntityList< IfcStructuralLoad >::ptr IfcStructuralPlanarActionVarying::SubsequentAppliedLoads() const { IfcEntityList::ptr es = *entity->getArgument(13); return es->as<IfcStructuralLoad>(); }
void IfcStructuralPlanarActionVarying::setSubsequentAppliedLoads(IfcTemplatedEntityList< IfcStructuralLoad >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(13,attr);} }
bool IfcStructuralPlanarActionVarying::is(Type::Enum v) const { return v == Type::IfcStructuralPlanarActionVarying || IfcStructuralPlanarAction::is(v); }
Type::Enum IfcStructuralPlanarActionVarying::type() const { return Type::IfcStructuralPlanarActionVarying; }
Type::Enum IfcStructuralPlanarActionVarying::Class() { return Type::IfcStructuralPlanarActionVarying; }
IfcStructuralPlanarActionVarying::IfcStructuralPlanarActionVarying(IfcEntityInstanceData* e) : IfcStructuralPlanarAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralPlanarActionVarying) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPlanarActionVarying::IfcStructuralPlanarActionVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue, IfcShapeAspect* v13_VaryingAppliedLoadLocation, IfcTemplatedEntityList< IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads) : IfcStructuralPlanarAction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_VaryingAppliedLoadLocation));entity->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SubsequentAppliedLoads)->generalize());entity->setArgument(13,attr);} }

// Function implementations for IfcStructuralPointAction
bool IfcStructuralPointAction::is(Type::Enum v) const { return v == Type::IfcStructuralPointAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralPointAction::type() const { return Type::IfcStructuralPointAction; }
Type::Enum IfcStructuralPointAction::Class() { return Type::IfcStructuralPointAction; }
IfcStructuralPointAction::IfcStructuralPointAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralPointAction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointAction::IfcStructuralPointAction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy) : IfcStructuralAction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));entity->setArgument(10,attr);} }

// Function implementations for IfcStructuralPointConnection
bool IfcStructuralPointConnection::is(Type::Enum v) const { return v == Type::IfcStructuralPointConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralPointConnection::type() const { return Type::IfcStructuralPointConnection; }
Type::Enum IfcStructuralPointConnection::Class() { return Type::IfcStructuralPointConnection; }
IfcStructuralPointConnection::IfcStructuralPointConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralPointConnection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointConnection::IfcStructuralPointConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralPointReaction
bool IfcStructuralPointReaction::is(Type::Enum v) const { return v == Type::IfcStructuralPointReaction || IfcStructuralReaction::is(v); }
Type::Enum IfcStructuralPointReaction::type() const { return Type::IfcStructuralPointReaction; }
Type::Enum IfcStructuralPointReaction::Class() { return Type::IfcStructuralPointReaction; }
IfcStructuralPointReaction::IfcStructuralPointReaction(IfcEntityInstanceData* e) : IfcStructuralReaction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralPointReaction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointReaction::IfcStructuralPointReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralReaction((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);} }

// Function implementations for IfcStructuralProfileProperties
bool IfcStructuralProfileProperties::hasTorsionalConstantX() const { return !entity->getArgument(7)->isNull(); }
double IfcStructuralProfileProperties::TorsionalConstantX() const { return *entity->getArgument(7); }
void IfcStructuralProfileProperties::setTorsionalConstantX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcStructuralProfileProperties::hasMomentOfInertiaYZ() const { return !entity->getArgument(8)->isNull(); }
double IfcStructuralProfileProperties::MomentOfInertiaYZ() const { return *entity->getArgument(8); }
void IfcStructuralProfileProperties::setMomentOfInertiaYZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcStructuralProfileProperties::hasMomentOfInertiaY() const { return !entity->getArgument(9)->isNull(); }
double IfcStructuralProfileProperties::MomentOfInertiaY() const { return *entity->getArgument(9); }
void IfcStructuralProfileProperties::setMomentOfInertiaY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcStructuralProfileProperties::hasMomentOfInertiaZ() const { return !entity->getArgument(10)->isNull(); }
double IfcStructuralProfileProperties::MomentOfInertiaZ() const { return *entity->getArgument(10); }
void IfcStructuralProfileProperties::setMomentOfInertiaZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcStructuralProfileProperties::hasWarpingConstant() const { return !entity->getArgument(11)->isNull(); }
double IfcStructuralProfileProperties::WarpingConstant() const { return *entity->getArgument(11); }
void IfcStructuralProfileProperties::setWarpingConstant(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcStructuralProfileProperties::hasShearCentreZ() const { return !entity->getArgument(12)->isNull(); }
double IfcStructuralProfileProperties::ShearCentreZ() const { return *entity->getArgument(12); }
void IfcStructuralProfileProperties::setShearCentreZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcStructuralProfileProperties::hasShearCentreY() const { return !entity->getArgument(13)->isNull(); }
double IfcStructuralProfileProperties::ShearCentreY() const { return *entity->getArgument(13); }
void IfcStructuralProfileProperties::setShearCentreY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcStructuralProfileProperties::hasShearDeformationAreaZ() const { return !entity->getArgument(14)->isNull(); }
double IfcStructuralProfileProperties::ShearDeformationAreaZ() const { return *entity->getArgument(14); }
void IfcStructuralProfileProperties::setShearDeformationAreaZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcStructuralProfileProperties::hasShearDeformationAreaY() const { return !entity->getArgument(15)->isNull(); }
double IfcStructuralProfileProperties::ShearDeformationAreaY() const { return *entity->getArgument(15); }
void IfcStructuralProfileProperties::setShearDeformationAreaY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(15,attr);} }
bool IfcStructuralProfileProperties::hasMaximumSectionModulusY() const { return !entity->getArgument(16)->isNull(); }
double IfcStructuralProfileProperties::MaximumSectionModulusY() const { return *entity->getArgument(16); }
void IfcStructuralProfileProperties::setMaximumSectionModulusY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(16,attr);} }
bool IfcStructuralProfileProperties::hasMinimumSectionModulusY() const { return !entity->getArgument(17)->isNull(); }
double IfcStructuralProfileProperties::MinimumSectionModulusY() const { return *entity->getArgument(17); }
void IfcStructuralProfileProperties::setMinimumSectionModulusY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(17,attr);} }
bool IfcStructuralProfileProperties::hasMaximumSectionModulusZ() const { return !entity->getArgument(18)->isNull(); }
double IfcStructuralProfileProperties::MaximumSectionModulusZ() const { return *entity->getArgument(18); }
void IfcStructuralProfileProperties::setMaximumSectionModulusZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(18,attr);} }
bool IfcStructuralProfileProperties::hasMinimumSectionModulusZ() const { return !entity->getArgument(19)->isNull(); }
double IfcStructuralProfileProperties::MinimumSectionModulusZ() const { return *entity->getArgument(19); }
void IfcStructuralProfileProperties::setMinimumSectionModulusZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(19,attr);} }
bool IfcStructuralProfileProperties::hasTorsionalSectionModulus() const { return !entity->getArgument(20)->isNull(); }
double IfcStructuralProfileProperties::TorsionalSectionModulus() const { return *entity->getArgument(20); }
void IfcStructuralProfileProperties::setTorsionalSectionModulus(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(20,attr);} }
bool IfcStructuralProfileProperties::hasCentreOfGravityInX() const { return !entity->getArgument(21)->isNull(); }
double IfcStructuralProfileProperties::CentreOfGravityInX() const { return *entity->getArgument(21); }
void IfcStructuralProfileProperties::setCentreOfGravityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(21,attr);} }
bool IfcStructuralProfileProperties::hasCentreOfGravityInY() const { return !entity->getArgument(22)->isNull(); }
double IfcStructuralProfileProperties::CentreOfGravityInY() const { return *entity->getArgument(22); }
void IfcStructuralProfileProperties::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(22,attr);} }
bool IfcStructuralProfileProperties::is(Type::Enum v) const { return v == Type::IfcStructuralProfileProperties || IfcGeneralProfileProperties::is(v); }
Type::Enum IfcStructuralProfileProperties::type() const { return Type::IfcStructuralProfileProperties; }
Type::Enum IfcStructuralProfileProperties::Class() { return Type::IfcStructuralProfileProperties; }
IfcStructuralProfileProperties::IfcStructuralProfileProperties(IfcEntityInstanceData* e) : IfcGeneralProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralProfileProperties::IfcStructuralProfileProperties(boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY) : IfcGeneralProfileProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));entity->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_TorsionalConstantX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TorsionalConstantX));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_MomentOfInertiaYZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_MomentOfInertiaYZ));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_MomentOfInertiaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MomentOfInertiaY));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_MomentOfInertiaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MomentOfInertiaZ));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_WarpingConstant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WarpingConstant));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_ShearCentreZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ShearCentreZ));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } if (v14_ShearCentreY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ShearCentreY));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_ShearDeformationAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ShearDeformationAreaZ));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } if (v16_ShearDeformationAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ShearDeformationAreaY));entity->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(15, attr); } if (v17_MaximumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MaximumSectionModulusY));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } if (v18_MinimumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_MinimumSectionModulusY));entity->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(17, attr); } if (v19_MaximumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_MaximumSectionModulusZ));entity->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(18, attr); } if (v20_MinimumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_MinimumSectionModulusZ));entity->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(19, attr); } if (v21_TorsionalSectionModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_TorsionalSectionModulus));entity->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(20, attr); } if (v22_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_CentreOfGravityInX));entity->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(21, attr); } if (v23_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_CentreOfGravityInY));entity->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(22, attr); } }

// Function implementations for IfcStructuralReaction
IfcStructuralAction::list::ptr IfcStructuralReaction::Causes() const { return entity->getInverse(Type::IfcStructuralAction, 10)->as<IfcStructuralAction>(); }
bool IfcStructuralReaction::is(Type::Enum v) const { return v == Type::IfcStructuralReaction || IfcStructuralActivity::is(v); }
Type::Enum IfcStructuralReaction::type() const { return Type::IfcStructuralReaction; }
Type::Enum IfcStructuralReaction::Class() { return Type::IfcStructuralReaction; }
IfcStructuralReaction::IfcStructuralReaction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralReaction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralReaction::IfcStructuralReaction(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralActivity((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));entity->setArgument(8,attr);} }

// Function implementations for IfcStructuralResultGroup
IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcStructuralResultGroup::TheoryType() const { return IfcAnalysisTheoryTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralResultGroup::setTheoryType(IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcAnalysisTheoryTypeEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcStructuralResultGroup::hasResultForLoadGroup() const { return !entity->getArgument(6)->isNull(); }
IfcStructuralLoadGroup* IfcStructuralResultGroup::ResultForLoadGroup() const { return (IfcStructuralLoadGroup*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcStructuralResultGroup::setResultForLoadGroup(IfcStructuralLoadGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcStructuralResultGroup::IsLinear() const { return *entity->getArgument(7); }
void IfcStructuralResultGroup::setIsLinear(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcStructuralAnalysisModel::list::ptr IfcStructuralResultGroup::ResultGroupFor() const { return entity->getInverse(Type::IfcStructuralAnalysisModel, 8)->as<IfcStructuralAnalysisModel>(); }
bool IfcStructuralResultGroup::is(Type::Enum v) const { return v == Type::IfcStructuralResultGroup || IfcGroup::is(v); }
Type::Enum IfcStructuralResultGroup::type() const { return Type::IfcStructuralResultGroup; }
Type::Enum IfcStructuralResultGroup::Class() { return Type::IfcStructuralResultGroup; }
IfcStructuralResultGroup::IfcStructuralResultGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralResultGroup) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralResultGroup::IfcStructuralResultGroup(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v6_TheoryType, IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_TheoryType,IfcAnalysisTheoryTypeEnum::ToString(v6_TheoryType))));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ResultForLoadGroup));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_IsLinear));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralSteelProfileProperties
bool IfcStructuralSteelProfileProperties::hasShearAreaZ() const { return !entity->getArgument(23)->isNull(); }
double IfcStructuralSteelProfileProperties::ShearAreaZ() const { return *entity->getArgument(23); }
void IfcStructuralSteelProfileProperties::setShearAreaZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(23,attr);} }
bool IfcStructuralSteelProfileProperties::hasShearAreaY() const { return !entity->getArgument(24)->isNull(); }
double IfcStructuralSteelProfileProperties::ShearAreaY() const { return *entity->getArgument(24); }
void IfcStructuralSteelProfileProperties::setShearAreaY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(24,attr);} }
bool IfcStructuralSteelProfileProperties::hasPlasticShapeFactorY() const { return !entity->getArgument(25)->isNull(); }
double IfcStructuralSteelProfileProperties::PlasticShapeFactorY() const { return *entity->getArgument(25); }
void IfcStructuralSteelProfileProperties::setPlasticShapeFactorY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(25,attr);} }
bool IfcStructuralSteelProfileProperties::hasPlasticShapeFactorZ() const { return !entity->getArgument(26)->isNull(); }
double IfcStructuralSteelProfileProperties::PlasticShapeFactorZ() const { return *entity->getArgument(26); }
void IfcStructuralSteelProfileProperties::setPlasticShapeFactorZ(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(26,attr);} }
bool IfcStructuralSteelProfileProperties::is(Type::Enum v) const { return v == Type::IfcStructuralSteelProfileProperties || IfcStructuralProfileProperties::is(v); }
Type::Enum IfcStructuralSteelProfileProperties::type() const { return Type::IfcStructuralSteelProfileProperties; }
Type::Enum IfcStructuralSteelProfileProperties::Class() { return Type::IfcStructuralSteelProfileProperties; }
IfcStructuralSteelProfileProperties::IfcStructuralSteelProfileProperties(IfcEntityInstanceData* e) : IfcStructuralProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralSteelProfileProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSteelProfileProperties::IfcStructuralSteelProfileProperties(boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY, boost::optional< double > v24_ShearAreaZ, boost::optional< double > v25_ShearAreaY, boost::optional< double > v26_PlasticShapeFactorY, boost::optional< double > v27_PlasticShapeFactorZ) : IfcStructuralProfileProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));entity->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_TorsionalConstantX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TorsionalConstantX));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_MomentOfInertiaYZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_MomentOfInertiaYZ));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_MomentOfInertiaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MomentOfInertiaY));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_MomentOfInertiaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MomentOfInertiaZ));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_WarpingConstant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WarpingConstant));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_ShearCentreZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ShearCentreZ));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } if (v14_ShearCentreY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ShearCentreY));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_ShearDeformationAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ShearDeformationAreaZ));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } if (v16_ShearDeformationAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ShearDeformationAreaY));entity->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(15, attr); } if (v17_MaximumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MaximumSectionModulusY));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } if (v18_MinimumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_MinimumSectionModulusY));entity->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(17, attr); } if (v19_MaximumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_MaximumSectionModulusZ));entity->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(18, attr); } if (v20_MinimumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_MinimumSectionModulusZ));entity->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(19, attr); } if (v21_TorsionalSectionModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_TorsionalSectionModulus));entity->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(20, attr); } if (v22_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_CentreOfGravityInX));entity->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(21, attr); } if (v23_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_CentreOfGravityInY));entity->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(22, attr); } if (v24_ShearAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v24_ShearAreaZ));entity->setArgument(23,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(23, attr); } if (v25_ShearAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v25_ShearAreaY));entity->setArgument(24,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(24, attr); } if (v26_PlasticShapeFactorY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v26_PlasticShapeFactorY));entity->setArgument(25,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(25, attr); } if (v27_PlasticShapeFactorZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v27_PlasticShapeFactorZ));entity->setArgument(26,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(26, attr); } }

// Function implementations for IfcStructuralSurfaceConnection
bool IfcStructuralSurfaceConnection::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralSurfaceConnection::type() const { return Type::IfcStructuralSurfaceConnection; }
Type::Enum IfcStructuralSurfaceConnection::Class() { return Type::IfcStructuralSurfaceConnection; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralSurfaceConnection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));entity->setArgument(7,attr);} }

// Function implementations for IfcStructuralSurfaceMember
IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum IfcStructuralSurfaceMember::PredefinedType() const { return IfcStructuralSurfaceTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralSurfaceMember::setPredefinedType(IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcStructuralSurfaceTypeEnum::ToString(v)));entity->setArgument(7,attr);} }
bool IfcStructuralSurfaceMember::hasThickness() const { return !entity->getArgument(8)->isNull(); }
double IfcStructuralSurfaceMember::Thickness() const { return *entity->getArgument(8); }
void IfcStructuralSurfaceMember::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcStructuralSurfaceMember::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceMember || IfcStructuralMember::is(v); }
Type::Enum IfcStructuralSurfaceMember::type() const { return Type::IfcStructuralSurfaceMember; }
Type::Enum IfcStructuralSurfaceMember::Class() { return Type::IfcStructuralSurfaceMember; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralSurfaceMember) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness) : IfcStructuralMember((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralSurfaceTypeEnum::ToString(v8_PredefinedType))));entity->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcStructuralSurfaceMemberVarying
std::vector< double > /*[2:?]*/ IfcStructuralSurfaceMemberVarying::SubsequentThickness() const { return *entity->getArgument(9); }
void IfcStructuralSurfaceMemberVarying::setSubsequentThickness(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
IfcShapeAspect* IfcStructuralSurfaceMemberVarying::VaryingThicknessLocation() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(10))); }
void IfcStructuralSurfaceMemberVarying::setVaryingThicknessLocation(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcStructuralSurfaceMemberVarying::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceMemberVarying || IfcStructuralSurfaceMember::is(v); }
Type::Enum IfcStructuralSurfaceMemberVarying::type() const { return Type::IfcStructuralSurfaceMemberVarying; }
Type::Enum IfcStructuralSurfaceMemberVarying::Class() { return Type::IfcStructuralSurfaceMemberVarying; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(IfcEntityInstanceData* e) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuralSurfaceMemberVarying) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness, std::vector< double > /*[2:?]*/ v10_SubsequentThickness, IfcShapeAspect* v11_VaryingThicknessLocation) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,IfcStructuralSurfaceTypeEnum::ToString(v8_PredefinedType))));entity->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SubsequentThickness));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_VaryingThicknessLocation));entity->setArgument(10,attr);} }

// Function implementations for IfcStructuredDimensionCallout
bool IfcStructuredDimensionCallout::is(Type::Enum v) const { return v == Type::IfcStructuredDimensionCallout || IfcDraughtingCallout::is(v); }
Type::Enum IfcStructuredDimensionCallout::type() const { return Type::IfcStructuredDimensionCallout; }
Type::Enum IfcStructuredDimensionCallout::Class() { return Type::IfcStructuredDimensionCallout; }
IfcStructuredDimensionCallout::IfcStructuredDimensionCallout(IfcEntityInstanceData* e) : IfcDraughtingCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStructuredDimensionCallout) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuredDimensionCallout::IfcStructuredDimensionCallout(IfcEntityList::ptr v1_Contents) : IfcDraughtingCallout((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));entity->setArgument(0,attr);} }

// Function implementations for IfcStyleModel
bool IfcStyleModel::is(Type::Enum v) const { return v == Type::IfcStyleModel || IfcRepresentation::is(v); }
Type::Enum IfcStyleModel::type() const { return Type::IfcStyleModel; }
Type::Enum IfcStyleModel::Class() { return Type::IfcStyleModel; }
IfcStyleModel::IfcStyleModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStyleModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyleModel::IfcStyleModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcStyledItem
bool IfcStyledItem::hasItem() const { return !entity->getArgument(0)->isNull(); }
IfcRepresentationItem* IfcStyledItem::Item() const { return (IfcRepresentationItem*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcStyledItem::setItem(IfcRepresentationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr IfcStyledItem::Styles() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcPresentationStyleAssignment>(); }
void IfcStyledItem::setStyles(IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcStyledItem::hasName() const { return !entity->getArgument(2)->isNull(); }
std::string IfcStyledItem::Name() const { return *entity->getArgument(2); }
void IfcStyledItem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcStyledItem::is(Type::Enum v) const { return v == Type::IfcStyledItem || IfcRepresentationItem::is(v); }
Type::Enum IfcStyledItem::type() const { return Type::IfcStyledItem; }
Type::Enum IfcStyledItem::Class() { return Type::IfcStyledItem; }
IfcStyledItem::IfcStyledItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStyledItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyledItem::IfcStyledItem(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } }

// Function implementations for IfcStyledRepresentation
bool IfcStyledRepresentation::is(Type::Enum v) const { return v == Type::IfcStyledRepresentation || IfcStyleModel::is(v); }
Type::Enum IfcStyledRepresentation::type() const { return Type::IfcStyledRepresentation; }
Type::Enum IfcStyledRepresentation::Class() { return Type::IfcStyledRepresentation; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcEntityInstanceData* e) : IfcStyleModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcStyledRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcStyleModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcSubContractResource
bool IfcSubContractResource::hasSubContractor() const { return !entity->getArgument(9)->isNull(); }
IfcActorSelect* IfcSubContractResource::SubContractor() const { return (IfcActorSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(9))); }
void IfcSubContractResource::setSubContractor(IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcSubContractResource::hasJobDescription() const { return !entity->getArgument(10)->isNull(); }
std::string IfcSubContractResource::JobDescription() const { return *entity->getArgument(10); }
void IfcSubContractResource::setJobDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcSubContractResource::is(Type::Enum v) const { return v == Type::IfcSubContractResource || IfcConstructionResource::is(v); }
Type::Enum IfcSubContractResource::type() const { return Type::IfcSubContractResource; }
Type::Enum IfcSubContractResource::Class() { return Type::IfcSubContractResource; }
IfcSubContractResource::IfcSubContractResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSubContractResource) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSubContractResource::IfcSubContractResource(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, IfcActorSelect* v10_SubContractor, boost::optional< std::string > v11_JobDescription) : IfcConstructionResource((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SubContractor));entity->setArgument(9,attr);} if (v11_JobDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_JobDescription));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcSubedge
IfcEdge* IfcSubedge::ParentEdge() const { return (IfcEdge*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSubedge::setParentEdge(IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSubedge::is(Type::Enum v) const { return v == Type::IfcSubedge || IfcEdge::is(v); }
Type::Enum IfcSubedge::type() const { return Type::IfcSubedge; }
Type::Enum IfcSubedge::Class() { return Type::IfcSubedge; }
IfcSubedge::IfcSubedge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSubedge) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSubedge::IfcSubedge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcEdge* v3_ParentEdge) : IfcEdge((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentEdge));entity->setArgument(2,attr);} }

// Function implementations for IfcSurface
bool IfcSurface::is(Type::Enum v) const { return v == Type::IfcSurface || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSurface::type() const { return Type::IfcSurface; }
Type::Enum IfcSurface::Class() { return Type::IfcSurface; }
IfcSurface::IfcSurface(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurface::IfcSurface() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcSurfaceCurveSweptAreaSolid
IfcCurve* IfcSurfaceCurveSweptAreaSolid::Directrix() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSurfaceCurveSweptAreaSolid::setDirectrix(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcSurfaceCurveSweptAreaSolid::StartParam() const { return *entity->getArgument(3); }
void IfcSurfaceCurveSweptAreaSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcSurfaceCurveSweptAreaSolid::EndParam() const { return *entity->getArgument(4); }
void IfcSurfaceCurveSweptAreaSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcSurface* IfcSurfaceCurveSweptAreaSolid::ReferenceSurface() const { return (IfcSurface*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcSurfaceCurveSweptAreaSolid::setReferenceSurface(IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcSurfaceCurveSweptAreaSolid::is(Type::Enum v) const { return v == Type::IfcSurfaceCurveSweptAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcSurfaceCurveSweptAreaSolid::type() const { return Type::IfcSurfaceCurveSweptAreaSolid; }
Type::Enum IfcSurfaceCurveSweptAreaSolid::Class() { return Type::IfcSurfaceCurveSweptAreaSolid; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurfaceCurveSweptAreaSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, double v4_StartParam, double v5_EndParam, IfcSurface* v6_ReferenceSurface) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Directrix));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_StartParam));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndParam));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReferenceSurface));entity->setArgument(5,attr);} }

// Function implementations for IfcSurfaceOfLinearExtrusion
IfcDirection* IfcSurfaceOfLinearExtrusion::ExtrudedDirection() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSurfaceOfLinearExtrusion::setExtrudedDirection(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcSurfaceOfLinearExtrusion::Depth() const { return *entity->getArgument(3); }
void IfcSurfaceOfLinearExtrusion::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcSurfaceOfLinearExtrusion::is(Type::Enum v) const { return v == Type::IfcSurfaceOfLinearExtrusion || IfcSweptSurface::is(v); }
Type::Enum IfcSurfaceOfLinearExtrusion::type() const { return Type::IfcSurfaceOfLinearExtrusion; }
Type::Enum IfcSurfaceOfLinearExtrusion::Class() { return Type::IfcSurfaceOfLinearExtrusion; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurfaceOfLinearExtrusion) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);} }

// Function implementations for IfcSurfaceOfRevolution
IfcAxis1Placement* IfcSurfaceOfRevolution::AxisPosition() const { return (IfcAxis1Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSurfaceOfRevolution::setAxisPosition(IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSurfaceOfRevolution::is(Type::Enum v) const { return v == Type::IfcSurfaceOfRevolution || IfcSweptSurface::is(v); }
Type::Enum IfcSurfaceOfRevolution::type() const { return Type::IfcSurfaceOfRevolution; }
Type::Enum IfcSurfaceOfRevolution::Class() { return Type::IfcSurfaceOfRevolution; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurfaceOfRevolution) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_AxisPosition) : IfcSweptSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AxisPosition));entity->setArgument(2,attr);} }

// Function implementations for IfcSurfaceStyle
IfcSurfaceSide::IfcSurfaceSide IfcSurfaceStyle::Side() const { return IfcSurfaceSide::FromString(*entity->getArgument(1)); }
void IfcSurfaceStyle::setSide(IfcSurfaceSide::IfcSurfaceSide v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSurfaceSide::ToString(v)));entity->setArgument(1,attr);} }
IfcEntityList::ptr IfcSurfaceStyle::Styles() const { return *entity->getArgument(2); }
void IfcSurfaceStyle::setStyles(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSurfaceStyle::is(Type::Enum v) const { return v == Type::IfcSurfaceStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcSurfaceStyle::type() const { return Type::IfcSurfaceStyle; }
Type::Enum IfcSurfaceStyle::Class() { return Type::IfcSurfaceStyle; }
IfcSurfaceStyle::IfcSurfaceStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurfaceStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyle::IfcSurfaceStyle(boost::optional< std::string > v1_Name, IfcSurfaceSide::IfcSurfaceSide v2_Side, IfcEntityList::ptr v3_Styles) : IfcPresentationStyle((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_Side,IfcSurfaceSide::ToString(v2_Side))));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Styles));entity->setArgument(2,attr);} }

// Function implementations for IfcSurfaceStyleLighting
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseTransmissionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSurfaceStyleLighting::setDiffuseTransmissionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseReflectionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcSurfaceStyleLighting::setDiffuseReflectionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::TransmissionColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSurfaceStyleLighting::setTransmissionColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcColourRgb* IfcSurfaceStyleLighting::ReflectanceColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcSurfaceStyleLighting::setReflectanceColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcSurfaceStyleLighting::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleLighting; }
Type::Enum IfcSurfaceStyleLighting::type() const { return Type::IfcSurfaceStyleLighting; }
Type::Enum IfcSurfaceStyleLighting::Class() { return Type::IfcSurfaceStyleLighting; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSurfaceStyleLighting) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcColourRgb* v1_DiffuseTransmissionColour, IfcColourRgb* v2_DiffuseReflectionColour, IfcColourRgb* v3_TransmissionColour, IfcColourRgb* v4_ReflectanceColour) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DiffuseTransmissionColour));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DiffuseReflectionColour));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TransmissionColour));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReflectanceColour));entity->setArgument(3,attr);} }

// Function implementations for IfcSurfaceStyleRefraction
bool IfcSurfaceStyleRefraction::hasRefractionIndex() const { return !entity->getArgument(0)->isNull(); }
double IfcSurfaceStyleRefraction::RefractionIndex() const { return *entity->getArgument(0); }
void IfcSurfaceStyleRefraction::setRefractionIndex(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcSurfaceStyleRefraction::hasDispersionFactor() const { return !entity->getArgument(1)->isNull(); }
double IfcSurfaceStyleRefraction::DispersionFactor() const { return *entity->getArgument(1); }
void IfcSurfaceStyleRefraction::setDispersionFactor(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSurfaceStyleRefraction::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleRefraction; }
Type::Enum IfcSurfaceStyleRefraction::type() const { return Type::IfcSurfaceStyleRefraction; }
Type::Enum IfcSurfaceStyleRefraction::Class() { return Type::IfcSurfaceStyleRefraction; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSurfaceStyleRefraction) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(boost::optional< double > v1_RefractionIndex, boost::optional< double > v2_DispersionFactor) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_RefractionIndex) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_RefractionIndex));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_DispersionFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DispersionFactor));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } }

// Function implementations for IfcSurfaceStyleRendering
bool IfcSurfaceStyleRendering::hasTransparency() const { return !entity->getArgument(1)->isNull(); }
double IfcSurfaceStyleRendering::Transparency() const { return *entity->getArgument(1); }
void IfcSurfaceStyleRendering::setTransparency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSurfaceStyleRendering::hasDiffuseColour() const { return !entity->getArgument(2)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::DiffuseColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcSurfaceStyleRendering::setDiffuseColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcSurfaceStyleRendering::hasTransmissionColour() const { return !entity->getArgument(3)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::TransmissionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcSurfaceStyleRendering::setTransmissionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcSurfaceStyleRendering::hasDiffuseTransmissionColour() const { return !entity->getArgument(4)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::DiffuseTransmissionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcSurfaceStyleRendering::setDiffuseTransmissionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcSurfaceStyleRendering::hasReflectionColour() const { return !entity->getArgument(5)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::ReflectionColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcSurfaceStyleRendering::setReflectionColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcSurfaceStyleRendering::hasSpecularColour() const { return !entity->getArgument(6)->isNull(); }
IfcColourOrFactor* IfcSurfaceStyleRendering::SpecularColour() const { return (IfcColourOrFactor*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcSurfaceStyleRendering::setSpecularColour(IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcSurfaceStyleRendering::hasSpecularHighlight() const { return !entity->getArgument(7)->isNull(); }
IfcSpecularHighlightSelect* IfcSurfaceStyleRendering::SpecularHighlight() const { return (IfcSpecularHighlightSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcSurfaceStyleRendering::setSpecularHighlight(IfcSpecularHighlightSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcSurfaceStyleRendering::ReflectanceMethod() const { return IfcReflectanceMethodEnum::FromString(*entity->getArgument(8)); }
void IfcSurfaceStyleRendering::setReflectanceMethod(IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcReflectanceMethodEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcSurfaceStyleRendering::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleRendering || IfcSurfaceStyleShading::is(v); }
Type::Enum IfcSurfaceStyleRendering::type() const { return Type::IfcSurfaceStyleRendering; }
Type::Enum IfcSurfaceStyleRendering::Class() { return Type::IfcSurfaceStyleRendering; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcEntityInstanceData* e) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSurfaceStyleRendering) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency, IfcColourOrFactor* v3_DiffuseColour, IfcColourOrFactor* v4_TransmissionColour, IfcColourOrFactor* v5_DiffuseTransmissionColour, IfcColourOrFactor* v6_ReflectionColour, IfcColourOrFactor* v7_SpecularColour, IfcSpecularHighlightSelect* v8_SpecularHighlight, IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v9_ReflectanceMethod) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));entity->setArgument(0,attr);} if (v2_Transparency) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Transparency));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DiffuseColour));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TransmissionColour));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_DiffuseTransmissionColour));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReflectionColour));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SpecularColour));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_SpecularHighlight));entity->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ReflectanceMethod,IfcReflectanceMethodEnum::ToString(v9_ReflectanceMethod))));entity->setArgument(8,attr);} }

// Function implementations for IfcSurfaceStyleShading
IfcColourRgb* IfcSurfaceStyleShading::SurfaceColour() const { return (IfcColourRgb*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSurfaceStyleShading::setSurfaceColour(IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcSurfaceStyleShading::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleShading; }
Type::Enum IfcSurfaceStyleShading::type() const { return Type::IfcSurfaceStyleShading; }
Type::Enum IfcSurfaceStyleShading::Class() { return Type::IfcSurfaceStyleShading; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSurfaceStyleShading) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcColourRgb* v1_SurfaceColour) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));entity->setArgument(0,attr);} }

// Function implementations for IfcSurfaceStyleWithTextures
IfcTemplatedEntityList< IfcSurfaceTexture >::ptr IfcSurfaceStyleWithTextures::Textures() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcSurfaceTexture>(); }
void IfcSurfaceStyleWithTextures::setTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcSurfaceStyleWithTextures::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleWithTextures; }
Type::Enum IfcSurfaceStyleWithTextures::type() const { return Type::IfcSurfaceStyleWithTextures; }
Type::Enum IfcSurfaceStyleWithTextures::Class() { return Type::IfcSurfaceStyleWithTextures; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSurfaceStyleWithTextures) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Textures) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Textures)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcSurfaceTexture
bool IfcSurfaceTexture::RepeatS() const { return *entity->getArgument(0); }
void IfcSurfaceTexture::setRepeatS(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcSurfaceTexture::RepeatT() const { return *entity->getArgument(1); }
void IfcSurfaceTexture::setRepeatT(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcSurfaceTextureEnum::IfcSurfaceTextureEnum IfcSurfaceTexture::TextureType() const { return IfcSurfaceTextureEnum::FromString(*entity->getArgument(2)); }
void IfcSurfaceTexture::setTextureType(IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSurfaceTextureEnum::ToString(v)));entity->setArgument(2,attr);} }
bool IfcSurfaceTexture::hasTextureTransform() const { return !entity->getArgument(3)->isNull(); }
IfcCartesianTransformationOperator2D* IfcSurfaceTexture::TextureTransform() const { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcSurfaceTexture::setTextureTransform(IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcSurfaceTexture::is(Type::Enum v) const { return v == Type::IfcSurfaceTexture; }
Type::Enum IfcSurfaceTexture::type() const { return Type::IfcSurfaceTexture; }
Type::Enum IfcSurfaceTexture::Class() { return Type::IfcSurfaceTexture; }
IfcSurfaceTexture::IfcSurfaceTexture(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcSurfaceTexture) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceTexture::IfcSurfaceTexture(bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,IfcSurfaceTextureEnum::ToString(v3_TextureType))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));entity->setArgument(3,attr);} }

// Function implementations for IfcSweptAreaSolid
IfcProfileDef* IfcSweptAreaSolid::SweptArea() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSweptAreaSolid::setSweptArea(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcAxis2Placement3D* IfcSweptAreaSolid::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcSweptAreaSolid::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSweptAreaSolid::is(Type::Enum v) const { return v == Type::IfcSweptAreaSolid || IfcSolidModel::is(v); }
Type::Enum IfcSweptAreaSolid::type() const { return Type::IfcSweptAreaSolid; }
Type::Enum IfcSweptAreaSolid::Class() { return Type::IfcSweptAreaSolid; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSweptAreaSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position) : IfcSolidModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);} }

// Function implementations for IfcSweptDiskSolid
IfcCurve* IfcSweptDiskSolid::Directrix() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSweptDiskSolid::setDirectrix(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcSweptDiskSolid::Radius() const { return *entity->getArgument(1); }
void IfcSweptDiskSolid::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSweptDiskSolid::hasInnerRadius() const { return !entity->getArgument(2)->isNull(); }
double IfcSweptDiskSolid::InnerRadius() const { return *entity->getArgument(2); }
void IfcSweptDiskSolid::setInnerRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
double IfcSweptDiskSolid::StartParam() const { return *entity->getArgument(3); }
void IfcSweptDiskSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcSweptDiskSolid::EndParam() const { return *entity->getArgument(4); }
void IfcSweptDiskSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcSweptDiskSolid::is(Type::Enum v) const { return v == Type::IfcSweptDiskSolid || IfcSolidModel::is(v); }
Type::Enum IfcSweptDiskSolid::type() const { return Type::IfcSweptDiskSolid; }
Type::Enum IfcSweptDiskSolid::Class() { return Type::IfcSweptDiskSolid; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSweptDiskSolid) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, double v4_StartParam, double v5_EndParam) : IfcSolidModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Directrix));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));entity->setArgument(1,attr);} if (v3_InnerRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_InnerRadius));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_StartParam));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndParam));entity->setArgument(4,attr);} }

// Function implementations for IfcSweptSurface
IfcProfileDef* IfcSweptSurface::SweptCurve() const { return (IfcProfileDef*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcSweptSurface::setSweptCurve(IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcAxis2Placement3D* IfcSweptSurface::Position() const { return (IfcAxis2Placement3D*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcSweptSurface::setPosition(IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSweptSurface::is(Type::Enum v) const { return v == Type::IfcSweptSurface || IfcSurface::is(v); }
Type::Enum IfcSweptSurface::type() const { return Type::IfcSweptSurface; }
Type::Enum IfcSweptSurface::Class() { return Type::IfcSweptSurface; }
IfcSweptSurface::IfcSweptSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSweptSurface) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptSurface::IfcSweptSurface(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position) : IfcSurface((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));entity->setArgument(1,attr);} }

// Function implementations for IfcSwitchingDeviceType
IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceType::PredefinedType() const { return IfcSwitchingDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSwitchingDeviceType::setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcSwitchingDeviceTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcSwitchingDeviceType::is(Type::Enum v) const { return v == Type::IfcSwitchingDeviceType || IfcFlowControllerType::is(v); }
Type::Enum IfcSwitchingDeviceType::type() const { return Type::IfcSwitchingDeviceType; }
Type::Enum IfcSwitchingDeviceType::Class() { return Type::IfcSwitchingDeviceType; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSwitchingDeviceType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcSwitchingDeviceTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcSymbolStyle
IfcSymbolStyleSelect* IfcSymbolStyle::StyleOfSymbol() const { return (IfcSymbolStyleSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcSymbolStyle::setStyleOfSymbol(IfcSymbolStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcSymbolStyle::is(Type::Enum v) const { return v == Type::IfcSymbolStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcSymbolStyle::type() const { return Type::IfcSymbolStyle; }
Type::Enum IfcSymbolStyle::Class() { return Type::IfcSymbolStyle; }
IfcSymbolStyle::IfcSymbolStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSymbolStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSymbolStyle::IfcSymbolStyle(boost::optional< std::string > v1_Name, IfcSymbolStyleSelect* v2_StyleOfSymbol) : IfcPresentationStyle((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StyleOfSymbol));entity->setArgument(1,attr);} }

// Function implementations for IfcSystem
IfcRelServicesBuildings::list::ptr IfcSystem::ServicesBuildings() const { return entity->getInverse(Type::IfcRelServicesBuildings, 4)->as<IfcRelServicesBuildings>(); }
bool IfcSystem::is(Type::Enum v) const { return v == Type::IfcSystem || IfcGroup::is(v); }
Type::Enum IfcSystem::type() const { return Type::IfcSystem; }
Type::Enum IfcSystem::Class() { return Type::IfcSystem; }
IfcSystem::IfcSystem(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSystem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSystem::IfcSystem(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcSystemFurnitureElementType
bool IfcSystemFurnitureElementType::is(Type::Enum v) const { return v == Type::IfcSystemFurnitureElementType || IfcFurnishingElementType::is(v); }
Type::Enum IfcSystemFurnitureElementType::type() const { return Type::IfcSystemFurnitureElementType; }
Type::Enum IfcSystemFurnitureElementType::Class() { return Type::IfcSystemFurnitureElementType; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcSystemFurnitureElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcTShapeProfileDef
double IfcTShapeProfileDef::Depth() const { return *entity->getArgument(3); }
void IfcTShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcTShapeProfileDef::FlangeWidth() const { return *entity->getArgument(4); }
void IfcTShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcTShapeProfileDef::WebThickness() const { return *entity->getArgument(5); }
void IfcTShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcTShapeProfileDef::FlangeThickness() const { return *entity->getArgument(6); }
void IfcTShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTShapeProfileDef::hasFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcTShapeProfileDef::FilletRadius() const { return *entity->getArgument(7); }
void IfcTShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcTShapeProfileDef::hasFlangeEdgeRadius() const { return !entity->getArgument(8)->isNull(); }
double IfcTShapeProfileDef::FlangeEdgeRadius() const { return *entity->getArgument(8); }
void IfcTShapeProfileDef::setFlangeEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcTShapeProfileDef::hasWebEdgeRadius() const { return !entity->getArgument(9)->isNull(); }
double IfcTShapeProfileDef::WebEdgeRadius() const { return *entity->getArgument(9); }
void IfcTShapeProfileDef::setWebEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcTShapeProfileDef::hasWebSlope() const { return !entity->getArgument(10)->isNull(); }
double IfcTShapeProfileDef::WebSlope() const { return *entity->getArgument(10); }
void IfcTShapeProfileDef::setWebSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcTShapeProfileDef::hasFlangeSlope() const { return !entity->getArgument(11)->isNull(); }
double IfcTShapeProfileDef::FlangeSlope() const { return *entity->getArgument(11); }
void IfcTShapeProfileDef::setFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcTShapeProfileDef::hasCentreOfGravityInY() const { return !entity->getArgument(12)->isNull(); }
double IfcTShapeProfileDef::CentreOfGravityInY() const { return *entity->getArgument(12); }
void IfcTShapeProfileDef::setCentreOfGravityInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcTShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcTShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcTShapeProfileDef::type() const { return Type::IfcTShapeProfileDef; }
Type::Enum IfcTShapeProfileDef::Class() { return Type::IfcTShapeProfileDef; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_WebEdgeRadius, boost::optional< double > v11_WebSlope, boost::optional< double > v12_FlangeSlope, boost::optional< double > v13_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));entity->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_FlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FlangeEdgeRadius));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_WebEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WebEdgeRadius));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_WebSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_WebSlope));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_FlangeSlope));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); } if (v13_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_CentreOfGravityInY));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } }

// Function implementations for IfcTable
std::string IfcTable::Name() const { return *entity->getArgument(0); }
void IfcTable::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcTableRow >::ptr IfcTable::Rows() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcTableRow>(); }
void IfcTable::setRows(IfcTemplatedEntityList< IfcTableRow >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcTable::is(Type::Enum v) const { return v == Type::IfcTable; }
Type::Enum IfcTable::type() const { return Type::IfcTable; }
Type::Enum IfcTable::Class() { return Type::IfcTable; }
IfcTable::IfcTable(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTable) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTable::IfcTable(std::string v1_Name, IfcTemplatedEntityList< IfcTableRow >::ptr v2_Rows) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Rows)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcTableRow
IfcEntityList::ptr IfcTableRow::RowCells() const { return *entity->getArgument(0); }
void IfcTableRow::setRowCells(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTableRow::IsHeading() const { return *entity->getArgument(1); }
void IfcTableRow::setIsHeading(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcTable::list::ptr IfcTableRow::OfTable() const { return entity->getInverse(Type::IfcTable, 1)->as<IfcTable>(); }
bool IfcTableRow::is(Type::Enum v) const { return v == Type::IfcTableRow; }
Type::Enum IfcTableRow::type() const { return Type::IfcTableRow; }
Type::Enum IfcTableRow::Class() { return Type::IfcTableRow; }
IfcTableRow::IfcTableRow(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTableRow) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTableRow::IfcTableRow(IfcEntityList::ptr v1_RowCells, bool v2_IsHeading) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RowCells));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_IsHeading));entity->setArgument(1,attr);} }

// Function implementations for IfcTankType
IfcTankTypeEnum::IfcTankTypeEnum IfcTankType::PredefinedType() const { return IfcTankTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTankType::setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTankTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcTankType::is(Type::Enum v) const { return v == Type::IfcTankType || IfcFlowStorageDeviceType::is(v); }
Type::Enum IfcTankType::type() const { return Type::IfcTankType; }
Type::Enum IfcTankType::Class() { return Type::IfcTankType; }
IfcTankType::IfcTankType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTankType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTankType::IfcTankType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTankTypeEnum::IfcTankTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTankTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcTask
std::string IfcTask::TaskId() const { return *entity->getArgument(5); }
void IfcTask::setTaskId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcTask::hasStatus() const { return !entity->getArgument(6)->isNull(); }
std::string IfcTask::Status() const { return *entity->getArgument(6); }
void IfcTask::setStatus(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTask::hasWorkMethod() const { return !entity->getArgument(7)->isNull(); }
std::string IfcTask::WorkMethod() const { return *entity->getArgument(7); }
void IfcTask::setWorkMethod(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcTask::IsMilestone() const { return *entity->getArgument(8); }
void IfcTask::setIsMilestone(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcTask::hasPriority() const { return !entity->getArgument(9)->isNull(); }
int IfcTask::Priority() const { return *entity->getArgument(9); }
void IfcTask::setPriority(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcTask::is(Type::Enum v) const { return v == Type::IfcTask || IfcProcess::is(v); }
Type::Enum IfcTask::type() const { return Type::IfcTask; }
Type::Enum IfcTask::Class() { return Type::IfcTask; }
IfcTask::IfcTask(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTask) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTask::IfcTask(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority) : IfcProcess((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));entity->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));entity->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcTelecomAddress
bool IfcTelecomAddress::hasTelephoneNumbers() const { return !entity->getArgument(3)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::TelephoneNumbers() const { return *entity->getArgument(3); }
void IfcTelecomAddress::setTelephoneNumbers(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTelecomAddress::hasFacsimileNumbers() const { return !entity->getArgument(4)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::FacsimileNumbers() const { return *entity->getArgument(4); }
void IfcTelecomAddress::setFacsimileNumbers(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcTelecomAddress::hasPagerNumber() const { return !entity->getArgument(5)->isNull(); }
std::string IfcTelecomAddress::PagerNumber() const { return *entity->getArgument(5); }
void IfcTelecomAddress::setPagerNumber(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcTelecomAddress::hasElectronicMailAddresses() const { return !entity->getArgument(6)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTelecomAddress::ElectronicMailAddresses() const { return *entity->getArgument(6); }
void IfcTelecomAddress::setElectronicMailAddresses(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTelecomAddress::hasWWWHomePageURL() const { return !entity->getArgument(7)->isNull(); }
std::string IfcTelecomAddress::WWWHomePageURL() const { return *entity->getArgument(7); }
void IfcTelecomAddress::setWWWHomePageURL(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcTelecomAddress::is(Type::Enum v) const { return v == Type::IfcTelecomAddress || IfcAddress::is(v); }
Type::Enum IfcTelecomAddress::type() const { return Type::IfcTelecomAddress; }
Type::Enum IfcTelecomAddress::Class() { return Type::IfcTelecomAddress; }
IfcTelecomAddress::IfcTelecomAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTelecomAddress) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTelecomAddress::IfcTelecomAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< std::string > v6_PagerNumber, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< std::string > v8_WWWHomePageURL) : IfcAddress((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose))));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_TelephoneNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TelephoneNumbers));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_FacsimileNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FacsimileNumbers));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_PagerNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PagerNumber));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_ElectronicMailAddresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ElectronicMailAddresses));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_WWWHomePageURL) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WWWHomePageURL));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcTendon
IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendon::PredefinedType() const { return IfcTendonTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTendon::setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTendonTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
double IfcTendon::NominalDiameter() const { return *entity->getArgument(10); }
void IfcTendon::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
double IfcTendon::CrossSectionArea() const { return *entity->getArgument(11); }
void IfcTendon::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcTendon::hasTensionForce() const { return !entity->getArgument(12)->isNull(); }
double IfcTendon::TensionForce() const { return *entity->getArgument(12); }
void IfcTendon::setTensionForce(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcTendon::hasPreStress() const { return !entity->getArgument(13)->isNull(); }
double IfcTendon::PreStress() const { return *entity->getArgument(13); }
void IfcTendon::setPreStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(13,attr);} }
bool IfcTendon::hasFrictionCoefficient() const { return !entity->getArgument(14)->isNull(); }
double IfcTendon::FrictionCoefficient() const { return *entity->getArgument(14); }
void IfcTendon::setFrictionCoefficient(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcTendon::hasAnchorageSlip() const { return !entity->getArgument(15)->isNull(); }
double IfcTendon::AnchorageSlip() const { return *entity->getArgument(15); }
void IfcTendon::setAnchorageSlip(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(15,attr);} }
bool IfcTendon::hasMinCurvatureRadius() const { return !entity->getArgument(16)->isNull(); }
double IfcTendon::MinCurvatureRadius() const { return *entity->getArgument(16); }
void IfcTendon::setMinCurvatureRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(16,attr);} }
bool IfcTendon::is(Type::Enum v) const { return v == Type::IfcTendon || IfcReinforcingElement::is(v); }
Type::Enum IfcTendon::type() const { return Type::IfcTendon; }
Type::Enum IfcTendon::Class() { return Type::IfcTendon; }
IfcTendon::IfcTendon(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTendon) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendon::IfcTendon(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, IfcTendonTypeEnum::IfcTendonTypeEnum v10_PredefinedType, double v11_NominalDiameter, double v12_CrossSectionArea, boost::optional< double > v13_TensionForce, boost::optional< double > v14_PreStress, boost::optional< double > v15_FrictionCoefficient, boost::optional< double > v16_AnchorageSlip, boost::optional< double > v17_MinCurvatureRadius) : IfcReinforcingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTendonTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_NominalDiameter));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_CrossSectionArea));entity->setArgument(11,attr);} if (v13_TensionForce) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TensionForce));entity->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(12, attr); } if (v14_PreStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_PreStress));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_FrictionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_FrictionCoefficient));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } if (v16_AnchorageSlip) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_AnchorageSlip));entity->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(15, attr); } if (v17_MinCurvatureRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MinCurvatureRadius));entity->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(16, attr); } }

// Function implementations for IfcTendonAnchor
bool IfcTendonAnchor::is(Type::Enum v) const { return v == Type::IfcTendonAnchor || IfcReinforcingElement::is(v); }
Type::Enum IfcTendonAnchor::type() const { return Type::IfcTendonAnchor; }
Type::Enum IfcTendonAnchor::Class() { return Type::IfcTendonAnchor; }
IfcTendonAnchor::IfcTendonAnchor(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTendonAnchor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendonAnchor::IfcTendonAnchor(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade) : IfcReinforcingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcTerminatorSymbol
IfcAnnotationCurveOccurrence* IfcTerminatorSymbol::AnnotatedCurve() const { return (IfcAnnotationCurveOccurrence*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcTerminatorSymbol::setAnnotatedCurve(IfcAnnotationCurveOccurrence* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTerminatorSymbol::is(Type::Enum v) const { return v == Type::IfcTerminatorSymbol || IfcAnnotationSymbolOccurrence::is(v); }
Type::Enum IfcTerminatorSymbol::type() const { return Type::IfcTerminatorSymbol; }
Type::Enum IfcTerminatorSymbol::Class() { return Type::IfcTerminatorSymbol; }
IfcTerminatorSymbol::IfcTerminatorSymbol(IfcEntityInstanceData* e) : IfcAnnotationSymbolOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTerminatorSymbol) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTerminatorSymbol::IfcTerminatorSymbol(IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcAnnotationCurveOccurrence* v4_AnnotatedCurve) : IfcAnnotationSymbolOccurrence((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AnnotatedCurve));entity->setArgument(3,attr);} }

// Function implementations for IfcTextLiteral
std::string IfcTextLiteral::Literal() const { return *entity->getArgument(0); }
void IfcTextLiteral::setLiteral(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcAxis2Placement* IfcTextLiteral::Placement() const { return (IfcAxis2Placement*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcTextLiteral::setPlacement(IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcTextPath::IfcTextPath IfcTextLiteral::Path() const { return IfcTextPath::FromString(*entity->getArgument(2)); }
void IfcTextLiteral::setPath(IfcTextPath::IfcTextPath v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTextPath::ToString(v)));entity->setArgument(2,attr);} }
bool IfcTextLiteral::is(Type::Enum v) const { return v == Type::IfcTextLiteral || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcTextLiteral::type() const { return Type::IfcTextLiteral; }
Type::Enum IfcTextLiteral::Class() { return Type::IfcTextLiteral; }
IfcTextLiteral::IfcTextLiteral(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextLiteral) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextLiteral::IfcTextLiteral(std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,IfcTextPath::ToString(v3_Path))));entity->setArgument(2,attr);} }

// Function implementations for IfcTextLiteralWithExtent
IfcPlanarExtent* IfcTextLiteralWithExtent::Extent() const { return (IfcPlanarExtent*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcTextLiteralWithExtent::setExtent(IfcPlanarExtent* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
std::string IfcTextLiteralWithExtent::BoxAlignment() const { return *entity->getArgument(4); }
void IfcTextLiteralWithExtent::setBoxAlignment(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcTextLiteralWithExtent::is(Type::Enum v) const { return v == Type::IfcTextLiteralWithExtent || IfcTextLiteral::is(v); }
Type::Enum IfcTextLiteralWithExtent::type() const { return Type::IfcTextLiteralWithExtent; }
Type::Enum IfcTextLiteralWithExtent::Class() { return Type::IfcTextLiteralWithExtent; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(IfcEntityInstanceData* e) : IfcTextLiteral((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextLiteralWithExtent) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path, IfcPlanarExtent* v4_Extent, std::string v5_BoxAlignment) : IfcTextLiteral((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,IfcTextPath::ToString(v3_Path))));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Extent));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_BoxAlignment));entity->setArgument(4,attr);} }

// Function implementations for IfcTextStyle
bool IfcTextStyle::hasTextCharacterAppearance() const { return !entity->getArgument(1)->isNull(); }
IfcCharacterStyleSelect* IfcTextStyle::TextCharacterAppearance() const { return (IfcCharacterStyleSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcTextStyle::setTextCharacterAppearance(IfcCharacterStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextStyle::hasTextStyle() const { return !entity->getArgument(2)->isNull(); }
IfcTextStyleSelect* IfcTextStyle::TextStyle() const { return (IfcTextStyleSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcTextStyle::setTextStyle(IfcTextStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcTextFontSelect* IfcTextStyle::TextFontStyle() const { return (IfcTextFontSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcTextStyle::setTextFontStyle(IfcTextFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTextStyle::is(Type::Enum v) const { return v == Type::IfcTextStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcTextStyle::type() const { return Type::IfcTextStyle; }
Type::Enum IfcTextStyle::Class() { return Type::IfcTextStyle; }
IfcTextStyle::IfcTextStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyle::IfcTextStyle(boost::optional< std::string > v1_Name, IfcCharacterStyleSelect* v2_TextCharacterAppearance, IfcTextStyleSelect* v3_TextStyle, IfcTextFontSelect* v4_TextFontStyle) : IfcPresentationStyle((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TextCharacterAppearance));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TextStyle));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextFontStyle));entity->setArgument(3,attr);} }

// Function implementations for IfcTextStyleFontModel
bool IfcTextStyleFontModel::hasFontFamily() const { return !entity->getArgument(1)->isNull(); }
std::vector< std::string > /*[1:?]*/ IfcTextStyleFontModel::FontFamily() const { return *entity->getArgument(1); }
void IfcTextStyleFontModel::setFontFamily(std::vector< std::string > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextStyleFontModel::hasFontStyle() const { return !entity->getArgument(2)->isNull(); }
std::string IfcTextStyleFontModel::FontStyle() const { return *entity->getArgument(2); }
void IfcTextStyleFontModel::setFontStyle(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcTextStyleFontModel::hasFontVariant() const { return !entity->getArgument(3)->isNull(); }
std::string IfcTextStyleFontModel::FontVariant() const { return *entity->getArgument(3); }
void IfcTextStyleFontModel::setFontVariant(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTextStyleFontModel::hasFontWeight() const { return !entity->getArgument(4)->isNull(); }
std::string IfcTextStyleFontModel::FontWeight() const { return *entity->getArgument(4); }
void IfcTextStyleFontModel::setFontWeight(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
IfcSizeSelect* IfcTextStyleFontModel::FontSize() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(5))); }
void IfcTextStyleFontModel::setFontSize(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcTextStyleFontModel::is(Type::Enum v) const { return v == Type::IfcTextStyleFontModel || IfcPreDefinedTextFont::is(v); }
Type::Enum IfcTextStyleFontModel::type() const { return Type::IfcTextStyleFontModel; }
Type::Enum IfcTextStyleFontModel::Class() { return Type::IfcTextStyleFontModel; }
IfcTextStyleFontModel::IfcTextStyleFontModel(IfcEntityInstanceData* e) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextStyleFontModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleFontModel::IfcTextStyleFontModel(std::string v1_Name, boost::optional< std::vector< std::string > /*[1:?]*/ > v2_FontFamily, boost::optional< std::string > v3_FontStyle, boost::optional< std::string > v4_FontVariant, boost::optional< std::string > v5_FontWeight, IfcSizeSelect* v6_FontSize) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_FontFamily) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_FontFamily));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_FontStyle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_FontStyle));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_FontVariant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_FontVariant));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_FontWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FontWeight));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FontSize));entity->setArgument(5,attr);} }

// Function implementations for IfcTextStyleForDefinedFont
IfcColour* IfcTextStyleForDefinedFont::Colour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcTextStyleForDefinedFont::setColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTextStyleForDefinedFont::hasBackgroundColour() const { return !entity->getArgument(1)->isNull(); }
IfcColour* IfcTextStyleForDefinedFont::BackgroundColour() const { return (IfcColour*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcTextStyleForDefinedFont::setBackgroundColour(IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextStyleForDefinedFont::is(Type::Enum v) const { return v == Type::IfcTextStyleForDefinedFont; }
Type::Enum IfcTextStyleForDefinedFont::type() const { return Type::IfcTextStyleForDefinedFont; }
Type::Enum IfcTextStyleForDefinedFont::Class() { return Type::IfcTextStyleForDefinedFont; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTextStyleForDefinedFont) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcColour* v1_Colour, IfcColour* v2_BackgroundColour) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Colour));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_BackgroundColour));entity->setArgument(1,attr);} }

// Function implementations for IfcTextStyleTextModel
bool IfcTextStyleTextModel::hasTextIndent() const { return !entity->getArgument(0)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::TextIndent() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcTextStyleTextModel::setTextIndent(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTextStyleTextModel::hasTextAlign() const { return !entity->getArgument(1)->isNull(); }
std::string IfcTextStyleTextModel::TextAlign() const { return *entity->getArgument(1); }
void IfcTextStyleTextModel::setTextAlign(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextStyleTextModel::hasTextDecoration() const { return !entity->getArgument(2)->isNull(); }
std::string IfcTextStyleTextModel::TextDecoration() const { return *entity->getArgument(2); }
void IfcTextStyleTextModel::setTextDecoration(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcTextStyleTextModel::hasLetterSpacing() const { return !entity->getArgument(3)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::LetterSpacing() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcTextStyleTextModel::setLetterSpacing(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTextStyleTextModel::hasWordSpacing() const { return !entity->getArgument(4)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::WordSpacing() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcTextStyleTextModel::setWordSpacing(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcTextStyleTextModel::hasTextTransform() const { return !entity->getArgument(5)->isNull(); }
std::string IfcTextStyleTextModel::TextTransform() const { return *entity->getArgument(5); }
void IfcTextStyleTextModel::setTextTransform(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcTextStyleTextModel::hasLineHeight() const { return !entity->getArgument(6)->isNull(); }
IfcSizeSelect* IfcTextStyleTextModel::LineHeight() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcTextStyleTextModel::setLineHeight(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTextStyleTextModel::is(Type::Enum v) const { return v == Type::IfcTextStyleTextModel; }
Type::Enum IfcTextStyleTextModel::type() const { return Type::IfcTextStyleTextModel; }
Type::Enum IfcTextStyleTextModel::Class() { return Type::IfcTextStyleTextModel; }
IfcTextStyleTextModel::IfcTextStyleTextModel(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTextStyleTextModel) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleTextModel::IfcTextStyleTextModel(IfcSizeSelect* v1_TextIndent, boost::optional< std::string > v2_TextAlign, boost::optional< std::string > v3_TextDecoration, IfcSizeSelect* v4_LetterSpacing, IfcSizeSelect* v5_WordSpacing, boost::optional< std::string > v6_TextTransform, IfcSizeSelect* v7_LineHeight) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextIndent));entity->setArgument(0,attr);} if (v2_TextAlign) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TextAlign));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_TextDecoration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TextDecoration));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LetterSpacing));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WordSpacing));entity->setArgument(4,attr);} if (v6_TextTransform) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_TextTransform));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LineHeight));entity->setArgument(6,attr);} }

// Function implementations for IfcTextStyleWithBoxCharacteristics
bool IfcTextStyleWithBoxCharacteristics::hasBoxHeight() const { return !entity->getArgument(0)->isNull(); }
double IfcTextStyleWithBoxCharacteristics::BoxHeight() const { return *entity->getArgument(0); }
void IfcTextStyleWithBoxCharacteristics::setBoxHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTextStyleWithBoxCharacteristics::hasBoxWidth() const { return !entity->getArgument(1)->isNull(); }
double IfcTextStyleWithBoxCharacteristics::BoxWidth() const { return *entity->getArgument(1); }
void IfcTextStyleWithBoxCharacteristics::setBoxWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextStyleWithBoxCharacteristics::hasBoxSlantAngle() const { return !entity->getArgument(2)->isNull(); }
double IfcTextStyleWithBoxCharacteristics::BoxSlantAngle() const { return *entity->getArgument(2); }
void IfcTextStyleWithBoxCharacteristics::setBoxSlantAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcTextStyleWithBoxCharacteristics::hasBoxRotateAngle() const { return !entity->getArgument(3)->isNull(); }
double IfcTextStyleWithBoxCharacteristics::BoxRotateAngle() const { return *entity->getArgument(3); }
void IfcTextStyleWithBoxCharacteristics::setBoxRotateAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcTextStyleWithBoxCharacteristics::hasCharacterSpacing() const { return !entity->getArgument(4)->isNull(); }
IfcSizeSelect* IfcTextStyleWithBoxCharacteristics::CharacterSpacing() const { return (IfcSizeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(4))); }
void IfcTextStyleWithBoxCharacteristics::setCharacterSpacing(IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcTextStyleWithBoxCharacteristics::is(Type::Enum v) const { return v == Type::IfcTextStyleWithBoxCharacteristics; }
Type::Enum IfcTextStyleWithBoxCharacteristics::type() const { return Type::IfcTextStyleWithBoxCharacteristics; }
Type::Enum IfcTextStyleWithBoxCharacteristics::Class() { return Type::IfcTextStyleWithBoxCharacteristics; }
IfcTextStyleWithBoxCharacteristics::IfcTextStyleWithBoxCharacteristics(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTextStyleWithBoxCharacteristics) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleWithBoxCharacteristics::IfcTextStyleWithBoxCharacteristics(boost::optional< double > v1_BoxHeight, boost::optional< double > v2_BoxWidth, boost::optional< double > v3_BoxSlantAngle, boost::optional< double > v4_BoxRotateAngle, IfcSizeSelect* v5_CharacterSpacing) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  if (v1_BoxHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_BoxHeight));entity->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(0, attr); } if (v2_BoxWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_BoxWidth));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_BoxSlantAngle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_BoxSlantAngle));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_BoxRotateAngle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_BoxRotateAngle));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CharacterSpacing));entity->setArgument(4,attr);} }

// Function implementations for IfcTextureCoordinate
IfcAnnotationSurface::list::ptr IfcTextureCoordinate::AnnotatedSurface() const { return entity->getInverse(Type::IfcAnnotationSurface, 1)->as<IfcAnnotationSurface>(); }
bool IfcTextureCoordinate::is(Type::Enum v) const { return v == Type::IfcTextureCoordinate; }
Type::Enum IfcTextureCoordinate::type() const { return Type::IfcTextureCoordinate; }
Type::Enum IfcTextureCoordinate::Class() { return Type::IfcTextureCoordinate; }
IfcTextureCoordinate::IfcTextureCoordinate(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTextureCoordinate) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureCoordinate::IfcTextureCoordinate() : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcTextureCoordinateGenerator
std::string IfcTextureCoordinateGenerator::Mode() const { return *entity->getArgument(0); }
void IfcTextureCoordinateGenerator::setMode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcTextureCoordinateGenerator::Parameter() const { return *entity->getArgument(1); }
void IfcTextureCoordinateGenerator::setParameter(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTextureCoordinateGenerator::is(Type::Enum v) const { return v == Type::IfcTextureCoordinateGenerator || IfcTextureCoordinate::is(v); }
Type::Enum IfcTextureCoordinateGenerator::type() const { return Type::IfcTextureCoordinateGenerator; }
Type::Enum IfcTextureCoordinateGenerator::Class() { return Type::IfcTextureCoordinateGenerator; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextureCoordinateGenerator) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(std::string v1_Mode, IfcEntityList::ptr v2_Parameter) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Mode));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Parameter));entity->setArgument(1,attr);} }

// Function implementations for IfcTextureMap
IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr IfcTextureMap::TextureMaps() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcVertexBasedTextureMap>(); }
void IfcTextureMap::setTextureMaps(IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
bool IfcTextureMap::is(Type::Enum v) const { return v == Type::IfcTextureMap || IfcTextureCoordinate::is(v); }
Type::Enum IfcTextureMap::type() const { return Type::IfcTextureMap; }
Type::Enum IfcTextureMap::Class() { return Type::IfcTextureMap; }
IfcTextureMap::IfcTextureMap(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTextureMap) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureMap::IfcTextureMap(IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr v1_TextureMaps) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextureMaps)->generalize());entity->setArgument(0,attr);} }

// Function implementations for IfcTextureVertex
std::vector< double > /*[2:2]*/ IfcTextureVertex::Coordinates() const { return *entity->getArgument(0); }
void IfcTextureVertex::setCoordinates(std::vector< double > /*[2:2]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTextureVertex::is(Type::Enum v) const { return v == Type::IfcTextureVertex; }
Type::Enum IfcTextureVertex::type() const { return Type::IfcTextureVertex; }
Type::Enum IfcTextureVertex::Class() { return Type::IfcTextureVertex; }
IfcTextureVertex::IfcTextureVertex(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTextureVertex) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureVertex::IfcTextureVertex(std::vector< double > /*[2:2]*/ v1_Coordinates) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));entity->setArgument(0,attr);} }

// Function implementations for IfcThermalMaterialProperties
bool IfcThermalMaterialProperties::hasSpecificHeatCapacity() const { return !entity->getArgument(1)->isNull(); }
double IfcThermalMaterialProperties::SpecificHeatCapacity() const { return *entity->getArgument(1); }
void IfcThermalMaterialProperties::setSpecificHeatCapacity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcThermalMaterialProperties::hasBoilingPoint() const { return !entity->getArgument(2)->isNull(); }
double IfcThermalMaterialProperties::BoilingPoint() const { return *entity->getArgument(2); }
void IfcThermalMaterialProperties::setBoilingPoint(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcThermalMaterialProperties::hasFreezingPoint() const { return !entity->getArgument(3)->isNull(); }
double IfcThermalMaterialProperties::FreezingPoint() const { return *entity->getArgument(3); }
void IfcThermalMaterialProperties::setFreezingPoint(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcThermalMaterialProperties::hasThermalConductivity() const { return !entity->getArgument(4)->isNull(); }
double IfcThermalMaterialProperties::ThermalConductivity() const { return *entity->getArgument(4); }
void IfcThermalMaterialProperties::setThermalConductivity(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcThermalMaterialProperties::is(Type::Enum v) const { return v == Type::IfcThermalMaterialProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcThermalMaterialProperties::type() const { return Type::IfcThermalMaterialProperties; }
Type::Enum IfcThermalMaterialProperties::Class() { return Type::IfcThermalMaterialProperties; }
IfcThermalMaterialProperties::IfcThermalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcThermalMaterialProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcThermalMaterialProperties::IfcThermalMaterialProperties(IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_BoilingPoint, boost::optional< double > v4_FreezingPoint, boost::optional< double > v5_ThermalConductivity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_SpecificHeatCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SpecificHeatCapacity));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_BoilingPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_BoilingPoint));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_FreezingPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_FreezingPoint));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ThermalConductivity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ThermalConductivity));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

// Function implementations for IfcTimeSeries
std::string IfcTimeSeries::Name() const { return *entity->getArgument(0); }
void IfcTimeSeries::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTimeSeries::hasDescription() const { return !entity->getArgument(1)->isNull(); }
std::string IfcTimeSeries::Description() const { return *entity->getArgument(1); }
void IfcTimeSeries::setDescription(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcDateTimeSelect* IfcTimeSeries::StartTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(2))); }
void IfcTimeSeries::setStartTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
IfcDateTimeSelect* IfcTimeSeries::EndTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(3))); }
void IfcTimeSeries::setEndTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeries::TimeSeriesDataType() const { return IfcTimeSeriesDataTypeEnum::FromString(*entity->getArgument(4)); }
void IfcTimeSeries::setTimeSeriesDataType(IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTimeSeriesDataTypeEnum::ToString(v)));entity->setArgument(4,attr);} }
IfcDataOriginEnum::IfcDataOriginEnum IfcTimeSeries::DataOrigin() const { return IfcDataOriginEnum::FromString(*entity->getArgument(5)); }
void IfcTimeSeries::setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcDataOriginEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcTimeSeries::hasUserDefinedDataOrigin() const { return !entity->getArgument(6)->isNull(); }
std::string IfcTimeSeries::UserDefinedDataOrigin() const { return *entity->getArgument(6); }
void IfcTimeSeries::setUserDefinedDataOrigin(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTimeSeries::hasUnit() const { return !entity->getArgument(7)->isNull(); }
IfcUnit* IfcTimeSeries::Unit() const { return (IfcUnit*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcTimeSeries::setUnit(IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
IfcTimeSeriesReferenceRelationship::list::ptr IfcTimeSeries::DocumentedBy() const { return entity->getInverse(Type::IfcTimeSeriesReferenceRelationship, 0)->as<IfcTimeSeriesReferenceRelationship>(); }
bool IfcTimeSeries::is(Type::Enum v) const { return v == Type::IfcTimeSeries; }
Type::Enum IfcTimeSeries::type() const { return Type::IfcTimeSeries; }
Type::Enum IfcTimeSeries::Class() { return Type::IfcTimeSeries; }
IfcTimeSeries::IfcTimeSeries(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTimeSeries) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeries::IfcTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));entity->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin))));entity->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));entity->setArgument(7,attr);} }

// Function implementations for IfcTimeSeriesReferenceRelationship
IfcTimeSeries* IfcTimeSeriesReferenceRelationship::ReferencedTimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcTimeSeriesReferenceRelationship::setReferencedTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcTimeSeriesReferenceRelationship::TimeSeriesReferences() const { return *entity->getArgument(1); }
void IfcTimeSeriesReferenceRelationship::setTimeSeriesReferences(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTimeSeriesReferenceRelationship::is(Type::Enum v) const { return v == Type::IfcTimeSeriesReferenceRelationship; }
Type::Enum IfcTimeSeriesReferenceRelationship::type() const { return Type::IfcTimeSeriesReferenceRelationship; }
Type::Enum IfcTimeSeriesReferenceRelationship::Class() { return Type::IfcTimeSeriesReferenceRelationship; }
IfcTimeSeriesReferenceRelationship::IfcTimeSeriesReferenceRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTimeSeriesReferenceRelationship) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeriesReferenceRelationship::IfcTimeSeriesReferenceRelationship(IfcTimeSeries* v1_ReferencedTimeSeries, IfcEntityList::ptr v2_TimeSeriesReferences) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ReferencedTimeSeries));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TimeSeriesReferences));entity->setArgument(1,attr);} }

// Function implementations for IfcTimeSeriesSchedule
bool IfcTimeSeriesSchedule::hasApplicableDates() const { return !entity->getArgument(5)->isNull(); }
IfcEntityList::ptr IfcTimeSeriesSchedule::ApplicableDates() const { return *entity->getArgument(5); }
void IfcTimeSeriesSchedule::setApplicableDates(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum IfcTimeSeriesSchedule::TimeSeriesScheduleType() const { return IfcTimeSeriesScheduleTypeEnum::FromString(*entity->getArgument(6)); }
void IfcTimeSeriesSchedule::setTimeSeriesScheduleType(IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTimeSeriesScheduleTypeEnum::ToString(v)));entity->setArgument(6,attr);} }
IfcTimeSeries* IfcTimeSeriesSchedule::TimeSeries() const { return (IfcTimeSeries*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(7))); }
void IfcTimeSeriesSchedule::setTimeSeries(IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcTimeSeriesSchedule::is(Type::Enum v) const { return v == Type::IfcTimeSeriesSchedule || IfcControl::is(v); }
Type::Enum IfcTimeSeriesSchedule::type() const { return Type::IfcTimeSeriesSchedule; }
Type::Enum IfcTimeSeriesSchedule::Class() { return Type::IfcTimeSeriesSchedule; }
IfcTimeSeriesSchedule::IfcTimeSeriesSchedule(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTimeSeriesSchedule) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeriesSchedule::IfcTimeSeriesSchedule(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcEntityList::ptr > v6_ApplicableDates, IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum v7_TimeSeriesScheduleType, IfcTimeSeries* v8_TimeSeries) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ApplicableDates) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ApplicableDates));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_TimeSeriesScheduleType,IfcTimeSeriesScheduleTypeEnum::ToString(v7_TimeSeriesScheduleType))));entity->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_TimeSeries));entity->setArgument(7,attr);} }

// Function implementations for IfcTimeSeriesValue
IfcEntityList::ptr IfcTimeSeriesValue::ListValues() const { return *entity->getArgument(0); }
void IfcTimeSeriesValue::setListValues(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcTimeSeriesValue::is(Type::Enum v) const { return v == Type::IfcTimeSeriesValue; }
Type::Enum IfcTimeSeriesValue::type() const { return Type::IfcTimeSeriesValue; }
Type::Enum IfcTimeSeriesValue::Class() { return Type::IfcTimeSeriesValue; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcTimeSeriesValue) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntityList::ptr v1_ListValues) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ListValues));entity->setArgument(0,attr);} }

// Function implementations for IfcTopologicalRepresentationItem
bool IfcTopologicalRepresentationItem::is(Type::Enum v) const { return v == Type::IfcTopologicalRepresentationItem || IfcRepresentationItem::is(v); }
Type::Enum IfcTopologicalRepresentationItem::type() const { return Type::IfcTopologicalRepresentationItem; }
Type::Enum IfcTopologicalRepresentationItem::Class() { return Type::IfcTopologicalRepresentationItem; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTopologicalRepresentationItem) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcTopologyRepresentation
bool IfcTopologyRepresentation::is(Type::Enum v) const { return v == Type::IfcTopologyRepresentation || IfcShapeModel::is(v); }
Type::Enum IfcTopologyRepresentation::type() const { return Type::IfcTopologyRepresentation; }
Type::Enum IfcTopologyRepresentation::Class() { return Type::IfcTopologyRepresentation; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTopologyRepresentation) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));entity->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());entity->setArgument(3,attr);} }

// Function implementations for IfcTransformerType
IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerType::PredefinedType() const { return IfcTransformerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTransformerType::setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransformerTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcTransformerType::is(Type::Enum v) const { return v == Type::IfcTransformerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcTransformerType::type() const { return Type::IfcTransformerType; }
Type::Enum IfcTransformerType::Class() { return Type::IfcTransformerType; }
IfcTransformerType::IfcTransformerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTransformerType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransformerType::IfcTransformerType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransformerTypeEnum::IfcTransformerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTransformerTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcTransportElement
bool IfcTransportElement::hasOperationType() const { return !entity->getArgument(8)->isNull(); }
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElement::OperationType() const { return IfcTransportElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcTransportElement::setOperationType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransportElementTypeEnum::ToString(v)));entity->setArgument(8,attr);} }
bool IfcTransportElement::hasCapacityByWeight() const { return !entity->getArgument(9)->isNull(); }
double IfcTransportElement::CapacityByWeight() const { return *entity->getArgument(9); }
void IfcTransportElement::setCapacityByWeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcTransportElement::hasCapacityByNumber() const { return !entity->getArgument(10)->isNull(); }
double IfcTransportElement::CapacityByNumber() const { return *entity->getArgument(10); }
void IfcTransportElement::setCapacityByNumber(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcTransportElement::is(Type::Enum v) const { return v == Type::IfcTransportElement || IfcElement::is(v); }
Type::Enum IfcTransportElement::type() const { return Type::IfcTransportElement; }
Type::Enum IfcTransportElement::Class() { return Type::IfcTransportElement; }
IfcTransportElement::IfcTransportElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTransportElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransportElement::IfcTransportElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransportElementTypeEnum::IfcTransportElementTypeEnum > v9_OperationType, boost::optional< double > v10_CapacityByWeight, boost::optional< double > v11_CapacityByNumber) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_OperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_OperationType,IfcTransportElementTypeEnum::ToString(*v9_OperationType))));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_CapacityByWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_CapacityByWeight));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_CapacityByNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CapacityByNumber));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcTransportElementType
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementType::PredefinedType() const { return IfcTransportElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTransportElementType::setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTransportElementTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcTransportElementType::is(Type::Enum v) const { return v == Type::IfcTransportElementType || IfcElementType::is(v); }
Type::Enum IfcTransportElementType::type() const { return Type::IfcTransportElementType; }
Type::Enum IfcTransportElementType::Class() { return Type::IfcTransportElementType; }
IfcTransportElementType::IfcTransportElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTransportElementType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransportElementType::IfcTransportElementType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v10_PredefinedType) : IfcElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTransportElementTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcTrapeziumProfileDef
double IfcTrapeziumProfileDef::BottomXDim() const { return *entity->getArgument(3); }
void IfcTrapeziumProfileDef::setBottomXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcTrapeziumProfileDef::TopXDim() const { return *entity->getArgument(4); }
void IfcTrapeziumProfileDef::setTopXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcTrapeziumProfileDef::YDim() const { return *entity->getArgument(5); }
void IfcTrapeziumProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcTrapeziumProfileDef::TopXOffset() const { return *entity->getArgument(6); }
void IfcTrapeziumProfileDef::setTopXOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcTrapeziumProfileDef::is(Type::Enum v) const { return v == Type::IfcTrapeziumProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcTrapeziumProfileDef::type() const { return Type::IfcTrapeziumProfileDef; }
Type::Enum IfcTrapeziumProfileDef::Class() { return Type::IfcTrapeziumProfileDef; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTrapeziumProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomXDim, double v5_TopXDim, double v6_YDim, double v7_TopXOffset) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_BottomXDim));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_TopXDim));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_YDim));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TopXOffset));entity->setArgument(6,attr);} }

// Function implementations for IfcTrimmedCurve
IfcCurve* IfcTrimmedCurve::BasisCurve() const { return (IfcCurve*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcTrimmedCurve::setBasisCurve(IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
IfcEntityList::ptr IfcTrimmedCurve::Trim1() const { return *entity->getArgument(1); }
void IfcTrimmedCurve::setTrim1(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
IfcEntityList::ptr IfcTrimmedCurve::Trim2() const { return *entity->getArgument(2); }
void IfcTrimmedCurve::setTrim2(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcTrimmedCurve::SenseAgreement() const { return *entity->getArgument(3); }
void IfcTrimmedCurve::setSenseAgreement(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmedCurve::MasterRepresentation() const { return IfcTrimmingPreference::FromString(*entity->getArgument(4)); }
void IfcTrimmedCurve::setMasterRepresentation(IfcTrimmingPreference::IfcTrimmingPreference v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTrimmingPreference::ToString(v)));entity->setArgument(4,attr);} }
bool IfcTrimmedCurve::is(Type::Enum v) const { return v == Type::IfcTrimmedCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcTrimmedCurve::type() const { return Type::IfcTrimmedCurve; }
Type::Enum IfcTrimmedCurve::Class() { return Type::IfcTrimmedCurve; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTrimmedCurve) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcCurve* v1_BasisCurve, IfcEntityList::ptr v2_Trim1, IfcEntityList::ptr v3_Trim2, bool v4_SenseAgreement, IfcTrimmingPreference::IfcTrimmingPreference v5_MasterRepresentation) : IfcBoundedCurve((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Trim1));entity->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Trim2));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SenseAgreement));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_MasterRepresentation,IfcTrimmingPreference::ToString(v5_MasterRepresentation))));entity->setArgument(4,attr);} }

// Function implementations for IfcTubeBundleType
IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleType::PredefinedType() const { return IfcTubeBundleTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTubeBundleType::setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcTubeBundleTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcTubeBundleType::is(Type::Enum v) const { return v == Type::IfcTubeBundleType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcTubeBundleType::type() const { return Type::IfcTubeBundleType; }
Type::Enum IfcTubeBundleType::Class() { return Type::IfcTubeBundleType; }
IfcTubeBundleType::IfcTubeBundleType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTubeBundleType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTubeBundleType::IfcTubeBundleType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcTubeBundleTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcTwoDirectionRepeatFactor
IfcVector* IfcTwoDirectionRepeatFactor::SecondRepeatFactor() const { return (IfcVector*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(1))); }
void IfcTwoDirectionRepeatFactor::setSecondRepeatFactor(IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcTwoDirectionRepeatFactor::is(Type::Enum v) const { return v == Type::IfcTwoDirectionRepeatFactor || IfcOneDirectionRepeatFactor::is(v); }
Type::Enum IfcTwoDirectionRepeatFactor::type() const { return Type::IfcTwoDirectionRepeatFactor; }
Type::Enum IfcTwoDirectionRepeatFactor::Class() { return Type::IfcTwoDirectionRepeatFactor; }
IfcTwoDirectionRepeatFactor::IfcTwoDirectionRepeatFactor(IfcEntityInstanceData* e) : IfcOneDirectionRepeatFactor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTwoDirectionRepeatFactor) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTwoDirectionRepeatFactor::IfcTwoDirectionRepeatFactor(IfcVector* v1_RepeatFactor, IfcVector* v2_SecondRepeatFactor) : IfcOneDirectionRepeatFactor((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatFactor));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SecondRepeatFactor));entity->setArgument(1,attr);} }

// Function implementations for IfcTypeObject
bool IfcTypeObject::hasApplicableOccurrence() const { return !entity->getArgument(4)->isNull(); }
std::string IfcTypeObject::ApplicableOccurrence() const { return *entity->getArgument(4); }
void IfcTypeObject::setApplicableOccurrence(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcTypeObject::hasHasPropertySets() const { return !entity->getArgument(5)->isNull(); }
IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr IfcTypeObject::HasPropertySets() const { IfcEntityList::ptr es = *entity->getArgument(5); return es->as<IfcPropertySetDefinition>(); }
void IfcTypeObject::setHasPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(5,attr);} }
IfcRelDefinesByType::list::ptr IfcTypeObject::ObjectTypeOf() const { return entity->getInverse(Type::IfcRelDefinesByType, 5)->as<IfcRelDefinesByType>(); }
bool IfcTypeObject::is(Type::Enum v) const { return v == Type::IfcTypeObject || IfcObjectDefinition::is(v); }
Type::Enum IfcTypeObject::type() const { return Type::IfcTypeObject; }
Type::Enum IfcTypeObject::Class() { return Type::IfcTypeObject; }
IfcTypeObject::IfcTypeObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTypeObject) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeObject::IfcTypeObject(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets) : IfcObjectDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } }

// Function implementations for IfcTypeProduct
bool IfcTypeProduct::hasRepresentationMaps() const { return !entity->getArgument(6)->isNull(); }
IfcTemplatedEntityList< IfcRepresentationMap >::ptr IfcTypeProduct::RepresentationMaps() const { IfcEntityList::ptr es = *entity->getArgument(6); return es->as<IfcRepresentationMap>(); }
void IfcTypeProduct::setRepresentationMaps(IfcTemplatedEntityList< IfcRepresentationMap >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(6,attr);} }
bool IfcTypeProduct::hasTag() const { return !entity->getArgument(7)->isNull(); }
std::string IfcTypeProduct::Tag() const { return *entity->getArgument(7); }
void IfcTypeProduct::setTag(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcTypeProduct::is(Type::Enum v) const { return v == Type::IfcTypeProduct || IfcTypeObject::is(v); }
Type::Enum IfcTypeProduct::type() const { return Type::IfcTypeProduct; }
Type::Enum IfcTypeProduct::Class() { return Type::IfcTypeProduct; }
IfcTypeProduct::IfcTypeProduct(IfcEntityInstanceData* e) : IfcTypeObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcTypeProduct) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeProduct::IfcTypeProduct(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag) : IfcTypeObject((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcUShapeProfileDef
double IfcUShapeProfileDef::Depth() const { return *entity->getArgument(3); }
void IfcUShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcUShapeProfileDef::FlangeWidth() const { return *entity->getArgument(4); }
void IfcUShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcUShapeProfileDef::WebThickness() const { return *entity->getArgument(5); }
void IfcUShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcUShapeProfileDef::FlangeThickness() const { return *entity->getArgument(6); }
void IfcUShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcUShapeProfileDef::hasFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcUShapeProfileDef::FilletRadius() const { return *entity->getArgument(7); }
void IfcUShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcUShapeProfileDef::hasEdgeRadius() const { return !entity->getArgument(8)->isNull(); }
double IfcUShapeProfileDef::EdgeRadius() const { return *entity->getArgument(8); }
void IfcUShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcUShapeProfileDef::hasFlangeSlope() const { return !entity->getArgument(9)->isNull(); }
double IfcUShapeProfileDef::FlangeSlope() const { return *entity->getArgument(9); }
void IfcUShapeProfileDef::setFlangeSlope(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcUShapeProfileDef::hasCentreOfGravityInX() const { return !entity->getArgument(10)->isNull(); }
double IfcUShapeProfileDef::CentreOfGravityInX() const { return *entity->getArgument(10); }
void IfcUShapeProfileDef::setCentreOfGravityInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcUShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcUShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcUShapeProfileDef::type() const { return Type::IfcUShapeProfileDef; }
Type::Enum IfcUShapeProfileDef::Class() { return Type::IfcUShapeProfileDef; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcUShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius, boost::optional< double > v10_FlangeSlope, boost::optional< double > v11_CentreOfGravityInX) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));entity->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FlangeSlope));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CentreOfGravityInX));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } }

// Function implementations for IfcUnitAssignment
IfcEntityList::ptr IfcUnitAssignment::Units() const { return *entity->getArgument(0); }
void IfcUnitAssignment::setUnits(IfcEntityList::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcUnitAssignment::is(Type::Enum v) const { return v == Type::IfcUnitAssignment; }
Type::Enum IfcUnitAssignment::type() const { return Type::IfcUnitAssignment; }
Type::Enum IfcUnitAssignment::Class() { return Type::IfcUnitAssignment; }
IfcUnitAssignment::IfcUnitAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcUnitAssignment) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitAssignment::IfcUnitAssignment(IfcEntityList::ptr v1_Units) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Units));entity->setArgument(0,attr);} }

// Function implementations for IfcUnitaryEquipmentType
IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentType::PredefinedType() const { return IfcUnitaryEquipmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcUnitaryEquipmentType::setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcUnitaryEquipmentTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcUnitaryEquipmentType::is(Type::Enum v) const { return v == Type::IfcUnitaryEquipmentType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcUnitaryEquipmentType::type() const { return Type::IfcUnitaryEquipmentType; }
Type::Enum IfcUnitaryEquipmentType::Class() { return Type::IfcUnitaryEquipmentType; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcUnitaryEquipmentType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcUnitaryEquipmentTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcValveType
IfcValveTypeEnum::IfcValveTypeEnum IfcValveType::PredefinedType() const { return IfcValveTypeEnum::FromString(*entity->getArgument(9)); }
void IfcValveType::setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcValveTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcValveType::is(Type::Enum v) const { return v == Type::IfcValveType || IfcFlowControllerType::is(v); }
Type::Enum IfcValveType::type() const { return Type::IfcValveType; }
Type::Enum IfcValveType::Class() { return Type::IfcValveType; }
IfcValveType::IfcValveType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcValveType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcValveType::IfcValveType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcValveTypeEnum::IfcValveTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcValveTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcVector
IfcDirection* IfcVector::Orientation() const { return (IfcDirection*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcVector::setOrientation(IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
double IfcVector::Magnitude() const { return *entity->getArgument(1); }
void IfcVector::setMagnitude(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcVector::is(Type::Enum v) const { return v == Type::IfcVector || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcVector::type() const { return Type::IfcVector; }
Type::Enum IfcVector::Class() { return Type::IfcVector; }
IfcVector::IfcVector(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVector) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVector::IfcVector(IfcDirection* v1_Orientation, double v2_Magnitude) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Orientation));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Magnitude));entity->setArgument(1,attr);} }

// Function implementations for IfcVertex
bool IfcVertex::is(Type::Enum v) const { return v == Type::IfcVertex || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcVertex::type() const { return Type::IfcVertex; }
Type::Enum IfcVertex::Class() { return Type::IfcVertex; }
IfcVertex::IfcVertex(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVertex) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertex::IfcVertex() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class());  }

// Function implementations for IfcVertexBasedTextureMap
IfcTemplatedEntityList< IfcTextureVertex >::ptr IfcVertexBasedTextureMap::TextureVertices() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcTextureVertex>(); }
void IfcVertexBasedTextureMap::setTextureVertices(IfcTemplatedEntityList< IfcTextureVertex >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
IfcTemplatedEntityList< IfcCartesianPoint >::ptr IfcVertexBasedTextureMap::TexturePoints() const { IfcEntityList::ptr es = *entity->getArgument(1); return es->as<IfcCartesianPoint>(); }
void IfcVertexBasedTextureMap::setTexturePoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(1,attr);} }
bool IfcVertexBasedTextureMap::is(Type::Enum v) const { return v == Type::IfcVertexBasedTextureMap; }
Type::Enum IfcVertexBasedTextureMap::type() const { return Type::IfcVertexBasedTextureMap; }
Type::Enum IfcVertexBasedTextureMap::Class() { return Type::IfcVertexBasedTextureMap; }
IfcVertexBasedTextureMap::IfcVertexBasedTextureMap(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcVertexBasedTextureMap) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertexBasedTextureMap::IfcVertexBasedTextureMap(IfcTemplatedEntityList< IfcTextureVertex >::ptr v1_TextureVertices, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_TexturePoints) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextureVertices)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TexturePoints)->generalize());entity->setArgument(1,attr);} }

// Function implementations for IfcVertexLoop
IfcVertex* IfcVertexLoop::LoopVertex() const { return (IfcVertex*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcVertexLoop::setLoopVertex(IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcVertexLoop::is(Type::Enum v) const { return v == Type::IfcVertexLoop || IfcLoop::is(v); }
Type::Enum IfcVertexLoop::type() const { return Type::IfcVertexLoop; }
Type::Enum IfcVertexLoop::Class() { return Type::IfcVertexLoop; }
IfcVertexLoop::IfcVertexLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVertexLoop) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertexLoop::IfcVertexLoop(IfcVertex* v1_LoopVertex) : IfcLoop((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LoopVertex));entity->setArgument(0,attr);} }

// Function implementations for IfcVertexPoint
IfcPoint* IfcVertexPoint::VertexGeometry() const { return (IfcPoint*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(0))); }
void IfcVertexPoint::setVertexGeometry(IfcPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(0,attr);} }
bool IfcVertexPoint::is(Type::Enum v) const { return v == Type::IfcVertexPoint || IfcVertex::is(v); }
Type::Enum IfcVertexPoint::type() const { return Type::IfcVertexPoint; }
Type::Enum IfcVertexPoint::Class() { return Type::IfcVertexPoint; }
IfcVertexPoint::IfcVertexPoint(IfcEntityInstanceData* e) : IfcVertex((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVertexPoint) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertexPoint::IfcVertexPoint(IfcPoint* v1_VertexGeometry) : IfcVertex((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VertexGeometry));entity->setArgument(0,attr);} }

// Function implementations for IfcVibrationIsolatorType
IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorType::PredefinedType() const { return IfcVibrationIsolatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcVibrationIsolatorType::setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcVibrationIsolatorTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcVibrationIsolatorType::is(Type::Enum v) const { return v == Type::IfcVibrationIsolatorType || IfcDiscreteAccessoryType::is(v); }
Type::Enum IfcVibrationIsolatorType::type() const { return Type::IfcVibrationIsolatorType; }
Type::Enum IfcVibrationIsolatorType::Class() { return Type::IfcVibrationIsolatorType; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(IfcEntityInstanceData* e) : IfcDiscreteAccessoryType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVibrationIsolatorType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v10_PredefinedType) : IfcDiscreteAccessoryType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcVibrationIsolatorTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcVirtualElement
bool IfcVirtualElement::is(Type::Enum v) const { return v == Type::IfcVirtualElement || IfcElement::is(v); }
Type::Enum IfcVirtualElement::type() const { return Type::IfcVirtualElement; }
Type::Enum IfcVirtualElement::Class() { return Type::IfcVirtualElement; }
IfcVirtualElement::IfcVirtualElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcVirtualElement) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVirtualElement::IfcVirtualElement(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcVirtualGridIntersection
IfcTemplatedEntityList< IfcGridAxis >::ptr IfcVirtualGridIntersection::IntersectingAxes() const { IfcEntityList::ptr es = *entity->getArgument(0); return es->as<IfcGridAxis>(); }
void IfcVirtualGridIntersection::setIntersectingAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(0,attr);} }
std::vector< double > /*[2:3]*/ IfcVirtualGridIntersection::OffsetDistances() const { return *entity->getArgument(1); }
void IfcVirtualGridIntersection::setOffsetDistances(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcVirtualGridIntersection::is(Type::Enum v) const { return v == Type::IfcVirtualGridIntersection; }
Type::Enum IfcVirtualGridIntersection::type() const { return Type::IfcVirtualGridIntersection; }
Type::Enum IfcVirtualGridIntersection::Class() { return Type::IfcVirtualGridIntersection; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != Type::IfcVirtualGridIntersection) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcTemplatedEntityList< IfcGridAxis >::ptr v1_IntersectingAxes, std::vector< double > /*[2:3]*/ v2_OffsetDistances) : IfcUtil::IfcBaseEntity() {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_IntersectingAxes)->generalize());entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OffsetDistances));entity->setArgument(1,attr);} }

// Function implementations for IfcWall
bool IfcWall::is(Type::Enum v) const { return v == Type::IfcWall || IfcBuildingElement::is(v); }
Type::Enum IfcWall::type() const { return Type::IfcWall; }
Type::Enum IfcWall::Class() { return Type::IfcWall; }
IfcWall::IfcWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWall) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWall::IfcWall(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcWallStandardCase
bool IfcWallStandardCase::is(Type::Enum v) const { return v == Type::IfcWallStandardCase || IfcWall::is(v); }
Type::Enum IfcWallStandardCase::type() const { return Type::IfcWallStandardCase; }
Type::Enum IfcWallStandardCase::Class() { return Type::IfcWallStandardCase; }
IfcWallStandardCase::IfcWallStandardCase(IfcEntityInstanceData* e) : IfcWall((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWallStandardCase) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWallStandardCase::IfcWallStandardCase(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcWall((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcWallType
IfcWallTypeEnum::IfcWallTypeEnum IfcWallType::PredefinedType() const { return IfcWallTypeEnum::FromString(*entity->getArgument(9)); }
void IfcWallType::setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWallTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcWallType::is(Type::Enum v) const { return v == Type::IfcWallType || IfcBuildingElementType::is(v); }
Type::Enum IfcWallType::type() const { return Type::IfcWallType; }
Type::Enum IfcWallType::Class() { return Type::IfcWallType; }
IfcWallType::IfcWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWallType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWallType::IfcWallType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWallTypeEnum::IfcWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcWallTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcWasteTerminalType
IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalType::PredefinedType() const { return IfcWasteTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcWasteTerminalType::setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWasteTerminalTypeEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcWasteTerminalType::is(Type::Enum v) const { return v == Type::IfcWasteTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcWasteTerminalType::type() const { return Type::IfcWasteTerminalType; }
Type::Enum IfcWasteTerminalType::Class() { return Type::IfcWasteTerminalType; }
IfcWasteTerminalType::IfcWasteTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWasteTerminalType) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWasteTerminalType::IfcWasteTerminalType(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,IfcWasteTerminalTypeEnum::ToString(v10_PredefinedType))));entity->setArgument(9,attr);} }

// Function implementations for IfcWaterProperties
bool IfcWaterProperties::hasIsPotable() const { return !entity->getArgument(1)->isNull(); }
bool IfcWaterProperties::IsPotable() const { return *entity->getArgument(1); }
void IfcWaterProperties::setIsPotable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(1,attr);} }
bool IfcWaterProperties::hasHardness() const { return !entity->getArgument(2)->isNull(); }
double IfcWaterProperties::Hardness() const { return *entity->getArgument(2); }
void IfcWaterProperties::setHardness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(2,attr);} }
bool IfcWaterProperties::hasAlkalinityConcentration() const { return !entity->getArgument(3)->isNull(); }
double IfcWaterProperties::AlkalinityConcentration() const { return *entity->getArgument(3); }
void IfcWaterProperties::setAlkalinityConcentration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
bool IfcWaterProperties::hasAcidityConcentration() const { return !entity->getArgument(4)->isNull(); }
double IfcWaterProperties::AcidityConcentration() const { return *entity->getArgument(4); }
void IfcWaterProperties::setAcidityConcentration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcWaterProperties::hasImpuritiesContent() const { return !entity->getArgument(5)->isNull(); }
double IfcWaterProperties::ImpuritiesContent() const { return *entity->getArgument(5); }
void IfcWaterProperties::setImpuritiesContent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcWaterProperties::hasPHLevel() const { return !entity->getArgument(6)->isNull(); }
double IfcWaterProperties::PHLevel() const { return *entity->getArgument(6); }
void IfcWaterProperties::setPHLevel(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcWaterProperties::hasDissolvedSolidsContent() const { return !entity->getArgument(7)->isNull(); }
double IfcWaterProperties::DissolvedSolidsContent() const { return *entity->getArgument(7); }
void IfcWaterProperties::setDissolvedSolidsContent(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcWaterProperties::is(Type::Enum v) const { return v == Type::IfcWaterProperties || IfcMaterialProperties::is(v); }
Type::Enum IfcWaterProperties::type() const { return Type::IfcWaterProperties; }
Type::Enum IfcWaterProperties::Class() { return Type::IfcWaterProperties; }
IfcWaterProperties::IfcWaterProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWaterProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWaterProperties::IfcWaterProperties(IfcMaterial* v1_Material, boost::optional< bool > v2_IsPotable, boost::optional< double > v3_Hardness, boost::optional< double > v4_AlkalinityConcentration, boost::optional< double > v5_AcidityConcentration, boost::optional< double > v6_ImpuritiesContent, boost::optional< double > v7_PHLevel, boost::optional< double > v8_DissolvedSolidsContent) : IfcMaterialProperties((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));entity->setArgument(0,attr);} if (v2_IsPotable) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_IsPotable));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); } if (v3_Hardness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Hardness));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_AlkalinityConcentration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_AlkalinityConcentration));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_AcidityConcentration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_AcidityConcentration));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_ImpuritiesContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ImpuritiesContent));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_PHLevel) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_PHLevel));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_DissolvedSolidsContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_DissolvedSolidsContent));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } }

// Function implementations for IfcWindow
bool IfcWindow::hasOverallHeight() const { return !entity->getArgument(8)->isNull(); }
double IfcWindow::OverallHeight() const { return *entity->getArgument(8); }
void IfcWindow::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcWindow::hasOverallWidth() const { return !entity->getArgument(9)->isNull(); }
double IfcWindow::OverallWidth() const { return *entity->getArgument(9); }
void IfcWindow::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcWindow::is(Type::Enum v) const { return v == Type::IfcWindow || IfcBuildingElement::is(v); }
Type::Enum IfcWindow::type() const { return Type::IfcWindow; }
Type::Enum IfcWindow::Class() { return Type::IfcWindow; }
IfcWindow::IfcWindow(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWindow) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindow::IfcWindow(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth) : IfcBuildingElement((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));entity->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } }

// Function implementations for IfcWindowLiningProperties
bool IfcWindowLiningProperties::hasLiningDepth() const { return !entity->getArgument(4)->isNull(); }
double IfcWindowLiningProperties::LiningDepth() const { return *entity->getArgument(4); }
void IfcWindowLiningProperties::setLiningDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
bool IfcWindowLiningProperties::hasLiningThickness() const { return !entity->getArgument(5)->isNull(); }
double IfcWindowLiningProperties::LiningThickness() const { return *entity->getArgument(5); }
void IfcWindowLiningProperties::setLiningThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
bool IfcWindowLiningProperties::hasTransomThickness() const { return !entity->getArgument(6)->isNull(); }
double IfcWindowLiningProperties::TransomThickness() const { return *entity->getArgument(6); }
void IfcWindowLiningProperties::setTransomThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcWindowLiningProperties::hasMullionThickness() const { return !entity->getArgument(7)->isNull(); }
double IfcWindowLiningProperties::MullionThickness() const { return *entity->getArgument(7); }
void IfcWindowLiningProperties::setMullionThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcWindowLiningProperties::hasFirstTransomOffset() const { return !entity->getArgument(8)->isNull(); }
double IfcWindowLiningProperties::FirstTransomOffset() const { return *entity->getArgument(8); }
void IfcWindowLiningProperties::setFirstTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcWindowLiningProperties::hasSecondTransomOffset() const { return !entity->getArgument(9)->isNull(); }
double IfcWindowLiningProperties::SecondTransomOffset() const { return *entity->getArgument(9); }
void IfcWindowLiningProperties::setSecondTransomOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcWindowLiningProperties::hasFirstMullionOffset() const { return !entity->getArgument(10)->isNull(); }
double IfcWindowLiningProperties::FirstMullionOffset() const { return *entity->getArgument(10); }
void IfcWindowLiningProperties::setFirstMullionOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcWindowLiningProperties::hasSecondMullionOffset() const { return !entity->getArgument(11)->isNull(); }
double IfcWindowLiningProperties::SecondMullionOffset() const { return *entity->getArgument(11); }
void IfcWindowLiningProperties::setSecondMullionOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcWindowLiningProperties::hasShapeAspectStyle() const { return !entity->getArgument(12)->isNull(); }
IfcShapeAspect* IfcWindowLiningProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcWindowLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcWindowLiningProperties::is(Type::Enum v) const { return v == Type::IfcWindowLiningProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcWindowLiningProperties::type() const { return Type::IfcWindowLiningProperties; }
Type::Enum IfcWindowLiningProperties::Class() { return Type::IfcWindowLiningProperties; }
IfcWindowLiningProperties::IfcWindowLiningProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWindowLiningProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowLiningProperties::IfcWindowLiningProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_TransomThickness, boost::optional< double > v8_MullionThickness, boost::optional< double > v9_FirstTransomOffset, boost::optional< double > v10_SecondTransomOffset, boost::optional< double > v11_FirstMullionOffset, boost::optional< double > v12_SecondMullionOffset, IfcShapeAspect* v13_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_TransomThickness));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_MullionThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MullionThickness));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_FirstTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FirstTransomOffset));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_SecondTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SecondTransomOffset));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_FirstMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_FirstMullionOffset));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); } if (v12_SecondMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_SecondMullionOffset));entity->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(11, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ShapeAspectStyle));entity->setArgument(12,attr);} }

// Function implementations for IfcWindowPanelProperties
IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelProperties::OperationType() const { return IfcWindowPanelOperationEnum::FromString(*entity->getArgument(4)); }
void IfcWindowPanelProperties::setOperationType(IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelOperationEnum::ToString(v)));entity->setArgument(4,attr);} }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelProperties::PanelPosition() const { return IfcWindowPanelPositionEnum::FromString(*entity->getArgument(5)); }
void IfcWindowPanelProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowPanelPositionEnum::ToString(v)));entity->setArgument(5,attr);} }
bool IfcWindowPanelProperties::hasFrameDepth() const { return !entity->getArgument(6)->isNull(); }
double IfcWindowPanelProperties::FrameDepth() const { return *entity->getArgument(6); }
void IfcWindowPanelProperties::setFrameDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcWindowPanelProperties::hasFrameThickness() const { return !entity->getArgument(7)->isNull(); }
double IfcWindowPanelProperties::FrameThickness() const { return *entity->getArgument(7); }
void IfcWindowPanelProperties::setFrameThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcWindowPanelProperties::hasShapeAspectStyle() const { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcWindowPanelProperties::ShapeAspectStyle() const { return (IfcShapeAspect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(8))); }
void IfcWindowPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcWindowPanelProperties::is(Type::Enum v) const { return v == Type::IfcWindowPanelProperties || IfcPropertySetDefinition::is(v); }
Type::Enum IfcWindowPanelProperties::type() const { return Type::IfcWindowPanelProperties; }
Type::Enum IfcWindowPanelProperties::Class() { return Type::IfcWindowPanelProperties; }
IfcWindowPanelProperties::IfcWindowPanelProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWindowPanelProperties) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowPanelProperties::IfcWindowPanelProperties(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,IfcWindowPanelOperationEnum::ToString(v5_OperationType))));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));entity->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));entity->setArgument(8,attr);} }

// Function implementations for IfcWindowStyle
IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyle::ConstructionType() const { return IfcWindowStyleConstructionEnum::FromString(*entity->getArgument(8)); }
void IfcWindowStyle::setConstructionType(IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowStyleConstructionEnum::ToString(v)));entity->setArgument(8,attr);} }
IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyle::OperationType() const { return IfcWindowStyleOperationEnum::FromString(*entity->getArgument(9)); }
void IfcWindowStyle::setOperationType(IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWindowStyleOperationEnum::ToString(v)));entity->setArgument(9,attr);} }
bool IfcWindowStyle::ParameterTakesPrecedence() const { return *entity->getArgument(10); }
void IfcWindowStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
bool IfcWindowStyle::Sizeable() const { return *entity->getArgument(11); }
void IfcWindowStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcWindowStyle::is(Type::Enum v) const { return v == Type::IfcWindowStyle || IfcTypeProduct::is(v); }
Type::Enum IfcWindowStyle::type() const { return Type::IfcWindowStyle; }
Type::Enum IfcWindowStyle::Class() { return Type::IfcWindowStyle; }
IfcWindowStyle::IfcWindowStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWindowStyle) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowStyle::IfcWindowStyle(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v9_ConstructionType, IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());entity->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());entity->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ConstructionType,IfcWindowStyleConstructionEnum::ToString(v9_ConstructionType))));entity->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_OperationType,IfcWindowStyleOperationEnum::ToString(v10_OperationType))));entity->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));entity->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));entity->setArgument(11,attr);} }

// Function implementations for IfcWorkControl
std::string IfcWorkControl::Identifier() const { return *entity->getArgument(5); }
void IfcWorkControl::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
IfcDateTimeSelect* IfcWorkControl::CreationDate() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(6))); }
void IfcWorkControl::setCreationDate(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcWorkControl::hasCreators() const { return !entity->getArgument(7)->isNull(); }
IfcTemplatedEntityList< IfcPerson >::ptr IfcWorkControl::Creators() const { IfcEntityList::ptr es = *entity->getArgument(7); return es->as<IfcPerson>(); }
void IfcWorkControl::setCreators(IfcTemplatedEntityList< IfcPerson >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v->generalize());entity->setArgument(7,attr);} }
bool IfcWorkControl::hasPurpose() const { return !entity->getArgument(8)->isNull(); }
std::string IfcWorkControl::Purpose() const { return *entity->getArgument(8); }
void IfcWorkControl::setPurpose(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcWorkControl::hasDuration() const { return !entity->getArgument(9)->isNull(); }
double IfcWorkControl::Duration() const { return *entity->getArgument(9); }
void IfcWorkControl::setDuration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(9,attr);} }
bool IfcWorkControl::hasTotalFloat() const { return !entity->getArgument(10)->isNull(); }
double IfcWorkControl::TotalFloat() const { return *entity->getArgument(10); }
void IfcWorkControl::setTotalFloat(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(10,attr);} }
IfcDateTimeSelect* IfcWorkControl::StartTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(11))); }
void IfcWorkControl::setStartTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(11,attr);} }
bool IfcWorkControl::hasFinishTime() const { return !entity->getArgument(12)->isNull(); }
IfcDateTimeSelect* IfcWorkControl::FinishTime() const { return (IfcDateTimeSelect*)((IfcUtil::IfcBaseClass*)(*entity->getArgument(12))); }
void IfcWorkControl::setFinishTime(IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(12,attr);} }
bool IfcWorkControl::hasWorkControlType() const { return !entity->getArgument(13)->isNull(); }
IfcWorkControlTypeEnum::IfcWorkControlTypeEnum IfcWorkControl::WorkControlType() const { return IfcWorkControlTypeEnum::FromString(*entity->getArgument(13)); }
void IfcWorkControl::setWorkControlType(IfcWorkControlTypeEnum::IfcWorkControlTypeEnum v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,IfcWorkControlTypeEnum::ToString(v)));entity->setArgument(13,attr);} }
bool IfcWorkControl::hasUserDefinedControlType() const { return !entity->getArgument(14)->isNull(); }
std::string IfcWorkControl::UserDefinedControlType() const { return *entity->getArgument(14); }
void IfcWorkControl::setUserDefinedControlType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(14,attr);} }
bool IfcWorkControl::is(Type::Enum v) const { return v == Type::IfcWorkControl || IfcControl::is(v); }
Type::Enum IfcWorkControl::type() const { return Type::IfcWorkControl; }
Type::Enum IfcWorkControl::Class() { return Type::IfcWorkControl; }
IfcWorkControl::IfcWorkControl(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWorkControl) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkControl::IfcWorkControl(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));entity->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));entity->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } }

// Function implementations for IfcWorkPlan
bool IfcWorkPlan::is(Type::Enum v) const { return v == Type::IfcWorkPlan || IfcWorkControl::is(v); }
Type::Enum IfcWorkPlan::type() const { return Type::IfcWorkPlan; }
Type::Enum IfcWorkPlan::Class() { return Type::IfcWorkPlan; }
IfcWorkPlan::IfcWorkPlan(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWorkPlan) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkPlan::IfcWorkPlan(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcWorkControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));entity->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));entity->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } }

// Function implementations for IfcWorkSchedule
bool IfcWorkSchedule::is(Type::Enum v) const { return v == Type::IfcWorkSchedule || IfcWorkControl::is(v); }
Type::Enum IfcWorkSchedule::type() const { return Type::IfcWorkSchedule; }
Type::Enum IfcWorkSchedule::Class() { return Type::IfcWorkSchedule; }
IfcWorkSchedule::IfcWorkSchedule(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcWorkSchedule) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkSchedule::IfcWorkSchedule(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcWorkControl((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));entity->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));entity->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));entity->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));entity->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));entity->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));entity->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));entity->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(14, attr); } }

// Function implementations for IfcZShapeProfileDef
double IfcZShapeProfileDef::Depth() const { return *entity->getArgument(3); }
void IfcZShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(3,attr);} }
double IfcZShapeProfileDef::FlangeWidth() const { return *entity->getArgument(4); }
void IfcZShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(4,attr);} }
double IfcZShapeProfileDef::WebThickness() const { return *entity->getArgument(5); }
void IfcZShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(5,attr);} }
double IfcZShapeProfileDef::FlangeThickness() const { return *entity->getArgument(6); }
void IfcZShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(6,attr);} }
bool IfcZShapeProfileDef::hasFilletRadius() const { return !entity->getArgument(7)->isNull(); }
double IfcZShapeProfileDef::FilletRadius() const { return *entity->getArgument(7); }
void IfcZShapeProfileDef::setFilletRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(7,attr);} }
bool IfcZShapeProfileDef::hasEdgeRadius() const { return !entity->getArgument(8)->isNull(); }
double IfcZShapeProfileDef::EdgeRadius() const { return *entity->getArgument(8); }
void IfcZShapeProfileDef::setEdgeRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);entity->setArgument(8,attr);} }
bool IfcZShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcZShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcZShapeProfileDef::type() const { return Type::IfcZShapeProfileDef; }
Type::Enum IfcZShapeProfileDef::Class() { return Type::IfcZShapeProfileDef; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcZShapeProfileDef) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType))));entity->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));entity->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));entity->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));entity->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));entity->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));entity->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));entity->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));entity->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));entity->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(8, attr); } }

// Function implementations for IfcZone
bool IfcZone::is(Type::Enum v) const { return v == Type::IfcZone || IfcGroup::is(v); }
Type::Enum IfcZone::type() const { return Type::IfcZone; }
Type::Enum IfcZone::Class() { return Type::IfcZone; }
IfcZone::IfcZone(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != Type::IfcZone) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcZone::IfcZone(std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {entity = new IfcEntityInstanceData(Class()); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));entity->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));entity->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));entity->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));entity->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));entity->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::none); entity->setArgument(4, attr); } }

#endif
