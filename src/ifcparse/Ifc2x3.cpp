/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC2X3_TC1.exp. Do not make modifications  *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#include "../ifcparse/Ifc2x3.h"
#include "../ifcparse/IfcSchema.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"

#include <map>

const char* const Ifc2x3::Identifier = "IFC2X3";

using namespace IfcParse;
using namespace IfcWrite;

// External definitions
extern entity* IFC2X3_Ifc2DCompositeCurve_type;
extern entity* IFC2X3_IfcActionRequest_type;
extern entity* IFC2X3_IfcActor_type;
extern entity* IFC2X3_IfcActorRole_type;
extern entity* IFC2X3_IfcActuatorType_type;
extern entity* IFC2X3_IfcAddress_type;
extern entity* IFC2X3_IfcAirTerminalBoxType_type;
extern entity* IFC2X3_IfcAirTerminalType_type;
extern entity* IFC2X3_IfcAirToAirHeatRecoveryType_type;
extern entity* IFC2X3_IfcAlarmType_type;
extern entity* IFC2X3_IfcAngularDimension_type;
extern entity* IFC2X3_IfcAnnotation_type;
extern entity* IFC2X3_IfcAnnotationCurveOccurrence_type;
extern entity* IFC2X3_IfcAnnotationFillArea_type;
extern entity* IFC2X3_IfcAnnotationFillAreaOccurrence_type;
extern entity* IFC2X3_IfcAnnotationOccurrence_type;
extern entity* IFC2X3_IfcAnnotationSurface_type;
extern entity* IFC2X3_IfcAnnotationSurfaceOccurrence_type;
extern entity* IFC2X3_IfcAnnotationSymbolOccurrence_type;
extern entity* IFC2X3_IfcAnnotationTextOccurrence_type;
extern entity* IFC2X3_IfcApplication_type;
extern entity* IFC2X3_IfcAppliedValue_type;
extern entity* IFC2X3_IfcAppliedValueRelationship_type;
extern entity* IFC2X3_IfcApproval_type;
extern entity* IFC2X3_IfcApprovalActorRelationship_type;
extern entity* IFC2X3_IfcApprovalPropertyRelationship_type;
extern entity* IFC2X3_IfcApprovalRelationship_type;
extern entity* IFC2X3_IfcArbitraryClosedProfileDef_type;
extern entity* IFC2X3_IfcArbitraryOpenProfileDef_type;
extern entity* IFC2X3_IfcArbitraryProfileDefWithVoids_type;
extern entity* IFC2X3_IfcAsset_type;
extern entity* IFC2X3_IfcAsymmetricIShapeProfileDef_type;
extern entity* IFC2X3_IfcAxis1Placement_type;
extern entity* IFC2X3_IfcAxis2Placement2D_type;
extern entity* IFC2X3_IfcAxis2Placement3D_type;
extern entity* IFC2X3_IfcBSplineCurve_type;
extern entity* IFC2X3_IfcBeam_type;
extern entity* IFC2X3_IfcBeamType_type;
extern entity* IFC2X3_IfcBezierCurve_type;
extern entity* IFC2X3_IfcBlobTexture_type;
extern entity* IFC2X3_IfcBlock_type;
extern entity* IFC2X3_IfcBoilerType_type;
extern entity* IFC2X3_IfcBooleanClippingResult_type;
extern entity* IFC2X3_IfcBooleanResult_type;
extern entity* IFC2X3_IfcBoundaryCondition_type;
extern entity* IFC2X3_IfcBoundaryEdgeCondition_type;
extern entity* IFC2X3_IfcBoundaryFaceCondition_type;
extern entity* IFC2X3_IfcBoundaryNodeCondition_type;
extern entity* IFC2X3_IfcBoundaryNodeConditionWarping_type;
extern entity* IFC2X3_IfcBoundedCurve_type;
extern entity* IFC2X3_IfcBoundedSurface_type;
extern entity* IFC2X3_IfcBoundingBox_type;
extern entity* IFC2X3_IfcBoxedHalfSpace_type;
extern entity* IFC2X3_IfcBuilding_type;
extern entity* IFC2X3_IfcBuildingElement_type;
extern entity* IFC2X3_IfcBuildingElementComponent_type;
extern entity* IFC2X3_IfcBuildingElementPart_type;
extern entity* IFC2X3_IfcBuildingElementProxy_type;
extern entity* IFC2X3_IfcBuildingElementProxyType_type;
extern entity* IFC2X3_IfcBuildingElementType_type;
extern entity* IFC2X3_IfcBuildingStorey_type;
extern entity* IFC2X3_IfcCShapeProfileDef_type;
extern entity* IFC2X3_IfcCableCarrierFittingType_type;
extern entity* IFC2X3_IfcCableCarrierSegmentType_type;
extern entity* IFC2X3_IfcCableSegmentType_type;
extern entity* IFC2X3_IfcCalendarDate_type;
extern entity* IFC2X3_IfcCartesianPoint_type;
extern entity* IFC2X3_IfcCartesianTransformationOperator_type;
extern entity* IFC2X3_IfcCartesianTransformationOperator2D_type;
extern entity* IFC2X3_IfcCartesianTransformationOperator2DnonUniform_type;
extern entity* IFC2X3_IfcCartesianTransformationOperator3D_type;
extern entity* IFC2X3_IfcCartesianTransformationOperator3DnonUniform_type;
extern entity* IFC2X3_IfcCenterLineProfileDef_type;
extern entity* IFC2X3_IfcChamferEdgeFeature_type;
extern entity* IFC2X3_IfcChillerType_type;
extern entity* IFC2X3_IfcCircle_type;
extern entity* IFC2X3_IfcCircleHollowProfileDef_type;
extern entity* IFC2X3_IfcCircleProfileDef_type;
extern entity* IFC2X3_IfcClassification_type;
extern entity* IFC2X3_IfcClassificationItem_type;
extern entity* IFC2X3_IfcClassificationItemRelationship_type;
extern entity* IFC2X3_IfcClassificationNotation_type;
extern entity* IFC2X3_IfcClassificationNotationFacet_type;
extern entity* IFC2X3_IfcClassificationReference_type;
extern entity* IFC2X3_IfcClosedShell_type;
extern entity* IFC2X3_IfcCoilType_type;
extern entity* IFC2X3_IfcColourRgb_type;
extern entity* IFC2X3_IfcColourSpecification_type;
extern entity* IFC2X3_IfcColumn_type;
extern entity* IFC2X3_IfcColumnType_type;
extern entity* IFC2X3_IfcComplexProperty_type;
extern entity* IFC2X3_IfcCompositeCurve_type;
extern entity* IFC2X3_IfcCompositeCurveSegment_type;
extern entity* IFC2X3_IfcCompositeProfileDef_type;
extern entity* IFC2X3_IfcCompressorType_type;
extern entity* IFC2X3_IfcCondenserType_type;
extern entity* IFC2X3_IfcCondition_type;
extern entity* IFC2X3_IfcConditionCriterion_type;
extern entity* IFC2X3_IfcConic_type;
extern entity* IFC2X3_IfcConnectedFaceSet_type;
extern entity* IFC2X3_IfcConnectionCurveGeometry_type;
extern entity* IFC2X3_IfcConnectionGeometry_type;
extern entity* IFC2X3_IfcConnectionPointEccentricity_type;
extern entity* IFC2X3_IfcConnectionPointGeometry_type;
extern entity* IFC2X3_IfcConnectionPortGeometry_type;
extern entity* IFC2X3_IfcConnectionSurfaceGeometry_type;
extern entity* IFC2X3_IfcConstraint_type;
extern entity* IFC2X3_IfcConstraintAggregationRelationship_type;
extern entity* IFC2X3_IfcConstraintClassificationRelationship_type;
extern entity* IFC2X3_IfcConstraintRelationship_type;
extern entity* IFC2X3_IfcConstructionEquipmentResource_type;
extern entity* IFC2X3_IfcConstructionMaterialResource_type;
extern entity* IFC2X3_IfcConstructionProductResource_type;
extern entity* IFC2X3_IfcConstructionResource_type;
extern entity* IFC2X3_IfcContextDependentUnit_type;
extern entity* IFC2X3_IfcControl_type;
extern entity* IFC2X3_IfcControllerType_type;
extern entity* IFC2X3_IfcConversionBasedUnit_type;
extern entity* IFC2X3_IfcCooledBeamType_type;
extern entity* IFC2X3_IfcCoolingTowerType_type;
extern entity* IFC2X3_IfcCoordinatedUniversalTimeOffset_type;
extern entity* IFC2X3_IfcCostItem_type;
extern entity* IFC2X3_IfcCostSchedule_type;
extern entity* IFC2X3_IfcCostValue_type;
extern entity* IFC2X3_IfcCovering_type;
extern entity* IFC2X3_IfcCoveringType_type;
extern entity* IFC2X3_IfcCraneRailAShapeProfileDef_type;
extern entity* IFC2X3_IfcCraneRailFShapeProfileDef_type;
extern entity* IFC2X3_IfcCrewResource_type;
extern entity* IFC2X3_IfcCsgPrimitive3D_type;
extern entity* IFC2X3_IfcCsgSolid_type;
extern entity* IFC2X3_IfcCurrencyRelationship_type;
extern entity* IFC2X3_IfcCurtainWall_type;
extern entity* IFC2X3_IfcCurtainWallType_type;
extern entity* IFC2X3_IfcCurve_type;
extern entity* IFC2X3_IfcCurveBoundedPlane_type;
extern entity* IFC2X3_IfcCurveStyle_type;
extern entity* IFC2X3_IfcCurveStyleFont_type;
extern entity* IFC2X3_IfcCurveStyleFontAndScaling_type;
extern entity* IFC2X3_IfcCurveStyleFontPattern_type;
extern entity* IFC2X3_IfcDamperType_type;
extern entity* IFC2X3_IfcDateAndTime_type;
extern entity* IFC2X3_IfcDefinedSymbol_type;
extern entity* IFC2X3_IfcDerivedProfileDef_type;
extern entity* IFC2X3_IfcDerivedUnit_type;
extern entity* IFC2X3_IfcDerivedUnitElement_type;
extern entity* IFC2X3_IfcDiameterDimension_type;
extern entity* IFC2X3_IfcDimensionCalloutRelationship_type;
extern entity* IFC2X3_IfcDimensionCurve_type;
extern entity* IFC2X3_IfcDimensionCurveDirectedCallout_type;
extern entity* IFC2X3_IfcDimensionCurveTerminator_type;
extern entity* IFC2X3_IfcDimensionPair_type;
extern entity* IFC2X3_IfcDimensionalExponents_type;
extern entity* IFC2X3_IfcDirection_type;
extern entity* IFC2X3_IfcDiscreteAccessory_type;
extern entity* IFC2X3_IfcDiscreteAccessoryType_type;
extern entity* IFC2X3_IfcDistributionChamberElement_type;
extern entity* IFC2X3_IfcDistributionChamberElementType_type;
extern entity* IFC2X3_IfcDistributionControlElement_type;
extern entity* IFC2X3_IfcDistributionControlElementType_type;
extern entity* IFC2X3_IfcDistributionElement_type;
extern entity* IFC2X3_IfcDistributionElementType_type;
extern entity* IFC2X3_IfcDistributionFlowElement_type;
extern entity* IFC2X3_IfcDistributionFlowElementType_type;
extern entity* IFC2X3_IfcDistributionPort_type;
extern entity* IFC2X3_IfcDocumentElectronicFormat_type;
extern entity* IFC2X3_IfcDocumentInformation_type;
extern entity* IFC2X3_IfcDocumentInformationRelationship_type;
extern entity* IFC2X3_IfcDocumentReference_type;
extern entity* IFC2X3_IfcDoor_type;
extern entity* IFC2X3_IfcDoorLiningProperties_type;
extern entity* IFC2X3_IfcDoorPanelProperties_type;
extern entity* IFC2X3_IfcDoorStyle_type;
extern entity* IFC2X3_IfcDraughtingCallout_type;
extern entity* IFC2X3_IfcDraughtingCalloutRelationship_type;
extern entity* IFC2X3_IfcDraughtingPreDefinedColour_type;
extern entity* IFC2X3_IfcDraughtingPreDefinedCurveFont_type;
extern entity* IFC2X3_IfcDraughtingPreDefinedTextFont_type;
extern entity* IFC2X3_IfcDuctFittingType_type;
extern entity* IFC2X3_IfcDuctSegmentType_type;
extern entity* IFC2X3_IfcDuctSilencerType_type;
extern entity* IFC2X3_IfcEdge_type;
extern entity* IFC2X3_IfcEdgeCurve_type;
extern entity* IFC2X3_IfcEdgeFeature_type;
extern entity* IFC2X3_IfcEdgeLoop_type;
extern entity* IFC2X3_IfcElectricApplianceType_type;
extern entity* IFC2X3_IfcElectricDistributionPoint_type;
extern entity* IFC2X3_IfcElectricFlowStorageDeviceType_type;
extern entity* IFC2X3_IfcElectricGeneratorType_type;
extern entity* IFC2X3_IfcElectricHeaterType_type;
extern entity* IFC2X3_IfcElectricMotorType_type;
extern entity* IFC2X3_IfcElectricTimeControlType_type;
extern entity* IFC2X3_IfcElectricalBaseProperties_type;
extern entity* IFC2X3_IfcElectricalCircuit_type;
extern entity* IFC2X3_IfcElectricalElement_type;
extern entity* IFC2X3_IfcElement_type;
extern entity* IFC2X3_IfcElementAssembly_type;
extern entity* IFC2X3_IfcElementComponent_type;
extern entity* IFC2X3_IfcElementComponentType_type;
extern entity* IFC2X3_IfcElementQuantity_type;
extern entity* IFC2X3_IfcElementType_type;
extern entity* IFC2X3_IfcElementarySurface_type;
extern entity* IFC2X3_IfcEllipse_type;
extern entity* IFC2X3_IfcEllipseProfileDef_type;
extern entity* IFC2X3_IfcEnergyConversionDevice_type;
extern entity* IFC2X3_IfcEnergyConversionDeviceType_type;
extern entity* IFC2X3_IfcEnergyProperties_type;
extern entity* IFC2X3_IfcEnvironmentalImpactValue_type;
extern entity* IFC2X3_IfcEquipmentElement_type;
extern entity* IFC2X3_IfcEquipmentStandard_type;
extern entity* IFC2X3_IfcEvaporativeCoolerType_type;
extern entity* IFC2X3_IfcEvaporatorType_type;
extern entity* IFC2X3_IfcExtendedMaterialProperties_type;
extern entity* IFC2X3_IfcExternalReference_type;
extern entity* IFC2X3_IfcExternallyDefinedHatchStyle_type;
extern entity* IFC2X3_IfcExternallyDefinedSurfaceStyle_type;
extern entity* IFC2X3_IfcExternallyDefinedSymbol_type;
extern entity* IFC2X3_IfcExternallyDefinedTextFont_type;
extern entity* IFC2X3_IfcExtrudedAreaSolid_type;
extern entity* IFC2X3_IfcFace_type;
extern entity* IFC2X3_IfcFaceBasedSurfaceModel_type;
extern entity* IFC2X3_IfcFaceBound_type;
extern entity* IFC2X3_IfcFaceOuterBound_type;
extern entity* IFC2X3_IfcFaceSurface_type;
extern entity* IFC2X3_IfcFacetedBrep_type;
extern entity* IFC2X3_IfcFacetedBrepWithVoids_type;
extern entity* IFC2X3_IfcFailureConnectionCondition_type;
extern entity* IFC2X3_IfcFanType_type;
extern entity* IFC2X3_IfcFastener_type;
extern entity* IFC2X3_IfcFastenerType_type;
extern entity* IFC2X3_IfcFeatureElement_type;
extern entity* IFC2X3_IfcFeatureElementAddition_type;
extern entity* IFC2X3_IfcFeatureElementSubtraction_type;
extern entity* IFC2X3_IfcFillAreaStyle_type;
extern entity* IFC2X3_IfcFillAreaStyleHatching_type;
extern entity* IFC2X3_IfcFillAreaStyleTileSymbolWithStyle_type;
extern entity* IFC2X3_IfcFillAreaStyleTiles_type;
extern entity* IFC2X3_IfcFilterType_type;
extern entity* IFC2X3_IfcFireSuppressionTerminalType_type;
extern entity* IFC2X3_IfcFlowController_type;
extern entity* IFC2X3_IfcFlowControllerType_type;
extern entity* IFC2X3_IfcFlowFitting_type;
extern entity* IFC2X3_IfcFlowFittingType_type;
extern entity* IFC2X3_IfcFlowInstrumentType_type;
extern entity* IFC2X3_IfcFlowMeterType_type;
extern entity* IFC2X3_IfcFlowMovingDevice_type;
extern entity* IFC2X3_IfcFlowMovingDeviceType_type;
extern entity* IFC2X3_IfcFlowSegment_type;
extern entity* IFC2X3_IfcFlowSegmentType_type;
extern entity* IFC2X3_IfcFlowStorageDevice_type;
extern entity* IFC2X3_IfcFlowStorageDeviceType_type;
extern entity* IFC2X3_IfcFlowTerminal_type;
extern entity* IFC2X3_IfcFlowTerminalType_type;
extern entity* IFC2X3_IfcFlowTreatmentDevice_type;
extern entity* IFC2X3_IfcFlowTreatmentDeviceType_type;
extern entity* IFC2X3_IfcFluidFlowProperties_type;
extern entity* IFC2X3_IfcFooting_type;
extern entity* IFC2X3_IfcFuelProperties_type;
extern entity* IFC2X3_IfcFurnishingElement_type;
extern entity* IFC2X3_IfcFurnishingElementType_type;
extern entity* IFC2X3_IfcFurnitureStandard_type;
extern entity* IFC2X3_IfcFurnitureType_type;
extern entity* IFC2X3_IfcGasTerminalType_type;
extern entity* IFC2X3_IfcGeneralMaterialProperties_type;
extern entity* IFC2X3_IfcGeneralProfileProperties_type;
extern entity* IFC2X3_IfcGeometricCurveSet_type;
extern entity* IFC2X3_IfcGeometricRepresentationContext_type;
extern entity* IFC2X3_IfcGeometricRepresentationItem_type;
extern entity* IFC2X3_IfcGeometricRepresentationSubContext_type;
extern entity* IFC2X3_IfcGeometricSet_type;
extern entity* IFC2X3_IfcGrid_type;
extern entity* IFC2X3_IfcGridAxis_type;
extern entity* IFC2X3_IfcGridPlacement_type;
extern entity* IFC2X3_IfcGroup_type;
extern entity* IFC2X3_IfcHalfSpaceSolid_type;
extern entity* IFC2X3_IfcHeatExchangerType_type;
extern entity* IFC2X3_IfcHumidifierType_type;
extern entity* IFC2X3_IfcHygroscopicMaterialProperties_type;
extern entity* IFC2X3_IfcIShapeProfileDef_type;
extern entity* IFC2X3_IfcImageTexture_type;
extern entity* IFC2X3_IfcInventory_type;
extern entity* IFC2X3_IfcIrregularTimeSeries_type;
extern entity* IFC2X3_IfcIrregularTimeSeriesValue_type;
extern entity* IFC2X3_IfcJunctionBoxType_type;
extern entity* IFC2X3_IfcLShapeProfileDef_type;
extern entity* IFC2X3_IfcLaborResource_type;
extern entity* IFC2X3_IfcLampType_type;
extern entity* IFC2X3_IfcLibraryInformation_type;
extern entity* IFC2X3_IfcLibraryReference_type;
extern entity* IFC2X3_IfcLightDistributionData_type;
extern entity* IFC2X3_IfcLightFixtureType_type;
extern entity* IFC2X3_IfcLightIntensityDistribution_type;
extern entity* IFC2X3_IfcLightSource_type;
extern entity* IFC2X3_IfcLightSourceAmbient_type;
extern entity* IFC2X3_IfcLightSourceDirectional_type;
extern entity* IFC2X3_IfcLightSourceGoniometric_type;
extern entity* IFC2X3_IfcLightSourcePositional_type;
extern entity* IFC2X3_IfcLightSourceSpot_type;
extern entity* IFC2X3_IfcLine_type;
extern entity* IFC2X3_IfcLinearDimension_type;
extern entity* IFC2X3_IfcLocalPlacement_type;
extern entity* IFC2X3_IfcLocalTime_type;
extern entity* IFC2X3_IfcLoop_type;
extern entity* IFC2X3_IfcManifoldSolidBrep_type;
extern entity* IFC2X3_IfcMappedItem_type;
extern entity* IFC2X3_IfcMaterial_type;
extern entity* IFC2X3_IfcMaterialClassificationRelationship_type;
extern entity* IFC2X3_IfcMaterialDefinitionRepresentation_type;
extern entity* IFC2X3_IfcMaterialLayer_type;
extern entity* IFC2X3_IfcMaterialLayerSet_type;
extern entity* IFC2X3_IfcMaterialLayerSetUsage_type;
extern entity* IFC2X3_IfcMaterialList_type;
extern entity* IFC2X3_IfcMaterialProperties_type;
extern entity* IFC2X3_IfcMeasureWithUnit_type;
extern entity* IFC2X3_IfcMechanicalConcreteMaterialProperties_type;
extern entity* IFC2X3_IfcMechanicalFastener_type;
extern entity* IFC2X3_IfcMechanicalFastenerType_type;
extern entity* IFC2X3_IfcMechanicalMaterialProperties_type;
extern entity* IFC2X3_IfcMechanicalSteelMaterialProperties_type;
extern entity* IFC2X3_IfcMember_type;
extern entity* IFC2X3_IfcMemberType_type;
extern entity* IFC2X3_IfcMetric_type;
extern entity* IFC2X3_IfcMonetaryUnit_type;
extern entity* IFC2X3_IfcMotorConnectionType_type;
extern entity* IFC2X3_IfcMove_type;
extern entity* IFC2X3_IfcNamedUnit_type;
extern entity* IFC2X3_IfcObject_type;
extern entity* IFC2X3_IfcObjectDefinition_type;
extern entity* IFC2X3_IfcObjectPlacement_type;
extern entity* IFC2X3_IfcObjective_type;
extern entity* IFC2X3_IfcOccupant_type;
extern entity* IFC2X3_IfcOffsetCurve2D_type;
extern entity* IFC2X3_IfcOffsetCurve3D_type;
extern entity* IFC2X3_IfcOneDirectionRepeatFactor_type;
extern entity* IFC2X3_IfcOpenShell_type;
extern entity* IFC2X3_IfcOpeningElement_type;
extern entity* IFC2X3_IfcOpticalMaterialProperties_type;
extern entity* IFC2X3_IfcOrderAction_type;
extern entity* IFC2X3_IfcOrganization_type;
extern entity* IFC2X3_IfcOrganizationRelationship_type;
extern entity* IFC2X3_IfcOrientedEdge_type;
extern entity* IFC2X3_IfcOutletType_type;
extern entity* IFC2X3_IfcOwnerHistory_type;
extern entity* IFC2X3_IfcParameterizedProfileDef_type;
extern entity* IFC2X3_IfcPath_type;
extern entity* IFC2X3_IfcPerformanceHistory_type;
extern entity* IFC2X3_IfcPermeableCoveringProperties_type;
extern entity* IFC2X3_IfcPermit_type;
extern entity* IFC2X3_IfcPerson_type;
extern entity* IFC2X3_IfcPersonAndOrganization_type;
extern entity* IFC2X3_IfcPhysicalComplexQuantity_type;
extern entity* IFC2X3_IfcPhysicalQuantity_type;
extern entity* IFC2X3_IfcPhysicalSimpleQuantity_type;
extern entity* IFC2X3_IfcPile_type;
extern entity* IFC2X3_IfcPipeFittingType_type;
extern entity* IFC2X3_IfcPipeSegmentType_type;
extern entity* IFC2X3_IfcPixelTexture_type;
extern entity* IFC2X3_IfcPlacement_type;
extern entity* IFC2X3_IfcPlanarBox_type;
extern entity* IFC2X3_IfcPlanarExtent_type;
extern entity* IFC2X3_IfcPlane_type;
extern entity* IFC2X3_IfcPlate_type;
extern entity* IFC2X3_IfcPlateType_type;
extern entity* IFC2X3_IfcPoint_type;
extern entity* IFC2X3_IfcPointOnCurve_type;
extern entity* IFC2X3_IfcPointOnSurface_type;
extern entity* IFC2X3_IfcPolyLoop_type;
extern entity* IFC2X3_IfcPolygonalBoundedHalfSpace_type;
extern entity* IFC2X3_IfcPolyline_type;
extern entity* IFC2X3_IfcPort_type;
extern entity* IFC2X3_IfcPostalAddress_type;
extern entity* IFC2X3_IfcPreDefinedColour_type;
extern entity* IFC2X3_IfcPreDefinedCurveFont_type;
extern entity* IFC2X3_IfcPreDefinedDimensionSymbol_type;
extern entity* IFC2X3_IfcPreDefinedItem_type;
extern entity* IFC2X3_IfcPreDefinedPointMarkerSymbol_type;
extern entity* IFC2X3_IfcPreDefinedSymbol_type;
extern entity* IFC2X3_IfcPreDefinedTerminatorSymbol_type;
extern entity* IFC2X3_IfcPreDefinedTextFont_type;
extern entity* IFC2X3_IfcPresentationLayerAssignment_type;
extern entity* IFC2X3_IfcPresentationLayerWithStyle_type;
extern entity* IFC2X3_IfcPresentationStyle_type;
extern entity* IFC2X3_IfcPresentationStyleAssignment_type;
extern entity* IFC2X3_IfcProcedure_type;
extern entity* IFC2X3_IfcProcess_type;
extern entity* IFC2X3_IfcProduct_type;
extern entity* IFC2X3_IfcProductDefinitionShape_type;
extern entity* IFC2X3_IfcProductRepresentation_type;
extern entity* IFC2X3_IfcProductsOfCombustionProperties_type;
extern entity* IFC2X3_IfcProfileDef_type;
extern entity* IFC2X3_IfcProfileProperties_type;
extern entity* IFC2X3_IfcProject_type;
extern entity* IFC2X3_IfcProjectOrder_type;
extern entity* IFC2X3_IfcProjectOrderRecord_type;
extern entity* IFC2X3_IfcProjectionCurve_type;
extern entity* IFC2X3_IfcProjectionElement_type;
extern entity* IFC2X3_IfcProperty_type;
extern entity* IFC2X3_IfcPropertyBoundedValue_type;
extern entity* IFC2X3_IfcPropertyConstraintRelationship_type;
extern entity* IFC2X3_IfcPropertyDefinition_type;
extern entity* IFC2X3_IfcPropertyDependencyRelationship_type;
extern entity* IFC2X3_IfcPropertyEnumeratedValue_type;
extern entity* IFC2X3_IfcPropertyEnumeration_type;
extern entity* IFC2X3_IfcPropertyListValue_type;
extern entity* IFC2X3_IfcPropertyReferenceValue_type;
extern entity* IFC2X3_IfcPropertySet_type;
extern entity* IFC2X3_IfcPropertySetDefinition_type;
extern entity* IFC2X3_IfcPropertySingleValue_type;
extern entity* IFC2X3_IfcPropertyTableValue_type;
extern entity* IFC2X3_IfcProtectiveDeviceType_type;
extern entity* IFC2X3_IfcProxy_type;
extern entity* IFC2X3_IfcPumpType_type;
extern entity* IFC2X3_IfcQuantityArea_type;
extern entity* IFC2X3_IfcQuantityCount_type;
extern entity* IFC2X3_IfcQuantityLength_type;
extern entity* IFC2X3_IfcQuantityTime_type;
extern entity* IFC2X3_IfcQuantityVolume_type;
extern entity* IFC2X3_IfcQuantityWeight_type;
extern entity* IFC2X3_IfcRadiusDimension_type;
extern entity* IFC2X3_IfcRailing_type;
extern entity* IFC2X3_IfcRailingType_type;
extern entity* IFC2X3_IfcRamp_type;
extern entity* IFC2X3_IfcRampFlight_type;
extern entity* IFC2X3_IfcRampFlightType_type;
extern entity* IFC2X3_IfcRationalBezierCurve_type;
extern entity* IFC2X3_IfcRectangleHollowProfileDef_type;
extern entity* IFC2X3_IfcRectangleProfileDef_type;
extern entity* IFC2X3_IfcRectangularPyramid_type;
extern entity* IFC2X3_IfcRectangularTrimmedSurface_type;
extern entity* IFC2X3_IfcReferencesValueDocument_type;
extern entity* IFC2X3_IfcRegularTimeSeries_type;
extern entity* IFC2X3_IfcReinforcementBarProperties_type;
extern entity* IFC2X3_IfcReinforcementDefinitionProperties_type;
extern entity* IFC2X3_IfcReinforcingBar_type;
extern entity* IFC2X3_IfcReinforcingElement_type;
extern entity* IFC2X3_IfcReinforcingMesh_type;
extern entity* IFC2X3_IfcRelAggregates_type;
extern entity* IFC2X3_IfcRelAssigns_type;
extern entity* IFC2X3_IfcRelAssignsTasks_type;
extern entity* IFC2X3_IfcRelAssignsToActor_type;
extern entity* IFC2X3_IfcRelAssignsToControl_type;
extern entity* IFC2X3_IfcRelAssignsToGroup_type;
extern entity* IFC2X3_IfcRelAssignsToProcess_type;
extern entity* IFC2X3_IfcRelAssignsToProduct_type;
extern entity* IFC2X3_IfcRelAssignsToProjectOrder_type;
extern entity* IFC2X3_IfcRelAssignsToResource_type;
extern entity* IFC2X3_IfcRelAssociates_type;
extern entity* IFC2X3_IfcRelAssociatesAppliedValue_type;
extern entity* IFC2X3_IfcRelAssociatesApproval_type;
extern entity* IFC2X3_IfcRelAssociatesClassification_type;
extern entity* IFC2X3_IfcRelAssociatesConstraint_type;
extern entity* IFC2X3_IfcRelAssociatesDocument_type;
extern entity* IFC2X3_IfcRelAssociatesLibrary_type;
extern entity* IFC2X3_IfcRelAssociatesMaterial_type;
extern entity* IFC2X3_IfcRelAssociatesProfileProperties_type;
extern entity* IFC2X3_IfcRelConnects_type;
extern entity* IFC2X3_IfcRelConnectsElements_type;
extern entity* IFC2X3_IfcRelConnectsPathElements_type;
extern entity* IFC2X3_IfcRelConnectsPortToElement_type;
extern entity* IFC2X3_IfcRelConnectsPorts_type;
extern entity* IFC2X3_IfcRelConnectsStructuralActivity_type;
extern entity* IFC2X3_IfcRelConnectsStructuralElement_type;
extern entity* IFC2X3_IfcRelConnectsStructuralMember_type;
extern entity* IFC2X3_IfcRelConnectsWithEccentricity_type;
extern entity* IFC2X3_IfcRelConnectsWithRealizingElements_type;
extern entity* IFC2X3_IfcRelContainedInSpatialStructure_type;
extern entity* IFC2X3_IfcRelCoversBldgElements_type;
extern entity* IFC2X3_IfcRelCoversSpaces_type;
extern entity* IFC2X3_IfcRelDecomposes_type;
extern entity* IFC2X3_IfcRelDefines_type;
extern entity* IFC2X3_IfcRelDefinesByProperties_type;
extern entity* IFC2X3_IfcRelDefinesByType_type;
extern entity* IFC2X3_IfcRelFillsElement_type;
extern entity* IFC2X3_IfcRelFlowControlElements_type;
extern entity* IFC2X3_IfcRelInteractionRequirements_type;
extern entity* IFC2X3_IfcRelNests_type;
extern entity* IFC2X3_IfcRelOccupiesSpaces_type;
extern entity* IFC2X3_IfcRelOverridesProperties_type;
extern entity* IFC2X3_IfcRelProjectsElement_type;
extern entity* IFC2X3_IfcRelReferencedInSpatialStructure_type;
extern entity* IFC2X3_IfcRelSchedulesCostItems_type;
extern entity* IFC2X3_IfcRelSequence_type;
extern entity* IFC2X3_IfcRelServicesBuildings_type;
extern entity* IFC2X3_IfcRelSpaceBoundary_type;
extern entity* IFC2X3_IfcRelVoidsElement_type;
extern entity* IFC2X3_IfcRelationship_type;
extern entity* IFC2X3_IfcRelaxation_type;
extern entity* IFC2X3_IfcRepresentation_type;
extern entity* IFC2X3_IfcRepresentationContext_type;
extern entity* IFC2X3_IfcRepresentationItem_type;
extern entity* IFC2X3_IfcRepresentationMap_type;
extern entity* IFC2X3_IfcResource_type;
extern entity* IFC2X3_IfcRevolvedAreaSolid_type;
extern entity* IFC2X3_IfcRibPlateProfileProperties_type;
extern entity* IFC2X3_IfcRightCircularCone_type;
extern entity* IFC2X3_IfcRightCircularCylinder_type;
extern entity* IFC2X3_IfcRoof_type;
extern entity* IFC2X3_IfcRoot_type;
extern entity* IFC2X3_IfcRoundedEdgeFeature_type;
extern entity* IFC2X3_IfcRoundedRectangleProfileDef_type;
extern entity* IFC2X3_IfcSIUnit_type;
extern entity* IFC2X3_IfcSanitaryTerminalType_type;
extern entity* IFC2X3_IfcScheduleTimeControl_type;
extern entity* IFC2X3_IfcSectionProperties_type;
extern entity* IFC2X3_IfcSectionReinforcementProperties_type;
extern entity* IFC2X3_IfcSectionedSpine_type;
extern entity* IFC2X3_IfcSensorType_type;
extern entity* IFC2X3_IfcServiceLife_type;
extern entity* IFC2X3_IfcServiceLifeFactor_type;
extern entity* IFC2X3_IfcShapeAspect_type;
extern entity* IFC2X3_IfcShapeModel_type;
extern entity* IFC2X3_IfcShapeRepresentation_type;
extern entity* IFC2X3_IfcShellBasedSurfaceModel_type;
extern entity* IFC2X3_IfcSimpleProperty_type;
extern entity* IFC2X3_IfcSite_type;
extern entity* IFC2X3_IfcSlab_type;
extern entity* IFC2X3_IfcSlabType_type;
extern entity* IFC2X3_IfcSlippageConnectionCondition_type;
extern entity* IFC2X3_IfcSolidModel_type;
extern entity* IFC2X3_IfcSoundProperties_type;
extern entity* IFC2X3_IfcSoundValue_type;
extern entity* IFC2X3_IfcSpace_type;
extern entity* IFC2X3_IfcSpaceHeaterType_type;
extern entity* IFC2X3_IfcSpaceProgram_type;
extern entity* IFC2X3_IfcSpaceThermalLoadProperties_type;
extern entity* IFC2X3_IfcSpaceType_type;
extern entity* IFC2X3_IfcSpatialStructureElement_type;
extern entity* IFC2X3_IfcSpatialStructureElementType_type;
extern entity* IFC2X3_IfcSphere_type;
extern entity* IFC2X3_IfcStackTerminalType_type;
extern entity* IFC2X3_IfcStair_type;
extern entity* IFC2X3_IfcStairFlight_type;
extern entity* IFC2X3_IfcStairFlightType_type;
extern entity* IFC2X3_IfcStructuralAction_type;
extern entity* IFC2X3_IfcStructuralActivity_type;
extern entity* IFC2X3_IfcStructuralAnalysisModel_type;
extern entity* IFC2X3_IfcStructuralConnection_type;
extern entity* IFC2X3_IfcStructuralConnectionCondition_type;
extern entity* IFC2X3_IfcStructuralCurveConnection_type;
extern entity* IFC2X3_IfcStructuralCurveMember_type;
extern entity* IFC2X3_IfcStructuralCurveMemberVarying_type;
extern entity* IFC2X3_IfcStructuralItem_type;
extern entity* IFC2X3_IfcStructuralLinearAction_type;
extern entity* IFC2X3_IfcStructuralLinearActionVarying_type;
extern entity* IFC2X3_IfcStructuralLoad_type;
extern entity* IFC2X3_IfcStructuralLoadGroup_type;
extern entity* IFC2X3_IfcStructuralLoadLinearForce_type;
extern entity* IFC2X3_IfcStructuralLoadPlanarForce_type;
extern entity* IFC2X3_IfcStructuralLoadSingleDisplacement_type;
extern entity* IFC2X3_IfcStructuralLoadSingleDisplacementDistortion_type;
extern entity* IFC2X3_IfcStructuralLoadSingleForce_type;
extern entity* IFC2X3_IfcStructuralLoadSingleForceWarping_type;
extern entity* IFC2X3_IfcStructuralLoadStatic_type;
extern entity* IFC2X3_IfcStructuralLoadTemperature_type;
extern entity* IFC2X3_IfcStructuralMember_type;
extern entity* IFC2X3_IfcStructuralPlanarAction_type;
extern entity* IFC2X3_IfcStructuralPlanarActionVarying_type;
extern entity* IFC2X3_IfcStructuralPointAction_type;
extern entity* IFC2X3_IfcStructuralPointConnection_type;
extern entity* IFC2X3_IfcStructuralPointReaction_type;
extern entity* IFC2X3_IfcStructuralProfileProperties_type;
extern entity* IFC2X3_IfcStructuralReaction_type;
extern entity* IFC2X3_IfcStructuralResultGroup_type;
extern entity* IFC2X3_IfcStructuralSteelProfileProperties_type;
extern entity* IFC2X3_IfcStructuralSurfaceConnection_type;
extern entity* IFC2X3_IfcStructuralSurfaceMember_type;
extern entity* IFC2X3_IfcStructuralSurfaceMemberVarying_type;
extern entity* IFC2X3_IfcStructuredDimensionCallout_type;
extern entity* IFC2X3_IfcStyleModel_type;
extern entity* IFC2X3_IfcStyledItem_type;
extern entity* IFC2X3_IfcStyledRepresentation_type;
extern entity* IFC2X3_IfcSubContractResource_type;
extern entity* IFC2X3_IfcSubedge_type;
extern entity* IFC2X3_IfcSurface_type;
extern entity* IFC2X3_IfcSurfaceCurveSweptAreaSolid_type;
extern entity* IFC2X3_IfcSurfaceOfLinearExtrusion_type;
extern entity* IFC2X3_IfcSurfaceOfRevolution_type;
extern entity* IFC2X3_IfcSurfaceStyle_type;
extern entity* IFC2X3_IfcSurfaceStyleLighting_type;
extern entity* IFC2X3_IfcSurfaceStyleRefraction_type;
extern entity* IFC2X3_IfcSurfaceStyleRendering_type;
extern entity* IFC2X3_IfcSurfaceStyleShading_type;
extern entity* IFC2X3_IfcSurfaceStyleWithTextures_type;
extern entity* IFC2X3_IfcSurfaceTexture_type;
extern entity* IFC2X3_IfcSweptAreaSolid_type;
extern entity* IFC2X3_IfcSweptDiskSolid_type;
extern entity* IFC2X3_IfcSweptSurface_type;
extern entity* IFC2X3_IfcSwitchingDeviceType_type;
extern entity* IFC2X3_IfcSymbolStyle_type;
extern entity* IFC2X3_IfcSystem_type;
extern entity* IFC2X3_IfcSystemFurnitureElementType_type;
extern entity* IFC2X3_IfcTShapeProfileDef_type;
extern entity* IFC2X3_IfcTable_type;
extern entity* IFC2X3_IfcTableRow_type;
extern entity* IFC2X3_IfcTankType_type;
extern entity* IFC2X3_IfcTask_type;
extern entity* IFC2X3_IfcTelecomAddress_type;
extern entity* IFC2X3_IfcTendon_type;
extern entity* IFC2X3_IfcTendonAnchor_type;
extern entity* IFC2X3_IfcTerminatorSymbol_type;
extern entity* IFC2X3_IfcTextLiteral_type;
extern entity* IFC2X3_IfcTextLiteralWithExtent_type;
extern entity* IFC2X3_IfcTextStyle_type;
extern entity* IFC2X3_IfcTextStyleFontModel_type;
extern entity* IFC2X3_IfcTextStyleForDefinedFont_type;
extern entity* IFC2X3_IfcTextStyleTextModel_type;
extern entity* IFC2X3_IfcTextStyleWithBoxCharacteristics_type;
extern entity* IFC2X3_IfcTextureCoordinate_type;
extern entity* IFC2X3_IfcTextureCoordinateGenerator_type;
extern entity* IFC2X3_IfcTextureMap_type;
extern entity* IFC2X3_IfcTextureVertex_type;
extern entity* IFC2X3_IfcThermalMaterialProperties_type;
extern entity* IFC2X3_IfcTimeSeries_type;
extern entity* IFC2X3_IfcTimeSeriesReferenceRelationship_type;
extern entity* IFC2X3_IfcTimeSeriesSchedule_type;
extern entity* IFC2X3_IfcTimeSeriesValue_type;
extern entity* IFC2X3_IfcTopologicalRepresentationItem_type;
extern entity* IFC2X3_IfcTopologyRepresentation_type;
extern entity* IFC2X3_IfcTransformerType_type;
extern entity* IFC2X3_IfcTransportElement_type;
extern entity* IFC2X3_IfcTransportElementType_type;
extern entity* IFC2X3_IfcTrapeziumProfileDef_type;
extern entity* IFC2X3_IfcTrimmedCurve_type;
extern entity* IFC2X3_IfcTubeBundleType_type;
extern entity* IFC2X3_IfcTwoDirectionRepeatFactor_type;
extern entity* IFC2X3_IfcTypeObject_type;
extern entity* IFC2X3_IfcTypeProduct_type;
extern entity* IFC2X3_IfcUShapeProfileDef_type;
extern entity* IFC2X3_IfcUnitAssignment_type;
extern entity* IFC2X3_IfcUnitaryEquipmentType_type;
extern entity* IFC2X3_IfcValveType_type;
extern entity* IFC2X3_IfcVector_type;
extern entity* IFC2X3_IfcVertex_type;
extern entity* IFC2X3_IfcVertexBasedTextureMap_type;
extern entity* IFC2X3_IfcVertexLoop_type;
extern entity* IFC2X3_IfcVertexPoint_type;
extern entity* IFC2X3_IfcVibrationIsolatorType_type;
extern entity* IFC2X3_IfcVirtualElement_type;
extern entity* IFC2X3_IfcVirtualGridIntersection_type;
extern entity* IFC2X3_IfcWall_type;
extern entity* IFC2X3_IfcWallStandardCase_type;
extern entity* IFC2X3_IfcWallType_type;
extern entity* IFC2X3_IfcWasteTerminalType_type;
extern entity* IFC2X3_IfcWaterProperties_type;
extern entity* IFC2X3_IfcWindow_type;
extern entity* IFC2X3_IfcWindowLiningProperties_type;
extern entity* IFC2X3_IfcWindowPanelProperties_type;
extern entity* IFC2X3_IfcWindowStyle_type;
extern entity* IFC2X3_IfcWorkControl_type;
extern entity* IFC2X3_IfcWorkPlan_type;
extern entity* IFC2X3_IfcWorkSchedule_type;
extern entity* IFC2X3_IfcZShapeProfileDef_type;
extern entity* IFC2X3_IfcZone_type;
extern type_declaration* IFC2X3_IfcAbsorbedDoseMeasure_type;
extern type_declaration* IFC2X3_IfcAccelerationMeasure_type;
extern type_declaration* IFC2X3_IfcAmountOfSubstanceMeasure_type;
extern type_declaration* IFC2X3_IfcAngularVelocityMeasure_type;
extern type_declaration* IFC2X3_IfcAreaMeasure_type;
extern type_declaration* IFC2X3_IfcBoolean_type;
extern type_declaration* IFC2X3_IfcBoxAlignment_type;
extern type_declaration* IFC2X3_IfcComplexNumber_type;
extern type_declaration* IFC2X3_IfcCompoundPlaneAngleMeasure_type;
extern type_declaration* IFC2X3_IfcContextDependentMeasure_type;
extern type_declaration* IFC2X3_IfcCountMeasure_type;
extern type_declaration* IFC2X3_IfcCurvatureMeasure_type;
extern type_declaration* IFC2X3_IfcDayInMonthNumber_type;
extern type_declaration* IFC2X3_IfcDaylightSavingHour_type;
extern type_declaration* IFC2X3_IfcDescriptiveMeasure_type;
extern type_declaration* IFC2X3_IfcDimensionCount_type;
extern type_declaration* IFC2X3_IfcDoseEquivalentMeasure_type;
extern type_declaration* IFC2X3_IfcDynamicViscosityMeasure_type;
extern type_declaration* IFC2X3_IfcElectricCapacitanceMeasure_type;
extern type_declaration* IFC2X3_IfcElectricChargeMeasure_type;
extern type_declaration* IFC2X3_IfcElectricConductanceMeasure_type;
extern type_declaration* IFC2X3_IfcElectricCurrentMeasure_type;
extern type_declaration* IFC2X3_IfcElectricResistanceMeasure_type;
extern type_declaration* IFC2X3_IfcElectricVoltageMeasure_type;
extern type_declaration* IFC2X3_IfcEnergyMeasure_type;
extern type_declaration* IFC2X3_IfcFontStyle_type;
extern type_declaration* IFC2X3_IfcFontVariant_type;
extern type_declaration* IFC2X3_IfcFontWeight_type;
extern type_declaration* IFC2X3_IfcForceMeasure_type;
extern type_declaration* IFC2X3_IfcFrequencyMeasure_type;
extern type_declaration* IFC2X3_IfcGloballyUniqueId_type;
extern type_declaration* IFC2X3_IfcHeatFluxDensityMeasure_type;
extern type_declaration* IFC2X3_IfcHeatingValueMeasure_type;
extern type_declaration* IFC2X3_IfcHourInDay_type;
extern type_declaration* IFC2X3_IfcIdentifier_type;
extern type_declaration* IFC2X3_IfcIlluminanceMeasure_type;
extern type_declaration* IFC2X3_IfcInductanceMeasure_type;
extern type_declaration* IFC2X3_IfcInteger_type;
extern type_declaration* IFC2X3_IfcIntegerCountRateMeasure_type;
extern type_declaration* IFC2X3_IfcIonConcentrationMeasure_type;
extern type_declaration* IFC2X3_IfcIsothermalMoistureCapacityMeasure_type;
extern type_declaration* IFC2X3_IfcKinematicViscosityMeasure_type;
extern type_declaration* IFC2X3_IfcLabel_type;
extern type_declaration* IFC2X3_IfcLengthMeasure_type;
extern type_declaration* IFC2X3_IfcLinearForceMeasure_type;
extern type_declaration* IFC2X3_IfcLinearMomentMeasure_type;
extern type_declaration* IFC2X3_IfcLinearStiffnessMeasure_type;
extern type_declaration* IFC2X3_IfcLinearVelocityMeasure_type;
extern type_declaration* IFC2X3_IfcLogical_type;
extern type_declaration* IFC2X3_IfcLuminousFluxMeasure_type;
extern type_declaration* IFC2X3_IfcLuminousIntensityDistributionMeasure_type;
extern type_declaration* IFC2X3_IfcLuminousIntensityMeasure_type;
extern type_declaration* IFC2X3_IfcMagneticFluxDensityMeasure_type;
extern type_declaration* IFC2X3_IfcMagneticFluxMeasure_type;
extern type_declaration* IFC2X3_IfcMassDensityMeasure_type;
extern type_declaration* IFC2X3_IfcMassFlowRateMeasure_type;
extern type_declaration* IFC2X3_IfcMassMeasure_type;
extern type_declaration* IFC2X3_IfcMassPerLengthMeasure_type;
extern type_declaration* IFC2X3_IfcMinuteInHour_type;
extern type_declaration* IFC2X3_IfcModulusOfElasticityMeasure_type;
extern type_declaration* IFC2X3_IfcModulusOfLinearSubgradeReactionMeasure_type;
extern type_declaration* IFC2X3_IfcModulusOfRotationalSubgradeReactionMeasure_type;
extern type_declaration* IFC2X3_IfcModulusOfSubgradeReactionMeasure_type;
extern type_declaration* IFC2X3_IfcMoistureDiffusivityMeasure_type;
extern type_declaration* IFC2X3_IfcMolecularWeightMeasure_type;
extern type_declaration* IFC2X3_IfcMomentOfInertiaMeasure_type;
extern type_declaration* IFC2X3_IfcMonetaryMeasure_type;
extern type_declaration* IFC2X3_IfcMonthInYearNumber_type;
extern type_declaration* IFC2X3_IfcNormalisedRatioMeasure_type;
extern type_declaration* IFC2X3_IfcNumericMeasure_type;
extern type_declaration* IFC2X3_IfcPHMeasure_type;
extern type_declaration* IFC2X3_IfcParameterValue_type;
extern type_declaration* IFC2X3_IfcPlanarForceMeasure_type;
extern type_declaration* IFC2X3_IfcPlaneAngleMeasure_type;
extern type_declaration* IFC2X3_IfcPositiveLengthMeasure_type;
extern type_declaration* IFC2X3_IfcPositivePlaneAngleMeasure_type;
extern type_declaration* IFC2X3_IfcPositiveRatioMeasure_type;
extern type_declaration* IFC2X3_IfcPowerMeasure_type;
extern type_declaration* IFC2X3_IfcPresentableText_type;
extern type_declaration* IFC2X3_IfcPressureMeasure_type;
extern type_declaration* IFC2X3_IfcRadioActivityMeasure_type;
extern type_declaration* IFC2X3_IfcRatioMeasure_type;
extern type_declaration* IFC2X3_IfcReal_type;
extern type_declaration* IFC2X3_IfcRotationalFrequencyMeasure_type;
extern type_declaration* IFC2X3_IfcRotationalMassMeasure_type;
extern type_declaration* IFC2X3_IfcRotationalStiffnessMeasure_type;
extern type_declaration* IFC2X3_IfcSecondInMinute_type;
extern type_declaration* IFC2X3_IfcSectionModulusMeasure_type;
extern type_declaration* IFC2X3_IfcSectionalAreaIntegralMeasure_type;
extern type_declaration* IFC2X3_IfcShearModulusMeasure_type;
extern type_declaration* IFC2X3_IfcSolidAngleMeasure_type;
extern type_declaration* IFC2X3_IfcSoundPowerMeasure_type;
extern type_declaration* IFC2X3_IfcSoundPressureMeasure_type;
extern type_declaration* IFC2X3_IfcSpecificHeatCapacityMeasure_type;
extern type_declaration* IFC2X3_IfcSpecularExponent_type;
extern type_declaration* IFC2X3_IfcSpecularRoughness_type;
extern type_declaration* IFC2X3_IfcTemperatureGradientMeasure_type;
extern type_declaration* IFC2X3_IfcText_type;
extern type_declaration* IFC2X3_IfcTextAlignment_type;
extern type_declaration* IFC2X3_IfcTextDecoration_type;
extern type_declaration* IFC2X3_IfcTextFontName_type;
extern type_declaration* IFC2X3_IfcTextTransformation_type;
extern type_declaration* IFC2X3_IfcThermalAdmittanceMeasure_type;
extern type_declaration* IFC2X3_IfcThermalConductivityMeasure_type;
extern type_declaration* IFC2X3_IfcThermalExpansionCoefficientMeasure_type;
extern type_declaration* IFC2X3_IfcThermalResistanceMeasure_type;
extern type_declaration* IFC2X3_IfcThermalTransmittanceMeasure_type;
extern type_declaration* IFC2X3_IfcThermodynamicTemperatureMeasure_type;
extern type_declaration* IFC2X3_IfcTimeMeasure_type;
extern type_declaration* IFC2X3_IfcTimeStamp_type;
extern type_declaration* IFC2X3_IfcTorqueMeasure_type;
extern type_declaration* IFC2X3_IfcVaporPermeabilityMeasure_type;
extern type_declaration* IFC2X3_IfcVolumeMeasure_type;
extern type_declaration* IFC2X3_IfcVolumetricFlowRateMeasure_type;
extern type_declaration* IFC2X3_IfcWarpingConstantMeasure_type;
extern type_declaration* IFC2X3_IfcWarpingMomentMeasure_type;
extern type_declaration* IFC2X3_IfcYearNumber_type;
extern enumeration_type* IFC2X3_IfcActionSourceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcActionTypeEnum_type;
extern enumeration_type* IFC2X3_IfcActuatorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAddressTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAheadOrBehind_type;
extern enumeration_type* IFC2X3_IfcAirTerminalBoxTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAirTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAirToAirHeatRecoveryTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAlarmTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAnalysisModelTypeEnum_type;
extern enumeration_type* IFC2X3_IfcAnalysisTheoryTypeEnum_type;
extern enumeration_type* IFC2X3_IfcArithmeticOperatorEnum_type;
extern enumeration_type* IFC2X3_IfcAssemblyPlaceEnum_type;
extern enumeration_type* IFC2X3_IfcBSplineCurveForm_type;
extern enumeration_type* IFC2X3_IfcBeamTypeEnum_type;
extern enumeration_type* IFC2X3_IfcBenchmarkEnum_type;
extern enumeration_type* IFC2X3_IfcBoilerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcBooleanOperator_type;
extern enumeration_type* IFC2X3_IfcBuildingElementProxyTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCableCarrierFittingTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCableCarrierSegmentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCableSegmentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcChangeActionEnum_type;
extern enumeration_type* IFC2X3_IfcChillerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCoilTypeEnum_type;
extern enumeration_type* IFC2X3_IfcColumnTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCompressorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCondenserTypeEnum_type;
extern enumeration_type* IFC2X3_IfcConnectionTypeEnum_type;
extern enumeration_type* IFC2X3_IfcConstraintEnum_type;
extern enumeration_type* IFC2X3_IfcControllerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCooledBeamTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCoolingTowerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCostScheduleTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCoveringTypeEnum_type;
extern enumeration_type* IFC2X3_IfcCurrencyEnum_type;
extern enumeration_type* IFC2X3_IfcCurtainWallTypeEnum_type;
extern enumeration_type* IFC2X3_IfcDamperTypeEnum_type;
extern enumeration_type* IFC2X3_IfcDataOriginEnum_type;
extern enumeration_type* IFC2X3_IfcDerivedUnitEnum_type;
extern enumeration_type* IFC2X3_IfcDimensionExtentUsage_type;
extern enumeration_type* IFC2X3_IfcDirectionSenseEnum_type;
extern enumeration_type* IFC2X3_IfcDistributionChamberElementTypeEnum_type;
extern enumeration_type* IFC2X3_IfcDocumentConfidentialityEnum_type;
extern enumeration_type* IFC2X3_IfcDocumentStatusEnum_type;
extern enumeration_type* IFC2X3_IfcDoorPanelOperationEnum_type;
extern enumeration_type* IFC2X3_IfcDoorPanelPositionEnum_type;
extern enumeration_type* IFC2X3_IfcDoorStyleConstructionEnum_type;
extern enumeration_type* IFC2X3_IfcDoorStyleOperationEnum_type;
extern enumeration_type* IFC2X3_IfcDuctFittingTypeEnum_type;
extern enumeration_type* IFC2X3_IfcDuctSegmentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcDuctSilencerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricApplianceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricCurrentEnum_type;
extern enumeration_type* IFC2X3_IfcElectricDistributionPointFunctionEnum_type;
extern enumeration_type* IFC2X3_IfcElectricFlowStorageDeviceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricGeneratorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricHeaterTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricMotorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElectricTimeControlTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElementAssemblyTypeEnum_type;
extern enumeration_type* IFC2X3_IfcElementCompositionEnum_type;
extern enumeration_type* IFC2X3_IfcEnergySequenceEnum_type;
extern enumeration_type* IFC2X3_IfcEnvironmentalImpactCategoryEnum_type;
extern enumeration_type* IFC2X3_IfcEvaporativeCoolerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcEvaporatorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFanTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFilterTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFireSuppressionTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFlowDirectionEnum_type;
extern enumeration_type* IFC2X3_IfcFlowInstrumentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFlowMeterTypeEnum_type;
extern enumeration_type* IFC2X3_IfcFootingTypeEnum_type;
extern enumeration_type* IFC2X3_IfcGasTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcGeometricProjectionEnum_type;
extern enumeration_type* IFC2X3_IfcGlobalOrLocalEnum_type;
extern enumeration_type* IFC2X3_IfcHeatExchangerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcHumidifierTypeEnum_type;
extern enumeration_type* IFC2X3_IfcInternalOrExternalEnum_type;
extern enumeration_type* IFC2X3_IfcInventoryTypeEnum_type;
extern enumeration_type* IFC2X3_IfcJunctionBoxTypeEnum_type;
extern enumeration_type* IFC2X3_IfcLampTypeEnum_type;
extern enumeration_type* IFC2X3_IfcLayerSetDirectionEnum_type;
extern enumeration_type* IFC2X3_IfcLightDistributionCurveEnum_type;
extern enumeration_type* IFC2X3_IfcLightEmissionSourceEnum_type;
extern enumeration_type* IFC2X3_IfcLightFixtureTypeEnum_type;
extern enumeration_type* IFC2X3_IfcLoadGroupTypeEnum_type;
extern enumeration_type* IFC2X3_IfcLogicalOperatorEnum_type;
extern enumeration_type* IFC2X3_IfcMemberTypeEnum_type;
extern enumeration_type* IFC2X3_IfcMotorConnectionTypeEnum_type;
extern enumeration_type* IFC2X3_IfcNullStyle_type;
extern enumeration_type* IFC2X3_IfcObjectTypeEnum_type;
extern enumeration_type* IFC2X3_IfcObjectiveEnum_type;
extern enumeration_type* IFC2X3_IfcOccupantTypeEnum_type;
extern enumeration_type* IFC2X3_IfcOutletTypeEnum_type;
extern enumeration_type* IFC2X3_IfcPermeableCoveringOperationEnum_type;
extern enumeration_type* IFC2X3_IfcPhysicalOrVirtualEnum_type;
extern enumeration_type* IFC2X3_IfcPileConstructionEnum_type;
extern enumeration_type* IFC2X3_IfcPileTypeEnum_type;
extern enumeration_type* IFC2X3_IfcPipeFittingTypeEnum_type;
extern enumeration_type* IFC2X3_IfcPipeSegmentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcPlateTypeEnum_type;
extern enumeration_type* IFC2X3_IfcProcedureTypeEnum_type;
extern enumeration_type* IFC2X3_IfcProfileTypeEnum_type;
extern enumeration_type* IFC2X3_IfcProjectOrderRecordTypeEnum_type;
extern enumeration_type* IFC2X3_IfcProjectOrderTypeEnum_type;
extern enumeration_type* IFC2X3_IfcProjectedOrTrueLengthEnum_type;
extern enumeration_type* IFC2X3_IfcPropertySourceEnum_type;
extern enumeration_type* IFC2X3_IfcProtectiveDeviceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcPumpTypeEnum_type;
extern enumeration_type* IFC2X3_IfcRailingTypeEnum_type;
extern enumeration_type* IFC2X3_IfcRampFlightTypeEnum_type;
extern enumeration_type* IFC2X3_IfcRampTypeEnum_type;
extern enumeration_type* IFC2X3_IfcReflectanceMethodEnum_type;
extern enumeration_type* IFC2X3_IfcReinforcingBarRoleEnum_type;
extern enumeration_type* IFC2X3_IfcReinforcingBarSurfaceEnum_type;
extern enumeration_type* IFC2X3_IfcResourceConsumptionEnum_type;
extern enumeration_type* IFC2X3_IfcRibPlateDirectionEnum_type;
extern enumeration_type* IFC2X3_IfcRoleEnum_type;
extern enumeration_type* IFC2X3_IfcRoofTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSIPrefix_type;
extern enumeration_type* IFC2X3_IfcSIUnitName_type;
extern enumeration_type* IFC2X3_IfcSanitaryTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSectionTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSensorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSequenceEnum_type;
extern enumeration_type* IFC2X3_IfcServiceLifeFactorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcServiceLifeTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSlabTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSoundScaleEnum_type;
extern enumeration_type* IFC2X3_IfcSpaceHeaterTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSpaceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcStackTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcStairFlightTypeEnum_type;
extern enumeration_type* IFC2X3_IfcStairTypeEnum_type;
extern enumeration_type* IFC2X3_IfcStateEnum_type;
extern enumeration_type* IFC2X3_IfcStructuralCurveTypeEnum_type;
extern enumeration_type* IFC2X3_IfcStructuralSurfaceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcSurfaceSide_type;
extern enumeration_type* IFC2X3_IfcSurfaceTextureEnum_type;
extern enumeration_type* IFC2X3_IfcSwitchingDeviceTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTankTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTendonTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTextPath_type;
extern enumeration_type* IFC2X3_IfcThermalLoadSourceEnum_type;
extern enumeration_type* IFC2X3_IfcThermalLoadTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTimeSeriesDataTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTimeSeriesScheduleTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTransformerTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTransitionCode_type;
extern enumeration_type* IFC2X3_IfcTransportElementTypeEnum_type;
extern enumeration_type* IFC2X3_IfcTrimmingPreference_type;
extern enumeration_type* IFC2X3_IfcTubeBundleTypeEnum_type;
extern enumeration_type* IFC2X3_IfcUnitEnum_type;
extern enumeration_type* IFC2X3_IfcUnitaryEquipmentTypeEnum_type;
extern enumeration_type* IFC2X3_IfcValveTypeEnum_type;
extern enumeration_type* IFC2X3_IfcVibrationIsolatorTypeEnum_type;
extern enumeration_type* IFC2X3_IfcWallTypeEnum_type;
extern enumeration_type* IFC2X3_IfcWasteTerminalTypeEnum_type;
extern enumeration_type* IFC2X3_IfcWindowPanelOperationEnum_type;
extern enumeration_type* IFC2X3_IfcWindowPanelPositionEnum_type;
extern enumeration_type* IFC2X3_IfcWindowStyleConstructionEnum_type;
extern enumeration_type* IFC2X3_IfcWindowStyleOperationEnum_type;
extern enumeration_type* IFC2X3_IfcWorkControlTypeEnum_type;
extern select_type* IFC2X3_IfcActorSelect_type;
extern select_type* IFC2X3_IfcAppliedValueSelect_type;
extern select_type* IFC2X3_IfcAxis2Placement_type;
extern select_type* IFC2X3_IfcBooleanOperand_type;
extern select_type* IFC2X3_IfcCharacterStyleSelect_type;
extern select_type* IFC2X3_IfcClassificationNotationSelect_type;
extern select_type* IFC2X3_IfcColour_type;
extern select_type* IFC2X3_IfcColourOrFactor_type;
extern select_type* IFC2X3_IfcConditionCriterionSelect_type;
extern select_type* IFC2X3_IfcCsgSelect_type;
extern select_type* IFC2X3_IfcCurveFontOrScaledCurveFontSelect_type;
extern select_type* IFC2X3_IfcCurveOrEdgeCurve_type;
extern select_type* IFC2X3_IfcCurveStyleFontSelect_type;
extern select_type* IFC2X3_IfcDateTimeSelect_type;
extern select_type* IFC2X3_IfcDefinedSymbolSelect_type;
extern select_type* IFC2X3_IfcDerivedMeasureValue_type;
extern select_type* IFC2X3_IfcDocumentSelect_type;
extern select_type* IFC2X3_IfcDraughtingCalloutElement_type;
extern select_type* IFC2X3_IfcFillAreaStyleTileShapeSelect_type;
extern select_type* IFC2X3_IfcFillStyleSelect_type;
extern select_type* IFC2X3_IfcGeometricSetSelect_type;
extern select_type* IFC2X3_IfcHatchLineDistanceSelect_type;
extern select_type* IFC2X3_IfcLayeredItem_type;
extern select_type* IFC2X3_IfcLibrarySelect_type;
extern select_type* IFC2X3_IfcLightDistributionDataSourceSelect_type;
extern select_type* IFC2X3_IfcMaterialSelect_type;
extern select_type* IFC2X3_IfcMeasureValue_type;
extern select_type* IFC2X3_IfcMetricValueSelect_type;
extern select_type* IFC2X3_IfcObjectReferenceSelect_type;
extern select_type* IFC2X3_IfcOrientationSelect_type;
extern select_type* IFC2X3_IfcPointOrVertexPoint_type;
extern select_type* IFC2X3_IfcPresentationStyleSelect_type;
extern select_type* IFC2X3_IfcShell_type;
extern select_type* IFC2X3_IfcSimpleValue_type;
extern select_type* IFC2X3_IfcSizeSelect_type;
extern select_type* IFC2X3_IfcSpecularHighlightSelect_type;
extern select_type* IFC2X3_IfcStructuralActivityAssignmentSelect_type;
extern select_type* IFC2X3_IfcSurfaceOrFaceSurface_type;
extern select_type* IFC2X3_IfcSurfaceStyleElementSelect_type;
extern select_type* IFC2X3_IfcSymbolStyleSelect_type;
extern select_type* IFC2X3_IfcTextFontSelect_type;
extern select_type* IFC2X3_IfcTextStyleSelect_type;
extern select_type* IFC2X3_IfcTrimmingSelect_type;
extern select_type* IFC2X3_IfcUnit_type;
extern select_type* IFC2X3_IfcValue_type;
extern select_type* IFC2X3_IfcVectorOrDirection_type;


const IfcParse::enumeration_type& Ifc2x3::IfcActionSourceTypeEnum::declaration() const { return *IFC2X3_IfcActionSourceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcActionSourceTypeEnum::Class() { return *IFC2X3_IfcActionSourceTypeEnum_type; }

Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActionSourceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActionSourceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcActionSourceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 27 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DEAD_LOAD_G", "COMPLETION_G1", "LIVE_LOAD_Q", "SNOW_S", "WIND_W", "PRESTRESSING_P", "SETTLEMENT_U", "TEMPERATURE_T", "EARTHQUAKE_E", "FIRE", "IMPULSE", "IMPACT", "TRANSPORT", "ERECTION", "PROPPING", "SYSTEM_IMPERFECTION", "SHRINKAGE", "CREEP", "LACK_OF_FIT", "BUOYANCY", "ICE", "CURRENT", "WAVE", "RAIN", "BRAKES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcActionSourceTypeEnum::Value Ifc2x3::IfcActionSourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEAD_LOAD_G") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_DEAD_LOAD_G;
    if (s == "COMPLETION_G1") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_COMPLETION_G1;
    if (s == "LIVE_LOAD_Q") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_LIVE_LOAD_Q;
    if (s == "SNOW_S") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SNOW_S;
    if (s == "WIND_W") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_WIND_W;
    if (s == "PRESTRESSING_P") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_PRESTRESSING_P;
    if (s == "SETTLEMENT_U") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SETTLEMENT_U;
    if (s == "TEMPERATURE_T") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_TEMPERATURE_T;
    if (s == "EARTHQUAKE_E") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_EARTHQUAKE_E;
    if (s == "FIRE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_FIRE;
    if (s == "IMPULSE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_IMPULSE;
    if (s == "IMPACT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_IMPACT;
    if (s == "TRANSPORT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_TRANSPORT;
    if (s == "ERECTION") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_ERECTION;
    if (s == "PROPPING") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_PROPPING;
    if (s == "SYSTEM_IMPERFECTION") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SYSTEM_IMPERFECTION;
    if (s == "SHRINKAGE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_SHRINKAGE;
    if (s == "CREEP") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_CREEP;
    if (s == "LACK_OF_FIT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_LACK_OF_FIT;
    if (s == "BUOYANCY") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_BUOYANCY;
    if (s == "ICE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_ICE;
    if (s == "CURRENT") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_CURRENT;
    if (s == "WAVE") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_WAVE;
    if (s == "RAIN") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_RAIN;
    if (s == "BRAKES") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_BRAKES;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActionSourceTypeEnum::IfcActionSourceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcActionSourceTypeEnum::operator Ifc2x3::IfcActionSourceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcActionTypeEnum::declaration() const { return *IFC2X3_IfcActionTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcActionTypeEnum::Class() { return *IFC2X3_IfcActionTypeEnum_type; }

Ifc2x3::IfcActionTypeEnum::IfcActionTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcActionTypeEnum::IfcActionTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcActionTypeEnum::IfcActionTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcActionTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PERMANENT_G", "VARIABLE_Q", "EXTRAORDINARY_A", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcActionTypeEnum::Value Ifc2x3::IfcActionTypeEnum::FromString(const std::string& s) {
    if (s == "PERMANENT_G") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_PERMANENT_G;
    if (s == "VARIABLE_Q") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_VARIABLE_Q;
    if (s == "EXTRAORDINARY_A") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_EXTRAORDINARY_A;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActionTypeEnum::IfcActionType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcActionTypeEnum::operator Ifc2x3::IfcActionTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcActuatorTypeEnum::declaration() const { return *IFC2X3_IfcActuatorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcActuatorTypeEnum::Class() { return *IFC2X3_IfcActuatorTypeEnum_type; }

Ifc2x3::IfcActuatorTypeEnum::IfcActuatorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcActuatorTypeEnum::IfcActuatorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActuatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcActuatorTypeEnum::IfcActuatorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcActuatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcActuatorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ELECTRICACTUATOR", "HANDOPERATEDACTUATOR", "HYDRAULICACTUATOR", "PNEUMATICACTUATOR", "THERMOSTATICACTUATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcActuatorTypeEnum::Value Ifc2x3::IfcActuatorTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_ELECTRICACTUATOR;
    if (s == "HANDOPERATEDACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_HANDOPERATEDACTUATOR;
    if (s == "HYDRAULICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_HYDRAULICACTUATOR;
    if (s == "PNEUMATICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_PNEUMATICACTUATOR;
    if (s == "THERMOSTATICACTUATOR") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_THERMOSTATICACTUATOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcActuatorTypeEnum::IfcActuatorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcActuatorTypeEnum::operator Ifc2x3::IfcActuatorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAddressTypeEnum::declaration() const { return *IFC2X3_IfcAddressTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAddressTypeEnum::Class() { return *IFC2X3_IfcAddressTypeEnum_type; }

Ifc2x3::IfcAddressTypeEnum::IfcAddressTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAddressTypeEnum::IfcAddressTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAddressTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAddressTypeEnum::IfcAddressTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAddressTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAddressTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "HOME", "DISTRIBUTIONPOINT", "USERDEFINED" };
    return names[v];
}

Ifc2x3::IfcAddressTypeEnum::Value Ifc2x3::IfcAddressTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_OFFICE;
    if (s == "SITE") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_SITE;
    if (s == "HOME") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_HOME;
    if (s == "DISTRIBUTIONPOINT") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_DISTRIBUTIONPOINT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAddressTypeEnum::IfcAddressType_USERDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAddressTypeEnum::operator Ifc2x3::IfcAddressTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAheadOrBehind::declaration() const { return *IFC2X3_IfcAheadOrBehind_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAheadOrBehind::Class() { return *IFC2X3_IfcAheadOrBehind_type; }

Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAheadOrBehind_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAheadOrBehind_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAheadOrBehind::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AHEAD", "BEHIND" };
    return names[v];
}

Ifc2x3::IfcAheadOrBehind::Value Ifc2x3::IfcAheadOrBehind::FromString(const std::string& s) {
    if (s == "AHEAD") return ::Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind_AHEAD;
    if (s == "BEHIND") return ::Ifc2x3::IfcAheadOrBehind::IfcAheadOrBehind_BEHIND;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAheadOrBehind::operator Ifc2x3::IfcAheadOrBehind::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAirTerminalBoxTypeEnum::declaration() const { return *IFC2X3_IfcAirTerminalBoxTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAirTerminalBoxTypeEnum::Class() { return *IFC2X3_IfcAirTerminalBoxTypeEnum_type; }

Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalBoxTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalBoxTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAirTerminalBoxTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CONSTANTFLOW", "VARIABLEFLOWPRESSUREDEPENDANT", "VARIABLEFLOWPRESSUREINDEPENDANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAirTerminalBoxTypeEnum::Value Ifc2x3::IfcAirTerminalBoxTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTANTFLOW") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_CONSTANTFLOW;
    if (s == "VARIABLEFLOWPRESSUREDEPENDANT") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT;
    if (s == "VARIABLEFLOWPRESSUREINDEPENDANT") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAirTerminalBoxTypeEnum::operator Ifc2x3::IfcAirTerminalBoxTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAirTerminalTypeEnum::declaration() const { return *IFC2X3_IfcAirTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAirTerminalTypeEnum::Class() { return *IFC2X3_IfcAirTerminalTypeEnum_type; }

Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAirTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GRILLE", "REGISTER", "DIFFUSER", "EYEBALL", "IRIS", "LINEARGRILLE", "LINEARDIFFUSER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAirTerminalTypeEnum::Value Ifc2x3::IfcAirTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "GRILLE") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_GRILLE;
    if (s == "REGISTER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_REGISTER;
    if (s == "DIFFUSER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_DIFFUSER;
    if (s == "EYEBALL") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_EYEBALL;
    if (s == "IRIS") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_IRIS;
    if (s == "LINEARGRILLE") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_LINEARGRILLE;
    if (s == "LINEARDIFFUSER") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_LINEARDIFFUSER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirTerminalTypeEnum::IfcAirTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAirTerminalTypeEnum::operator Ifc2x3::IfcAirTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::declaration() const { return *IFC2X3_IfcAirToAirHeatRecoveryTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Class() { return *IFC2X3_IfcAirToAirHeatRecoveryTypeEnum_type; }

Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirToAirHeatRecoveryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAirToAirHeatRecoveryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FIXEDPLATECOUNTERFLOWEXCHANGER", "FIXEDPLATECROSSFLOWEXCHANGER", "FIXEDPLATEPARALLELFLOWEXCHANGER", "ROTARYWHEEL", "RUNAROUNDCOILLOOP", "HEATPIPE", "TWINTOWERENTHALPYRECOVERYLOOPS", "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS", "THERMOSIPHONCOILTYPEHEATEXCHANGERS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Value Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::FromString(const std::string& s) {
    if (s == "FIXEDPLATECOUNTERFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER;
    if (s == "FIXEDPLATECROSSFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER;
    if (s == "FIXEDPLATEPARALLELFLOWEXCHANGER") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER;
    if (s == "ROTARYWHEEL") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_ROTARYWHEEL;
    if (s == "RUNAROUNDCOILLOOP") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP;
    if (s == "HEATPIPE") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_HEATPIPE;
    if (s == "TWINTOWERENTHALPYRECOVERYLOOPS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS;
    if (s == "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS;
    if (s == "THERMOSIPHONCOILTYPEHEATEXCHANGERS") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::operator Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAlarmTypeEnum::declaration() const { return *IFC2X3_IfcAlarmTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAlarmTypeEnum::Class() { return *IFC2X3_IfcAlarmTypeEnum_type; }

Ifc2x3::IfcAlarmTypeEnum::IfcAlarmTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAlarmTypeEnum::IfcAlarmTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAlarmTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAlarmTypeEnum::IfcAlarmTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAlarmTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAlarmTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BELL", "BREAKGLASSBUTTON", "LIGHT", "MANUALPULLBOX", "SIREN", "WHISTLE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAlarmTypeEnum::Value Ifc2x3::IfcAlarmTypeEnum::FromString(const std::string& s) {
    if (s == "BELL") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_BELL;
    if (s == "BREAKGLASSBUTTON") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_BREAKGLASSBUTTON;
    if (s == "LIGHT") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_LIGHT;
    if (s == "MANUALPULLBOX") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_MANUALPULLBOX;
    if (s == "SIREN") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_SIREN;
    if (s == "WHISTLE") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_WHISTLE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAlarmTypeEnum::IfcAlarmType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAlarmTypeEnum::operator Ifc2x3::IfcAlarmTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAnalysisModelTypeEnum::declaration() const { return *IFC2X3_IfcAnalysisModelTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAnalysisModelTypeEnum::Class() { return *IFC2X3_IfcAnalysisModelTypeEnum_type; }

Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAnalysisModelTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAnalysisModelTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAnalysisModelTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "IN_PLANE_LOADING_2D", "OUT_PLANE_LOADING_2D", "LOADING_3D", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAnalysisModelTypeEnum::Value Ifc2x3::IfcAnalysisModelTypeEnum::FromString(const std::string& s) {
    if (s == "IN_PLANE_LOADING_2D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_IN_PLANE_LOADING_2D;
    if (s == "OUT_PLANE_LOADING_2D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_OUT_PLANE_LOADING_2D;
    if (s == "LOADING_3D") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_LOADING_3D;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAnalysisModelTypeEnum::operator Ifc2x3::IfcAnalysisModelTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAnalysisTheoryTypeEnum::declaration() const { return *IFC2X3_IfcAnalysisTheoryTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAnalysisTheoryTypeEnum::Class() { return *IFC2X3_IfcAnalysisTheoryTypeEnum_type; }

Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAnalysisTheoryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAnalysisTheoryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAnalysisTheoryTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FIRST_ORDER_THEORY", "SECOND_ORDER_THEORY", "THIRD_ORDER_THEORY", "FULL_NONLINEAR_THEORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAnalysisTheoryTypeEnum::Value Ifc2x3::IfcAnalysisTheoryTypeEnum::FromString(const std::string& s) {
    if (s == "FIRST_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FIRST_ORDER_THEORY;
    if (s == "SECOND_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_SECOND_ORDER_THEORY;
    if (s == "THIRD_ORDER_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_THIRD_ORDER_THEORY;
    if (s == "FULL_NONLINEAR_THEORY") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAnalysisTheoryTypeEnum::operator Ifc2x3::IfcAnalysisTheoryTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcArithmeticOperatorEnum::declaration() const { return *IFC2X3_IfcArithmeticOperatorEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcArithmeticOperatorEnum::Class() { return *IFC2X3_IfcArithmeticOperatorEnum_type; }

Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcArithmeticOperatorEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcArithmeticOperatorEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcArithmeticOperatorEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ADD", "DIVIDE", "MULTIPLY", "SUBTRACT" };
    return names[v];
}

Ifc2x3::IfcArithmeticOperatorEnum::Value Ifc2x3::IfcArithmeticOperatorEnum::FromString(const std::string& s) {
    if (s == "ADD") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_ADD;
    if (s == "DIVIDE") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_DIVIDE;
    if (s == "MULTIPLY") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_MULTIPLY;
    if (s == "SUBTRACT") return ::Ifc2x3::IfcArithmeticOperatorEnum::IfcArithmeticOperator_SUBTRACT;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcArithmeticOperatorEnum::operator Ifc2x3::IfcArithmeticOperatorEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcAssemblyPlaceEnum::declaration() const { return *IFC2X3_IfcAssemblyPlaceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcAssemblyPlaceEnum::Class() { return *IFC2X3_IfcAssemblyPlaceEnum_type; }

Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAssemblyPlaceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcAssemblyPlaceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcAssemblyPlaceEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SITE", "FACTORY", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcAssemblyPlaceEnum::Value Ifc2x3::IfcAssemblyPlaceEnum::FromString(const std::string& s) {
    if (s == "SITE") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_SITE;
    if (s == "FACTORY") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_FACTORY;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcAssemblyPlaceEnum::IfcAssemblyPlace_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcAssemblyPlaceEnum::operator Ifc2x3::IfcAssemblyPlaceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBSplineCurveForm::declaration() const { return *IFC2X3_IfcBSplineCurveForm_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBSplineCurveForm::Class() { return *IFC2X3_IfcBSplineCurveForm_type; }

Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBSplineCurveForm_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBSplineCurveForm_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBSplineCurveForm::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "POLYLINE_FORM", "CIRCULAR_ARC", "ELLIPTIC_ARC", "PARABOLIC_ARC", "HYPERBOLIC_ARC", "UNSPECIFIED" };
    return names[v];
}

Ifc2x3::IfcBSplineCurveForm::Value Ifc2x3::IfcBSplineCurveForm::FromString(const std::string& s) {
    if (s == "POLYLINE_FORM") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_POLYLINE_FORM;
    if (s == "CIRCULAR_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_CIRCULAR_ARC;
    if (s == "ELLIPTIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_ELLIPTIC_ARC;
    if (s == "PARABOLIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_PARABOLIC_ARC;
    if (s == "HYPERBOLIC_ARC") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_HYPERBOLIC_ARC;
    if (s == "UNSPECIFIED") return ::Ifc2x3::IfcBSplineCurveForm::IfcBSplineCurveForm_UNSPECIFIED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBSplineCurveForm::operator Ifc2x3::IfcBSplineCurveForm::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBeamTypeEnum::declaration() const { return *IFC2X3_IfcBeamTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBeamTypeEnum::Class() { return *IFC2X3_IfcBeamTypeEnum_type; }

Ifc2x3::IfcBeamTypeEnum::IfcBeamTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBeamTypeEnum::IfcBeamTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBeamTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBeamTypeEnum::IfcBeamTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBeamTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBeamTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BEAM", "JOIST", "LINTEL", "T_BEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcBeamTypeEnum::Value Ifc2x3::IfcBeamTypeEnum::FromString(const std::string& s) {
    if (s == "BEAM") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_BEAM;
    if (s == "JOIST") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_JOIST;
    if (s == "LINTEL") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_LINTEL;
    if (s == "T_BEAM") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_T_BEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBeamTypeEnum::IfcBeamType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBeamTypeEnum::operator Ifc2x3::IfcBeamTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBenchmarkEnum::declaration() const { return *IFC2X3_IfcBenchmarkEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBenchmarkEnum::Class() { return *IFC2X3_IfcBenchmarkEnum_type; }

Ifc2x3::IfcBenchmarkEnum::IfcBenchmarkEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBenchmarkEnum::IfcBenchmarkEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBenchmarkEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBenchmarkEnum::IfcBenchmarkEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBenchmarkEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBenchmarkEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GREATERTHAN", "GREATERTHANOREQUALTO", "LESSTHAN", "LESSTHANOREQUALTO", "EQUALTO", "NOTEQUALTO" };
    return names[v];
}

Ifc2x3::IfcBenchmarkEnum::Value Ifc2x3::IfcBenchmarkEnum::FromString(const std::string& s) {
    if (s == "GREATERTHAN") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_GREATERTHAN;
    if (s == "GREATERTHANOREQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_GREATERTHANOREQUALTO;
    if (s == "LESSTHAN") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_LESSTHAN;
    if (s == "LESSTHANOREQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_LESSTHANOREQUALTO;
    if (s == "EQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_EQUALTO;
    if (s == "NOTEQUALTO") return ::Ifc2x3::IfcBenchmarkEnum::IfcBenchmark_NOTEQUALTO;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBenchmarkEnum::operator Ifc2x3::IfcBenchmarkEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBoilerTypeEnum::declaration() const { return *IFC2X3_IfcBoilerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBoilerTypeEnum::Class() { return *IFC2X3_IfcBoilerTypeEnum_type; }

Ifc2x3::IfcBoilerTypeEnum::IfcBoilerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBoilerTypeEnum::IfcBoilerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBoilerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBoilerTypeEnum::IfcBoilerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBoilerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBoilerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "WATER", "STEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcBoilerTypeEnum::Value Ifc2x3::IfcBoilerTypeEnum::FromString(const std::string& s) {
    if (s == "WATER") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_WATER;
    if (s == "STEAM") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_STEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBoilerTypeEnum::IfcBoilerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBoilerTypeEnum::operator Ifc2x3::IfcBoilerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBooleanOperator::declaration() const { return *IFC2X3_IfcBooleanOperator_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBooleanOperator::Class() { return *IFC2X3_IfcBooleanOperator_type; }

Ifc2x3::IfcBooleanOperator::IfcBooleanOperator(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBooleanOperator::IfcBooleanOperator(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBooleanOperator_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBooleanOperator::IfcBooleanOperator(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBooleanOperator_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBooleanOperator::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "UNION", "INTERSECTION", "DIFFERENCE" };
    return names[v];
}

Ifc2x3::IfcBooleanOperator::Value Ifc2x3::IfcBooleanOperator::FromString(const std::string& s) {
    if (s == "UNION") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_UNION;
    if (s == "INTERSECTION") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_INTERSECTION;
    if (s == "DIFFERENCE") return ::Ifc2x3::IfcBooleanOperator::IfcBooleanOperator_DIFFERENCE;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBooleanOperator::operator Ifc2x3::IfcBooleanOperator::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcBuildingElementProxyTypeEnum::declaration() const { return *IFC2X3_IfcBuildingElementProxyTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcBuildingElementProxyTypeEnum::Class() { return *IFC2X3_IfcBuildingElementProxyTypeEnum_type; }

Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementProxyTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementProxyTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcBuildingElementProxyTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcBuildingElementProxyTypeEnum::Value Ifc2x3::IfcBuildingElementProxyTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcBuildingElementProxyTypeEnum::operator Ifc2x3::IfcBuildingElementProxyTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCableCarrierFittingTypeEnum::declaration() const { return *IFC2X3_IfcCableCarrierFittingTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCableCarrierFittingTypeEnum::Class() { return *IFC2X3_IfcCableCarrierFittingTypeEnum_type; }

Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCableCarrierFittingTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BEND", "CROSS", "REDUCER", "TEE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCableCarrierFittingTypeEnum::Value Ifc2x3::IfcCableCarrierFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_BEND;
    if (s == "CROSS") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_CROSS;
    if (s == "REDUCER") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_REDUCER;
    if (s == "TEE") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_TEE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCableCarrierFittingTypeEnum::operator Ifc2x3::IfcCableCarrierFittingTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCableCarrierSegmentTypeEnum::declaration() const { return *IFC2X3_IfcCableCarrierSegmentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCableCarrierSegmentTypeEnum::Class() { return *IFC2X3_IfcCableCarrierSegmentTypeEnum_type; }

Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCableCarrierSegmentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CABLELADDERSEGMENT", "CABLETRAYSEGMENT", "CABLETRUNKINGSEGMENT", "CONDUITSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCableCarrierSegmentTypeEnum::Value Ifc2x3::IfcCableCarrierSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLELADDERSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLELADDERSEGMENT;
    if (s == "CABLETRAYSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRAYSEGMENT;
    if (s == "CABLETRUNKINGSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT;
    if (s == "CONDUITSEGMENT") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CONDUITSEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCableCarrierSegmentTypeEnum::operator Ifc2x3::IfcCableCarrierSegmentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCableSegmentTypeEnum::declaration() const { return *IFC2X3_IfcCableSegmentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCableSegmentTypeEnum::Class() { return *IFC2X3_IfcCableSegmentTypeEnum_type; }

Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCableSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCableSegmentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CABLESEGMENT", "CONDUCTORSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCableSegmentTypeEnum::Value Ifc2x3::IfcCableSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLESEGMENT") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_CABLESEGMENT;
    if (s == "CONDUCTORSEGMENT") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_CONDUCTORSEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCableSegmentTypeEnum::IfcCableSegmentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCableSegmentTypeEnum::operator Ifc2x3::IfcCableSegmentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcChangeActionEnum::declaration() const { return *IFC2X3_IfcChangeActionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcChangeActionEnum::Class() { return *IFC2X3_IfcChangeActionEnum_type; }

Ifc2x3::IfcChangeActionEnum::IfcChangeActionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcChangeActionEnum::IfcChangeActionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcChangeActionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcChangeActionEnum::IfcChangeActionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcChangeActionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcChangeActionEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "NOCHANGE", "MODIFIED", "ADDED", "DELETED", "MODIFIEDADDED", "MODIFIEDDELETED" };
    return names[v];
}

Ifc2x3::IfcChangeActionEnum::Value Ifc2x3::IfcChangeActionEnum::FromString(const std::string& s) {
    if (s == "NOCHANGE") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_NOCHANGE;
    if (s == "MODIFIED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIED;
    if (s == "ADDED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_ADDED;
    if (s == "DELETED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_DELETED;
    if (s == "MODIFIEDADDED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIEDADDED;
    if (s == "MODIFIEDDELETED") return ::Ifc2x3::IfcChangeActionEnum::IfcChangeAction_MODIFIEDDELETED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcChangeActionEnum::operator Ifc2x3::IfcChangeActionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcChillerTypeEnum::declaration() const { return *IFC2X3_IfcChillerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcChillerTypeEnum::Class() { return *IFC2X3_IfcChillerTypeEnum_type; }

Ifc2x3::IfcChillerTypeEnum::IfcChillerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcChillerTypeEnum::IfcChillerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcChillerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcChillerTypeEnum::IfcChillerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcChillerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcChillerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AIRCOOLED", "WATERCOOLED", "HEATRECOVERY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcChillerTypeEnum::Value Ifc2x3::IfcChillerTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_AIRCOOLED;
    if (s == "WATERCOOLED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_WATERCOOLED;
    if (s == "HEATRECOVERY") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_HEATRECOVERY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcChillerTypeEnum::IfcChillerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcChillerTypeEnum::operator Ifc2x3::IfcChillerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCoilTypeEnum::declaration() const { return *IFC2X3_IfcCoilTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCoilTypeEnum::Class() { return *IFC2X3_IfcCoilTypeEnum_type; }

Ifc2x3::IfcCoilTypeEnum::IfcCoilTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCoilTypeEnum::IfcCoilTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoilTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCoilTypeEnum::IfcCoilTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoilTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCoilTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DXCOOLINGCOIL", "WATERCOOLINGCOIL", "STEAMHEATINGCOIL", "WATERHEATINGCOIL", "ELECTRICHEATINGCOIL", "GASHEATINGCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCoilTypeEnum::Value Ifc2x3::IfcCoilTypeEnum::FromString(const std::string& s) {
    if (s == "DXCOOLINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_DXCOOLINGCOIL;
    if (s == "WATERCOOLINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_WATERCOOLINGCOIL;
    if (s == "STEAMHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_STEAMHEATINGCOIL;
    if (s == "WATERHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_WATERHEATINGCOIL;
    if (s == "ELECTRICHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_ELECTRICHEATINGCOIL;
    if (s == "GASHEATINGCOIL") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_GASHEATINGCOIL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoilTypeEnum::IfcCoilType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCoilTypeEnum::operator Ifc2x3::IfcCoilTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcColumnTypeEnum::declaration() const { return *IFC2X3_IfcColumnTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcColumnTypeEnum::Class() { return *IFC2X3_IfcColumnTypeEnum_type; }

Ifc2x3::IfcColumnTypeEnum::IfcColumnTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcColumnTypeEnum::IfcColumnTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcColumnTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcColumnTypeEnum::IfcColumnTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcColumnTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcColumnTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COLUMN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcColumnTypeEnum::Value Ifc2x3::IfcColumnTypeEnum::FromString(const std::string& s) {
    if (s == "COLUMN") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_COLUMN;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcColumnTypeEnum::IfcColumnType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcColumnTypeEnum::operator Ifc2x3::IfcColumnTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCompressorTypeEnum::declaration() const { return *IFC2X3_IfcCompressorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCompressorTypeEnum::Class() { return *IFC2X3_IfcCompressorTypeEnum_type; }

Ifc2x3::IfcCompressorTypeEnum::IfcCompressorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCompressorTypeEnum::IfcCompressorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCompressorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCompressorTypeEnum::IfcCompressorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCompressorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCompressorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 17 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DYNAMIC", "RECIPROCATING", "ROTARY", "SCROLL", "TROCHOIDAL", "SINGLESTAGE", "BOOSTER", "OPENTYPE", "HERMETIC", "SEMIHERMETIC", "WELDEDSHELLHERMETIC", "ROLLINGPISTON", "ROTARYVANE", "SINGLESCREW", "TWINSCREW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCompressorTypeEnum::Value Ifc2x3::IfcCompressorTypeEnum::FromString(const std::string& s) {
    if (s == "DYNAMIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_DYNAMIC;
    if (s == "RECIPROCATING") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_RECIPROCATING;
    if (s == "ROTARY") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROTARY;
    if (s == "SCROLL") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SCROLL;
    if (s == "TROCHOIDAL") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_TROCHOIDAL;
    if (s == "SINGLESTAGE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SINGLESTAGE;
    if (s == "BOOSTER") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_BOOSTER;
    if (s == "OPENTYPE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_OPENTYPE;
    if (s == "HERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_HERMETIC;
    if (s == "SEMIHERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SEMIHERMETIC;
    if (s == "WELDEDSHELLHERMETIC") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_WELDEDSHELLHERMETIC;
    if (s == "ROLLINGPISTON") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROLLINGPISTON;
    if (s == "ROTARYVANE") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_ROTARYVANE;
    if (s == "SINGLESCREW") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_SINGLESCREW;
    if (s == "TWINSCREW") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_TWINSCREW;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCompressorTypeEnum::IfcCompressorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCompressorTypeEnum::operator Ifc2x3::IfcCompressorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCondenserTypeEnum::declaration() const { return *IFC2X3_IfcCondenserTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCondenserTypeEnum::Class() { return *IFC2X3_IfcCondenserTypeEnum_type; }

Ifc2x3::IfcCondenserTypeEnum::IfcCondenserTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCondenserTypeEnum::IfcCondenserTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCondenserTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCondenserTypeEnum::IfcCondenserTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCondenserTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCondenserTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "WATERCOOLEDSHELLTUBE", "WATERCOOLEDSHELLCOIL", "WATERCOOLEDTUBEINTUBE", "WATERCOOLEDBRAZEDPLATE", "AIRCOOLED", "EVAPORATIVECOOLED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCondenserTypeEnum::Value Ifc2x3::IfcCondenserTypeEnum::FromString(const std::string& s) {
    if (s == "WATERCOOLEDSHELLTUBE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLTUBE;
    if (s == "WATERCOOLEDSHELLCOIL") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLCOIL;
    if (s == "WATERCOOLEDTUBEINTUBE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDTUBEINTUBE;
    if (s == "WATERCOOLEDBRAZEDPLATE") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDBRAZEDPLATE;
    if (s == "AIRCOOLED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_AIRCOOLED;
    if (s == "EVAPORATIVECOOLED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_EVAPORATIVECOOLED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCondenserTypeEnum::IfcCondenserType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCondenserTypeEnum::operator Ifc2x3::IfcCondenserTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcConnectionTypeEnum::declaration() const { return *IFC2X3_IfcConnectionTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcConnectionTypeEnum::Class() { return *IFC2X3_IfcConnectionTypeEnum_type; }

Ifc2x3::IfcConnectionTypeEnum::IfcConnectionTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcConnectionTypeEnum::IfcConnectionTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcConnectionTypeEnum::IfcConnectionTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcConnectionTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ATPATH", "ATSTART", "ATEND", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcConnectionTypeEnum::Value Ifc2x3::IfcConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "ATPATH") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATPATH;
    if (s == "ATSTART") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATSTART;
    if (s == "ATEND") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_ATEND;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcConnectionTypeEnum::IfcConnectionType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcConnectionTypeEnum::operator Ifc2x3::IfcConnectionTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcConstraintEnum::declaration() const { return *IFC2X3_IfcConstraintEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcConstraintEnum::Class() { return *IFC2X3_IfcConstraintEnum_type; }

Ifc2x3::IfcConstraintEnum::IfcConstraintEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcConstraintEnum::IfcConstraintEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraintEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcConstraintEnum::IfcConstraintEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraintEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcConstraintEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "HARD", "SOFT", "ADVISORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcConstraintEnum::Value Ifc2x3::IfcConstraintEnum::FromString(const std::string& s) {
    if (s == "HARD") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_HARD;
    if (s == "SOFT") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_SOFT;
    if (s == "ADVISORY") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_ADVISORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcConstraintEnum::IfcConstraint_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcConstraintEnum::operator Ifc2x3::IfcConstraintEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcControllerTypeEnum::declaration() const { return *IFC2X3_IfcControllerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcControllerTypeEnum::Class() { return *IFC2X3_IfcControllerTypeEnum_type; }

Ifc2x3::IfcControllerTypeEnum::IfcControllerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcControllerTypeEnum::IfcControllerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcControllerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcControllerTypeEnum::IfcControllerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcControllerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcControllerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLOATING", "PROPORTIONAL", "PROPORTIONALINTEGRAL", "PROPORTIONALINTEGRALDERIVATIVE", "TIMEDTWOPOSITION", "TWOPOSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcControllerTypeEnum::Value Ifc2x3::IfcControllerTypeEnum::FromString(const std::string& s) {
    if (s == "FLOATING") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_FLOATING;
    if (s == "PROPORTIONAL") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONAL;
    if (s == "PROPORTIONALINTEGRAL") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONALINTEGRAL;
    if (s == "PROPORTIONALINTEGRALDERIVATIVE") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_PROPORTIONALINTEGRALDERIVATIVE;
    if (s == "TIMEDTWOPOSITION") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_TIMEDTWOPOSITION;
    if (s == "TWOPOSITION") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_TWOPOSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcControllerTypeEnum::IfcControllerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcControllerTypeEnum::operator Ifc2x3::IfcControllerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCooledBeamTypeEnum::declaration() const { return *IFC2X3_IfcCooledBeamTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCooledBeamTypeEnum::Class() { return *IFC2X3_IfcCooledBeamTypeEnum_type; }

Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCooledBeamTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCooledBeamTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCooledBeamTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ACTIVE", "PASSIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCooledBeamTypeEnum::Value Ifc2x3::IfcCooledBeamTypeEnum::FromString(const std::string& s) {
    if (s == "ACTIVE") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_ACTIVE;
    if (s == "PASSIVE") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_PASSIVE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCooledBeamTypeEnum::IfcCooledBeamType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCooledBeamTypeEnum::operator Ifc2x3::IfcCooledBeamTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCoolingTowerTypeEnum::declaration() const { return *IFC2X3_IfcCoolingTowerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCoolingTowerTypeEnum::Class() { return *IFC2X3_IfcCoolingTowerTypeEnum_type; }

Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoolingTowerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoolingTowerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCoolingTowerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "NATURALDRAFT", "MECHANICALINDUCEDDRAFT", "MECHANICALFORCEDDRAFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCoolingTowerTypeEnum::Value Ifc2x3::IfcCoolingTowerTypeEnum::FromString(const std::string& s) {
    if (s == "NATURALDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NATURALDRAFT;
    if (s == "MECHANICALINDUCEDDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALINDUCEDDRAFT;
    if (s == "MECHANICALFORCEDDRAFT") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALFORCEDDRAFT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCoolingTowerTypeEnum::operator Ifc2x3::IfcCoolingTowerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCostScheduleTypeEnum::declaration() const { return *IFC2X3_IfcCostScheduleTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCostScheduleTypeEnum::Class() { return *IFC2X3_IfcCostScheduleTypeEnum_type; }

Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCostScheduleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCostScheduleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCostScheduleTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BUDGET", "COSTPLAN", "ESTIMATE", "TENDER", "PRICEDBILLOFQUANTITIES", "UNPRICEDBILLOFQUANTITIES", "SCHEDULEOFRATES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCostScheduleTypeEnum::Value Ifc2x3::IfcCostScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "BUDGET") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_BUDGET;
    if (s == "COSTPLAN") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_COSTPLAN;
    if (s == "ESTIMATE") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_ESTIMATE;
    if (s == "TENDER") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_TENDER;
    if (s == "PRICEDBILLOFQUANTITIES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_PRICEDBILLOFQUANTITIES;
    if (s == "UNPRICEDBILLOFQUANTITIES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES;
    if (s == "SCHEDULEOFRATES") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_SCHEDULEOFRATES;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCostScheduleTypeEnum::IfcCostScheduleType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCostScheduleTypeEnum::operator Ifc2x3::IfcCostScheduleTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCoveringTypeEnum::declaration() const { return *IFC2X3_IfcCoveringTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCoveringTypeEnum::Class() { return *IFC2X3_IfcCoveringTypeEnum_type; }

Ifc2x3::IfcCoveringTypeEnum::IfcCoveringTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCoveringTypeEnum::IfcCoveringTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoveringTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCoveringTypeEnum::IfcCoveringTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCoveringTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCoveringTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CEILING", "FLOORING", "CLADDING", "ROOFING", "INSULATION", "MEMBRANE", "SLEEVING", "WRAPPING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCoveringTypeEnum::Value Ifc2x3::IfcCoveringTypeEnum::FromString(const std::string& s) {
    if (s == "CEILING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_CEILING;
    if (s == "FLOORING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_FLOORING;
    if (s == "CLADDING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_CLADDING;
    if (s == "ROOFING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_ROOFING;
    if (s == "INSULATION") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_INSULATION;
    if (s == "MEMBRANE") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_MEMBRANE;
    if (s == "SLEEVING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_SLEEVING;
    if (s == "WRAPPING") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_WRAPPING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCoveringTypeEnum::IfcCoveringType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCoveringTypeEnum::operator Ifc2x3::IfcCoveringTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCurrencyEnum::declaration() const { return *IFC2X3_IfcCurrencyEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCurrencyEnum::Class() { return *IFC2X3_IfcCurrencyEnum_type; }

Ifc2x3::IfcCurrencyEnum::IfcCurrencyEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCurrencyEnum::IfcCurrencyEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCurrencyEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCurrencyEnum::IfcCurrencyEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCurrencyEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCurrencyEnum::ToString(Value v) {
    if ( v < 0 || v >= 83 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AED", "AES", "ATS", "AUD", "BBD", "BEG", "BGL", "BHD", "BMD", "BND", "BRL", "BSD", "BWP", "BZD", "CAD", "CBD", "CHF", "CLP", "CNY", "CYS", "CZK", "DDP", "DEM", "DKK", "EGL", "EST", "EUR", "FAK", "FIM", "FJD", "FKP", "FRF", "GBP", "GIP", "GMD", "GRX", "HKD", "HUF", "ICK", "IDR", "ILS", "INR", "IRP", "ITL", "JMD", "JOD", "JPY", "KES", "KRW", "KWD", "KYD", "LKR", "LUF", "MTL", "MUR", "MXN", "MYR", "NLG", "NZD", "OMR", "PGK", "PHP", "PKR", "PLN", "PTN", "QAR", "RUR", "SAR", "SCR", "SEK", "SGD", "SKP", "THB", "TRL", "TTD", "TWD", "USD", "VEB", "VND", "XEU", "ZAR", "ZWD", "NOK" };
    return names[v];
}

Ifc2x3::IfcCurrencyEnum::Value Ifc2x3::IfcCurrencyEnum::FromString(const std::string& s) {
    if (s == "AED") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AED;
    if (s == "AES") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AES;
    if (s == "ATS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ATS;
    if (s == "AUD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_AUD;
    if (s == "BBD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BBD;
    if (s == "BEG") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BEG;
    if (s == "BGL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BGL;
    if (s == "BHD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BHD;
    if (s == "BMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BMD;
    if (s == "BND") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BND;
    if (s == "BRL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BRL;
    if (s == "BSD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BSD;
    if (s == "BWP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BWP;
    if (s == "BZD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_BZD;
    if (s == "CAD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CAD;
    if (s == "CBD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CBD;
    if (s == "CHF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CHF;
    if (s == "CLP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CLP;
    if (s == "CNY") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CNY;
    if (s == "CYS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CYS;
    if (s == "CZK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_CZK;
    if (s == "DDP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DDP;
    if (s == "DEM") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DEM;
    if (s == "DKK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_DKK;
    if (s == "EGL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EGL;
    if (s == "EST") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EST;
    if (s == "EUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_EUR;
    if (s == "FAK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FAK;
    if (s == "FIM") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FIM;
    if (s == "FJD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FJD;
    if (s == "FKP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FKP;
    if (s == "FRF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_FRF;
    if (s == "GBP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GBP;
    if (s == "GIP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GIP;
    if (s == "GMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GMD;
    if (s == "GRX") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_GRX;
    if (s == "HKD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_HKD;
    if (s == "HUF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_HUF;
    if (s == "ICK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ICK;
    if (s == "IDR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_IDR;
    if (s == "ILS") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ILS;
    if (s == "INR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_INR;
    if (s == "IRP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_IRP;
    if (s == "ITL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ITL;
    if (s == "JMD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JMD;
    if (s == "JOD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JOD;
    if (s == "JPY") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_JPY;
    if (s == "KES") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KES;
    if (s == "KRW") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KRW;
    if (s == "KWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KWD;
    if (s == "KYD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_KYD;
    if (s == "LKR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_LKR;
    if (s == "LUF") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_LUF;
    if (s == "MTL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MTL;
    if (s == "MUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MUR;
    if (s == "MXN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MXN;
    if (s == "MYR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_MYR;
    if (s == "NLG") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NLG;
    if (s == "NZD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NZD;
    if (s == "OMR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_OMR;
    if (s == "PGK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PGK;
    if (s == "PHP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PHP;
    if (s == "PKR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PKR;
    if (s == "PLN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PLN;
    if (s == "PTN") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_PTN;
    if (s == "QAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_QAR;
    if (s == "RUR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_RUR;
    if (s == "SAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SAR;
    if (s == "SCR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SCR;
    if (s == "SEK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SEK;
    if (s == "SGD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SGD;
    if (s == "SKP") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_SKP;
    if (s == "THB") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_THB;
    if (s == "TRL") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TRL;
    if (s == "TTD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TTD;
    if (s == "TWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_TWD;
    if (s == "USD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_USD;
    if (s == "VEB") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_VEB;
    if (s == "VND") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_VND;
    if (s == "XEU") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_XEU;
    if (s == "ZAR") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ZAR;
    if (s == "ZWD") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_ZWD;
    if (s == "NOK") return ::Ifc2x3::IfcCurrencyEnum::IfcCurrency_NOK;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCurrencyEnum::operator Ifc2x3::IfcCurrencyEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcCurtainWallTypeEnum::declaration() const { return *IFC2X3_IfcCurtainWallTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcCurtainWallTypeEnum::Class() { return *IFC2X3_IfcCurtainWallTypeEnum_type; }

Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCurtainWallTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcCurtainWallTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcCurtainWallTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcCurtainWallTypeEnum::Value Ifc2x3::IfcCurtainWallTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcCurtainWallTypeEnum::IfcCurtainWallType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcCurtainWallTypeEnum::operator Ifc2x3::IfcCurtainWallTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDamperTypeEnum::declaration() const { return *IFC2X3_IfcDamperTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDamperTypeEnum::Class() { return *IFC2X3_IfcDamperTypeEnum_type; }

Ifc2x3::IfcDamperTypeEnum::IfcDamperTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDamperTypeEnum::IfcDamperTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDamperTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDamperTypeEnum::IfcDamperTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDamperTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDamperTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CONTROLDAMPER", "FIREDAMPER", "SMOKEDAMPER", "FIRESMOKEDAMPER", "BACKDRAFTDAMPER", "RELIEFDAMPER", "BLASTDAMPER", "GRAVITYDAMPER", "GRAVITYRELIEFDAMPER", "BALANCINGDAMPER", "FUMEHOODEXHAUST", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDamperTypeEnum::Value Ifc2x3::IfcDamperTypeEnum::FromString(const std::string& s) {
    if (s == "CONTROLDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_CONTROLDAMPER;
    if (s == "FIREDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FIREDAMPER;
    if (s == "SMOKEDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_SMOKEDAMPER;
    if (s == "FIRESMOKEDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FIRESMOKEDAMPER;
    if (s == "BACKDRAFTDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BACKDRAFTDAMPER;
    if (s == "RELIEFDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_RELIEFDAMPER;
    if (s == "BLASTDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BLASTDAMPER;
    if (s == "GRAVITYDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_GRAVITYDAMPER;
    if (s == "GRAVITYRELIEFDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_GRAVITYRELIEFDAMPER;
    if (s == "BALANCINGDAMPER") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_BALANCINGDAMPER;
    if (s == "FUMEHOODEXHAUST") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_FUMEHOODEXHAUST;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDamperTypeEnum::IfcDamperType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDamperTypeEnum::operator Ifc2x3::IfcDamperTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDataOriginEnum::declaration() const { return *IFC2X3_IfcDataOriginEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDataOriginEnum::Class() { return *IFC2X3_IfcDataOriginEnum_type; }

Ifc2x3::IfcDataOriginEnum::IfcDataOriginEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDataOriginEnum::IfcDataOriginEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDataOriginEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDataOriginEnum::IfcDataOriginEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDataOriginEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDataOriginEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "MEASURED", "PREDICTED", "SIMULATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDataOriginEnum::Value Ifc2x3::IfcDataOriginEnum::FromString(const std::string& s) {
    if (s == "MEASURED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_MEASURED;
    if (s == "PREDICTED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_PREDICTED;
    if (s == "SIMULATED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_SIMULATED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDataOriginEnum::IfcDataOrigin_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDataOriginEnum::operator Ifc2x3::IfcDataOriginEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDerivedUnitEnum::declaration() const { return *IFC2X3_IfcDerivedUnitEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDerivedUnitEnum::Class() { return *IFC2X3_IfcDerivedUnitEnum_type; }

Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnitEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnitEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDerivedUnitEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnitEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDerivedUnitEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDerivedUnitEnum::ToString(Value v) {
    if ( v < 0 || v >= 49 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ANGULARVELOCITYUNIT", "COMPOUNDPLANEANGLEUNIT", "DYNAMICVISCOSITYUNIT", "HEATFLUXDENSITYUNIT", "INTEGERCOUNTRATEUNIT", "ISOTHERMALMOISTURECAPACITYUNIT", "KINEMATICVISCOSITYUNIT", "LINEARVELOCITYUNIT", "MASSDENSITYUNIT", "MASSFLOWRATEUNIT", "MOISTUREDIFFUSIVITYUNIT", "MOLECULARWEIGHTUNIT", "SPECIFICHEATCAPACITYUNIT", "THERMALADMITTANCEUNIT", "THERMALCONDUCTANCEUNIT", "THERMALRESISTANCEUNIT", "THERMALTRANSMITTANCEUNIT", "VAPORPERMEABILITYUNIT", "VOLUMETRICFLOWRATEUNIT", "ROTATIONALFREQUENCYUNIT", "TORQUEUNIT", "MOMENTOFINERTIAUNIT", "LINEARMOMENTUNIT", "LINEARFORCEUNIT", "PLANARFORCEUNIT", "MODULUSOFELASTICITYUNIT", "SHEARMODULUSUNIT", "LINEARSTIFFNESSUNIT", "ROTATIONALSTIFFNESSUNIT", "MODULUSOFSUBGRADEREACTIONUNIT", "ACCELERATIONUNIT", "CURVATUREUNIT", "HEATINGVALUEUNIT", "IONCONCENTRATIONUNIT", "LUMINOUSINTENSITYDISTRIBUTIONUNIT", "MASSPERLENGTHUNIT", "MODULUSOFLINEARSUBGRADEREACTIONUNIT", "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT", "PHUNIT", "ROTATIONALMASSUNIT", "SECTIONAREAINTEGRALUNIT", "SECTIONMODULUSUNIT", "SOUNDPOWERUNIT", "SOUNDPRESSUREUNIT", "TEMPERATUREGRADIENTUNIT", "THERMALEXPANSIONCOEFFICIENTUNIT", "WARPINGCONSTANTUNIT", "WARPINGMOMENTUNIT", "USERDEFINED" };
    return names[v];
}

Ifc2x3::IfcDerivedUnitEnum::Value Ifc2x3::IfcDerivedUnitEnum::FromString(const std::string& s) {
    if (s == "ANGULARVELOCITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ANGULARVELOCITYUNIT;
    if (s == "COMPOUNDPLANEANGLEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT;
    if (s == "DYNAMICVISCOSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_DYNAMICVISCOSITYUNIT;
    if (s == "HEATFLUXDENSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_HEATFLUXDENSITYUNIT;
    if (s == "INTEGERCOUNTRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_INTEGERCOUNTRATEUNIT;
    if (s == "ISOTHERMALMOISTURECAPACITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT;
    if (s == "KINEMATICVISCOSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_KINEMATICVISCOSITYUNIT;
    if (s == "LINEARVELOCITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARVELOCITYUNIT;
    if (s == "MASSDENSITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSDENSITYUNIT;
    if (s == "MASSFLOWRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSFLOWRATEUNIT;
    if (s == "MOISTUREDIFFUSIVITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT;
    if (s == "MOLECULARWEIGHTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOLECULARWEIGHTUNIT;
    if (s == "SPECIFICHEATCAPACITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT;
    if (s == "THERMALADMITTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALADMITTANCEUNIT;
    if (s == "THERMALCONDUCTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALCONDUCTANCEUNIT;
    if (s == "THERMALRESISTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALRESISTANCEUNIT;
    if (s == "THERMALTRANSMITTANCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALTRANSMITTANCEUNIT;
    if (s == "VAPORPERMEABILITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_VAPORPERMEABILITYUNIT;
    if (s == "VOLUMETRICFLOWRATEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT;
    if (s == "ROTATIONALFREQUENCYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALFREQUENCYUNIT;
    if (s == "TORQUEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_TORQUEUNIT;
    if (s == "MOMENTOFINERTIAUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MOMENTOFINERTIAUNIT;
    if (s == "LINEARMOMENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARMOMENTUNIT;
    if (s == "LINEARFORCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARFORCEUNIT;
    if (s == "PLANARFORCEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_PLANARFORCEUNIT;
    if (s == "MODULUSOFELASTICITYUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFELASTICITYUNIT;
    if (s == "SHEARMODULUSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SHEARMODULUSUNIT;
    if (s == "LINEARSTIFFNESSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARSTIFFNESSUNIT;
    if (s == "ROTATIONALSTIFFNESSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT;
    if (s == "MODULUSOFSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT;
    if (s == "ACCELERATIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ACCELERATIONUNIT;
    if (s == "CURVATUREUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_CURVATUREUNIT;
    if (s == "HEATINGVALUEUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_HEATINGVALUEUNIT;
    if (s == "IONCONCENTRATIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_IONCONCENTRATIONUNIT;
    if (s == "LUMINOUSINTENSITYDISTRIBUTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT;
    if (s == "MASSPERLENGTHUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MASSPERLENGTHUNIT;
    if (s == "MODULUSOFLINEARSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT;
    if (s == "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT;
    if (s == "PHUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_PHUNIT;
    if (s == "ROTATIONALMASSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALMASSUNIT;
    if (s == "SECTIONAREAINTEGRALUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONAREAINTEGRALUNIT;
    if (s == "SECTIONMODULUSUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONMODULUSUNIT;
    if (s == "SOUNDPOWERUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERUNIT;
    if (s == "SOUNDPRESSUREUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSUREUNIT;
    if (s == "TEMPERATUREGRADIENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATUREGRADIENTUNIT;
    if (s == "THERMALEXPANSIONCOEFFICIENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT;
    if (s == "WARPINGCONSTANTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGCONSTANTUNIT;
    if (s == "WARPINGMOMENTUNIT") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGMOMENTUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDerivedUnitEnum::IfcDerivedUnit_USERDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDerivedUnitEnum::operator Ifc2x3::IfcDerivedUnitEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDimensionExtentUsage::declaration() const { return *IFC2X3_IfcDimensionExtentUsage_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDimensionExtentUsage::Class() { return *IFC2X3_IfcDimensionExtentUsage_type; }

Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionExtentUsage_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionExtentUsage_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDimensionExtentUsage::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ORIGIN", "TARGET" };
    return names[v];
}

Ifc2x3::IfcDimensionExtentUsage::Value Ifc2x3::IfcDimensionExtentUsage::FromString(const std::string& s) {
    if (s == "ORIGIN") return ::Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage_ORIGIN;
    if (s == "TARGET") return ::Ifc2x3::IfcDimensionExtentUsage::IfcDimensionExtentUsage_TARGET;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDimensionExtentUsage::operator Ifc2x3::IfcDimensionExtentUsage::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDirectionSenseEnum::declaration() const { return *IFC2X3_IfcDirectionSenseEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDirectionSenseEnum::Class() { return *IFC2X3_IfcDirectionSenseEnum_type; }

Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSenseEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSenseEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDirectionSenseEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSenseEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDirectionSenseEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDirectionSenseEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE" };
    return names[v];
}

Ifc2x3::IfcDirectionSenseEnum::Value Ifc2x3::IfcDirectionSenseEnum::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSense_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc2x3::IfcDirectionSenseEnum::IfcDirectionSense_NEGATIVE;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDirectionSenseEnum::operator Ifc2x3::IfcDirectionSenseEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDistributionChamberElementTypeEnum::declaration() const { return *IFC2X3_IfcDistributionChamberElementTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDistributionChamberElementTypeEnum::Class() { return *IFC2X3_IfcDistributionChamberElementTypeEnum_type; }

Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionChamberElementTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionChamberElementTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDistributionChamberElementTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FORMEDDUCT", "INSPECTIONCHAMBER", "INSPECTIONPIT", "MANHOLE", "METERCHAMBER", "SUMP", "TRENCH", "VALVECHAMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDistributionChamberElementTypeEnum::Value Ifc2x3::IfcDistributionChamberElementTypeEnum::FromString(const std::string& s) {
    if (s == "FORMEDDUCT") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_FORMEDDUCT;
    if (s == "INSPECTIONCHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONCHAMBER;
    if (s == "INSPECTIONPIT") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONPIT;
    if (s == "MANHOLE") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_MANHOLE;
    if (s == "METERCHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_METERCHAMBER;
    if (s == "SUMP") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_SUMP;
    if (s == "TRENCH") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_TRENCH;
    if (s == "VALVECHAMBER") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_VALVECHAMBER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDistributionChamberElementTypeEnum::operator Ifc2x3::IfcDistributionChamberElementTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDocumentConfidentialityEnum::declaration() const { return *IFC2X3_IfcDocumentConfidentialityEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDocumentConfidentialityEnum::Class() { return *IFC2X3_IfcDocumentConfidentialityEnum_type; }

Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentConfidentialityEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentConfidentialityEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDocumentConfidentialityEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PUBLIC", "RESTRICTED", "CONFIDENTIAL", "PERSONAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDocumentConfidentialityEnum::Value Ifc2x3::IfcDocumentConfidentialityEnum::FromString(const std::string& s) {
    if (s == "PUBLIC") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PUBLIC;
    if (s == "RESTRICTED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_RESTRICTED;
    if (s == "CONFIDENTIAL") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_CONFIDENTIAL;
    if (s == "PERSONAL") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PERSONAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDocumentConfidentialityEnum::operator Ifc2x3::IfcDocumentConfidentialityEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDocumentStatusEnum::declaration() const { return *IFC2X3_IfcDocumentStatusEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDocumentStatusEnum::Class() { return *IFC2X3_IfcDocumentStatusEnum_type; }

Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatusEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatusEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentStatusEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatusEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentStatusEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDocumentStatusEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DRAFT", "FINALDRAFT", "FINAL", "REVISION", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDocumentStatusEnum::Value Ifc2x3::IfcDocumentStatusEnum::FromString(const std::string& s) {
    if (s == "DRAFT") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_DRAFT;
    if (s == "FINALDRAFT") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_FINALDRAFT;
    if (s == "FINAL") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_FINAL;
    if (s == "REVISION") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_REVISION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDocumentStatusEnum::IfcDocumentStatus_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDocumentStatusEnum::operator Ifc2x3::IfcDocumentStatusEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDoorPanelOperationEnum::declaration() const { return *IFC2X3_IfcDoorPanelOperationEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDoorPanelOperationEnum::Class() { return *IFC2X3_IfcDoorPanelOperationEnum_type; }

Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorPanelOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorPanelOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDoorPanelOperationEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SWINGING", "DOUBLE_ACTING", "SLIDING", "FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDoorPanelOperationEnum::Value Ifc2x3::IfcDoorPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SWINGING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SWINGING;
    if (s == "DOUBLE_ACTING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_DOUBLE_ACTING;
    if (s == "SLIDING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SLIDING;
    if (s == "FOLDING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FOLDING;
    if (s == "REVOLVING") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDoorPanelOperationEnum::operator Ifc2x3::IfcDoorPanelOperationEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDoorPanelPositionEnum::declaration() const { return *IFC2X3_IfcDoorPanelPositionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDoorPanelPositionEnum::Class() { return *IFC2X3_IfcDoorPanelPositionEnum_type; }

Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorPanelPositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorPanelPositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDoorPanelPositionEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDoorPanelPositionEnum::Value Ifc2x3::IfcDoorPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_RIGHT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDoorPanelPositionEnum::operator Ifc2x3::IfcDoorPanelPositionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDoorStyleConstructionEnum::declaration() const { return *IFC2X3_IfcDoorStyleConstructionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDoorStyleConstructionEnum::Class() { return *IFC2X3_IfcDoorStyleConstructionEnum_type; }

Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorStyleConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorStyleConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDoorStyleConstructionEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "ALUMINIUM_PLASTIC", "PLASTIC", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDoorStyleConstructionEnum::Value Ifc2x3::IfcDoorStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_WOOD;
    if (s == "ALUMINIUM_PLASTIC") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_PLASTIC;
    if (s == "PLASTIC") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_PLASTIC;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDoorStyleConstructionEnum::operator Ifc2x3::IfcDoorStyleConstructionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDoorStyleOperationEnum::declaration() const { return *IFC2X3_IfcDoorStyleOperationEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDoorStyleOperationEnum::Class() { return *IFC2X3_IfcDoorStyleOperationEnum_type; }

Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorStyleOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorStyleOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDoorStyleOperationEnum::ToString(Value v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDoorStyleOperationEnum::Value Ifc2x3::IfcDoorStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDoorStyleOperationEnum::operator Ifc2x3::IfcDoorStyleOperationEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDuctFittingTypeEnum::declaration() const { return *IFC2X3_IfcDuctFittingTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDuctFittingTypeEnum::Class() { return *IFC2X3_IfcDuctFittingTypeEnum_type; }

Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDuctFittingTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDuctFittingTypeEnum::Value Ifc2x3::IfcDuctFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctFittingTypeEnum::IfcDuctFittingType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDuctFittingTypeEnum::operator Ifc2x3::IfcDuctFittingTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDuctSegmentTypeEnum::declaration() const { return *IFC2X3_IfcDuctSegmentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDuctSegmentTypeEnum::Class() { return *IFC2X3_IfcDuctSegmentTypeEnum_type; }

Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDuctSegmentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "RIGIDSEGMENT", "FLEXIBLESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDuctSegmentTypeEnum::Value Ifc2x3::IfcDuctSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "RIGIDSEGMENT") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_RIGIDSEGMENT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_FLEXIBLESEGMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDuctSegmentTypeEnum::operator Ifc2x3::IfcDuctSegmentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcDuctSilencerTypeEnum::declaration() const { return *IFC2X3_IfcDuctSilencerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcDuctSilencerTypeEnum::Class() { return *IFC2X3_IfcDuctSilencerTypeEnum_type; }

Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSilencerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSilencerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcDuctSilencerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLATOVAL", "RECTANGULAR", "ROUND", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcDuctSilencerTypeEnum::Value Ifc2x3::IfcDuctSilencerTypeEnum::FromString(const std::string& s) {
    if (s == "FLATOVAL") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_FLATOVAL;
    if (s == "RECTANGULAR") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_RECTANGULAR;
    if (s == "ROUND") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_ROUND;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcDuctSilencerTypeEnum::operator Ifc2x3::IfcDuctSilencerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricApplianceTypeEnum::declaration() const { return *IFC2X3_IfcElectricApplianceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricApplianceTypeEnum::Class() { return *IFC2X3_IfcElectricApplianceTypeEnum_type; }

Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricApplianceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricApplianceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricApplianceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 26 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMPUTER", "DIRECTWATERHEATER", "DISHWASHER", "ELECTRICCOOKER", "ELECTRICHEATER", "FACSIMILE", "FREESTANDINGFAN", "FREEZER", "FRIDGE_FREEZER", "HANDDRYER", "INDIRECTWATERHEATER", "MICROWAVE", "PHOTOCOPIER", "PRINTER", "REFRIGERATOR", "RADIANTHEATER", "SCANNER", "TELEPHONE", "TUMBLEDRYER", "TV", "VENDINGMACHINE", "WASHINGMACHINE", "WATERHEATER", "WATERCOOLER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricApplianceTypeEnum::Value Ifc2x3::IfcElectricApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "COMPUTER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_COMPUTER;
    if (s == "DIRECTWATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DIRECTWATERHEATER;
    if (s == "DISHWASHER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DISHWASHER;
    if (s == "ELECTRICCOOKER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICCOOKER;
    if (s == "ELECTRICHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICHEATER;
    if (s == "FACSIMILE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FACSIMILE;
    if (s == "FREESTANDINGFAN") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGFAN;
    if (s == "FREEZER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREEZER;
    if (s == "FRIDGE_FREEZER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FRIDGE_FREEZER;
    if (s == "HANDDRYER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_HANDDRYER;
    if (s == "INDIRECTWATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_INDIRECTWATERHEATER;
    if (s == "MICROWAVE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_MICROWAVE;
    if (s == "PHOTOCOPIER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PHOTOCOPIER;
    if (s == "PRINTER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PRINTER;
    if (s == "REFRIGERATOR") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_REFRIGERATOR;
    if (s == "RADIANTHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_RADIANTHEATER;
    if (s == "SCANNER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_SCANNER;
    if (s == "TELEPHONE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TELEPHONE;
    if (s == "TUMBLEDRYER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TUMBLEDRYER;
    if (s == "TV") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TV;
    if (s == "VENDINGMACHINE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_VENDINGMACHINE;
    if (s == "WASHINGMACHINE") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WASHINGMACHINE;
    if (s == "WATERHEATER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WATERHEATER;
    if (s == "WATERCOOLER") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WATERCOOLER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricApplianceTypeEnum::operator Ifc2x3::IfcElectricApplianceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricCurrentEnum::declaration() const { return *IFC2X3_IfcElectricCurrentEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricCurrentEnum::Class() { return *IFC2X3_IfcElectricCurrentEnum_type; }

Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrentEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrentEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricCurrentEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrentEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricCurrentEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricCurrentEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ALTERNATING", "DIRECT", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricCurrentEnum::Value Ifc2x3::IfcElectricCurrentEnum::FromString(const std::string& s) {
    if (s == "ALTERNATING") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_ALTERNATING;
    if (s == "DIRECT") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_DIRECT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricCurrentEnum::IfcElectricCurrent_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricCurrentEnum::operator Ifc2x3::IfcElectricCurrentEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricDistributionPointFunctionEnum::declaration() const { return *IFC2X3_IfcElectricDistributionPointFunctionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricDistributionPointFunctionEnum::Class() { return *IFC2X3_IfcElectricDistributionPointFunctionEnum_type; }

Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricDistributionPointFunctionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricDistributionPointFunctionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricDistributionPointFunctionEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ALARMPANEL", "CONSUMERUNIT", "CONTROLPANEL", "DISTRIBUTIONBOARD", "GASDETECTORPANEL", "INDICATORPANEL", "MIMICPANEL", "MOTORCONTROLCENTRE", "SWITCHBOARD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricDistributionPointFunctionEnum::Value Ifc2x3::IfcElectricDistributionPointFunctionEnum::FromString(const std::string& s) {
    if (s == "ALARMPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_ALARMPANEL;
    if (s == "CONSUMERUNIT") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_CONSUMERUNIT;
    if (s == "CONTROLPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_CONTROLPANEL;
    if (s == "DISTRIBUTIONBOARD") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_DISTRIBUTIONBOARD;
    if (s == "GASDETECTORPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_GASDETECTORPANEL;
    if (s == "INDICATORPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_INDICATORPANEL;
    if (s == "MIMICPANEL") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_MIMICPANEL;
    if (s == "MOTORCONTROLCENTRE") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_MOTORCONTROLCENTRE;
    if (s == "SWITCHBOARD") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_SWITCHBOARD;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunction_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricDistributionPointFunctionEnum::operator Ifc2x3::IfcElectricDistributionPointFunctionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::declaration() const { return *IFC2X3_IfcElectricFlowStorageDeviceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Class() { return *IFC2X3_IfcElectricFlowStorageDeviceTypeEnum_type; }

Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricFlowStorageDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricFlowStorageDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BATTERY", "CAPACITORBANK", "HARMONICFILTER", "INDUCTORBANK", "UPS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Value Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "BATTERY") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_BATTERY;
    if (s == "CAPACITORBANK") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_CAPACITORBANK;
    if (s == "HARMONICFILTER") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_HARMONICFILTER;
    if (s == "INDUCTORBANK") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_INDUCTORBANK;
    if (s == "UPS") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_UPS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::operator Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricGeneratorTypeEnum::declaration() const { return *IFC2X3_IfcElectricGeneratorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricGeneratorTypeEnum::Class() { return *IFC2X3_IfcElectricGeneratorTypeEnum_type; }

Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricGeneratorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricGeneratorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricGeneratorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricGeneratorTypeEnum::Value Ifc2x3::IfcElectricGeneratorTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricGeneratorTypeEnum::operator Ifc2x3::IfcElectricGeneratorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricHeaterTypeEnum::declaration() const { return *IFC2X3_IfcElectricHeaterTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricHeaterTypeEnum::Class() { return *IFC2X3_IfcElectricHeaterTypeEnum_type; }

Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricHeaterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricHeaterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricHeaterTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ELECTRICPOINTHEATER", "ELECTRICCABLEHEATER", "ELECTRICMATHEATER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricHeaterTypeEnum::Value Ifc2x3::IfcElectricHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICPOINTHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICPOINTHEATER;
    if (s == "ELECTRICCABLEHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICCABLEHEATER;
    if (s == "ELECTRICMATHEATER") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_ELECTRICMATHEATER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricHeaterTypeEnum::IfcElectricHeaterType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricHeaterTypeEnum::operator Ifc2x3::IfcElectricHeaterTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricMotorTypeEnum::declaration() const { return *IFC2X3_IfcElectricMotorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricMotorTypeEnum::Class() { return *IFC2X3_IfcElectricMotorTypeEnum_type; }

Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricMotorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricMotorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricMotorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DC", "INDUCTION", "POLYPHASE", "RELUCTANCESYNCHRONOUS", "SYNCHRONOUS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricMotorTypeEnum::Value Ifc2x3::IfcElectricMotorTypeEnum::FromString(const std::string& s) {
    if (s == "DC") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_DC;
    if (s == "INDUCTION") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_INDUCTION;
    if (s == "POLYPHASE") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_POLYPHASE;
    if (s == "RELUCTANCESYNCHRONOUS") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_RELUCTANCESYNCHRONOUS;
    if (s == "SYNCHRONOUS") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_SYNCHRONOUS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricMotorTypeEnum::IfcElectricMotorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricMotorTypeEnum::operator Ifc2x3::IfcElectricMotorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElectricTimeControlTypeEnum::declaration() const { return *IFC2X3_IfcElectricTimeControlTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElectricTimeControlTypeEnum::Class() { return *IFC2X3_IfcElectricTimeControlTypeEnum_type; }

Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricTimeControlTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricTimeControlTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElectricTimeControlTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "TIMECLOCK", "TIMEDELAY", "RELAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElectricTimeControlTypeEnum::Value Ifc2x3::IfcElectricTimeControlTypeEnum::FromString(const std::string& s) {
    if (s == "TIMECLOCK") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMECLOCK;
    if (s == "TIMEDELAY") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMEDELAY;
    if (s == "RELAY") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_RELAY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElectricTimeControlTypeEnum::operator Ifc2x3::IfcElectricTimeControlTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElementAssemblyTypeEnum::declaration() const { return *IFC2X3_IfcElementAssemblyTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElementAssemblyTypeEnum::Class() { return *IFC2X3_IfcElementAssemblyTypeEnum_type; }

Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElementAssemblyTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElementAssemblyTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElementAssemblyTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ACCESSORY_ASSEMBLY", "ARCH", "BEAM_GRID", "BRACED_FRAME", "GIRDER", "REINFORCEMENT_UNIT", "RIGID_FRAME", "SLAB_FIELD", "TRUSS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcElementAssemblyTypeEnum::Value Ifc2x3::IfcElementAssemblyTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESSORY_ASSEMBLY") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ACCESSORY_ASSEMBLY;
    if (s == "ARCH") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ARCH;
    if (s == "BEAM_GRID") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BEAM_GRID;
    if (s == "BRACED_FRAME") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BRACED_FRAME;
    if (s == "GIRDER") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_GIRDER;
    if (s == "REINFORCEMENT_UNIT") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_REINFORCEMENT_UNIT;
    if (s == "RIGID_FRAME") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_RIGID_FRAME;
    if (s == "SLAB_FIELD") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_SLAB_FIELD;
    if (s == "TRUSS") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_TRUSS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElementAssemblyTypeEnum::operator Ifc2x3::IfcElementAssemblyTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcElementCompositionEnum::declaration() const { return *IFC2X3_IfcElementCompositionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcElementCompositionEnum::Class() { return *IFC2X3_IfcElementCompositionEnum_type; }

Ifc2x3::IfcElementCompositionEnum::IfcElementCompositionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcElementCompositionEnum::IfcElementCompositionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElementCompositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcElementCompositionEnum::IfcElementCompositionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcElementCompositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcElementCompositionEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL" };
    return names[v];
}

Ifc2x3::IfcElementCompositionEnum::Value Ifc2x3::IfcElementCompositionEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_COMPLEX;
    if (s == "ELEMENT") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_ELEMENT;
    if (s == "PARTIAL") return ::Ifc2x3::IfcElementCompositionEnum::IfcElementComposition_PARTIAL;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcElementCompositionEnum::operator Ifc2x3::IfcElementCompositionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcEnergySequenceEnum::declaration() const { return *IFC2X3_IfcEnergySequenceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcEnergySequenceEnum::Class() { return *IFC2X3_IfcEnergySequenceEnum_type; }

Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequenceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequenceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergySequenceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequenceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergySequenceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcEnergySequenceEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PRIMARY", "SECONDARY", "TERTIARY", "AUXILIARY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcEnergySequenceEnum::Value Ifc2x3::IfcEnergySequenceEnum::FromString(const std::string& s) {
    if (s == "PRIMARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_PRIMARY;
    if (s == "SECONDARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_SECONDARY;
    if (s == "TERTIARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_TERTIARY;
    if (s == "AUXILIARY") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_AUXILIARY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEnergySequenceEnum::IfcEnergySequence_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcEnergySequenceEnum::operator Ifc2x3::IfcEnergySequenceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcEnvironmentalImpactCategoryEnum::declaration() const { return *IFC2X3_IfcEnvironmentalImpactCategoryEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Class() { return *IFC2X3_IfcEnvironmentalImpactCategoryEnum_type; }

Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEnvironmentalImpactCategoryEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEnvironmentalImpactCategoryEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcEnvironmentalImpactCategoryEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMBINEDVALUE", "DISPOSAL", "EXTRACTION", "INSTALLATION", "MANUFACTURE", "TRANSPORTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Value Ifc2x3::IfcEnvironmentalImpactCategoryEnum::FromString(const std::string& s) {
    if (s == "COMBINEDVALUE") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_COMBINEDVALUE;
    if (s == "DISPOSAL") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_DISPOSAL;
    if (s == "EXTRACTION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_EXTRACTION;
    if (s == "INSTALLATION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_INSTALLATION;
    if (s == "MANUFACTURE") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_MANUFACTURE;
    if (s == "TRANSPORTATION") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_TRANSPORTATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategory_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcEnvironmentalImpactCategoryEnum::operator Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcEvaporativeCoolerTypeEnum::declaration() const { return *IFC2X3_IfcEvaporativeCoolerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcEvaporativeCoolerTypeEnum::Class() { return *IFC2X3_IfcEvaporativeCoolerTypeEnum_type; }

Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporativeCoolerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporativeCoolerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcEvaporativeCoolerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER", "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER", "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER", "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER", "DIRECTEVAPORATIVEAIRWASHER", "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER", "INDIRECTEVAPORATIVEWETCOIL", "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER", "INDIRECTDIRECTCOMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcEvaporativeCoolerTypeEnum::Value Ifc2x3::IfcEvaporativeCoolerTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEAIRWASHER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER;
    if (s == "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER;
    if (s == "INDIRECTEVAPORATIVEWETCOIL") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL;
    if (s == "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER;
    if (s == "INDIRECTDIRECTCOMBINATION") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcEvaporativeCoolerTypeEnum::operator Ifc2x3::IfcEvaporativeCoolerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcEvaporatorTypeEnum::declaration() const { return *IFC2X3_IfcEvaporatorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcEvaporatorTypeEnum::Class() { return *IFC2X3_IfcEvaporatorTypeEnum_type; }

Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcEvaporatorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DIRECTEXPANSIONSHELLANDTUBE", "DIRECTEXPANSIONTUBEINTUBE", "DIRECTEXPANSIONBRAZEDPLATE", "FLOODEDSHELLANDTUBE", "SHELLANDCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcEvaporatorTypeEnum::Value Ifc2x3::IfcEvaporatorTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEXPANSIONSHELLANDTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE;
    if (s == "DIRECTEXPANSIONTUBEINTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE;
    if (s == "DIRECTEXPANSIONBRAZEDPLATE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE;
    if (s == "FLOODEDSHELLANDTUBE") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_FLOODEDSHELLANDTUBE;
    if (s == "SHELLANDCOIL") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_SHELLANDCOIL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcEvaporatorTypeEnum::IfcEvaporatorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcEvaporatorTypeEnum::operator Ifc2x3::IfcEvaporatorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFanTypeEnum::declaration() const { return *IFC2X3_IfcFanTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFanTypeEnum::Class() { return *IFC2X3_IfcFanTypeEnum_type; }

Ifc2x3::IfcFanTypeEnum::IfcFanTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFanTypeEnum::IfcFanTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFanTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFanTypeEnum::IfcFanTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFanTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFanTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CENTRIFUGALFORWARDCURVED", "CENTRIFUGALRADIAL", "CENTRIFUGALBACKWARDINCLINEDCURVED", "CENTRIFUGALAIRFOIL", "TUBEAXIAL", "VANEAXIAL", "PROPELLORAXIAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFanTypeEnum::Value Ifc2x3::IfcFanTypeEnum::FromString(const std::string& s) {
    if (s == "CENTRIFUGALFORWARDCURVED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALFORWARDCURVED;
    if (s == "CENTRIFUGALRADIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALRADIAL;
    if (s == "CENTRIFUGALBACKWARDINCLINEDCURVED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED;
    if (s == "CENTRIFUGALAIRFOIL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_CENTRIFUGALAIRFOIL;
    if (s == "TUBEAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_TUBEAXIAL;
    if (s == "VANEAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_VANEAXIAL;
    if (s == "PROPELLORAXIAL") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_PROPELLORAXIAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFanTypeEnum::IfcFanType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFanTypeEnum::operator Ifc2x3::IfcFanTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFilterTypeEnum::declaration() const { return *IFC2X3_IfcFilterTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFilterTypeEnum::Class() { return *IFC2X3_IfcFilterTypeEnum_type; }

Ifc2x3::IfcFilterTypeEnum::IfcFilterTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFilterTypeEnum::IfcFilterTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFilterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFilterTypeEnum::IfcFilterTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFilterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFilterTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AIRPARTICLEFILTER", "ODORFILTER", "OILFILTER", "STRAINER", "WATERFILTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFilterTypeEnum::Value Ifc2x3::IfcFilterTypeEnum::FromString(const std::string& s) {
    if (s == "AIRPARTICLEFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_AIRPARTICLEFILTER;
    if (s == "ODORFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_ODORFILTER;
    if (s == "OILFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_OILFILTER;
    if (s == "STRAINER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_STRAINER;
    if (s == "WATERFILTER") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_WATERFILTER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFilterTypeEnum::IfcFilterType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFilterTypeEnum::operator Ifc2x3::IfcFilterTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFireSuppressionTerminalTypeEnum::declaration() const { return *IFC2X3_IfcFireSuppressionTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Class() { return *IFC2X3_IfcFireSuppressionTerminalTypeEnum_type; }

Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFireSuppressionTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFireSuppressionTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFireSuppressionTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BREECHINGINLET", "FIREHYDRANT", "HOSEREEL", "SPRINKLER", "SPRINKLERDEFLECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Value Ifc2x3::IfcFireSuppressionTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BREECHINGINLET") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_BREECHINGINLET;
    if (s == "FIREHYDRANT") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_FIREHYDRANT;
    if (s == "HOSEREEL") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_HOSEREEL;
    if (s == "SPRINKLER") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLER;
    if (s == "SPRINKLERDEFLECTOR") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFireSuppressionTerminalTypeEnum::operator Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFlowDirectionEnum::declaration() const { return *IFC2X3_IfcFlowDirectionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFlowDirectionEnum::Class() { return *IFC2X3_IfcFlowDirectionEnum_type; }

Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirectionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirectionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirectionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFlowDirectionEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SOURCE", "SINK", "SOURCEANDSINK", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFlowDirectionEnum::Value Ifc2x3::IfcFlowDirectionEnum::FromString(const std::string& s) {
    if (s == "SOURCE") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SOURCE;
    if (s == "SINK") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SINK;
    if (s == "SOURCEANDSINK") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_SOURCEANDSINK;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowDirectionEnum::IfcFlowDirection_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFlowDirectionEnum::operator Ifc2x3::IfcFlowDirectionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFlowInstrumentTypeEnum::declaration() const { return *IFC2X3_IfcFlowInstrumentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFlowInstrumentTypeEnum::Class() { return *IFC2X3_IfcFlowInstrumentTypeEnum_type; }

Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowInstrumentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowInstrumentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFlowInstrumentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PRESSUREGAUGE", "THERMOMETER", "AMMETER", "FREQUENCYMETER", "POWERFACTORMETER", "PHASEANGLEMETER", "VOLTMETER_PEAK", "VOLTMETER_RMS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFlowInstrumentTypeEnum::Value Ifc2x3::IfcFlowInstrumentTypeEnum::FromString(const std::string& s) {
    if (s == "PRESSUREGAUGE") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PRESSUREGAUGE;
    if (s == "THERMOMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_THERMOMETER;
    if (s == "AMMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_AMMETER;
    if (s == "FREQUENCYMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_FREQUENCYMETER;
    if (s == "POWERFACTORMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_POWERFACTORMETER;
    if (s == "PHASEANGLEMETER") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PHASEANGLEMETER;
    if (s == "VOLTMETER_PEAK") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_PEAK;
    if (s == "VOLTMETER_RMS") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_RMS;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFlowInstrumentTypeEnum::operator Ifc2x3::IfcFlowInstrumentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFlowMeterTypeEnum::declaration() const { return *IFC2X3_IfcFlowMeterTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFlowMeterTypeEnum::Class() { return *IFC2X3_IfcFlowMeterTypeEnum_type; }

Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowMeterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowMeterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFlowMeterTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ELECTRICMETER", "ENERGYMETER", "FLOWMETER", "GASMETER", "OILMETER", "WATERMETER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFlowMeterTypeEnum::Value Ifc2x3::IfcFlowMeterTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_ELECTRICMETER;
    if (s == "ENERGYMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_ENERGYMETER;
    if (s == "FLOWMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_FLOWMETER;
    if (s == "GASMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_GASMETER;
    if (s == "OILMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_OILMETER;
    if (s == "WATERMETER") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_WATERMETER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFlowMeterTypeEnum::IfcFlowMeterType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFlowMeterTypeEnum::operator Ifc2x3::IfcFlowMeterTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcFootingTypeEnum::declaration() const { return *IFC2X3_IfcFootingTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcFootingTypeEnum::Class() { return *IFC2X3_IfcFootingTypeEnum_type; }

Ifc2x3::IfcFootingTypeEnum::IfcFootingTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcFootingTypeEnum::IfcFootingTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFootingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcFootingTypeEnum::IfcFootingTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcFootingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcFootingTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FOOTING_BEAM", "PAD_FOOTING", "PILE_CAP", "STRIP_FOOTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcFootingTypeEnum::Value Ifc2x3::IfcFootingTypeEnum::FromString(const std::string& s) {
    if (s == "FOOTING_BEAM") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_FOOTING_BEAM;
    if (s == "PAD_FOOTING") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_PAD_FOOTING;
    if (s == "PILE_CAP") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_PILE_CAP;
    if (s == "STRIP_FOOTING") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_STRIP_FOOTING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcFootingTypeEnum::IfcFootingType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcFootingTypeEnum::operator Ifc2x3::IfcFootingTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcGasTerminalTypeEnum::declaration() const { return *IFC2X3_IfcGasTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcGasTerminalTypeEnum::Class() { return *IFC2X3_IfcGasTerminalTypeEnum_type; }

Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGasTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGasTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcGasTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GASAPPLIANCE", "GASBOOSTER", "GASBURNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcGasTerminalTypeEnum::Value Ifc2x3::IfcGasTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "GASAPPLIANCE") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASAPPLIANCE;
    if (s == "GASBOOSTER") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASBOOSTER;
    if (s == "GASBURNER") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_GASBURNER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcGasTerminalTypeEnum::IfcGasTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcGasTerminalTypeEnum::operator Ifc2x3::IfcGasTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcGeometricProjectionEnum::declaration() const { return *IFC2X3_IfcGeometricProjectionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcGeometricProjectionEnum::Class() { return *IFC2X3_IfcGeometricProjectionEnum_type; }

Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjectionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjectionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricProjectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjectionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricProjectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcGeometricProjectionEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GRAPH_VIEW", "SKETCH_VIEW", "MODEL_VIEW", "PLAN_VIEW", "REFLECTED_PLAN_VIEW", "SECTION_VIEW", "ELEVATION_VIEW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcGeometricProjectionEnum::Value Ifc2x3::IfcGeometricProjectionEnum::FromString(const std::string& s) {
    if (s == "GRAPH_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_GRAPH_VIEW;
    if (s == "SKETCH_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_SKETCH_VIEW;
    if (s == "MODEL_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_MODEL_VIEW;
    if (s == "PLAN_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_PLAN_VIEW;
    if (s == "REFLECTED_PLAN_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_REFLECTED_PLAN_VIEW;
    if (s == "SECTION_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_SECTION_VIEW;
    if (s == "ELEVATION_VIEW") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_ELEVATION_VIEW;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcGeometricProjectionEnum::IfcGeometricProjection_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcGeometricProjectionEnum::operator Ifc2x3::IfcGeometricProjectionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcGlobalOrLocalEnum::declaration() const { return *IFC2X3_IfcGlobalOrLocalEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcGlobalOrLocalEnum::Class() { return *IFC2X3_IfcGlobalOrLocalEnum_type; }

Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGlobalOrLocalEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcGlobalOrLocalEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcGlobalOrLocalEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GLOBAL_COORDS", "LOCAL_COORDS" };
    return names[v];
}

Ifc2x3::IfcGlobalOrLocalEnum::Value Ifc2x3::IfcGlobalOrLocalEnum::FromString(const std::string& s) {
    if (s == "GLOBAL_COORDS") return ::Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_GLOBAL_COORDS;
    if (s == "LOCAL_COORDS") return ::Ifc2x3::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_LOCAL_COORDS;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcGlobalOrLocalEnum::operator Ifc2x3::IfcGlobalOrLocalEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcHeatExchangerTypeEnum::declaration() const { return *IFC2X3_IfcHeatExchangerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcHeatExchangerTypeEnum::Class() { return *IFC2X3_IfcHeatExchangerTypeEnum_type; }

Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcHeatExchangerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcHeatExchangerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcHeatExchangerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PLATE", "SHELLANDTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcHeatExchangerTypeEnum::Value Ifc2x3::IfcHeatExchangerTypeEnum::FromString(const std::string& s) {
    if (s == "PLATE") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_PLATE;
    if (s == "SHELLANDTUBE") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_SHELLANDTUBE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcHeatExchangerTypeEnum::operator Ifc2x3::IfcHeatExchangerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcHumidifierTypeEnum::declaration() const { return *IFC2X3_IfcHumidifierTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcHumidifierTypeEnum::Class() { return *IFC2X3_IfcHumidifierTypeEnum_type; }

Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcHumidifierTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcHumidifierTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcHumidifierTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STEAMINJECTION", "ADIABATICAIRWASHER", "ADIABATICPAN", "ADIABATICWETTEDELEMENT", "ADIABATICATOMIZING", "ADIABATICULTRASONIC", "ADIABATICRIGIDMEDIA", "ADIABATICCOMPRESSEDAIRNOZZLE", "ASSISTEDELECTRIC", "ASSISTEDNATURALGAS", "ASSISTEDPROPANE", "ASSISTEDBUTANE", "ASSISTEDSTEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcHumidifierTypeEnum::Value Ifc2x3::IfcHumidifierTypeEnum::FromString(const std::string& s) {
    if (s == "STEAMINJECTION") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_STEAMINJECTION;
    if (s == "ADIABATICAIRWASHER") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICAIRWASHER;
    if (s == "ADIABATICPAN") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICPAN;
    if (s == "ADIABATICWETTEDELEMENT") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICWETTEDELEMENT;
    if (s == "ADIABATICATOMIZING") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICATOMIZING;
    if (s == "ADIABATICULTRASONIC") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICULTRASONIC;
    if (s == "ADIABATICRIGIDMEDIA") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICRIGIDMEDIA;
    if (s == "ADIABATICCOMPRESSEDAIRNOZZLE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE;
    if (s == "ASSISTEDELECTRIC") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDELECTRIC;
    if (s == "ASSISTEDNATURALGAS") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDNATURALGAS;
    if (s == "ASSISTEDPROPANE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDPROPANE;
    if (s == "ASSISTEDBUTANE") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDBUTANE;
    if (s == "ASSISTEDSTEAM") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDSTEAM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcHumidifierTypeEnum::IfcHumidifierType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcHumidifierTypeEnum::operator Ifc2x3::IfcHumidifierTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcInternalOrExternalEnum::declaration() const { return *IFC2X3_IfcInternalOrExternalEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcInternalOrExternalEnum::Class() { return *IFC2X3_IfcInternalOrExternalEnum_type; }

Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternalEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternalEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcInternalOrExternalEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternalEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcInternalOrExternalEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcInternalOrExternalEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "INTERNAL", "EXTERNAL", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcInternalOrExternalEnum::Value Ifc2x3::IfcInternalOrExternalEnum::FromString(const std::string& s) {
    if (s == "INTERNAL") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcInternalOrExternalEnum::IfcInternalOrExternal_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcInternalOrExternalEnum::operator Ifc2x3::IfcInternalOrExternalEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcInventoryTypeEnum::declaration() const { return *IFC2X3_IfcInventoryTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcInventoryTypeEnum::Class() { return *IFC2X3_IfcInventoryTypeEnum_type; }

Ifc2x3::IfcInventoryTypeEnum::IfcInventoryTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcInventoryTypeEnum::IfcInventoryTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcInventoryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcInventoryTypeEnum::IfcInventoryTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcInventoryTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcInventoryTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ASSETINVENTORY", "SPACEINVENTORY", "FURNITUREINVENTORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcInventoryTypeEnum::Value Ifc2x3::IfcInventoryTypeEnum::FromString(const std::string& s) {
    if (s == "ASSETINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_ASSETINVENTORY;
    if (s == "SPACEINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_SPACEINVENTORY;
    if (s == "FURNITUREINVENTORY") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_FURNITUREINVENTORY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcInventoryTypeEnum::IfcInventoryType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcInventoryTypeEnum::operator Ifc2x3::IfcInventoryTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcJunctionBoxTypeEnum::declaration() const { return *IFC2X3_IfcJunctionBoxTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcJunctionBoxTypeEnum::Class() { return *IFC2X3_IfcJunctionBoxTypeEnum_type; }

Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcJunctionBoxTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcJunctionBoxTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcJunctionBoxTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcJunctionBoxTypeEnum::Value Ifc2x3::IfcJunctionBoxTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcJunctionBoxTypeEnum::operator Ifc2x3::IfcJunctionBoxTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLampTypeEnum::declaration() const { return *IFC2X3_IfcLampTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLampTypeEnum::Class() { return *IFC2X3_IfcLampTypeEnum_type; }

Ifc2x3::IfcLampTypeEnum::IfcLampTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLampTypeEnum::IfcLampTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLampTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLampTypeEnum::IfcLampTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLampTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLampTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "METALHALIDE", "TUNGSTENFILAMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcLampTypeEnum::Value Ifc2x3::IfcLampTypeEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_HIGHPRESSURESODIUM;
    if (s == "METALHALIDE") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_TUNGSTENFILAMENT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLampTypeEnum::IfcLampType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLampTypeEnum::operator Ifc2x3::IfcLampTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLayerSetDirectionEnum::declaration() const { return *IFC2X3_IfcLayerSetDirectionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLayerSetDirectionEnum::Class() { return *IFC2X3_IfcLayerSetDirectionEnum_type; }

Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLayerSetDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLayerSetDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLayerSetDirectionEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AXIS1", "AXIS2", "AXIS3" };
    return names[v];
}

Ifc2x3::IfcLayerSetDirectionEnum::Value Ifc2x3::IfcLayerSetDirectionEnum::FromString(const std::string& s) {
    if (s == "AXIS1") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS1;
    if (s == "AXIS2") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS2;
    if (s == "AXIS3") return ::Ifc2x3::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS3;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLayerSetDirectionEnum::operator Ifc2x3::IfcLayerSetDirectionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLightDistributionCurveEnum::declaration() const { return *IFC2X3_IfcLightDistributionCurveEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLightDistributionCurveEnum::Class() { return *IFC2X3_IfcLightDistributionCurveEnum_type; }

Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightDistributionCurveEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightDistributionCurveEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLightDistributionCurveEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "TYPE_A", "TYPE_B", "TYPE_C", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcLightDistributionCurveEnum::Value Ifc2x3::IfcLightDistributionCurveEnum::FromString(const std::string& s) {
    if (s == "TYPE_A") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_A;
    if (s == "TYPE_B") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_B;
    if (s == "TYPE_C") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_C;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLightDistributionCurveEnum::operator Ifc2x3::IfcLightDistributionCurveEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLightEmissionSourceEnum::declaration() const { return *IFC2X3_IfcLightEmissionSourceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLightEmissionSourceEnum::Class() { return *IFC2X3_IfcLightEmissionSourceEnum_type; }

Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightEmissionSourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightEmissionSourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLightEmissionSourceEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LIGHTEMITTINGDIODE", "LOWPRESSURESODIUM", "LOWVOLTAGEHALOGEN", "MAINVOLTAGEHALOGEN", "METALHALIDE", "TUNGSTENFILAMENT", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcLightEmissionSourceEnum::Value Ifc2x3::IfcLightEmissionSourceEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSURESODIUM;
    if (s == "LIGHTEMITTINGDIODE") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LIGHTEMITTINGDIODE;
    if (s == "LOWPRESSURESODIUM") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWPRESSURESODIUM;
    if (s == "LOWVOLTAGEHALOGEN") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWVOLTAGEHALOGEN;
    if (s == "MAINVOLTAGEHALOGEN") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_MAINVOLTAGEHALOGEN;
    if (s == "METALHALIDE") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_TUNGSTENFILAMENT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightEmissionSourceEnum::IfcLightEmissionSource_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLightEmissionSourceEnum::operator Ifc2x3::IfcLightEmissionSourceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLightFixtureTypeEnum::declaration() const { return *IFC2X3_IfcLightFixtureTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLightFixtureTypeEnum::Class() { return *IFC2X3_IfcLightFixtureTypeEnum_type; }

Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightFixtureTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLightFixtureTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLightFixtureTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "POINTSOURCE", "DIRECTIONSOURCE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcLightFixtureTypeEnum::Value Ifc2x3::IfcLightFixtureTypeEnum::FromString(const std::string& s) {
    if (s == "POINTSOURCE") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_POINTSOURCE;
    if (s == "DIRECTIONSOURCE") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_DIRECTIONSOURCE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLightFixtureTypeEnum::IfcLightFixtureType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLightFixtureTypeEnum::operator Ifc2x3::IfcLightFixtureTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLoadGroupTypeEnum::declaration() const { return *IFC2X3_IfcLoadGroupTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLoadGroupTypeEnum::Class() { return *IFC2X3_IfcLoadGroupTypeEnum_type; }

Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLoadGroupTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLoadGroupTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLoadGroupTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "LOAD_GROUP", "LOAD_CASE", "LOAD_COMBINATION_GROUP", "LOAD_COMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcLoadGroupTypeEnum::Value Ifc2x3::IfcLoadGroupTypeEnum::FromString(const std::string& s) {
    if (s == "LOAD_GROUP") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_GROUP;
    if (s == "LOAD_CASE") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_CASE;
    if (s == "LOAD_COMBINATION_GROUP") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION_GROUP;
    if (s == "LOAD_COMBINATION") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcLoadGroupTypeEnum::IfcLoadGroupType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLoadGroupTypeEnum::operator Ifc2x3::IfcLoadGroupTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcLogicalOperatorEnum::declaration() const { return *IFC2X3_IfcLogicalOperatorEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcLogicalOperatorEnum::Class() { return *IFC2X3_IfcLogicalOperatorEnum_type; }

Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperatorEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperatorEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLogicalOperatorEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperatorEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcLogicalOperatorEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcLogicalOperatorEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "LOGICALAND", "LOGICALOR" };
    return names[v];
}

Ifc2x3::IfcLogicalOperatorEnum::Value Ifc2x3::IfcLogicalOperatorEnum::FromString(const std::string& s) {
    if (s == "LOGICALAND") return ::Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALAND;
    if (s == "LOGICALOR") return ::Ifc2x3::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALOR;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcLogicalOperatorEnum::operator Ifc2x3::IfcLogicalOperatorEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcMemberTypeEnum::declaration() const { return *IFC2X3_IfcMemberTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcMemberTypeEnum::Class() { return *IFC2X3_IfcMemberTypeEnum_type; }

Ifc2x3::IfcMemberTypeEnum::IfcMemberTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcMemberTypeEnum::IfcMemberTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcMemberTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcMemberTypeEnum::IfcMemberTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcMemberTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcMemberTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BRACE", "CHORD", "COLLAR", "MEMBER", "MULLION", "PLATE", "POST", "PURLIN", "RAFTER", "STRINGER", "STRUT", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcMemberTypeEnum::Value Ifc2x3::IfcMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BRACE") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_BRACE;
    if (s == "CHORD") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_CHORD;
    if (s == "COLLAR") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_COLLAR;
    if (s == "MEMBER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_MEMBER;
    if (s == "MULLION") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_MULLION;
    if (s == "PLATE") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_PLATE;
    if (s == "POST") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_POST;
    if (s == "PURLIN") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_PURLIN;
    if (s == "RAFTER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_RAFTER;
    if (s == "STRINGER") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STRINGER;
    if (s == "STRUT") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STRUT;
    if (s == "STUD") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_STUD;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcMemberTypeEnum::IfcMemberType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcMemberTypeEnum::operator Ifc2x3::IfcMemberTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcMotorConnectionTypeEnum::declaration() const { return *IFC2X3_IfcMotorConnectionTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcMotorConnectionTypeEnum::Class() { return *IFC2X3_IfcMotorConnectionTypeEnum_type; }

Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcMotorConnectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcMotorConnectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcMotorConnectionTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BELTDRIVE", "COUPLING", "DIRECTDRIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcMotorConnectionTypeEnum::Value Ifc2x3::IfcMotorConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "BELTDRIVE") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_BELTDRIVE;
    if (s == "COUPLING") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_COUPLING;
    if (s == "DIRECTDRIVE") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_DIRECTDRIVE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcMotorConnectionTypeEnum::operator Ifc2x3::IfcMotorConnectionTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcNullStyle::declaration() const { return *IFC2X3_IfcNullStyle_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcNullStyle::Class() { return *IFC2X3_IfcNullStyle_type; }

Ifc2x3::IfcNullStyle::IfcNullStyle(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcNullStyle::IfcNullStyle(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcNullStyle_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcNullStyle::IfcNullStyle(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcNullStyle_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcNullStyle::ToString(Value v) {
    if ( v < 0 || v >= 1 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "NULL" };
    return names[v];
}

Ifc2x3::IfcNullStyle::Value Ifc2x3::IfcNullStyle::FromString(const std::string& s) {
    if (s == "NULL") return ::Ifc2x3::IfcNullStyle::IfcNullStyle_NULL;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcNullStyle::operator Ifc2x3::IfcNullStyle::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcObjectTypeEnum::declaration() const { return *IFC2X3_IfcObjectTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcObjectTypeEnum::Class() { return *IFC2X3_IfcObjectTypeEnum_type; }

Ifc2x3::IfcObjectTypeEnum::IfcObjectTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcObjectTypeEnum::IfcObjectTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcObjectTypeEnum::IfcObjectTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcObjectTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PRODUCT", "PROCESS", "CONTROL", "RESOURCE", "ACTOR", "GROUP", "PROJECT", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcObjectTypeEnum::Value Ifc2x3::IfcObjectTypeEnum::FromString(const std::string& s) {
    if (s == "PRODUCT") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PRODUCT;
    if (s == "PROCESS") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PROCESS;
    if (s == "CONTROL") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_CONTROL;
    if (s == "RESOURCE") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_RESOURCE;
    if (s == "ACTOR") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_ACTOR;
    if (s == "GROUP") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_GROUP;
    if (s == "PROJECT") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_PROJECT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcObjectTypeEnum::IfcObjectType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcObjectTypeEnum::operator Ifc2x3::IfcObjectTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcObjectiveEnum::declaration() const { return *IFC2X3_IfcObjectiveEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcObjectiveEnum::Class() { return *IFC2X3_IfcObjectiveEnum_type; }

Ifc2x3::IfcObjectiveEnum::IfcObjectiveEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcObjectiveEnum::IfcObjectiveEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectiveEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcObjectiveEnum::IfcObjectiveEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectiveEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcObjectiveEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CODECOMPLIANCE", "DESIGNINTENT", "HEALTHANDSAFETY", "REQUIREMENT", "SPECIFICATION", "TRIGGERCONDITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcObjectiveEnum::Value Ifc2x3::IfcObjectiveEnum::FromString(const std::string& s) {
    if (s == "CODECOMPLIANCE") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_CODECOMPLIANCE;
    if (s == "DESIGNINTENT") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_DESIGNINTENT;
    if (s == "HEALTHANDSAFETY") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_HEALTHANDSAFETY;
    if (s == "REQUIREMENT") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_REQUIREMENT;
    if (s == "SPECIFICATION") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_SPECIFICATION;
    if (s == "TRIGGERCONDITION") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_TRIGGERCONDITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcObjectiveEnum::IfcObjective_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcObjectiveEnum::operator Ifc2x3::IfcObjectiveEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcOccupantTypeEnum::declaration() const { return *IFC2X3_IfcOccupantTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcOccupantTypeEnum::Class() { return *IFC2X3_IfcOccupantTypeEnum_type; }

Ifc2x3::IfcOccupantTypeEnum::IfcOccupantTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcOccupantTypeEnum::IfcOccupantTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcOccupantTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcOccupantTypeEnum::IfcOccupantTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcOccupantTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcOccupantTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ASSIGNEE", "ASSIGNOR", "LESSEE", "LESSOR", "LETTINGAGENT", "OWNER", "TENANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcOccupantTypeEnum::Value Ifc2x3::IfcOccupantTypeEnum::FromString(const std::string& s) {
    if (s == "ASSIGNEE") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNEE;
    if (s == "ASSIGNOR") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNOR;
    if (s == "LESSEE") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LESSEE;
    if (s == "LESSOR") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LESSOR;
    if (s == "LETTINGAGENT") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_LETTINGAGENT;
    if (s == "OWNER") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_OWNER;
    if (s == "TENANT") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_TENANT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcOccupantTypeEnum::IfcOccupantType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcOccupantTypeEnum::operator Ifc2x3::IfcOccupantTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcOutletTypeEnum::declaration() const { return *IFC2X3_IfcOutletTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcOutletTypeEnum::Class() { return *IFC2X3_IfcOutletTypeEnum_type; }

Ifc2x3::IfcOutletTypeEnum::IfcOutletTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcOutletTypeEnum::IfcOutletTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcOutletTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcOutletTypeEnum::IfcOutletTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcOutletTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcOutletTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AUDIOVISUALOUTLET", "COMMUNICATIONSOUTLET", "POWEROUTLET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcOutletTypeEnum::Value Ifc2x3::IfcOutletTypeEnum::FromString(const std::string& s) {
    if (s == "AUDIOVISUALOUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_AUDIOVISUALOUTLET;
    if (s == "COMMUNICATIONSOUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_COMMUNICATIONSOUTLET;
    if (s == "POWEROUTLET") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_POWEROUTLET;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcOutletTypeEnum::IfcOutletType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcOutletTypeEnum::operator Ifc2x3::IfcOutletTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPermeableCoveringOperationEnum::declaration() const { return *IFC2X3_IfcPermeableCoveringOperationEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPermeableCoveringOperationEnum::Class() { return *IFC2X3_IfcPermeableCoveringOperationEnum_type; }

Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPermeableCoveringOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPermeableCoveringOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPermeableCoveringOperationEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "GRILL", "LOUVER", "SCREEN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPermeableCoveringOperationEnum::Value Ifc2x3::IfcPermeableCoveringOperationEnum::FromString(const std::string& s) {
    if (s == "GRILL") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_GRILL;
    if (s == "LOUVER") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_LOUVER;
    if (s == "SCREEN") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_SCREEN;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPermeableCoveringOperationEnum::operator Ifc2x3::IfcPermeableCoveringOperationEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPhysicalOrVirtualEnum::declaration() const { return *IFC2X3_IfcPhysicalOrVirtualEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPhysicalOrVirtualEnum::Class() { return *IFC2X3_IfcPhysicalOrVirtualEnum_type; }

Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPhysicalOrVirtualEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPhysicalOrVirtualEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPhysicalOrVirtualEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PHYSICAL", "VIRTUAL", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPhysicalOrVirtualEnum::Value Ifc2x3::IfcPhysicalOrVirtualEnum::FromString(const std::string& s) {
    if (s == "PHYSICAL") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_PHYSICAL;
    if (s == "VIRTUAL") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_VIRTUAL;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPhysicalOrVirtualEnum::operator Ifc2x3::IfcPhysicalOrVirtualEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPileConstructionEnum::declaration() const { return *IFC2X3_IfcPileConstructionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPileConstructionEnum::Class() { return *IFC2X3_IfcPileConstructionEnum_type; }

Ifc2x3::IfcPileConstructionEnum::IfcPileConstructionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPileConstructionEnum::IfcPileConstructionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPileConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPileConstructionEnum::IfcPileConstructionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPileConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPileConstructionEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CAST_IN_PLACE", "COMPOSITE", "PRECAST_CONCRETE", "PREFAB_STEEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPileConstructionEnum::Value Ifc2x3::IfcPileConstructionEnum::FromString(const std::string& s) {
    if (s == "CAST_IN_PLACE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_CAST_IN_PLACE;
    if (s == "COMPOSITE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_COMPOSITE;
    if (s == "PRECAST_CONCRETE") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_PRECAST_CONCRETE;
    if (s == "PREFAB_STEEL") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_PREFAB_STEEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPileConstructionEnum::IfcPileConstruction_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPileConstructionEnum::operator Ifc2x3::IfcPileConstructionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPileTypeEnum::declaration() const { return *IFC2X3_IfcPileTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPileTypeEnum::Class() { return *IFC2X3_IfcPileTypeEnum_type; }

Ifc2x3::IfcPileTypeEnum::IfcPileTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPileTypeEnum::IfcPileTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPileTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPileTypeEnum::IfcPileTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPileTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPileTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COHESION", "FRICTION", "SUPPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPileTypeEnum::Value Ifc2x3::IfcPileTypeEnum::FromString(const std::string& s) {
    if (s == "COHESION") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_COHESION;
    if (s == "FRICTION") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_FRICTION;
    if (s == "SUPPORT") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_SUPPORT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPileTypeEnum::IfcPileType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPileTypeEnum::operator Ifc2x3::IfcPileTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPipeFittingTypeEnum::declaration() const { return *IFC2X3_IfcPipeFittingTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPipeFittingTypeEnum::Class() { return *IFC2X3_IfcPipeFittingTypeEnum_type; }

Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeFittingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPipeFittingTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPipeFittingTypeEnum::Value Ifc2x3::IfcPipeFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPipeFittingTypeEnum::IfcPipeFittingType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPipeFittingTypeEnum::operator Ifc2x3::IfcPipeFittingTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPipeSegmentTypeEnum::declaration() const { return *IFC2X3_IfcPipeSegmentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPipeSegmentTypeEnum::Class() { return *IFC2X3_IfcPipeSegmentTypeEnum_type; }

Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeSegmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPipeSegmentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLEXIBLESEGMENT", "RIGIDSEGMENT", "GUTTER", "SPOOL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPipeSegmentTypeEnum::Value Ifc2x3::IfcPipeSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "FLEXIBLESEGMENT") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_FLEXIBLESEGMENT;
    if (s == "RIGIDSEGMENT") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_RIGIDSEGMENT;
    if (s == "GUTTER") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_GUTTER;
    if (s == "SPOOL") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_SPOOL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPipeSegmentTypeEnum::operator Ifc2x3::IfcPipeSegmentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPlateTypeEnum::declaration() const { return *IFC2X3_IfcPlateTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPlateTypeEnum::Class() { return *IFC2X3_IfcPlateTypeEnum_type; }

Ifc2x3::IfcPlateTypeEnum::IfcPlateTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPlateTypeEnum::IfcPlateTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPlateTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPlateTypeEnum::IfcPlateTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPlateTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPlateTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CURTAIN_PANEL", "SHEET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPlateTypeEnum::Value Ifc2x3::IfcPlateTypeEnum::FromString(const std::string& s) {
    if (s == "CURTAIN_PANEL") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_CURTAIN_PANEL;
    if (s == "SHEET") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_SHEET;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPlateTypeEnum::IfcPlateType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPlateTypeEnum::operator Ifc2x3::IfcPlateTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProcedureTypeEnum::declaration() const { return *IFC2X3_IfcProcedureTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProcedureTypeEnum::Class() { return *IFC2X3_IfcProcedureTypeEnum_type; }

Ifc2x3::IfcProcedureTypeEnum::IfcProcedureTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProcedureTypeEnum::IfcProcedureTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProcedureTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProcedureTypeEnum::IfcProcedureTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProcedureTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProcedureTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ADVICE_CAUTION", "ADVICE_NOTE", "ADVICE_WARNING", "CALIBRATION", "DIAGNOSTIC", "SHUTDOWN", "STARTUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcProcedureTypeEnum::Value Ifc2x3::IfcProcedureTypeEnum::FromString(const std::string& s) {
    if (s == "ADVICE_CAUTION") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_CAUTION;
    if (s == "ADVICE_NOTE") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_NOTE;
    if (s == "ADVICE_WARNING") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_WARNING;
    if (s == "CALIBRATION") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_CALIBRATION;
    if (s == "DIAGNOSTIC") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_DIAGNOSTIC;
    if (s == "SHUTDOWN") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_SHUTDOWN;
    if (s == "STARTUP") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_STARTUP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProcedureTypeEnum::IfcProcedureType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProcedureTypeEnum::operator Ifc2x3::IfcProcedureTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProfileTypeEnum::declaration() const { return *IFC2X3_IfcProfileTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProfileTypeEnum::Class() { return *IFC2X3_IfcProfileTypeEnum_type; }

Ifc2x3::IfcProfileTypeEnum::IfcProfileTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProfileTypeEnum::IfcProfileTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProfileTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProfileTypeEnum::IfcProfileTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProfileTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProfileTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CURVE", "AREA" };
    return names[v];
}

Ifc2x3::IfcProfileTypeEnum::Value Ifc2x3::IfcProfileTypeEnum::FromString(const std::string& s) {
    if (s == "CURVE") return ::Ifc2x3::IfcProfileTypeEnum::IfcProfileType_CURVE;
    if (s == "AREA") return ::Ifc2x3::IfcProfileTypeEnum::IfcProfileType_AREA;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProfileTypeEnum::operator Ifc2x3::IfcProfileTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProjectOrderRecordTypeEnum::declaration() const { return *IFC2X3_IfcProjectOrderRecordTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProjectOrderRecordTypeEnum::Class() { return *IFC2X3_IfcProjectOrderRecordTypeEnum_type; }

Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrderRecordTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrderRecordTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProjectOrderRecordTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CHANGE", "MAINTENANCE", "MOVE", "PURCHASE", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcProjectOrderRecordTypeEnum::Value Ifc2x3::IfcProjectOrderRecordTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_CHANGE;
    if (s == "MAINTENANCE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_MAINTENANCE;
    if (s == "MOVE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_MOVE;
    if (s == "PURCHASE") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_PURCHASE;
    if (s == "WORK") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_WORK;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProjectOrderRecordTypeEnum::operator Ifc2x3::IfcProjectOrderRecordTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProjectOrderTypeEnum::declaration() const { return *IFC2X3_IfcProjectOrderTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProjectOrderTypeEnum::Class() { return *IFC2X3_IfcProjectOrderTypeEnum_type; }

Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrderTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrderTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProjectOrderTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CHANGEORDER", "MAINTENANCEWORKORDER", "MOVEORDER", "PURCHASEORDER", "WORKORDER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcProjectOrderTypeEnum::Value Ifc2x3::IfcProjectOrderTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_CHANGEORDER;
    if (s == "MAINTENANCEWORKORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_MAINTENANCEWORKORDER;
    if (s == "MOVEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_MOVEORDER;
    if (s == "PURCHASEORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_PURCHASEORDER;
    if (s == "WORKORDER") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_WORKORDER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProjectOrderTypeEnum::IfcProjectOrderType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProjectOrderTypeEnum::operator Ifc2x3::IfcProjectOrderTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProjectedOrTrueLengthEnum::declaration() const { return *IFC2X3_IfcProjectedOrTrueLengthEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProjectedOrTrueLengthEnum::Class() { return *IFC2X3_IfcProjectedOrTrueLengthEnum_type; }

Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectedOrTrueLengthEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectedOrTrueLengthEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PROJECTED_LENGTH", "TRUE_LENGTH" };
    return names[v];
}

Ifc2x3::IfcProjectedOrTrueLengthEnum::Value Ifc2x3::IfcProjectedOrTrueLengthEnum::FromString(const std::string& s) {
    if (s == "PROJECTED_LENGTH") return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_PROJECTED_LENGTH;
    if (s == "TRUE_LENGTH") return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_TRUE_LENGTH;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProjectedOrTrueLengthEnum::operator Ifc2x3::IfcProjectedOrTrueLengthEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPropertySourceEnum::declaration() const { return *IFC2X3_IfcPropertySourceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPropertySourceEnum::Class() { return *IFC2X3_IfcPropertySourceEnum_type; }

Ifc2x3::IfcPropertySourceEnum::IfcPropertySourceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPropertySourceEnum::IfcPropertySourceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertySourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPropertySourceEnum::IfcPropertySourceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertySourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPropertySourceEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DESIGN", "DESIGNMAXIMUM", "DESIGNMINIMUM", "SIMULATED", "ASBUILT", "COMMISSIONING", "MEASURED", "USERDEFINED", "NOTKNOWN" };
    return names[v];
}

Ifc2x3::IfcPropertySourceEnum::Value Ifc2x3::IfcPropertySourceEnum::FromString(const std::string& s) {
    if (s == "DESIGN") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGN;
    if (s == "DESIGNMAXIMUM") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGNMAXIMUM;
    if (s == "DESIGNMINIMUM") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_DESIGNMINIMUM;
    if (s == "SIMULATED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_SIMULATED;
    if (s == "ASBUILT") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_ASBUILT;
    if (s == "COMMISSIONING") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_COMMISSIONING;
    if (s == "MEASURED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_MEASURED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_USERDEFINED;
    if (s == "NOTKNOWN") return ::Ifc2x3::IfcPropertySourceEnum::IfcPropertySource_NOTKNOWN;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPropertySourceEnum::operator Ifc2x3::IfcPropertySourceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcProtectiveDeviceTypeEnum::declaration() const { return *IFC2X3_IfcProtectiveDeviceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcProtectiveDeviceTypeEnum::Class() { return *IFC2X3_IfcProtectiveDeviceTypeEnum_type; }

Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProtectiveDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcProtectiveDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcProtectiveDeviceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FUSEDISCONNECTOR", "CIRCUITBREAKER", "EARTHFAILUREDEVICE", "RESIDUALCURRENTCIRCUITBREAKER", "RESIDUALCURRENTSWITCH", "VARISTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcProtectiveDeviceTypeEnum::Value Ifc2x3::IfcProtectiveDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "FUSEDISCONNECTOR") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_FUSEDISCONNECTOR;
    if (s == "CIRCUITBREAKER") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_CIRCUITBREAKER;
    if (s == "EARTHFAILUREDEVICE") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHFAILUREDEVICE;
    if (s == "RESIDUALCURRENTCIRCUITBREAKER") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER;
    if (s == "RESIDUALCURRENTSWITCH") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH;
    if (s == "VARISTOR") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_VARISTOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcProtectiveDeviceTypeEnum::operator Ifc2x3::IfcProtectiveDeviceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcPumpTypeEnum::declaration() const { return *IFC2X3_IfcPumpTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcPumpTypeEnum::Class() { return *IFC2X3_IfcPumpTypeEnum_type; }

Ifc2x3::IfcPumpTypeEnum::IfcPumpTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcPumpTypeEnum::IfcPumpTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPumpTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcPumpTypeEnum::IfcPumpTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcPumpTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcPumpTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CIRCULATOR", "ENDSUCTION", "SPLITCASE", "VERTICALINLINE", "VERTICALTURBINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcPumpTypeEnum::Value Ifc2x3::IfcPumpTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCULATOR") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_CIRCULATOR;
    if (s == "ENDSUCTION") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_ENDSUCTION;
    if (s == "SPLITCASE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_SPLITCASE;
    if (s == "VERTICALINLINE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_VERTICALINLINE;
    if (s == "VERTICALTURBINE") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_VERTICALTURBINE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcPumpTypeEnum::IfcPumpType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcPumpTypeEnum::operator Ifc2x3::IfcPumpTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRailingTypeEnum::declaration() const { return *IFC2X3_IfcRailingTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRailingTypeEnum::Class() { return *IFC2X3_IfcRailingTypeEnum_type; }

Ifc2x3::IfcRailingTypeEnum::IfcRailingTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRailingTypeEnum::IfcRailingTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRailingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRailingTypeEnum::IfcRailingTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRailingTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRailingTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "HANDRAIL", "GUARDRAIL", "BALUSTRADE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcRailingTypeEnum::Value Ifc2x3::IfcRailingTypeEnum::FromString(const std::string& s) {
    if (s == "HANDRAIL") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_HANDRAIL;
    if (s == "GUARDRAIL") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_GUARDRAIL;
    if (s == "BALUSTRADE") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_BALUSTRADE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRailingTypeEnum::IfcRailingType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRailingTypeEnum::operator Ifc2x3::IfcRailingTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRampFlightTypeEnum::declaration() const { return *IFC2X3_IfcRampFlightTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRampFlightTypeEnum::Class() { return *IFC2X3_IfcRampFlightTypeEnum_type; }

Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRampFlightTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRampFlightTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRampFlightTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STRAIGHT", "SPIRAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcRampFlightTypeEnum::Value Ifc2x3::IfcRampFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_STRAIGHT;
    if (s == "SPIRAL") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_SPIRAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRampFlightTypeEnum::IfcRampFlightType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRampFlightTypeEnum::operator Ifc2x3::IfcRampFlightTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRampTypeEnum::declaration() const { return *IFC2X3_IfcRampTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRampTypeEnum::Class() { return *IFC2X3_IfcRampTypeEnum_type; }

Ifc2x3::IfcRampTypeEnum::IfcRampTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRampTypeEnum::IfcRampTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRampTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRampTypeEnum::IfcRampTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRampTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRampTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_RAMP", "TWO_STRAIGHT_RUN_RAMP", "QUARTER_TURN_RAMP", "TWO_QUARTER_TURN_RAMP", "HALF_TURN_RAMP", "SPIRAL_RAMP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcRampTypeEnum::Value Ifc2x3::IfcRampTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_STRAIGHT_RUN_RAMP;
    if (s == "TWO_STRAIGHT_RUN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_TWO_STRAIGHT_RUN_RAMP;
    if (s == "QUARTER_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_QUARTER_TURN_RAMP;
    if (s == "TWO_QUARTER_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_TWO_QUARTER_TURN_RAMP;
    if (s == "HALF_TURN_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_HALF_TURN_RAMP;
    if (s == "SPIRAL_RAMP") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_SPIRAL_RAMP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRampTypeEnum::IfcRampType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRampTypeEnum::operator Ifc2x3::IfcRampTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcReflectanceMethodEnum::declaration() const { return *IFC2X3_IfcReflectanceMethodEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcReflectanceMethodEnum::Class() { return *IFC2X3_IfcReflectanceMethodEnum_type; }

Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethodEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethodEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReflectanceMethodEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethodEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReflectanceMethodEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcReflectanceMethodEnum::ToString(Value v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BLINN", "FLAT", "GLASS", "MATT", "METAL", "MIRROR", "PHONG", "PLASTIC", "STRAUSS", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcReflectanceMethodEnum::Value Ifc2x3::IfcReflectanceMethodEnum::FromString(const std::string& s) {
    if (s == "BLINN") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_BLINN;
    if (s == "FLAT") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_FLAT;
    if (s == "GLASS") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_GLASS;
    if (s == "MATT") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_MATT;
    if (s == "METAL") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_METAL;
    if (s == "MIRROR") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_MIRROR;
    if (s == "PHONG") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_PHONG;
    if (s == "PLASTIC") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_PLASTIC;
    if (s == "STRAUSS") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_STRAUSS;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcReflectanceMethodEnum::IfcReflectanceMethod_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcReflectanceMethodEnum::operator Ifc2x3::IfcReflectanceMethodEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcReinforcingBarRoleEnum::declaration() const { return *IFC2X3_IfcReinforcingBarRoleEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcReinforcingBarRoleEnum::Class() { return *IFC2X3_IfcReinforcingBarRoleEnum_type; }

Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingBarRoleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingBarRoleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcReinforcingBarRoleEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "MAIN", "SHEAR", "LIGATURE", "STUD", "PUNCHING", "EDGE", "RING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcReinforcingBarRoleEnum::Value Ifc2x3::IfcReinforcingBarRoleEnum::FromString(const std::string& s) {
    if (s == "MAIN") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_MAIN;
    if (s == "SHEAR") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_SHEAR;
    if (s == "LIGATURE") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_LIGATURE;
    if (s == "STUD") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_STUD;
    if (s == "PUNCHING") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_PUNCHING;
    if (s == "EDGE") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_EDGE;
    if (s == "RING") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_RING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcReinforcingBarRoleEnum::operator Ifc2x3::IfcReinforcingBarRoleEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcReinforcingBarSurfaceEnum::declaration() const { return *IFC2X3_IfcReinforcingBarSurfaceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcReinforcingBarSurfaceEnum::Class() { return *IFC2X3_IfcReinforcingBarSurfaceEnum_type; }

Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingBarSurfaceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingBarSurfaceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcReinforcingBarSurfaceEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PLAIN", "TEXTURED" };
    return names[v];
}

Ifc2x3::IfcReinforcingBarSurfaceEnum::Value Ifc2x3::IfcReinforcingBarSurfaceEnum::FromString(const std::string& s) {
    if (s == "PLAIN") return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_PLAIN;
    if (s == "TEXTURED") return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_TEXTURED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcReinforcingBarSurfaceEnum::operator Ifc2x3::IfcReinforcingBarSurfaceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcResourceConsumptionEnum::declaration() const { return *IFC2X3_IfcResourceConsumptionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcResourceConsumptionEnum::Class() { return *IFC2X3_IfcResourceConsumptionEnum_type; }

Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumptionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumptionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcResourceConsumptionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumptionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcResourceConsumptionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcResourceConsumptionEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CONSUMED", "PARTIALLYCONSUMED", "NOTCONSUMED", "OCCUPIED", "PARTIALLYOCCUPIED", "NOTOCCUPIED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcResourceConsumptionEnum::Value Ifc2x3::IfcResourceConsumptionEnum::FromString(const std::string& s) {
    if (s == "CONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_CONSUMED;
    if (s == "PARTIALLYCONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_PARTIALLYCONSUMED;
    if (s == "NOTCONSUMED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTCONSUMED;
    if (s == "OCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_OCCUPIED;
    if (s == "PARTIALLYOCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_PARTIALLYOCCUPIED;
    if (s == "NOTOCCUPIED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTOCCUPIED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcResourceConsumptionEnum::IfcResourceConsumption_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcResourceConsumptionEnum::operator Ifc2x3::IfcResourceConsumptionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRibPlateDirectionEnum::declaration() const { return *IFC2X3_IfcRibPlateDirectionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRibPlateDirectionEnum::Class() { return *IFC2X3_IfcRibPlateDirectionEnum_type; }

Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRibPlateDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRibPlateDirectionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRibPlateDirectionEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DIRECTION_X", "DIRECTION_Y" };
    return names[v];
}

Ifc2x3::IfcRibPlateDirectionEnum::Value Ifc2x3::IfcRibPlateDirectionEnum::FromString(const std::string& s) {
    if (s == "DIRECTION_X") return ::Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirection_DIRECTION_X;
    if (s == "DIRECTION_Y") return ::Ifc2x3::IfcRibPlateDirectionEnum::IfcRibPlateDirection_DIRECTION_Y;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRibPlateDirectionEnum::operator Ifc2x3::IfcRibPlateDirectionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRoleEnum::declaration() const { return *IFC2X3_IfcRoleEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRoleEnum::Class() { return *IFC2X3_IfcRoleEnum_type; }

Ifc2x3::IfcRoleEnum::IfcRoleEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRoleEnum::IfcRoleEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRoleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRoleEnum::IfcRoleEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRoleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRoleEnum::ToString(Value v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SUPPLIER", "MANUFACTURER", "CONTRACTOR", "SUBCONTRACTOR", "ARCHITECT", "STRUCTURALENGINEER", "COSTENGINEER", "CLIENT", "BUILDINGOWNER", "BUILDINGOPERATOR", "MECHANICALENGINEER", "ELECTRICALENGINEER", "PROJECTMANAGER", "FACILITIESMANAGER", "CIVILENGINEER", "COMISSIONINGENGINEER", "ENGINEER", "OWNER", "CONSULTANT", "CONSTRUCTIONMANAGER", "FIELDCONSTRUCTIONMANAGER", "RESELLER", "USERDEFINED" };
    return names[v];
}

Ifc2x3::IfcRoleEnum::Value Ifc2x3::IfcRoleEnum::FromString(const std::string& s) {
    if (s == "SUPPLIER") return ::Ifc2x3::IfcRoleEnum::IfcRole_SUPPLIER;
    if (s == "MANUFACTURER") return ::Ifc2x3::IfcRoleEnum::IfcRole_MANUFACTURER;
    if (s == "CONTRACTOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONTRACTOR;
    if (s == "SUBCONTRACTOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_SUBCONTRACTOR;
    if (s == "ARCHITECT") return ::Ifc2x3::IfcRoleEnum::IfcRole_ARCHITECT;
    if (s == "STRUCTURALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_STRUCTURALENGINEER;
    if (s == "COSTENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_COSTENGINEER;
    if (s == "CLIENT") return ::Ifc2x3::IfcRoleEnum::IfcRole_CLIENT;
    if (s == "BUILDINGOWNER") return ::Ifc2x3::IfcRoleEnum::IfcRole_BUILDINGOWNER;
    if (s == "BUILDINGOPERATOR") return ::Ifc2x3::IfcRoleEnum::IfcRole_BUILDINGOPERATOR;
    if (s == "MECHANICALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_MECHANICALENGINEER;
    if (s == "ELECTRICALENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_ELECTRICALENGINEER;
    if (s == "PROJECTMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_PROJECTMANAGER;
    if (s == "FACILITIESMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_FACILITIESMANAGER;
    if (s == "CIVILENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_CIVILENGINEER;
    if (s == "COMISSIONINGENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_COMISSIONINGENGINEER;
    if (s == "ENGINEER") return ::Ifc2x3::IfcRoleEnum::IfcRole_ENGINEER;
    if (s == "OWNER") return ::Ifc2x3::IfcRoleEnum::IfcRole_OWNER;
    if (s == "CONSULTANT") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONSULTANT;
    if (s == "CONSTRUCTIONMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_CONSTRUCTIONMANAGER;
    if (s == "FIELDCONSTRUCTIONMANAGER") return ::Ifc2x3::IfcRoleEnum::IfcRole_FIELDCONSTRUCTIONMANAGER;
    if (s == "RESELLER") return ::Ifc2x3::IfcRoleEnum::IfcRole_RESELLER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcRoleEnum::IfcRole_USERDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRoleEnum::operator Ifc2x3::IfcRoleEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcRoofTypeEnum::declaration() const { return *IFC2X3_IfcRoofTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcRoofTypeEnum::Class() { return *IFC2X3_IfcRoofTypeEnum_type; }

Ifc2x3::IfcRoofTypeEnum::IfcRoofTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcRoofTypeEnum::IfcRoofTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRoofTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcRoofTypeEnum::IfcRoofTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcRoofTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcRoofTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLAT_ROOF", "SHED_ROOF", "GABLE_ROOF", "HIP_ROOF", "HIPPED_GABLE_ROOF", "GAMBREL_ROOF", "MANSARD_ROOF", "BARREL_ROOF", "RAINBOW_ROOF", "BUTTERFLY_ROOF", "PAVILION_ROOF", "DOME_ROOF", "FREEFORM", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcRoofTypeEnum::Value Ifc2x3::IfcRoofTypeEnum::FromString(const std::string& s) {
    if (s == "FLAT_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_FLAT_ROOF;
    if (s == "SHED_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_SHED_ROOF;
    if (s == "GABLE_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_GABLE_ROOF;
    if (s == "HIP_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_HIP_ROOF;
    if (s == "HIPPED_GABLE_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_HIPPED_GABLE_ROOF;
    if (s == "GAMBREL_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_GAMBREL_ROOF;
    if (s == "MANSARD_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_MANSARD_ROOF;
    if (s == "BARREL_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_BARREL_ROOF;
    if (s == "RAINBOW_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_RAINBOW_ROOF;
    if (s == "BUTTERFLY_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_BUTTERFLY_ROOF;
    if (s == "PAVILION_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_PAVILION_ROOF;
    if (s == "DOME_ROOF") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_DOME_ROOF;
    if (s == "FREEFORM") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_FREEFORM;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcRoofTypeEnum::IfcRoofType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcRoofTypeEnum::operator Ifc2x3::IfcRoofTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSIPrefix::declaration() const { return *IFC2X3_IfcSIPrefix_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSIPrefix::Class() { return *IFC2X3_IfcSIPrefix_type; }

Ifc2x3::IfcSIPrefix::IfcSIPrefix(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSIPrefix::IfcSIPrefix(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSIPrefix_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSIPrefix::IfcSIPrefix(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSIPrefix_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSIPrefix::ToString(Value v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "EXA", "PETA", "TERA", "GIGA", "MEGA", "KILO", "HECTO", "DECA", "DECI", "CENTI", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO" };
    return names[v];
}

Ifc2x3::IfcSIPrefix::Value Ifc2x3::IfcSIPrefix::FromString(const std::string& s) {
    if (s == "EXA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_EXA;
    if (s == "PETA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_PETA;
    if (s == "TERA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_TERA;
    if (s == "GIGA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_GIGA;
    if (s == "MEGA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MEGA;
    if (s == "KILO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_KILO;
    if (s == "HECTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_HECTO;
    if (s == "DECA") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_DECA;
    if (s == "DECI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_DECI;
    if (s == "CENTI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_CENTI;
    if (s == "MILLI") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MILLI;
    if (s == "MICRO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_MICRO;
    if (s == "NANO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_NANO;
    if (s == "PICO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_PICO;
    if (s == "FEMTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_FEMTO;
    if (s == "ATTO") return ::Ifc2x3::IfcSIPrefix::IfcSIPrefix_ATTO;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSIPrefix::operator Ifc2x3::IfcSIPrefix::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSIUnitName::declaration() const { return *IFC2X3_IfcSIUnitName_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSIUnitName::Class() { return *IFC2X3_IfcSIUnitName_type; }

Ifc2x3::IfcSIUnitName::IfcSIUnitName(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSIUnitName::IfcSIUnitName(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSIUnitName_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSIUnitName::IfcSIUnitName(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSIUnitName_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSIUnitName::ToString(Value v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AMPERE", "BECQUEREL", "CANDELA", "COULOMB", "CUBIC_METRE", "DEGREE_CELSIUS", "FARAD", "GRAM", "GRAY", "HENRY", "HERTZ", "JOULE", "KELVIN", "LUMEN", "LUX", "METRE", "MOLE", "NEWTON", "OHM", "PASCAL", "RADIAN", "SECOND", "SIEMENS", "SIEVERT", "SQUARE_METRE", "STERADIAN", "TESLA", "VOLT", "WATT", "WEBER" };
    return names[v];
}

Ifc2x3::IfcSIUnitName::Value Ifc2x3::IfcSIUnitName::FromString(const std::string& s) {
    if (s == "AMPERE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_AMPERE;
    if (s == "BECQUEREL") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_BECQUEREL;
    if (s == "CANDELA") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_CANDELA;
    if (s == "COULOMB") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_COULOMB;
    if (s == "CUBIC_METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_CUBIC_METRE;
    if (s == "DEGREE_CELSIUS") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_DEGREE_CELSIUS;
    if (s == "FARAD") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_FARAD;
    if (s == "GRAM") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_GRAM;
    if (s == "GRAY") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_GRAY;
    if (s == "HENRY") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_HENRY;
    if (s == "HERTZ") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_HERTZ;
    if (s == "JOULE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_JOULE;
    if (s == "KELVIN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_KELVIN;
    if (s == "LUMEN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_LUMEN;
    if (s == "LUX") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_LUX;
    if (s == "METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_METRE;
    if (s == "MOLE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_MOLE;
    if (s == "NEWTON") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_NEWTON;
    if (s == "OHM") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_OHM;
    if (s == "PASCAL") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_PASCAL;
    if (s == "RADIAN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_RADIAN;
    if (s == "SECOND") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SECOND;
    if (s == "SIEMENS") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SIEMENS;
    if (s == "SIEVERT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SIEVERT;
    if (s == "SQUARE_METRE") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_SQUARE_METRE;
    if (s == "STERADIAN") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_STERADIAN;
    if (s == "TESLA") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_TESLA;
    if (s == "VOLT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_VOLT;
    if (s == "WATT") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_WATT;
    if (s == "WEBER") return ::Ifc2x3::IfcSIUnitName::IfcSIUnitName_WEBER;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSIUnitName::operator Ifc2x3::IfcSIUnitName::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSanitaryTerminalTypeEnum::declaration() const { return *IFC2X3_IfcSanitaryTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSanitaryTerminalTypeEnum::Class() { return *IFC2X3_IfcSanitaryTerminalTypeEnum_type; }

Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSanitaryTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSanitaryTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSanitaryTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BATH", "BIDET", "CISTERN", "SHOWER", "SINK", "SANITARYFOUNTAIN", "TOILETPAN", "URINAL", "WASHHANDBASIN", "WCSEAT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSanitaryTerminalTypeEnum::Value Ifc2x3::IfcSanitaryTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BATH") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BATH;
    if (s == "BIDET") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BIDET;
    if (s == "CISTERN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_CISTERN;
    if (s == "SHOWER") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SHOWER;
    if (s == "SINK") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SINK;
    if (s == "SANITARYFOUNTAIN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SANITARYFOUNTAIN;
    if (s == "TOILETPAN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_TOILETPAN;
    if (s == "URINAL") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_URINAL;
    if (s == "WASHHANDBASIN") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WASHHANDBASIN;
    if (s == "WCSEAT") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WCSEAT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSanitaryTerminalTypeEnum::operator Ifc2x3::IfcSanitaryTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSectionTypeEnum::declaration() const { return *IFC2X3_IfcSectionTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSectionTypeEnum::Class() { return *IFC2X3_IfcSectionTypeEnum_type; }

Ifc2x3::IfcSectionTypeEnum::IfcSectionTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSectionTypeEnum::IfcSectionTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSectionTypeEnum::IfcSectionTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSectionTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "UNIFORM", "TAPERED" };
    return names[v];
}

Ifc2x3::IfcSectionTypeEnum::Value Ifc2x3::IfcSectionTypeEnum::FromString(const std::string& s) {
    if (s == "UNIFORM") return ::Ifc2x3::IfcSectionTypeEnum::IfcSectionType_UNIFORM;
    if (s == "TAPERED") return ::Ifc2x3::IfcSectionTypeEnum::IfcSectionType_TAPERED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSectionTypeEnum::operator Ifc2x3::IfcSectionTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSensorTypeEnum::declaration() const { return *IFC2X3_IfcSensorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSensorTypeEnum::Class() { return *IFC2X3_IfcSensorTypeEnum_type; }

Ifc2x3::IfcSensorTypeEnum::IfcSensorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSensorTypeEnum::IfcSensorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSensorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSensorTypeEnum::IfcSensorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSensorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSensorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CO2SENSOR", "FIRESENSOR", "FLOWSENSOR", "GASSENSOR", "HEATSENSOR", "HUMIDITYSENSOR", "LIGHTSENSOR", "MOISTURESENSOR", "MOVEMENTSENSOR", "PRESSURESENSOR", "SMOKESENSOR", "SOUNDSENSOR", "TEMPERATURESENSOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSensorTypeEnum::Value Ifc2x3::IfcSensorTypeEnum::FromString(const std::string& s) {
    if (s == "CO2SENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_CO2SENSOR;
    if (s == "FIRESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_FIRESENSOR;
    if (s == "FLOWSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_FLOWSENSOR;
    if (s == "GASSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_GASSENSOR;
    if (s == "HEATSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_HEATSENSOR;
    if (s == "HUMIDITYSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_HUMIDITYSENSOR;
    if (s == "LIGHTSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_LIGHTSENSOR;
    if (s == "MOISTURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_MOISTURESENSOR;
    if (s == "MOVEMENTSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_MOVEMENTSENSOR;
    if (s == "PRESSURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_PRESSURESENSOR;
    if (s == "SMOKESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_SMOKESENSOR;
    if (s == "SOUNDSENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_SOUNDSENSOR;
    if (s == "TEMPERATURESENSOR") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_TEMPERATURESENSOR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSensorTypeEnum::IfcSensorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSensorTypeEnum::operator Ifc2x3::IfcSensorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSequenceEnum::declaration() const { return *IFC2X3_IfcSequenceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSequenceEnum::Class() { return *IFC2X3_IfcSequenceEnum_type; }

Ifc2x3::IfcSequenceEnum::IfcSequenceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSequenceEnum::IfcSequenceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSequenceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSequenceEnum::IfcSequenceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSequenceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSequenceEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "START_START", "START_FINISH", "FINISH_START", "FINISH_FINISH", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSequenceEnum::Value Ifc2x3::IfcSequenceEnum::FromString(const std::string& s) {
    if (s == "START_START") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_START_START;
    if (s == "START_FINISH") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_START_FINISH;
    if (s == "FINISH_START") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_FINISH_START;
    if (s == "FINISH_FINISH") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_FINISH_FINISH;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSequenceEnum::IfcSequence_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSequenceEnum::operator Ifc2x3::IfcSequenceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcServiceLifeFactorTypeEnum::declaration() const { return *IFC2X3_IfcServiceLifeFactorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcServiceLifeFactorTypeEnum::Class() { return *IFC2X3_IfcServiceLifeFactorTypeEnum_type; }

Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLifeFactorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLifeFactorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcServiceLifeFactorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "A_QUALITYOFCOMPONENTS", "B_DESIGNLEVEL", "C_WORKEXECUTIONLEVEL", "D_INDOORENVIRONMENT", "E_OUTDOORENVIRONMENT", "F_INUSECONDITIONS", "G_MAINTENANCELEVEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcServiceLifeFactorTypeEnum::Value Ifc2x3::IfcServiceLifeFactorTypeEnum::FromString(const std::string& s) {
    if (s == "A_QUALITYOFCOMPONENTS") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_A_QUALITYOFCOMPONENTS;
    if (s == "B_DESIGNLEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_B_DESIGNLEVEL;
    if (s == "C_WORKEXECUTIONLEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_C_WORKEXECUTIONLEVEL;
    if (s == "D_INDOORENVIRONMENT") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_D_INDOORENVIRONMENT;
    if (s == "E_OUTDOORENVIRONMENT") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_E_OUTDOORENVIRONMENT;
    if (s == "F_INUSECONDITIONS") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_F_INUSECONDITIONS;
    if (s == "G_MAINTENANCELEVEL") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_G_MAINTENANCELEVEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcServiceLifeFactorTypeEnum::operator Ifc2x3::IfcServiceLifeFactorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcServiceLifeTypeEnum::declaration() const { return *IFC2X3_IfcServiceLifeTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcServiceLifeTypeEnum::Class() { return *IFC2X3_IfcServiceLifeTypeEnum_type; }

Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLifeTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLifeTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcServiceLifeTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ACTUALSERVICELIFE", "EXPECTEDSERVICELIFE", "OPTIMISTICREFERENCESERVICELIFE", "PESSIMISTICREFERENCESERVICELIFE", "REFERENCESERVICELIFE" };
    return names[v];
}

Ifc2x3::IfcServiceLifeTypeEnum::Value Ifc2x3::IfcServiceLifeTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUALSERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_ACTUALSERVICELIFE;
    if (s == "EXPECTEDSERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_EXPECTEDSERVICELIFE;
    if (s == "OPTIMISTICREFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_OPTIMISTICREFERENCESERVICELIFE;
    if (s == "PESSIMISTICREFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_PESSIMISTICREFERENCESERVICELIFE;
    if (s == "REFERENCESERVICELIFE") return ::Ifc2x3::IfcServiceLifeTypeEnum::IfcServiceLifeType_REFERENCESERVICELIFE;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcServiceLifeTypeEnum::operator Ifc2x3::IfcServiceLifeTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSlabTypeEnum::declaration() const { return *IFC2X3_IfcSlabTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSlabTypeEnum::Class() { return *IFC2X3_IfcSlabTypeEnum_type; }

Ifc2x3::IfcSlabTypeEnum::IfcSlabTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSlabTypeEnum::IfcSlabTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSlabTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSlabTypeEnum::IfcSlabTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSlabTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSlabTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLOOR", "ROOF", "LANDING", "BASESLAB", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSlabTypeEnum::Value Ifc2x3::IfcSlabTypeEnum::FromString(const std::string& s) {
    if (s == "FLOOR") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_FLOOR;
    if (s == "ROOF") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_ROOF;
    if (s == "LANDING") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_LANDING;
    if (s == "BASESLAB") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_BASESLAB;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSlabTypeEnum::IfcSlabType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSlabTypeEnum::operator Ifc2x3::IfcSlabTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSoundScaleEnum::declaration() const { return *IFC2X3_IfcSoundScaleEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSoundScaleEnum::Class() { return *IFC2X3_IfcSoundScaleEnum_type; }

Ifc2x3::IfcSoundScaleEnum::IfcSoundScaleEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSoundScaleEnum::IfcSoundScaleEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundScaleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSoundScaleEnum::IfcSoundScaleEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundScaleEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSoundScaleEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DBA", "DBB", "DBC", "NC", "NR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSoundScaleEnum::Value Ifc2x3::IfcSoundScaleEnum::FromString(const std::string& s) {
    if (s == "DBA") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBA;
    if (s == "DBB") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBB;
    if (s == "DBC") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_DBC;
    if (s == "NC") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NC;
    if (s == "NR") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSoundScaleEnum::IfcSoundScale_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSoundScaleEnum::operator Ifc2x3::IfcSoundScaleEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSpaceHeaterTypeEnum::declaration() const { return *IFC2X3_IfcSpaceHeaterTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSpaceHeaterTypeEnum::Class() { return *IFC2X3_IfcSpaceHeaterTypeEnum_type; }

Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceHeaterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceHeaterTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSpaceHeaterTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SECTIONALRADIATOR", "PANELRADIATOR", "TUBULARRADIATOR", "CONVECTOR", "BASEBOARDHEATER", "FINNEDTUBEUNIT", "UNITHEATER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSpaceHeaterTypeEnum::Value Ifc2x3::IfcSpaceHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "SECTIONALRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_SECTIONALRADIATOR;
    if (s == "PANELRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_PANELRADIATOR;
    if (s == "TUBULARRADIATOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_TUBULARRADIATOR;
    if (s == "CONVECTOR") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_CONVECTOR;
    if (s == "BASEBOARDHEATER") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_BASEBOARDHEATER;
    if (s == "FINNEDTUBEUNIT") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_FINNEDTUBEUNIT;
    if (s == "UNITHEATER") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_UNITHEATER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSpaceHeaterTypeEnum::operator Ifc2x3::IfcSpaceHeaterTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSpaceTypeEnum::declaration() const { return *IFC2X3_IfcSpaceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSpaceTypeEnum::Class() { return *IFC2X3_IfcSpaceTypeEnum_type; }

Ifc2x3::IfcSpaceTypeEnum::IfcSpaceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSpaceTypeEnum::IfcSpaceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSpaceTypeEnum::IfcSpaceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSpaceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSpaceTypeEnum::Value Ifc2x3::IfcSpaceTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSpaceTypeEnum::IfcSpaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSpaceTypeEnum::IfcSpaceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSpaceTypeEnum::operator Ifc2x3::IfcSpaceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStackTerminalTypeEnum::declaration() const { return *IFC2X3_IfcStackTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStackTerminalTypeEnum::Class() { return *IFC2X3_IfcStackTerminalTypeEnum_type; }

Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStackTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStackTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStackTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BIRDCAGE", "COWL", "RAINWATERHOPPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcStackTerminalTypeEnum::Value Ifc2x3::IfcStackTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BIRDCAGE") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_BIRDCAGE;
    if (s == "COWL") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_COWL;
    if (s == "RAINWATERHOPPER") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_RAINWATERHOPPER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStackTerminalTypeEnum::IfcStackTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStackTerminalTypeEnum::operator Ifc2x3::IfcStackTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStairFlightTypeEnum::declaration() const { return *IFC2X3_IfcStairFlightTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStairFlightTypeEnum::Class() { return *IFC2X3_IfcStairFlightTypeEnum_type; }

Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStairFlightTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStairFlightTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStairFlightTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STRAIGHT", "WINDER", "SPIRAL", "CURVED", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcStairFlightTypeEnum::Value Ifc2x3::IfcStairFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_STRAIGHT;
    if (s == "WINDER") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_WINDER;
    if (s == "SPIRAL") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_SPIRAL;
    if (s == "CURVED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_CURVED;
    if (s == "FREEFORM") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStairFlightTypeEnum::IfcStairFlightType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStairFlightTypeEnum::operator Ifc2x3::IfcStairFlightTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStairTypeEnum::declaration() const { return *IFC2X3_IfcStairTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStairTypeEnum::Class() { return *IFC2X3_IfcStairTypeEnum_type; }

Ifc2x3::IfcStairTypeEnum::IfcStairTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStairTypeEnum::IfcStairTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStairTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStairTypeEnum::IfcStairTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStairTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStairTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_STAIR", "TWO_STRAIGHT_RUN_STAIR", "QUARTER_WINDING_STAIR", "QUARTER_TURN_STAIR", "HALF_WINDING_STAIR", "HALF_TURN_STAIR", "TWO_QUARTER_WINDING_STAIR", "TWO_QUARTER_TURN_STAIR", "THREE_QUARTER_WINDING_STAIR", "THREE_QUARTER_TURN_STAIR", "SPIRAL_STAIR", "DOUBLE_RETURN_STAIR", "CURVED_RUN_STAIR", "TWO_CURVED_RUN_STAIR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcStairTypeEnum::Value Ifc2x3::IfcStairTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_STRAIGHT_RUN_STAIR;
    if (s == "TWO_STRAIGHT_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_STRAIGHT_RUN_STAIR;
    if (s == "QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_QUARTER_WINDING_STAIR;
    if (s == "QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_QUARTER_TURN_STAIR;
    if (s == "HALF_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_HALF_WINDING_STAIR;
    if (s == "HALF_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_HALF_TURN_STAIR;
    if (s == "TWO_QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_WINDING_STAIR;
    if (s == "TWO_QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_TURN_STAIR;
    if (s == "THREE_QUARTER_WINDING_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_WINDING_STAIR;
    if (s == "THREE_QUARTER_TURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_TURN_STAIR;
    if (s == "SPIRAL_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_SPIRAL_STAIR;
    if (s == "DOUBLE_RETURN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_DOUBLE_RETURN_STAIR;
    if (s == "CURVED_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_CURVED_RUN_STAIR;
    if (s == "TWO_CURVED_RUN_STAIR") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_TWO_CURVED_RUN_STAIR;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStairTypeEnum::IfcStairType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStairTypeEnum::operator Ifc2x3::IfcStairTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStateEnum::declaration() const { return *IFC2X3_IfcStateEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStateEnum::Class() { return *IFC2X3_IfcStateEnum_type; }

Ifc2x3::IfcStateEnum::IfcStateEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStateEnum::IfcStateEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStateEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStateEnum::IfcStateEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStateEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStateEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "READWRITE", "READONLY", "LOCKED", "READWRITELOCKED", "READONLYLOCKED" };
    return names[v];
}

Ifc2x3::IfcStateEnum::Value Ifc2x3::IfcStateEnum::FromString(const std::string& s) {
    if (s == "READWRITE") return ::Ifc2x3::IfcStateEnum::IfcState_READWRITE;
    if (s == "READONLY") return ::Ifc2x3::IfcStateEnum::IfcState_READONLY;
    if (s == "LOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_LOCKED;
    if (s == "READWRITELOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_READWRITELOCKED;
    if (s == "READONLYLOCKED") return ::Ifc2x3::IfcStateEnum::IfcState_READONLYLOCKED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStateEnum::operator Ifc2x3::IfcStateEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStructuralCurveTypeEnum::declaration() const { return *IFC2X3_IfcStructuralCurveTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStructuralCurveTypeEnum::Class() { return *IFC2X3_IfcStructuralCurveTypeEnum_type; }

Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralCurveTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralCurveTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStructuralCurveTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "RIGID_JOINED_MEMBER", "PIN_JOINED_MEMBER", "CABLE", "TENSION_MEMBER", "COMPRESSION_MEMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcStructuralCurveTypeEnum::Value Ifc2x3::IfcStructuralCurveTypeEnum::FromString(const std::string& s) {
    if (s == "RIGID_JOINED_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_RIGID_JOINED_MEMBER;
    if (s == "PIN_JOINED_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_PIN_JOINED_MEMBER;
    if (s == "CABLE") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_CABLE;
    if (s == "TENSION_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_TENSION_MEMBER;
    if (s == "COMPRESSION_MEMBER") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_COMPRESSION_MEMBER;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStructuralCurveTypeEnum::IfcStructuralCurveType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStructuralCurveTypeEnum::operator Ifc2x3::IfcStructuralCurveTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcStructuralSurfaceTypeEnum::declaration() const { return *IFC2X3_IfcStructuralSurfaceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcStructuralSurfaceTypeEnum::Class() { return *IFC2X3_IfcStructuralSurfaceTypeEnum_type; }

Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSurfaceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSurfaceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcStructuralSurfaceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BENDING_ELEMENT", "MEMBRANE_ELEMENT", "SHELL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcStructuralSurfaceTypeEnum::Value Ifc2x3::IfcStructuralSurfaceTypeEnum::FromString(const std::string& s) {
    if (s == "BENDING_ELEMENT") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_BENDING_ELEMENT;
    if (s == "MEMBRANE_ELEMENT") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_MEMBRANE_ELEMENT;
    if (s == "SHELL") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_SHELL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcStructuralSurfaceTypeEnum::operator Ifc2x3::IfcStructuralSurfaceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSurfaceSide::declaration() const { return *IFC2X3_IfcSurfaceSide_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSurfaceSide::Class() { return *IFC2X3_IfcSurfaceSide_type; }

Ifc2x3::IfcSurfaceSide::IfcSurfaceSide(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSurfaceSide::IfcSurfaceSide(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceSide_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSurfaceSide::IfcSurfaceSide(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceSide_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSurfaceSide::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE", "BOTH" };
    return names[v];
}

Ifc2x3::IfcSurfaceSide::Value Ifc2x3::IfcSurfaceSide::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_NEGATIVE;
    if (s == "BOTH") return ::Ifc2x3::IfcSurfaceSide::IfcSurfaceSide_BOTH;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSurfaceSide::operator Ifc2x3::IfcSurfaceSide::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSurfaceTextureEnum::declaration() const { return *IFC2X3_IfcSurfaceTextureEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSurfaceTextureEnum::Class() { return *IFC2X3_IfcSurfaceTextureEnum_type; }

Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTextureEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTextureEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceTextureEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTextureEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceTextureEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSurfaceTextureEnum::ToString(Value v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "BUMP", "OPACITY", "REFLECTION", "SELFILLUMINATION", "SHININESS", "SPECULAR", "TEXTURE", "TRANSPARENCYMAP", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSurfaceTextureEnum::Value Ifc2x3::IfcSurfaceTextureEnum::FromString(const std::string& s) {
    if (s == "BUMP") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_BUMP;
    if (s == "OPACITY") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_OPACITY;
    if (s == "REFLECTION") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_REFLECTION;
    if (s == "SELFILLUMINATION") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SELFILLUMINATION;
    if (s == "SHININESS") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SHININESS;
    if (s == "SPECULAR") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_SPECULAR;
    if (s == "TEXTURE") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_TEXTURE;
    if (s == "TRANSPARENCYMAP") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_TRANSPARENCYMAP;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSurfaceTextureEnum::IfcSurfaceTexture_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSurfaceTextureEnum::operator Ifc2x3::IfcSurfaceTextureEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcSwitchingDeviceTypeEnum::declaration() const { return *IFC2X3_IfcSwitchingDeviceTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcSwitchingDeviceTypeEnum::Class() { return *IFC2X3_IfcSwitchingDeviceTypeEnum_type; }

Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSwitchingDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcSwitchingDeviceTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcSwitchingDeviceTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CONTACTOR", "EMERGENCYSTOP", "STARTER", "SWITCHDISCONNECTOR", "TOGGLESWITCH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcSwitchingDeviceTypeEnum::Value Ifc2x3::IfcSwitchingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CONTACTOR") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_CONTACTOR;
    if (s == "EMERGENCYSTOP") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_EMERGENCYSTOP;
    if (s == "STARTER") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_STARTER;
    if (s == "SWITCHDISCONNECTOR") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SWITCHDISCONNECTOR;
    if (s == "TOGGLESWITCH") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_TOGGLESWITCH;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcSwitchingDeviceTypeEnum::operator Ifc2x3::IfcSwitchingDeviceTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTankTypeEnum::declaration() const { return *IFC2X3_IfcTankTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTankTypeEnum::Class() { return *IFC2X3_IfcTankTypeEnum_type; }

Ifc2x3::IfcTankTypeEnum::IfcTankTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTankTypeEnum::IfcTankTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTankTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTankTypeEnum::IfcTankTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTankTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTankTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PREFORMED", "SECTIONAL", "EXPANSION", "PRESSUREVESSEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTankTypeEnum::Value Ifc2x3::IfcTankTypeEnum::FromString(const std::string& s) {
    if (s == "PREFORMED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_PREFORMED;
    if (s == "SECTIONAL") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_SECTIONAL;
    if (s == "EXPANSION") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_EXPANSION;
    if (s == "PRESSUREVESSEL") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_PRESSUREVESSEL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTankTypeEnum::IfcTankType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTankTypeEnum::operator Ifc2x3::IfcTankTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTendonTypeEnum::declaration() const { return *IFC2X3_IfcTendonTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTendonTypeEnum::Class() { return *IFC2X3_IfcTendonTypeEnum_type; }

Ifc2x3::IfcTendonTypeEnum::IfcTendonTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTendonTypeEnum::IfcTendonTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTendonTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTendonTypeEnum::IfcTendonTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTendonTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTendonTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STRAND", "WIRE", "BAR", "COATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTendonTypeEnum::Value Ifc2x3::IfcTendonTypeEnum::FromString(const std::string& s) {
    if (s == "STRAND") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_STRAND;
    if (s == "WIRE") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_WIRE;
    if (s == "BAR") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_BAR;
    if (s == "COATED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_COATED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTendonTypeEnum::IfcTendonType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTendonTypeEnum::operator Ifc2x3::IfcTendonTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTextPath::declaration() const { return *IFC2X3_IfcTextPath_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTextPath::Class() { return *IFC2X3_IfcTextPath_type; }

Ifc2x3::IfcTextPath::IfcTextPath(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTextPath::IfcTextPath(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTextPath_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTextPath::IfcTextPath(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTextPath_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTextPath::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "LEFT", "RIGHT", "UP", "DOWN" };
    return names[v];
}

Ifc2x3::IfcTextPath::Value Ifc2x3::IfcTextPath::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcTextPath::IfcTextPath_LEFT;
    if (s == "RIGHT") return ::Ifc2x3::IfcTextPath::IfcTextPath_RIGHT;
    if (s == "UP") return ::Ifc2x3::IfcTextPath::IfcTextPath_UP;
    if (s == "DOWN") return ::Ifc2x3::IfcTextPath::IfcTextPath_DOWN;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTextPath::operator Ifc2x3::IfcTextPath::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcThermalLoadSourceEnum::declaration() const { return *IFC2X3_IfcThermalLoadSourceEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcThermalLoadSourceEnum::Class() { return *IFC2X3_IfcThermalLoadSourceEnum_type; }

Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalLoadSourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalLoadSourceEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcThermalLoadSourceEnum::ToString(Value v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "PEOPLE", "LIGHTING", "EQUIPMENT", "VENTILATIONINDOORAIR", "VENTILATIONOUTSIDEAIR", "RECIRCULATEDAIR", "EXHAUSTAIR", "AIREXCHANGERATE", "DRYBULBTEMPERATURE", "RELATIVEHUMIDITY", "INFILTRATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcThermalLoadSourceEnum::Value Ifc2x3::IfcThermalLoadSourceEnum::FromString(const std::string& s) {
    if (s == "PEOPLE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_PEOPLE;
    if (s == "LIGHTING") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_LIGHTING;
    if (s == "EQUIPMENT") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_EQUIPMENT;
    if (s == "VENTILATIONINDOORAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_VENTILATIONINDOORAIR;
    if (s == "VENTILATIONOUTSIDEAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_VENTILATIONOUTSIDEAIR;
    if (s == "RECIRCULATEDAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_RECIRCULATEDAIR;
    if (s == "EXHAUSTAIR") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_EXHAUSTAIR;
    if (s == "AIREXCHANGERATE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_AIREXCHANGERATE;
    if (s == "DRYBULBTEMPERATURE") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_DRYBULBTEMPERATURE;
    if (s == "RELATIVEHUMIDITY") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_RELATIVEHUMIDITY;
    if (s == "INFILTRATION") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_INFILTRATION;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcThermalLoadSourceEnum::IfcThermalLoadSource_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcThermalLoadSourceEnum::operator Ifc2x3::IfcThermalLoadSourceEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcThermalLoadTypeEnum::declaration() const { return *IFC2X3_IfcThermalLoadTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcThermalLoadTypeEnum::Class() { return *IFC2X3_IfcThermalLoadTypeEnum_type; }

Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalLoadTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalLoadTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcThermalLoadTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SENSIBLE", "LATENT", "RADIANT", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcThermalLoadTypeEnum::Value Ifc2x3::IfcThermalLoadTypeEnum::FromString(const std::string& s) {
    if (s == "SENSIBLE") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_SENSIBLE;
    if (s == "LATENT") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_LATENT;
    if (s == "RADIANT") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_RADIANT;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcThermalLoadTypeEnum::IfcThermalLoadType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcThermalLoadTypeEnum::operator Ifc2x3::IfcThermalLoadTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTimeSeriesDataTypeEnum::declaration() const { return *IFC2X3_IfcTimeSeriesDataTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTimeSeriesDataTypeEnum::Class() { return *IFC2X3_IfcTimeSeriesDataTypeEnum_type; }

Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesDataTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesDataTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTimeSeriesDataTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CONTINUOUS", "DISCRETE", "DISCRETEBINARY", "PIECEWISEBINARY", "PIECEWISECONSTANT", "PIECEWISECONTINUOUS", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTimeSeriesDataTypeEnum::Value Ifc2x3::IfcTimeSeriesDataTypeEnum::FromString(const std::string& s) {
    if (s == "CONTINUOUS") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_CONTINUOUS;
    if (s == "DISCRETE") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETE;
    if (s == "DISCRETEBINARY") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETEBINARY;
    if (s == "PIECEWISEBINARY") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISEBINARY;
    if (s == "PIECEWISECONSTANT") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONSTANT;
    if (s == "PIECEWISECONTINUOUS") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONTINUOUS;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTimeSeriesDataTypeEnum::operator Ifc2x3::IfcTimeSeriesDataTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTimeSeriesScheduleTypeEnum::declaration() const { return *IFC2X3_IfcTimeSeriesScheduleTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Class() { return *IFC2X3_IfcTimeSeriesScheduleTypeEnum_type; }

Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesScheduleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesScheduleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTimeSeriesScheduleTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ANNUAL", "MONTHLY", "WEEKLY", "DAILY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Value Ifc2x3::IfcTimeSeriesScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "ANNUAL") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_ANNUAL;
    if (s == "MONTHLY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_MONTHLY;
    if (s == "WEEKLY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_WEEKLY;
    if (s == "DAILY") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_DAILY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTimeSeriesScheduleTypeEnum::operator Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTransformerTypeEnum::declaration() const { return *IFC2X3_IfcTransformerTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTransformerTypeEnum::Class() { return *IFC2X3_IfcTransformerTypeEnum_type; }

Ifc2x3::IfcTransformerTypeEnum::IfcTransformerTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTransformerTypeEnum::IfcTransformerTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransformerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTransformerTypeEnum::IfcTransformerTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransformerTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTransformerTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CURRENT", "FREQUENCY", "VOLTAGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTransformerTypeEnum::Value Ifc2x3::IfcTransformerTypeEnum::FromString(const std::string& s) {
    if (s == "CURRENT") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_CURRENT;
    if (s == "FREQUENCY") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_FREQUENCY;
    if (s == "VOLTAGE") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_VOLTAGE;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTransformerTypeEnum::IfcTransformerType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTransformerTypeEnum::operator Ifc2x3::IfcTransformerTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTransitionCode::declaration() const { return *IFC2X3_IfcTransitionCode_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTransitionCode::Class() { return *IFC2X3_IfcTransitionCode_type; }

Ifc2x3::IfcTransitionCode::IfcTransitionCode(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTransitionCode::IfcTransitionCode(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransitionCode_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTransitionCode::IfcTransitionCode(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransitionCode_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTransitionCode::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "DISCONTINUOUS", "CONTINUOUS", "CONTSAMEGRADIENT", "CONTSAMEGRADIENTSAMECURVATURE" };
    return names[v];
}

Ifc2x3::IfcTransitionCode::Value Ifc2x3::IfcTransitionCode::FromString(const std::string& s) {
    if (s == "DISCONTINUOUS") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_DISCONTINUOUS;
    if (s == "CONTINUOUS") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTINUOUS;
    if (s == "CONTSAMEGRADIENT") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENT;
    if (s == "CONTSAMEGRADIENTSAMECURVATURE") return ::Ifc2x3::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTransitionCode::operator Ifc2x3::IfcTransitionCode::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTransportElementTypeEnum::declaration() const { return *IFC2X3_IfcTransportElementTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTransportElementTypeEnum::Class() { return *IFC2X3_IfcTransportElementTypeEnum_type; }

Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransportElementTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTransportElementTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTransportElementTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ELEVATOR", "ESCALATOR", "MOVINGWALKWAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTransportElementTypeEnum::Value Ifc2x3::IfcTransportElementTypeEnum::FromString(const std::string& s) {
    if (s == "ELEVATOR") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_ELEVATOR;
    if (s == "ESCALATOR") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_ESCALATOR;
    if (s == "MOVINGWALKWAY") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_MOVINGWALKWAY;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTransportElementTypeEnum::IfcTransportElementType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTransportElementTypeEnum::operator Ifc2x3::IfcTransportElementTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTrimmingPreference::declaration() const { return *IFC2X3_IfcTrimmingPreference_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTrimmingPreference::Class() { return *IFC2X3_IfcTrimmingPreference_type; }

Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTrimmingPreference_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTrimmingPreference_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTrimmingPreference::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "CARTESIAN", "PARAMETER", "UNSPECIFIED" };
    return names[v];
}

Ifc2x3::IfcTrimmingPreference::Value Ifc2x3::IfcTrimmingPreference::FromString(const std::string& s) {
    if (s == "CARTESIAN") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_CARTESIAN;
    if (s == "PARAMETER") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_PARAMETER;
    if (s == "UNSPECIFIED") return ::Ifc2x3::IfcTrimmingPreference::IfcTrimmingPreference_UNSPECIFIED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTrimmingPreference::operator Ifc2x3::IfcTrimmingPreference::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcTubeBundleTypeEnum::declaration() const { return *IFC2X3_IfcTubeBundleTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcTubeBundleTypeEnum::Class() { return *IFC2X3_IfcTubeBundleTypeEnum_type; }

Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTubeBundleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcTubeBundleTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcTubeBundleTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FINNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcTubeBundleTypeEnum::Value Ifc2x3::IfcTubeBundleTypeEnum::FromString(const std::string& s) {
    if (s == "FINNED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_FINNED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcTubeBundleTypeEnum::IfcTubeBundleType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcTubeBundleTypeEnum::operator Ifc2x3::IfcTubeBundleTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcUnitEnum::declaration() const { return *IFC2X3_IfcUnitEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcUnitEnum::Class() { return *IFC2X3_IfcUnitEnum_type; }

Ifc2x3::IfcUnitEnum::IfcUnitEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcUnitEnum::IfcUnitEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcUnitEnum::IfcUnitEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcUnitEnum::ToString(Value v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ABSORBEDDOSEUNIT", "AMOUNTOFSUBSTANCEUNIT", "AREAUNIT", "DOSEEQUIVALENTUNIT", "ELECTRICCAPACITANCEUNIT", "ELECTRICCHARGEUNIT", "ELECTRICCONDUCTANCEUNIT", "ELECTRICCURRENTUNIT", "ELECTRICRESISTANCEUNIT", "ELECTRICVOLTAGEUNIT", "ENERGYUNIT", "FORCEUNIT", "FREQUENCYUNIT", "ILLUMINANCEUNIT", "INDUCTANCEUNIT", "LENGTHUNIT", "LUMINOUSFLUXUNIT", "LUMINOUSINTENSITYUNIT", "MAGNETICFLUXDENSITYUNIT", "MAGNETICFLUXUNIT", "MASSUNIT", "PLANEANGLEUNIT", "POWERUNIT", "PRESSUREUNIT", "RADIOACTIVITYUNIT", "SOLIDANGLEUNIT", "THERMODYNAMICTEMPERATUREUNIT", "TIMEUNIT", "VOLUMEUNIT", "USERDEFINED" };
    return names[v];
}

Ifc2x3::IfcUnitEnum::Value Ifc2x3::IfcUnitEnum::FromString(const std::string& s) {
    if (s == "ABSORBEDDOSEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ABSORBEDDOSEUNIT;
    if (s == "AMOUNTOFSUBSTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_AMOUNTOFSUBSTANCEUNIT;
    if (s == "AREAUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_AREAUNIT;
    if (s == "DOSEEQUIVALENTUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_DOSEEQUIVALENTUNIT;
    if (s == "ELECTRICCAPACITANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCAPACITANCEUNIT;
    if (s == "ELECTRICCHARGEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCHARGEUNIT;
    if (s == "ELECTRICCONDUCTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCONDUCTANCEUNIT;
    if (s == "ELECTRICCURRENTUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICCURRENTUNIT;
    if (s == "ELECTRICRESISTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICRESISTANCEUNIT;
    if (s == "ELECTRICVOLTAGEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ELECTRICVOLTAGEUNIT;
    if (s == "ENERGYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ENERGYUNIT;
    if (s == "FORCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_FORCEUNIT;
    if (s == "FREQUENCYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_FREQUENCYUNIT;
    if (s == "ILLUMINANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_ILLUMINANCEUNIT;
    if (s == "INDUCTANCEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_INDUCTANCEUNIT;
    if (s == "LENGTHUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LENGTHUNIT;
    if (s == "LUMINOUSFLUXUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LUMINOUSFLUXUNIT;
    if (s == "LUMINOUSINTENSITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_LUMINOUSINTENSITYUNIT;
    if (s == "MAGNETICFLUXDENSITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MAGNETICFLUXDENSITYUNIT;
    if (s == "MAGNETICFLUXUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MAGNETICFLUXUNIT;
    if (s == "MASSUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_MASSUNIT;
    if (s == "PLANEANGLEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_PLANEANGLEUNIT;
    if (s == "POWERUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_POWERUNIT;
    if (s == "PRESSUREUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_PRESSUREUNIT;
    if (s == "RADIOACTIVITYUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_RADIOACTIVITYUNIT;
    if (s == "SOLIDANGLEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_SOLIDANGLEUNIT;
    if (s == "THERMODYNAMICTEMPERATUREUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_THERMODYNAMICTEMPERATUREUNIT;
    if (s == "TIMEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_TIMEUNIT;
    if (s == "VOLUMEUNIT") return ::Ifc2x3::IfcUnitEnum::IfcUnit_VOLUMEUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcUnitEnum::IfcUnit_USERDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcUnitEnum::operator Ifc2x3::IfcUnitEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcUnitaryEquipmentTypeEnum::declaration() const { return *IFC2X3_IfcUnitaryEquipmentTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcUnitaryEquipmentTypeEnum::Class() { return *IFC2X3_IfcUnitaryEquipmentTypeEnum_type; }

Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitaryEquipmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitaryEquipmentTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcUnitaryEquipmentTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AIRHANDLER", "AIRCONDITIONINGUNIT", "SPLITSYSTEM", "ROOFTOPUNIT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcUnitaryEquipmentTypeEnum::Value Ifc2x3::IfcUnitaryEquipmentTypeEnum::FromString(const std::string& s) {
    if (s == "AIRHANDLER") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRHANDLER;
    if (s == "AIRCONDITIONINGUNIT") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT;
    if (s == "SPLITSYSTEM") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_SPLITSYSTEM;
    if (s == "ROOFTOPUNIT") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_ROOFTOPUNIT;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcUnitaryEquipmentTypeEnum::operator Ifc2x3::IfcUnitaryEquipmentTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcValveTypeEnum::declaration() const { return *IFC2X3_IfcValveTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcValveTypeEnum::Class() { return *IFC2X3_IfcValveTypeEnum_type; }

Ifc2x3::IfcValveTypeEnum::IfcValveTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcValveTypeEnum::IfcValveTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcValveTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcValveTypeEnum::IfcValveTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcValveTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcValveTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "AIRRELEASE", "ANTIVACUUM", "CHANGEOVER", "CHECK", "COMMISSIONING", "DIVERTING", "DRAWOFFCOCK", "DOUBLECHECK", "DOUBLEREGULATING", "FAUCET", "FLUSHING", "GASCOCK", "GASTAP", "ISOLATING", "MIXING", "PRESSUREREDUCING", "PRESSURERELIEF", "REGULATING", "SAFETYCUTOFF", "STEAMTRAP", "STOPCOCK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcValveTypeEnum::Value Ifc2x3::IfcValveTypeEnum::FromString(const std::string& s) {
    if (s == "AIRRELEASE") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_AIRRELEASE;
    if (s == "ANTIVACUUM") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_ANTIVACUUM;
    if (s == "CHANGEOVER") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_CHANGEOVER;
    if (s == "CHECK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_CHECK;
    if (s == "COMMISSIONING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_COMMISSIONING;
    if (s == "DIVERTING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DIVERTING;
    if (s == "DRAWOFFCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DRAWOFFCOCK;
    if (s == "DOUBLECHECK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DOUBLECHECK;
    if (s == "DOUBLEREGULATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_DOUBLEREGULATING;
    if (s == "FAUCET") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_FAUCET;
    if (s == "FLUSHING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_FLUSHING;
    if (s == "GASCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_GASCOCK;
    if (s == "GASTAP") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_GASTAP;
    if (s == "ISOLATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_ISOLATING;
    if (s == "MIXING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_MIXING;
    if (s == "PRESSUREREDUCING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_PRESSUREREDUCING;
    if (s == "PRESSURERELIEF") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_PRESSURERELIEF;
    if (s == "REGULATING") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_REGULATING;
    if (s == "SAFETYCUTOFF") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_SAFETYCUTOFF;
    if (s == "STEAMTRAP") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_STEAMTRAP;
    if (s == "STOPCOCK") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_STOPCOCK;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcValveTypeEnum::IfcValveType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcValveTypeEnum::operator Ifc2x3::IfcValveTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcVibrationIsolatorTypeEnum::declaration() const { return *IFC2X3_IfcVibrationIsolatorTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcVibrationIsolatorTypeEnum::Class() { return *IFC2X3_IfcVibrationIsolatorTypeEnum_type; }

Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcVibrationIsolatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcVibrationIsolatorTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcVibrationIsolatorTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "COMPRESSION", "SPRING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcVibrationIsolatorTypeEnum::Value Ifc2x3::IfcVibrationIsolatorTypeEnum::FromString(const std::string& s) {
    if (s == "COMPRESSION") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_COMPRESSION;
    if (s == "SPRING") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_SPRING;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcVibrationIsolatorTypeEnum::operator Ifc2x3::IfcVibrationIsolatorTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWallTypeEnum::declaration() const { return *IFC2X3_IfcWallTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWallTypeEnum::Class() { return *IFC2X3_IfcWallTypeEnum_type; }

Ifc2x3::IfcWallTypeEnum::IfcWallTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWallTypeEnum::IfcWallTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWallTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWallTypeEnum::IfcWallTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWallTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWallTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "STANDARD", "POLYGONAL", "SHEAR", "ELEMENTEDWALL", "PLUMBINGWALL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWallTypeEnum::Value Ifc2x3::IfcWallTypeEnum::FromString(const std::string& s) {
    if (s == "STANDARD") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_STANDARD;
    if (s == "POLYGONAL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_POLYGONAL;
    if (s == "SHEAR") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_SHEAR;
    if (s == "ELEMENTEDWALL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_ELEMENTEDWALL;
    if (s == "PLUMBINGWALL") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_PLUMBINGWALL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWallTypeEnum::IfcWallType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWallTypeEnum::operator Ifc2x3::IfcWallTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWasteTerminalTypeEnum::declaration() const { return *IFC2X3_IfcWasteTerminalTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWasteTerminalTypeEnum::Class() { return *IFC2X3_IfcWasteTerminalTypeEnum_type; }

Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWasteTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWasteTerminalTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWasteTerminalTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "FLOORTRAP", "FLOORWASTE", "GULLYSUMP", "GULLYTRAP", "GREASEINTERCEPTOR", "OILINTERCEPTOR", "PETROLINTERCEPTOR", "ROOFDRAIN", "WASTEDISPOSALUNIT", "WASTETRAP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWasteTerminalTypeEnum::Value Ifc2x3::IfcWasteTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "FLOORTRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORTRAP;
    if (s == "FLOORWASTE") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORWASTE;
    if (s == "GULLYSUMP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYSUMP;
    if (s == "GULLYTRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYTRAP;
    if (s == "GREASEINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GREASEINTERCEPTOR;
    if (s == "OILINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_OILINTERCEPTOR;
    if (s == "PETROLINTERCEPTOR") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_PETROLINTERCEPTOR;
    if (s == "ROOFDRAIN") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_ROOFDRAIN;
    if (s == "WASTEDISPOSALUNIT") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTEDISPOSALUNIT;
    if (s == "WASTETRAP") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTETRAP;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWasteTerminalTypeEnum::operator Ifc2x3::IfcWasteTerminalTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWindowPanelOperationEnum::declaration() const { return *IFC2X3_IfcWindowPanelOperationEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWindowPanelOperationEnum::Class() { return *IFC2X3_IfcWindowPanelOperationEnum_type; }

Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowPanelOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowPanelOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWindowPanelOperationEnum::ToString(Value v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SIDEHUNGRIGHTHAND", "SIDEHUNGLEFTHAND", "TILTANDTURNRIGHTHAND", "TILTANDTURNLEFTHAND", "TOPHUNG", "BOTTOMHUNG", "PIVOTHORIZONTAL", "PIVOTVERTICAL", "SLIDINGHORIZONTAL", "SLIDINGVERTICAL", "REMOVABLECASEMENT", "FIXEDCASEMENT", "OTHEROPERATION", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWindowPanelOperationEnum::Value Ifc2x3::IfcWindowPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SIDEHUNGRIGHTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGRIGHTHAND;
    if (s == "SIDEHUNGLEFTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGLEFTHAND;
    if (s == "TILTANDTURNRIGHTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNRIGHTHAND;
    if (s == "TILTANDTURNLEFTHAND") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNLEFTHAND;
    if (s == "TOPHUNG") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TOPHUNG;
    if (s == "BOTTOMHUNG") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_BOTTOMHUNG;
    if (s == "PIVOTHORIZONTAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTHORIZONTAL;
    if (s == "PIVOTVERTICAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTVERTICAL;
    if (s == "SLIDINGHORIZONTAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGHORIZONTAL;
    if (s == "SLIDINGVERTICAL") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGVERTICAL;
    if (s == "REMOVABLECASEMENT") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_REMOVABLECASEMENT;
    if (s == "FIXEDCASEMENT") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_FIXEDCASEMENT;
    if (s == "OTHEROPERATION") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_OTHEROPERATION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWindowPanelOperationEnum::operator Ifc2x3::IfcWindowPanelOperationEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWindowPanelPositionEnum::declaration() const { return *IFC2X3_IfcWindowPanelPositionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWindowPanelPositionEnum::Class() { return *IFC2X3_IfcWindowPanelPositionEnum_type; }

Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowPanelPositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowPanelPositionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWindowPanelPositionEnum::ToString(Value v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "BOTTOM", "TOP", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWindowPanelPositionEnum::Value Ifc2x3::IfcWindowPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_RIGHT;
    if (s == "BOTTOM") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_BOTTOM;
    if (s == "TOP") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_TOP;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWindowPanelPositionEnum::operator Ifc2x3::IfcWindowPanelPositionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWindowStyleConstructionEnum::declaration() const { return *IFC2X3_IfcWindowStyleConstructionEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWindowStyleConstructionEnum::Class() { return *IFC2X3_IfcWindowStyleConstructionEnum_type; }

Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowStyleConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowStyleConstructionEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWindowStyleConstructionEnum::ToString(Value v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "PLASTIC", "OTHER_CONSTRUCTION", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWindowStyleConstructionEnum::Value Ifc2x3::IfcWindowStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM_WOOD;
    if (s == "PLASTIC") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_PLASTIC;
    if (s == "OTHER_CONSTRUCTION") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_OTHER_CONSTRUCTION;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWindowStyleConstructionEnum::operator Ifc2x3::IfcWindowStyleConstructionEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWindowStyleOperationEnum::declaration() const { return *IFC2X3_IfcWindowStyleOperationEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWindowStyleOperationEnum::Class() { return *IFC2X3_IfcWindowStyleOperationEnum_type; }

Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowStyleOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowStyleOperationEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWindowStyleOperationEnum::ToString(Value v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWindowStyleOperationEnum::Value Ifc2x3::IfcWindowStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWindowStyleOperationEnum::operator Ifc2x3::IfcWindowStyleOperationEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::enumeration_type& Ifc2x3::IfcWorkControlTypeEnum::declaration() const { return *IFC2X3_IfcWorkControlTypeEnum_type; }
const IfcParse::enumeration_type& Ifc2x3::IfcWorkControlTypeEnum::Class() { return *IFC2X3_IfcWorkControlTypeEnum_type; }

Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlTypeEnum(IfcEntityInstanceData* e) {
    data_ = e;
}

Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlTypeEnum(Value v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWorkControlTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,ToString(v)));
    data_->setArgument(0,attr);
}

Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlTypeEnum(const std::string& v) {
    data_ = new IfcEntityInstanceData(IFC2X3_IfcWorkControlTypeEnum_type);
    IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
    attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(FromString(v),ToString(FromString(v))));
    data_->setArgument(0,attr);
}

const char* Ifc2x3::IfcWorkControlTypeEnum::ToString(Value v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

Ifc2x3::IfcWorkControlTypeEnum::Value Ifc2x3::IfcWorkControlTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_ACTUAL;
    if (s == "BASELINE") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_BASELINE;
    if (s == "PLANNED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc2x3::IfcWorkControlTypeEnum::IfcWorkControlType_NOTDEFINED;
    throw IfcException("Unable to find keyword in schema: " + s);
}

Ifc2x3::IfcWorkControlTypeEnum::operator Ifc2x3::IfcWorkControlTypeEnum::Value() const {
    return FromString((std::string) *data_->getArgument(0));
}

const IfcParse::select_type& Ifc2x3::IfcActorSelect::Class() { return *IFC2X3_IfcActorSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcAppliedValueSelect::Class() { return *IFC2X3_IfcAppliedValueSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcAxis2Placement::Class() { return *IFC2X3_IfcAxis2Placement_type; }

const IfcParse::select_type& Ifc2x3::IfcBooleanOperand::Class() { return *IFC2X3_IfcBooleanOperand_type; }

const IfcParse::select_type& Ifc2x3::IfcCharacterStyleSelect::Class() { return *IFC2X3_IfcCharacterStyleSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcClassificationNotationSelect::Class() { return *IFC2X3_IfcClassificationNotationSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcColour::Class() { return *IFC2X3_IfcColour_type; }

const IfcParse::select_type& Ifc2x3::IfcColourOrFactor::Class() { return *IFC2X3_IfcColourOrFactor_type; }

const IfcParse::select_type& Ifc2x3::IfcConditionCriterionSelect::Class() { return *IFC2X3_IfcConditionCriterionSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcCsgSelect::Class() { return *IFC2X3_IfcCsgSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcCurveFontOrScaledCurveFontSelect::Class() { return *IFC2X3_IfcCurveFontOrScaledCurveFontSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcCurveOrEdgeCurve::Class() { return *IFC2X3_IfcCurveOrEdgeCurve_type; }

const IfcParse::select_type& Ifc2x3::IfcCurveStyleFontSelect::Class() { return *IFC2X3_IfcCurveStyleFontSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcDateTimeSelect::Class() { return *IFC2X3_IfcDateTimeSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcDefinedSymbolSelect::Class() { return *IFC2X3_IfcDefinedSymbolSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcDerivedMeasureValue::Class() { return *IFC2X3_IfcDerivedMeasureValue_type; }

const IfcParse::select_type& Ifc2x3::IfcDocumentSelect::Class() { return *IFC2X3_IfcDocumentSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcDraughtingCalloutElement::Class() { return *IFC2X3_IfcDraughtingCalloutElement_type; }

const IfcParse::select_type& Ifc2x3::IfcFillAreaStyleTileShapeSelect::Class() { return *IFC2X3_IfcFillAreaStyleTileShapeSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcFillStyleSelect::Class() { return *IFC2X3_IfcFillStyleSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcGeometricSetSelect::Class() { return *IFC2X3_IfcGeometricSetSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcHatchLineDistanceSelect::Class() { return *IFC2X3_IfcHatchLineDistanceSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcLayeredItem::Class() { return *IFC2X3_IfcLayeredItem_type; }

const IfcParse::select_type& Ifc2x3::IfcLibrarySelect::Class() { return *IFC2X3_IfcLibrarySelect_type; }

const IfcParse::select_type& Ifc2x3::IfcLightDistributionDataSourceSelect::Class() { return *IFC2X3_IfcLightDistributionDataSourceSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcMaterialSelect::Class() { return *IFC2X3_IfcMaterialSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcMeasureValue::Class() { return *IFC2X3_IfcMeasureValue_type; }

const IfcParse::select_type& Ifc2x3::IfcMetricValueSelect::Class() { return *IFC2X3_IfcMetricValueSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcObjectReferenceSelect::Class() { return *IFC2X3_IfcObjectReferenceSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcOrientationSelect::Class() { return *IFC2X3_IfcOrientationSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcPointOrVertexPoint::Class() { return *IFC2X3_IfcPointOrVertexPoint_type; }

const IfcParse::select_type& Ifc2x3::IfcPresentationStyleSelect::Class() { return *IFC2X3_IfcPresentationStyleSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcShell::Class() { return *IFC2X3_IfcShell_type; }

const IfcParse::select_type& Ifc2x3::IfcSimpleValue::Class() { return *IFC2X3_IfcSimpleValue_type; }

const IfcParse::select_type& Ifc2x3::IfcSizeSelect::Class() { return *IFC2X3_IfcSizeSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcSpecularHighlightSelect::Class() { return *IFC2X3_IfcSpecularHighlightSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcStructuralActivityAssignmentSelect::Class() { return *IFC2X3_IfcStructuralActivityAssignmentSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcSurfaceOrFaceSurface::Class() { return *IFC2X3_IfcSurfaceOrFaceSurface_type; }

const IfcParse::select_type& Ifc2x3::IfcSurfaceStyleElementSelect::Class() { return *IFC2X3_IfcSurfaceStyleElementSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcSymbolStyleSelect::Class() { return *IFC2X3_IfcSymbolStyleSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcTextFontSelect::Class() { return *IFC2X3_IfcTextFontSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcTextStyleSelect::Class() { return *IFC2X3_IfcTextStyleSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcTrimmingSelect::Class() { return *IFC2X3_IfcTrimmingSelect_type; }

const IfcParse::select_type& Ifc2x3::IfcUnit::Class() { return *IFC2X3_IfcUnit_type; }

const IfcParse::select_type& Ifc2x3::IfcValue::Class() { return *IFC2X3_IfcValue_type; }

const IfcParse::select_type& Ifc2x3::IfcVectorOrDirection::Class() { return *IFC2X3_IfcVectorOrDirection_type; }


// Function implementations for IfcAbsorbedDoseMeasure
const IfcParse::type_declaration& Ifc2x3::IfcAbsorbedDoseMeasure::Class() { return *IFC2X3_IfcAbsorbedDoseMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcAbsorbedDoseMeasure::declaration() const { return *IFC2X3_IfcAbsorbedDoseMeasure_type; }
Ifc2x3::IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcAbsorbedDoseMeasure::IfcAbsorbedDoseMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcAbsorbedDoseMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcAbsorbedDoseMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAccelerationMeasure
const IfcParse::type_declaration& Ifc2x3::IfcAccelerationMeasure::Class() { return *IFC2X3_IfcAccelerationMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcAccelerationMeasure::declaration() const { return *IFC2X3_IfcAccelerationMeasure_type; }
Ifc2x3::IfcAccelerationMeasure::IfcAccelerationMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcAccelerationMeasure::IfcAccelerationMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcAccelerationMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcAccelerationMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAmountOfSubstanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcAmountOfSubstanceMeasure::Class() { return *IFC2X3_IfcAmountOfSubstanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcAmountOfSubstanceMeasure::declaration() const { return *IFC2X3_IfcAmountOfSubstanceMeasure_type; }
Ifc2x3::IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcAmountOfSubstanceMeasure::IfcAmountOfSubstanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcAmountOfSubstanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcAmountOfSubstanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAngularVelocityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcAngularVelocityMeasure::Class() { return *IFC2X3_IfcAngularVelocityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcAngularVelocityMeasure::declaration() const { return *IFC2X3_IfcAngularVelocityMeasure_type; }
Ifc2x3::IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcAngularVelocityMeasure::IfcAngularVelocityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcAngularVelocityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcAngularVelocityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcAreaMeasure
const IfcParse::type_declaration& Ifc2x3::IfcAreaMeasure::Class() { return *IFC2X3_IfcAreaMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcAreaMeasure::declaration() const { return *IFC2X3_IfcAreaMeasure_type; }
Ifc2x3::IfcAreaMeasure::IfcAreaMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcAreaMeasure::IfcAreaMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcAreaMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcAreaMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcBoolean
const IfcParse::type_declaration& Ifc2x3::IfcBoolean::Class() { return *IFC2X3_IfcBoolean_type; }
const IfcParse::type_declaration& Ifc2x3::IfcBoolean::declaration() const { return *IFC2X3_IfcBoolean_type; }
Ifc2x3::IfcBoolean::IfcBoolean(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcBoolean::IfcBoolean(bool v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcBoolean_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcBoolean::operator bool() const { return *data_->getArgument(0); }

// Function implementations for IfcBoxAlignment
const IfcParse::type_declaration& Ifc2x3::IfcBoxAlignment::Class() { return *IFC2X3_IfcBoxAlignment_type; }
const IfcParse::type_declaration& Ifc2x3::IfcBoxAlignment::declaration() const { return *IFC2X3_IfcBoxAlignment_type; }
Ifc2x3::IfcBoxAlignment::IfcBoxAlignment(IfcEntityInstanceData* e) : IfcLabel((IfcEntityInstanceData*)0) { data_ = e; }
Ifc2x3::IfcBoxAlignment::IfcBoxAlignment(std::string v) : IfcLabel((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IFC2X3_IfcBoxAlignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcBoxAlignment::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcComplexNumber
const IfcParse::type_declaration& Ifc2x3::IfcComplexNumber::Class() { return *IFC2X3_IfcComplexNumber_type; }
const IfcParse::type_declaration& Ifc2x3::IfcComplexNumber::declaration() const { return *IFC2X3_IfcComplexNumber_type; }
Ifc2x3::IfcComplexNumber::IfcComplexNumber(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcComplexNumber::IfcComplexNumber(std::vector< double > /*[1:2]*/ v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcComplexNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcComplexNumber::operator std::vector< double > /*[1:2]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcCompoundPlaneAngleMeasure
const IfcParse::type_declaration& Ifc2x3::IfcCompoundPlaneAngleMeasure::Class() { return *IFC2X3_IfcCompoundPlaneAngleMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcCompoundPlaneAngleMeasure::declaration() const { return *IFC2X3_IfcCompoundPlaneAngleMeasure_type; }
Ifc2x3::IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcCompoundPlaneAngleMeasure::IfcCompoundPlaneAngleMeasure(std::vector< int > /*[3:4]*/ v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcCompoundPlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcCompoundPlaneAngleMeasure::operator std::vector< int > /*[3:4]*/() const { return *data_->getArgument(0); }

// Function implementations for IfcContextDependentMeasure
const IfcParse::type_declaration& Ifc2x3::IfcContextDependentMeasure::Class() { return *IFC2X3_IfcContextDependentMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcContextDependentMeasure::declaration() const { return *IFC2X3_IfcContextDependentMeasure_type; }
Ifc2x3::IfcContextDependentMeasure::IfcContextDependentMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcContextDependentMeasure::IfcContextDependentMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcContextDependentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcContextDependentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcCountMeasure
const IfcParse::type_declaration& Ifc2x3::IfcCountMeasure::Class() { return *IFC2X3_IfcCountMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcCountMeasure::declaration() const { return *IFC2X3_IfcCountMeasure_type; }
Ifc2x3::IfcCountMeasure::IfcCountMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcCountMeasure::IfcCountMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcCountMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcCountMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcCurvatureMeasure
const IfcParse::type_declaration& Ifc2x3::IfcCurvatureMeasure::Class() { return *IFC2X3_IfcCurvatureMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcCurvatureMeasure::declaration() const { return *IFC2X3_IfcCurvatureMeasure_type; }
Ifc2x3::IfcCurvatureMeasure::IfcCurvatureMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcCurvatureMeasure::IfcCurvatureMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcCurvatureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcCurvatureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcDayInMonthNumber
const IfcParse::type_declaration& Ifc2x3::IfcDayInMonthNumber::Class() { return *IFC2X3_IfcDayInMonthNumber_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDayInMonthNumber::declaration() const { return *IFC2X3_IfcDayInMonthNumber_type; }
Ifc2x3::IfcDayInMonthNumber::IfcDayInMonthNumber(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDayInMonthNumber::IfcDayInMonthNumber(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDayInMonthNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDayInMonthNumber::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDaylightSavingHour
const IfcParse::type_declaration& Ifc2x3::IfcDaylightSavingHour::Class() { return *IFC2X3_IfcDaylightSavingHour_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDaylightSavingHour::declaration() const { return *IFC2X3_IfcDaylightSavingHour_type; }
Ifc2x3::IfcDaylightSavingHour::IfcDaylightSavingHour(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDaylightSavingHour::IfcDaylightSavingHour(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDaylightSavingHour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDaylightSavingHour::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDescriptiveMeasure
const IfcParse::type_declaration& Ifc2x3::IfcDescriptiveMeasure::Class() { return *IFC2X3_IfcDescriptiveMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDescriptiveMeasure::declaration() const { return *IFC2X3_IfcDescriptiveMeasure_type; }
Ifc2x3::IfcDescriptiveMeasure::IfcDescriptiveMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDescriptiveMeasure::IfcDescriptiveMeasure(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDescriptiveMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDescriptiveMeasure::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcDimensionCount
const IfcParse::type_declaration& Ifc2x3::IfcDimensionCount::Class() { return *IFC2X3_IfcDimensionCount_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDimensionCount::declaration() const { return *IFC2X3_IfcDimensionCount_type; }
Ifc2x3::IfcDimensionCount::IfcDimensionCount(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDimensionCount::IfcDimensionCount(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionCount_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDimensionCount::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcDoseEquivalentMeasure
const IfcParse::type_declaration& Ifc2x3::IfcDoseEquivalentMeasure::Class() { return *IFC2X3_IfcDoseEquivalentMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDoseEquivalentMeasure::declaration() const { return *IFC2X3_IfcDoseEquivalentMeasure_type; }
Ifc2x3::IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDoseEquivalentMeasure::IfcDoseEquivalentMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDoseEquivalentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDoseEquivalentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcDynamicViscosityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcDynamicViscosityMeasure::Class() { return *IFC2X3_IfcDynamicViscosityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcDynamicViscosityMeasure::declaration() const { return *IFC2X3_IfcDynamicViscosityMeasure_type; }
Ifc2x3::IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcDynamicViscosityMeasure::IfcDynamicViscosityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcDynamicViscosityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcDynamicViscosityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricCapacitanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricCapacitanceMeasure::Class() { return *IFC2X3_IfcElectricCapacitanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricCapacitanceMeasure::declaration() const { return *IFC2X3_IfcElectricCapacitanceMeasure_type; }
Ifc2x3::IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricCapacitanceMeasure::IfcElectricCapacitanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricCapacitanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricCapacitanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricChargeMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricChargeMeasure::Class() { return *IFC2X3_IfcElectricChargeMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricChargeMeasure::declaration() const { return *IFC2X3_IfcElectricChargeMeasure_type; }
Ifc2x3::IfcElectricChargeMeasure::IfcElectricChargeMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricChargeMeasure::IfcElectricChargeMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricChargeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricChargeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricConductanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricConductanceMeasure::Class() { return *IFC2X3_IfcElectricConductanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricConductanceMeasure::declaration() const { return *IFC2X3_IfcElectricConductanceMeasure_type; }
Ifc2x3::IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricConductanceMeasure::IfcElectricConductanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricConductanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricConductanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricCurrentMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricCurrentMeasure::Class() { return *IFC2X3_IfcElectricCurrentMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricCurrentMeasure::declaration() const { return *IFC2X3_IfcElectricCurrentMeasure_type; }
Ifc2x3::IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricCurrentMeasure::IfcElectricCurrentMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricCurrentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricCurrentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricResistanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricResistanceMeasure::Class() { return *IFC2X3_IfcElectricResistanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricResistanceMeasure::declaration() const { return *IFC2X3_IfcElectricResistanceMeasure_type; }
Ifc2x3::IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricResistanceMeasure::IfcElectricResistanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricResistanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricResistanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcElectricVoltageMeasure
const IfcParse::type_declaration& Ifc2x3::IfcElectricVoltageMeasure::Class() { return *IFC2X3_IfcElectricVoltageMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcElectricVoltageMeasure::declaration() const { return *IFC2X3_IfcElectricVoltageMeasure_type; }
Ifc2x3::IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcElectricVoltageMeasure::IfcElectricVoltageMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricVoltageMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcElectricVoltageMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcEnergyMeasure
const IfcParse::type_declaration& Ifc2x3::IfcEnergyMeasure::Class() { return *IFC2X3_IfcEnergyMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcEnergyMeasure::declaration() const { return *IFC2X3_IfcEnergyMeasure_type; }
Ifc2x3::IfcEnergyMeasure::IfcEnergyMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcEnergyMeasure::IfcEnergyMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcEnergyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcFontStyle
const IfcParse::type_declaration& Ifc2x3::IfcFontStyle::Class() { return *IFC2X3_IfcFontStyle_type; }
const IfcParse::type_declaration& Ifc2x3::IfcFontStyle::declaration() const { return *IFC2X3_IfcFontStyle_type; }
Ifc2x3::IfcFontStyle::IfcFontStyle(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcFontStyle::IfcFontStyle(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcFontStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcFontStyle::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcFontVariant
const IfcParse::type_declaration& Ifc2x3::IfcFontVariant::Class() { return *IFC2X3_IfcFontVariant_type; }
const IfcParse::type_declaration& Ifc2x3::IfcFontVariant::declaration() const { return *IFC2X3_IfcFontVariant_type; }
Ifc2x3::IfcFontVariant::IfcFontVariant(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcFontVariant::IfcFontVariant(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcFontVariant_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcFontVariant::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcFontWeight
const IfcParse::type_declaration& Ifc2x3::IfcFontWeight::Class() { return *IFC2X3_IfcFontWeight_type; }
const IfcParse::type_declaration& Ifc2x3::IfcFontWeight::declaration() const { return *IFC2X3_IfcFontWeight_type; }
Ifc2x3::IfcFontWeight::IfcFontWeight(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcFontWeight::IfcFontWeight(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcFontWeight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcFontWeight::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcForceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcForceMeasure::Class() { return *IFC2X3_IfcForceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcForceMeasure::declaration() const { return *IFC2X3_IfcForceMeasure_type; }
Ifc2x3::IfcForceMeasure::IfcForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcForceMeasure::IfcForceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcFrequencyMeasure
const IfcParse::type_declaration& Ifc2x3::IfcFrequencyMeasure::Class() { return *IFC2X3_IfcFrequencyMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcFrequencyMeasure::declaration() const { return *IFC2X3_IfcFrequencyMeasure_type; }
Ifc2x3::IfcFrequencyMeasure::IfcFrequencyMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcFrequencyMeasure::IfcFrequencyMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcFrequencyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcFrequencyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcGloballyUniqueId
const IfcParse::type_declaration& Ifc2x3::IfcGloballyUniqueId::Class() { return *IFC2X3_IfcGloballyUniqueId_type; }
const IfcParse::type_declaration& Ifc2x3::IfcGloballyUniqueId::declaration() const { return *IFC2X3_IfcGloballyUniqueId_type; }
Ifc2x3::IfcGloballyUniqueId::IfcGloballyUniqueId(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcGloballyUniqueId::IfcGloballyUniqueId(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcGloballyUniqueId_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcGloballyUniqueId::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcHeatFluxDensityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcHeatFluxDensityMeasure::Class() { return *IFC2X3_IfcHeatFluxDensityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcHeatFluxDensityMeasure::declaration() const { return *IFC2X3_IfcHeatFluxDensityMeasure_type; }
Ifc2x3::IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcHeatFluxDensityMeasure::IfcHeatFluxDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcHeatFluxDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcHeatFluxDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcHeatingValueMeasure
const IfcParse::type_declaration& Ifc2x3::IfcHeatingValueMeasure::Class() { return *IFC2X3_IfcHeatingValueMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcHeatingValueMeasure::declaration() const { return *IFC2X3_IfcHeatingValueMeasure_type; }
Ifc2x3::IfcHeatingValueMeasure::IfcHeatingValueMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcHeatingValueMeasure::IfcHeatingValueMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcHeatingValueMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcHeatingValueMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcHourInDay
const IfcParse::type_declaration& Ifc2x3::IfcHourInDay::Class() { return *IFC2X3_IfcHourInDay_type; }
const IfcParse::type_declaration& Ifc2x3::IfcHourInDay::declaration() const { return *IFC2X3_IfcHourInDay_type; }
Ifc2x3::IfcHourInDay::IfcHourInDay(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcHourInDay::IfcHourInDay(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcHourInDay_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcHourInDay::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcIdentifier
const IfcParse::type_declaration& Ifc2x3::IfcIdentifier::Class() { return *IFC2X3_IfcIdentifier_type; }
const IfcParse::type_declaration& Ifc2x3::IfcIdentifier::declaration() const { return *IFC2X3_IfcIdentifier_type; }
Ifc2x3::IfcIdentifier::IfcIdentifier(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcIdentifier::IfcIdentifier(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcIdentifier_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcIdentifier::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcIlluminanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcIlluminanceMeasure::Class() { return *IFC2X3_IfcIlluminanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcIlluminanceMeasure::declaration() const { return *IFC2X3_IfcIlluminanceMeasure_type; }
Ifc2x3::IfcIlluminanceMeasure::IfcIlluminanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcIlluminanceMeasure::IfcIlluminanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcIlluminanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcIlluminanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcInductanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcInductanceMeasure::Class() { return *IFC2X3_IfcInductanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcInductanceMeasure::declaration() const { return *IFC2X3_IfcInductanceMeasure_type; }
Ifc2x3::IfcInductanceMeasure::IfcInductanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcInductanceMeasure::IfcInductanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcInductanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcInductanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcInteger
const IfcParse::type_declaration& Ifc2x3::IfcInteger::Class() { return *IFC2X3_IfcInteger_type; }
const IfcParse::type_declaration& Ifc2x3::IfcInteger::declaration() const { return *IFC2X3_IfcInteger_type; }
Ifc2x3::IfcInteger::IfcInteger(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcInteger::IfcInteger(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcInteger_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcInteger::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcIntegerCountRateMeasure
const IfcParse::type_declaration& Ifc2x3::IfcIntegerCountRateMeasure::Class() { return *IFC2X3_IfcIntegerCountRateMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcIntegerCountRateMeasure::declaration() const { return *IFC2X3_IfcIntegerCountRateMeasure_type; }
Ifc2x3::IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcIntegerCountRateMeasure::IfcIntegerCountRateMeasure(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcIntegerCountRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcIntegerCountRateMeasure::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcIonConcentrationMeasure
const IfcParse::type_declaration& Ifc2x3::IfcIonConcentrationMeasure::Class() { return *IFC2X3_IfcIonConcentrationMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcIonConcentrationMeasure::declaration() const { return *IFC2X3_IfcIonConcentrationMeasure_type; }
Ifc2x3::IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcIonConcentrationMeasure::IfcIonConcentrationMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcIonConcentrationMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcIonConcentrationMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcIsothermalMoistureCapacityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcIsothermalMoistureCapacityMeasure::Class() { return *IFC2X3_IfcIsothermalMoistureCapacityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcIsothermalMoistureCapacityMeasure::declaration() const { return *IFC2X3_IfcIsothermalMoistureCapacityMeasure_type; }
Ifc2x3::IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcIsothermalMoistureCapacityMeasure::IfcIsothermalMoistureCapacityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcIsothermalMoistureCapacityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcIsothermalMoistureCapacityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcKinematicViscosityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcKinematicViscosityMeasure::Class() { return *IFC2X3_IfcKinematicViscosityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcKinematicViscosityMeasure::declaration() const { return *IFC2X3_IfcKinematicViscosityMeasure_type; }
Ifc2x3::IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcKinematicViscosityMeasure::IfcKinematicViscosityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcKinematicViscosityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcKinematicViscosityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLabel
const IfcParse::type_declaration& Ifc2x3::IfcLabel::Class() { return *IFC2X3_IfcLabel_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLabel::declaration() const { return *IFC2X3_IfcLabel_type; }
Ifc2x3::IfcLabel::IfcLabel(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLabel::IfcLabel(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLabel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLabel::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcLengthMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLengthMeasure::Class() { return *IFC2X3_IfcLengthMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLengthMeasure::declaration() const { return *IFC2X3_IfcLengthMeasure_type; }
Ifc2x3::IfcLengthMeasure::IfcLengthMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLengthMeasure::IfcLengthMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearForceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLinearForceMeasure::Class() { return *IFC2X3_IfcLinearForceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLinearForceMeasure::declaration() const { return *IFC2X3_IfcLinearForceMeasure_type; }
Ifc2x3::IfcLinearForceMeasure::IfcLinearForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLinearForceMeasure::IfcLinearForceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLinearForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLinearForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearMomentMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLinearMomentMeasure::Class() { return *IFC2X3_IfcLinearMomentMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLinearMomentMeasure::declaration() const { return *IFC2X3_IfcLinearMomentMeasure_type; }
Ifc2x3::IfcLinearMomentMeasure::IfcLinearMomentMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLinearMomentMeasure::IfcLinearMomentMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLinearMomentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLinearMomentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearStiffnessMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLinearStiffnessMeasure::Class() { return *IFC2X3_IfcLinearStiffnessMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLinearStiffnessMeasure::declaration() const { return *IFC2X3_IfcLinearStiffnessMeasure_type; }
Ifc2x3::IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLinearStiffnessMeasure::IfcLinearStiffnessMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLinearStiffnessMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLinearStiffnessMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLinearVelocityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLinearVelocityMeasure::Class() { return *IFC2X3_IfcLinearVelocityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLinearVelocityMeasure::declaration() const { return *IFC2X3_IfcLinearVelocityMeasure_type; }
Ifc2x3::IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLinearVelocityMeasure::IfcLinearVelocityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLinearVelocityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLinearVelocityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLogical
const IfcParse::type_declaration& Ifc2x3::IfcLogical::Class() { return *IFC2X3_IfcLogical_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLogical::declaration() const { return *IFC2X3_IfcLogical_type; }
Ifc2x3::IfcLogical::IfcLogical(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLogical::IfcLogical(boost::logic::tribool v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLogical_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLogical::operator boost::logic::tribool() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousFluxMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLuminousFluxMeasure::Class() { return *IFC2X3_IfcLuminousFluxMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLuminousFluxMeasure::declaration() const { return *IFC2X3_IfcLuminousFluxMeasure_type; }
Ifc2x3::IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLuminousFluxMeasure::IfcLuminousFluxMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLuminousFluxMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLuminousFluxMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousIntensityDistributionMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLuminousIntensityDistributionMeasure::Class() { return *IFC2X3_IfcLuminousIntensityDistributionMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLuminousIntensityDistributionMeasure::declaration() const { return *IFC2X3_IfcLuminousIntensityDistributionMeasure_type; }
Ifc2x3::IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLuminousIntensityDistributionMeasure::IfcLuminousIntensityDistributionMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLuminousIntensityDistributionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLuminousIntensityDistributionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcLuminousIntensityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcLuminousIntensityMeasure::Class() { return *IFC2X3_IfcLuminousIntensityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcLuminousIntensityMeasure::declaration() const { return *IFC2X3_IfcLuminousIntensityMeasure_type; }
Ifc2x3::IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcLuminousIntensityMeasure::IfcLuminousIntensityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcLuminousIntensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcLuminousIntensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMagneticFluxDensityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMagneticFluxDensityMeasure::Class() { return *IFC2X3_IfcMagneticFluxDensityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMagneticFluxDensityMeasure::declaration() const { return *IFC2X3_IfcMagneticFluxDensityMeasure_type; }
Ifc2x3::IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMagneticFluxDensityMeasure::IfcMagneticFluxDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMagneticFluxDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMagneticFluxDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMagneticFluxMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMagneticFluxMeasure::Class() { return *IFC2X3_IfcMagneticFluxMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMagneticFluxMeasure::declaration() const { return *IFC2X3_IfcMagneticFluxMeasure_type; }
Ifc2x3::IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMagneticFluxMeasure::IfcMagneticFluxMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMagneticFluxMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMagneticFluxMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassDensityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMassDensityMeasure::Class() { return *IFC2X3_IfcMassDensityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMassDensityMeasure::declaration() const { return *IFC2X3_IfcMassDensityMeasure_type; }
Ifc2x3::IfcMassDensityMeasure::IfcMassDensityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMassDensityMeasure::IfcMassDensityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMassDensityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMassDensityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassFlowRateMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMassFlowRateMeasure::Class() { return *IFC2X3_IfcMassFlowRateMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMassFlowRateMeasure::declaration() const { return *IFC2X3_IfcMassFlowRateMeasure_type; }
Ifc2x3::IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMassFlowRateMeasure::IfcMassFlowRateMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMassFlowRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMassFlowRateMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMassMeasure::Class() { return *IFC2X3_IfcMassMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMassMeasure::declaration() const { return *IFC2X3_IfcMassMeasure_type; }
Ifc2x3::IfcMassMeasure::IfcMassMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMassMeasure::IfcMassMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMassMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMassMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMassPerLengthMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMassPerLengthMeasure::Class() { return *IFC2X3_IfcMassPerLengthMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMassPerLengthMeasure::declaration() const { return *IFC2X3_IfcMassPerLengthMeasure_type; }
Ifc2x3::IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMassPerLengthMeasure::IfcMassPerLengthMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMassPerLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMassPerLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMinuteInHour
const IfcParse::type_declaration& Ifc2x3::IfcMinuteInHour::Class() { return *IFC2X3_IfcMinuteInHour_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMinuteInHour::declaration() const { return *IFC2X3_IfcMinuteInHour_type; }
Ifc2x3::IfcMinuteInHour::IfcMinuteInHour(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMinuteInHour::IfcMinuteInHour(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMinuteInHour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMinuteInHour::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfElasticityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfElasticityMeasure::Class() { return *IFC2X3_IfcModulusOfElasticityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfElasticityMeasure::declaration() const { return *IFC2X3_IfcModulusOfElasticityMeasure_type; }
Ifc2x3::IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcModulusOfElasticityMeasure::IfcModulusOfElasticityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcModulusOfElasticityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcModulusOfElasticityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfLinearSubgradeReactionMeasure
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfLinearSubgradeReactionMeasure::Class() { return *IFC2X3_IfcModulusOfLinearSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfLinearSubgradeReactionMeasure::declaration() const { return *IFC2X3_IfcModulusOfLinearSubgradeReactionMeasure_type; }
Ifc2x3::IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcModulusOfLinearSubgradeReactionMeasure::IfcModulusOfLinearSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcModulusOfLinearSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcModulusOfLinearSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfRotationalSubgradeReactionMeasure
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfRotationalSubgradeReactionMeasure::Class() { return *IFC2X3_IfcModulusOfRotationalSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfRotationalSubgradeReactionMeasure::declaration() const { return *IFC2X3_IfcModulusOfRotationalSubgradeReactionMeasure_type; }
Ifc2x3::IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcModulusOfRotationalSubgradeReactionMeasure::IfcModulusOfRotationalSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcModulusOfRotationalSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcModulusOfRotationalSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcModulusOfSubgradeReactionMeasure
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfSubgradeReactionMeasure::Class() { return *IFC2X3_IfcModulusOfSubgradeReactionMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcModulusOfSubgradeReactionMeasure::declaration() const { return *IFC2X3_IfcModulusOfSubgradeReactionMeasure_type; }
Ifc2x3::IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcModulusOfSubgradeReactionMeasure::IfcModulusOfSubgradeReactionMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcModulusOfSubgradeReactionMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcModulusOfSubgradeReactionMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMoistureDiffusivityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMoistureDiffusivityMeasure::Class() { return *IFC2X3_IfcMoistureDiffusivityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMoistureDiffusivityMeasure::declaration() const { return *IFC2X3_IfcMoistureDiffusivityMeasure_type; }
Ifc2x3::IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMoistureDiffusivityMeasure::IfcMoistureDiffusivityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMoistureDiffusivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMoistureDiffusivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMolecularWeightMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMolecularWeightMeasure::Class() { return *IFC2X3_IfcMolecularWeightMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMolecularWeightMeasure::declaration() const { return *IFC2X3_IfcMolecularWeightMeasure_type; }
Ifc2x3::IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMolecularWeightMeasure::IfcMolecularWeightMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMolecularWeightMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMolecularWeightMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMomentOfInertiaMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMomentOfInertiaMeasure::Class() { return *IFC2X3_IfcMomentOfInertiaMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMomentOfInertiaMeasure::declaration() const { return *IFC2X3_IfcMomentOfInertiaMeasure_type; }
Ifc2x3::IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMomentOfInertiaMeasure::IfcMomentOfInertiaMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMomentOfInertiaMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMomentOfInertiaMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMonetaryMeasure
const IfcParse::type_declaration& Ifc2x3::IfcMonetaryMeasure::Class() { return *IFC2X3_IfcMonetaryMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMonetaryMeasure::declaration() const { return *IFC2X3_IfcMonetaryMeasure_type; }
Ifc2x3::IfcMonetaryMeasure::IfcMonetaryMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMonetaryMeasure::IfcMonetaryMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMonetaryMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMonetaryMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcMonthInYearNumber
const IfcParse::type_declaration& Ifc2x3::IfcMonthInYearNumber::Class() { return *IFC2X3_IfcMonthInYearNumber_type; }
const IfcParse::type_declaration& Ifc2x3::IfcMonthInYearNumber::declaration() const { return *IFC2X3_IfcMonthInYearNumber_type; }
Ifc2x3::IfcMonthInYearNumber::IfcMonthInYearNumber(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcMonthInYearNumber::IfcMonthInYearNumber(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcMonthInYearNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcMonthInYearNumber::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcNormalisedRatioMeasure
const IfcParse::type_declaration& Ifc2x3::IfcNormalisedRatioMeasure::Class() { return *IFC2X3_IfcNormalisedRatioMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcNormalisedRatioMeasure::declaration() const { return *IFC2X3_IfcNormalisedRatioMeasure_type; }
Ifc2x3::IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = e; }
Ifc2x3::IfcNormalisedRatioMeasure::IfcNormalisedRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IFC2X3_IfcNormalisedRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcNormalisedRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcNumericMeasure
const IfcParse::type_declaration& Ifc2x3::IfcNumericMeasure::Class() { return *IFC2X3_IfcNumericMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcNumericMeasure::declaration() const { return *IFC2X3_IfcNumericMeasure_type; }
Ifc2x3::IfcNumericMeasure::IfcNumericMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcNumericMeasure::IfcNumericMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcNumericMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcNumericMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPHMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPHMeasure::Class() { return *IFC2X3_IfcPHMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPHMeasure::declaration() const { return *IFC2X3_IfcPHMeasure_type; }
Ifc2x3::IfcPHMeasure::IfcPHMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPHMeasure::IfcPHMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPHMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPHMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcParameterValue
const IfcParse::type_declaration& Ifc2x3::IfcParameterValue::Class() { return *IFC2X3_IfcParameterValue_type; }
const IfcParse::type_declaration& Ifc2x3::IfcParameterValue::declaration() const { return *IFC2X3_IfcParameterValue_type; }
Ifc2x3::IfcParameterValue::IfcParameterValue(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcParameterValue::IfcParameterValue(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcParameterValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcParameterValue::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPlanarForceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPlanarForceMeasure::Class() { return *IFC2X3_IfcPlanarForceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPlanarForceMeasure::declaration() const { return *IFC2X3_IfcPlanarForceMeasure_type; }
Ifc2x3::IfcPlanarForceMeasure::IfcPlanarForceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPlanarForceMeasure::IfcPlanarForceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPlanarForceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPlanarForceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPlaneAngleMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPlaneAngleMeasure::Class() { return *IFC2X3_IfcPlaneAngleMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPlaneAngleMeasure::declaration() const { return *IFC2X3_IfcPlaneAngleMeasure_type; }
Ifc2x3::IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPlaneAngleMeasure::IfcPlaneAngleMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPlaneAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositiveLengthMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPositiveLengthMeasure::Class() { return *IFC2X3_IfcPositiveLengthMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPositiveLengthMeasure::declaration() const { return *IFC2X3_IfcPositiveLengthMeasure_type; }
Ifc2x3::IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(IfcEntityInstanceData* e) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = e; }
Ifc2x3::IfcPositiveLengthMeasure::IfcPositiveLengthMeasure(double v) : IfcLengthMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPositiveLengthMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPositiveLengthMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositivePlaneAngleMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPositivePlaneAngleMeasure::Class() { return *IFC2X3_IfcPositivePlaneAngleMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPositivePlaneAngleMeasure::declaration() const { return *IFC2X3_IfcPositivePlaneAngleMeasure_type; }
Ifc2x3::IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(IfcEntityInstanceData* e) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { data_ = e; }
Ifc2x3::IfcPositivePlaneAngleMeasure::IfcPositivePlaneAngleMeasure(double v) : IfcPlaneAngleMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPositivePlaneAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPositivePlaneAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPositiveRatioMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPositiveRatioMeasure::Class() { return *IFC2X3_IfcPositiveRatioMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPositiveRatioMeasure::declaration() const { return *IFC2X3_IfcPositiveRatioMeasure_type; }
Ifc2x3::IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(IfcEntityInstanceData* e) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = e; }
Ifc2x3::IfcPositiveRatioMeasure::IfcPositiveRatioMeasure(double v) : IfcRatioMeasure((IfcEntityInstanceData*)0) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPositiveRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPositiveRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPowerMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPowerMeasure::Class() { return *IFC2X3_IfcPowerMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPowerMeasure::declaration() const { return *IFC2X3_IfcPowerMeasure_type; }
Ifc2x3::IfcPowerMeasure::IfcPowerMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPowerMeasure::IfcPowerMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPowerMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPowerMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcPresentableText
const IfcParse::type_declaration& Ifc2x3::IfcPresentableText::Class() { return *IFC2X3_IfcPresentableText_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPresentableText::declaration() const { return *IFC2X3_IfcPresentableText_type; }
Ifc2x3::IfcPresentableText::IfcPresentableText(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPresentableText::IfcPresentableText(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPresentableText_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPresentableText::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcPressureMeasure
const IfcParse::type_declaration& Ifc2x3::IfcPressureMeasure::Class() { return *IFC2X3_IfcPressureMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcPressureMeasure::declaration() const { return *IFC2X3_IfcPressureMeasure_type; }
Ifc2x3::IfcPressureMeasure::IfcPressureMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcPressureMeasure::IfcPressureMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcPressureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcPressureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRadioActivityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcRadioActivityMeasure::Class() { return *IFC2X3_IfcRadioActivityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcRadioActivityMeasure::declaration() const { return *IFC2X3_IfcRadioActivityMeasure_type; }
Ifc2x3::IfcRadioActivityMeasure::IfcRadioActivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcRadioActivityMeasure::IfcRadioActivityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcRadioActivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcRadioActivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRatioMeasure
const IfcParse::type_declaration& Ifc2x3::IfcRatioMeasure::Class() { return *IFC2X3_IfcRatioMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcRatioMeasure::declaration() const { return *IFC2X3_IfcRatioMeasure_type; }
Ifc2x3::IfcRatioMeasure::IfcRatioMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcRatioMeasure::IfcRatioMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcRatioMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcRatioMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcReal
const IfcParse::type_declaration& Ifc2x3::IfcReal::Class() { return *IFC2X3_IfcReal_type; }
const IfcParse::type_declaration& Ifc2x3::IfcReal::declaration() const { return *IFC2X3_IfcReal_type; }
Ifc2x3::IfcReal::IfcReal(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcReal::IfcReal(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcReal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcReal::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalFrequencyMeasure
const IfcParse::type_declaration& Ifc2x3::IfcRotationalFrequencyMeasure::Class() { return *IFC2X3_IfcRotationalFrequencyMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcRotationalFrequencyMeasure::declaration() const { return *IFC2X3_IfcRotationalFrequencyMeasure_type; }
Ifc2x3::IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcRotationalFrequencyMeasure::IfcRotationalFrequencyMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcRotationalFrequencyMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcRotationalFrequencyMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalMassMeasure
const IfcParse::type_declaration& Ifc2x3::IfcRotationalMassMeasure::Class() { return *IFC2X3_IfcRotationalMassMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcRotationalMassMeasure::declaration() const { return *IFC2X3_IfcRotationalMassMeasure_type; }
Ifc2x3::IfcRotationalMassMeasure::IfcRotationalMassMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcRotationalMassMeasure::IfcRotationalMassMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcRotationalMassMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcRotationalMassMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcRotationalStiffnessMeasure
const IfcParse::type_declaration& Ifc2x3::IfcRotationalStiffnessMeasure::Class() { return *IFC2X3_IfcRotationalStiffnessMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcRotationalStiffnessMeasure::declaration() const { return *IFC2X3_IfcRotationalStiffnessMeasure_type; }
Ifc2x3::IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcRotationalStiffnessMeasure::IfcRotationalStiffnessMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcRotationalStiffnessMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcRotationalStiffnessMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSecondInMinute
const IfcParse::type_declaration& Ifc2x3::IfcSecondInMinute::Class() { return *IFC2X3_IfcSecondInMinute_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSecondInMinute::declaration() const { return *IFC2X3_IfcSecondInMinute_type; }
Ifc2x3::IfcSecondInMinute::IfcSecondInMinute(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSecondInMinute::IfcSecondInMinute(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSecondInMinute_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSecondInMinute::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSectionModulusMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSectionModulusMeasure::Class() { return *IFC2X3_IfcSectionModulusMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSectionModulusMeasure::declaration() const { return *IFC2X3_IfcSectionModulusMeasure_type; }
Ifc2x3::IfcSectionModulusMeasure::IfcSectionModulusMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSectionModulusMeasure::IfcSectionModulusMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionModulusMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSectionModulusMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSectionalAreaIntegralMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSectionalAreaIntegralMeasure::Class() { return *IFC2X3_IfcSectionalAreaIntegralMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSectionalAreaIntegralMeasure::declaration() const { return *IFC2X3_IfcSectionalAreaIntegralMeasure_type; }
Ifc2x3::IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSectionalAreaIntegralMeasure::IfcSectionalAreaIntegralMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionalAreaIntegralMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSectionalAreaIntegralMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcShearModulusMeasure
const IfcParse::type_declaration& Ifc2x3::IfcShearModulusMeasure::Class() { return *IFC2X3_IfcShearModulusMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcShearModulusMeasure::declaration() const { return *IFC2X3_IfcShearModulusMeasure_type; }
Ifc2x3::IfcShearModulusMeasure::IfcShearModulusMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcShearModulusMeasure::IfcShearModulusMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcShearModulusMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcShearModulusMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSolidAngleMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSolidAngleMeasure::Class() { return *IFC2X3_IfcSolidAngleMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSolidAngleMeasure::declaration() const { return *IFC2X3_IfcSolidAngleMeasure_type; }
Ifc2x3::IfcSolidAngleMeasure::IfcSolidAngleMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSolidAngleMeasure::IfcSolidAngleMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSolidAngleMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSolidAngleMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPowerMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSoundPowerMeasure::Class() { return *IFC2X3_IfcSoundPowerMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSoundPowerMeasure::declaration() const { return *IFC2X3_IfcSoundPowerMeasure_type; }
Ifc2x3::IfcSoundPowerMeasure::IfcSoundPowerMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSoundPowerMeasure::IfcSoundPowerMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundPowerMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSoundPowerMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSoundPressureMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSoundPressureMeasure::Class() { return *IFC2X3_IfcSoundPressureMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSoundPressureMeasure::declaration() const { return *IFC2X3_IfcSoundPressureMeasure_type; }
Ifc2x3::IfcSoundPressureMeasure::IfcSoundPressureMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSoundPressureMeasure::IfcSoundPressureMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundPressureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSoundPressureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecificHeatCapacityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcSpecificHeatCapacityMeasure::Class() { return *IFC2X3_IfcSpecificHeatCapacityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSpecificHeatCapacityMeasure::declaration() const { return *IFC2X3_IfcSpecificHeatCapacityMeasure_type; }
Ifc2x3::IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSpecificHeatCapacityMeasure::IfcSpecificHeatCapacityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSpecificHeatCapacityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSpecificHeatCapacityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecularExponent
const IfcParse::type_declaration& Ifc2x3::IfcSpecularExponent::Class() { return *IFC2X3_IfcSpecularExponent_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSpecularExponent::declaration() const { return *IFC2X3_IfcSpecularExponent_type; }
Ifc2x3::IfcSpecularExponent::IfcSpecularExponent(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSpecularExponent::IfcSpecularExponent(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSpecularExponent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSpecularExponent::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcSpecularRoughness
const IfcParse::type_declaration& Ifc2x3::IfcSpecularRoughness::Class() { return *IFC2X3_IfcSpecularRoughness_type; }
const IfcParse::type_declaration& Ifc2x3::IfcSpecularRoughness::declaration() const { return *IFC2X3_IfcSpecularRoughness_type; }
Ifc2x3::IfcSpecularRoughness::IfcSpecularRoughness(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcSpecularRoughness::IfcSpecularRoughness(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcSpecularRoughness_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcSpecularRoughness::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTemperatureGradientMeasure
const IfcParse::type_declaration& Ifc2x3::IfcTemperatureGradientMeasure::Class() { return *IFC2X3_IfcTemperatureGradientMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTemperatureGradientMeasure::declaration() const { return *IFC2X3_IfcTemperatureGradientMeasure_type; }
Ifc2x3::IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTemperatureGradientMeasure::IfcTemperatureGradientMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTemperatureGradientMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTemperatureGradientMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcText
const IfcParse::type_declaration& Ifc2x3::IfcText::Class() { return *IFC2X3_IfcText_type; }
const IfcParse::type_declaration& Ifc2x3::IfcText::declaration() const { return *IFC2X3_IfcText_type; }
Ifc2x3::IfcText::IfcText(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcText::IfcText(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcText_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcText::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextAlignment
const IfcParse::type_declaration& Ifc2x3::IfcTextAlignment::Class() { return *IFC2X3_IfcTextAlignment_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTextAlignment::declaration() const { return *IFC2X3_IfcTextAlignment_type; }
Ifc2x3::IfcTextAlignment::IfcTextAlignment(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTextAlignment::IfcTextAlignment(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTextAlignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTextAlignment::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextDecoration
const IfcParse::type_declaration& Ifc2x3::IfcTextDecoration::Class() { return *IFC2X3_IfcTextDecoration_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTextDecoration::declaration() const { return *IFC2X3_IfcTextDecoration_type; }
Ifc2x3::IfcTextDecoration::IfcTextDecoration(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTextDecoration::IfcTextDecoration(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTextDecoration_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTextDecoration::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextFontName
const IfcParse::type_declaration& Ifc2x3::IfcTextFontName::Class() { return *IFC2X3_IfcTextFontName_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTextFontName::declaration() const { return *IFC2X3_IfcTextFontName_type; }
Ifc2x3::IfcTextFontName::IfcTextFontName(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTextFontName::IfcTextFontName(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTextFontName_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTextFontName::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcTextTransformation
const IfcParse::type_declaration& Ifc2x3::IfcTextTransformation::Class() { return *IFC2X3_IfcTextTransformation_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTextTransformation::declaration() const { return *IFC2X3_IfcTextTransformation_type; }
Ifc2x3::IfcTextTransformation::IfcTextTransformation(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTextTransformation::IfcTextTransformation(std::string v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTextTransformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTextTransformation::operator std::string() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalAdmittanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermalAdmittanceMeasure::Class() { return *IFC2X3_IfcThermalAdmittanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermalAdmittanceMeasure::declaration() const { return *IFC2X3_IfcThermalAdmittanceMeasure_type; }
Ifc2x3::IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermalAdmittanceMeasure::IfcThermalAdmittanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalAdmittanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermalAdmittanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalConductivityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermalConductivityMeasure::Class() { return *IFC2X3_IfcThermalConductivityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermalConductivityMeasure::declaration() const { return *IFC2X3_IfcThermalConductivityMeasure_type; }
Ifc2x3::IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermalConductivityMeasure::IfcThermalConductivityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalConductivityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermalConductivityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalExpansionCoefficientMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermalExpansionCoefficientMeasure::Class() { return *IFC2X3_IfcThermalExpansionCoefficientMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermalExpansionCoefficientMeasure::declaration() const { return *IFC2X3_IfcThermalExpansionCoefficientMeasure_type; }
Ifc2x3::IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermalExpansionCoefficientMeasure::IfcThermalExpansionCoefficientMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalExpansionCoefficientMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermalExpansionCoefficientMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalResistanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermalResistanceMeasure::Class() { return *IFC2X3_IfcThermalResistanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermalResistanceMeasure::declaration() const { return *IFC2X3_IfcThermalResistanceMeasure_type; }
Ifc2x3::IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermalResistanceMeasure::IfcThermalResistanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalResistanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermalResistanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermalTransmittanceMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermalTransmittanceMeasure::Class() { return *IFC2X3_IfcThermalTransmittanceMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermalTransmittanceMeasure::declaration() const { return *IFC2X3_IfcThermalTransmittanceMeasure_type; }
Ifc2x3::IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermalTransmittanceMeasure::IfcThermalTransmittanceMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalTransmittanceMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermalTransmittanceMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcThermodynamicTemperatureMeasure
const IfcParse::type_declaration& Ifc2x3::IfcThermodynamicTemperatureMeasure::Class() { return *IFC2X3_IfcThermodynamicTemperatureMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcThermodynamicTemperatureMeasure::declaration() const { return *IFC2X3_IfcThermodynamicTemperatureMeasure_type; }
Ifc2x3::IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcThermodynamicTemperatureMeasure::IfcThermodynamicTemperatureMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcThermodynamicTemperatureMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcThermodynamicTemperatureMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTimeMeasure
const IfcParse::type_declaration& Ifc2x3::IfcTimeMeasure::Class() { return *IFC2X3_IfcTimeMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTimeMeasure::declaration() const { return *IFC2X3_IfcTimeMeasure_type; }
Ifc2x3::IfcTimeMeasure::IfcTimeMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTimeMeasure::IfcTimeMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTimeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcTimeStamp
const IfcParse::type_declaration& Ifc2x3::IfcTimeStamp::Class() { return *IFC2X3_IfcTimeStamp_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTimeStamp::declaration() const { return *IFC2X3_IfcTimeStamp_type; }
Ifc2x3::IfcTimeStamp::IfcTimeStamp(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTimeStamp::IfcTimeStamp(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeStamp_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTimeStamp::operator int() const { return *data_->getArgument(0); }

// Function implementations for IfcTorqueMeasure
const IfcParse::type_declaration& Ifc2x3::IfcTorqueMeasure::Class() { return *IFC2X3_IfcTorqueMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcTorqueMeasure::declaration() const { return *IFC2X3_IfcTorqueMeasure_type; }
Ifc2x3::IfcTorqueMeasure::IfcTorqueMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcTorqueMeasure::IfcTorqueMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcTorqueMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcTorqueMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcVaporPermeabilityMeasure
const IfcParse::type_declaration& Ifc2x3::IfcVaporPermeabilityMeasure::Class() { return *IFC2X3_IfcVaporPermeabilityMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcVaporPermeabilityMeasure::declaration() const { return *IFC2X3_IfcVaporPermeabilityMeasure_type; }
Ifc2x3::IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcVaporPermeabilityMeasure::IfcVaporPermeabilityMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcVaporPermeabilityMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcVaporPermeabilityMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcVolumeMeasure
const IfcParse::type_declaration& Ifc2x3::IfcVolumeMeasure::Class() { return *IFC2X3_IfcVolumeMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcVolumeMeasure::declaration() const { return *IFC2X3_IfcVolumeMeasure_type; }
Ifc2x3::IfcVolumeMeasure::IfcVolumeMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcVolumeMeasure::IfcVolumeMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcVolumeMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcVolumeMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcVolumetricFlowRateMeasure
const IfcParse::type_declaration& Ifc2x3::IfcVolumetricFlowRateMeasure::Class() { return *IFC2X3_IfcVolumetricFlowRateMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcVolumetricFlowRateMeasure::declaration() const { return *IFC2X3_IfcVolumetricFlowRateMeasure_type; }
Ifc2x3::IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcVolumetricFlowRateMeasure::IfcVolumetricFlowRateMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcVolumetricFlowRateMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcVolumetricFlowRateMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcWarpingConstantMeasure
const IfcParse::type_declaration& Ifc2x3::IfcWarpingConstantMeasure::Class() { return *IFC2X3_IfcWarpingConstantMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcWarpingConstantMeasure::declaration() const { return *IFC2X3_IfcWarpingConstantMeasure_type; }
Ifc2x3::IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcWarpingConstantMeasure::IfcWarpingConstantMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcWarpingConstantMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcWarpingConstantMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcWarpingMomentMeasure
const IfcParse::type_declaration& Ifc2x3::IfcWarpingMomentMeasure::Class() { return *IFC2X3_IfcWarpingMomentMeasure_type; }
const IfcParse::type_declaration& Ifc2x3::IfcWarpingMomentMeasure::declaration() const { return *IFC2X3_IfcWarpingMomentMeasure_type; }
Ifc2x3::IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcWarpingMomentMeasure::IfcWarpingMomentMeasure(double v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcWarpingMomentMeasure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcWarpingMomentMeasure::operator double() const { return *data_->getArgument(0); }

// Function implementations for IfcYearNumber
const IfcParse::type_declaration& Ifc2x3::IfcYearNumber::Class() { return *IFC2X3_IfcYearNumber_type; }
const IfcParse::type_declaration& Ifc2x3::IfcYearNumber::declaration() const { return *IFC2X3_IfcYearNumber_type; }
Ifc2x3::IfcYearNumber::IfcYearNumber(IfcEntityInstanceData* e) { data_ = e; }
Ifc2x3::IfcYearNumber::IfcYearNumber(int v) { data_ = new IfcEntityInstanceData(IFC2X3_IfcYearNumber_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(v); data_->setArgument(0, attr);} }
Ifc2x3::IfcYearNumber::operator int() const { return *data_->getArgument(0); }


// Function implementations for Ifc2DCompositeCurve


const IfcParse::entity& Ifc2x3::Ifc2DCompositeCurve::declaration() const { return *IFC2X3_Ifc2DCompositeCurve_type; }
const IfcParse::entity& Ifc2x3::Ifc2DCompositeCurve::Class() { return *IFC2X3_Ifc2DCompositeCurve_type; }
Ifc2x3::Ifc2DCompositeCurve::Ifc2DCompositeCurve(IfcEntityInstanceData* e) : IfcCompositeCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_Ifc2DCompositeCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::Ifc2DCompositeCurve::Ifc2DCompositeCurve(aggregate_of< ::Ifc2x3::IfcCompositeCurveSegment >::ptr v1_Segments, boost::logic::tribool v2_SelfIntersect) : IfcCompositeCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_Ifc2DCompositeCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcActionRequest
std::string Ifc2x3::IfcActionRequest::RequestID() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcActionRequest::setRequestID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcActionRequest::declaration() const { return *IFC2X3_IfcActionRequest_type; }
const IfcParse::entity& Ifc2x3::IfcActionRequest::Class() { return *IFC2X3_IfcActionRequest_type; }
Ifc2x3::IfcActionRequest::IfcActionRequest(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcActionRequest_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcActionRequest::IfcActionRequest(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_RequestID) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcActionRequest_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RequestID));data_->setArgument(5,attr);} }

// Function implementations for IfcActor
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcActor::TheActor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcActor::setTheActor(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

::Ifc2x3::IfcRelAssignsToActor::list::ptr Ifc2x3::IfcActor::IsActingUpon() const { return data_->getInverse(IFC2X3_IfcRelAssignsToActor_type, 6)->as<IfcRelAssignsToActor>(); }

const IfcParse::entity& Ifc2x3::IfcActor::declaration() const { return *IFC2X3_IfcActor_type; }
const IfcParse::entity& Ifc2x3::IfcActor::Class() { return *IFC2X3_IfcActor_type; }
Ifc2x3::IfcActor::IfcActor(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcActor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcActor::IfcActor(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcActorSelect* v6_TheActor) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcActor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));data_->setArgument(5,attr);} }

// Function implementations for IfcActorRole
::Ifc2x3::IfcRoleEnum::Value Ifc2x3::IfcActorRole::Role() const {  return ::Ifc2x3::IfcRoleEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcActorRole::setRole(::Ifc2x3::IfcRoleEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRoleEnum::ToString(v)));data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcActorRole::UserDefinedRole() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcActorRole::setUserDefinedRole(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcActorRole::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcActorRole::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcActorRole::declaration() const { return *IFC2X3_IfcActorRole_type; }
const IfcParse::entity& Ifc2x3::IfcActorRole::Class() { return *IFC2X3_IfcActorRole_type; }
Ifc2x3::IfcActorRole::IfcActorRole(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcActorRole_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcActorRole::IfcActorRole(::Ifc2x3::IfcRoleEnum::Value v1_Role, boost::optional< std::string > v2_UserDefinedRole, boost::optional< std::string > v3_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcActorRole_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Role,::Ifc2x3::IfcRoleEnum::ToString(v1_Role))));data_->setArgument(0,attr);} if (v2_UserDefinedRole) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_UserDefinedRole));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcActuatorType
::Ifc2x3::IfcActuatorTypeEnum::Value Ifc2x3::IfcActuatorType::PredefinedType() const {  return ::Ifc2x3::IfcActuatorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcActuatorType::setPredefinedType(::Ifc2x3::IfcActuatorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcActuatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcActuatorType::declaration() const { return *IFC2X3_IfcActuatorType_type; }
const IfcParse::entity& Ifc2x3::IfcActuatorType::Class() { return *IFC2X3_IfcActuatorType_type; }
Ifc2x3::IfcActuatorType::IfcActuatorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcActuatorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcActuatorType::IfcActuatorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcActuatorTypeEnum::Value v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcActuatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcActuatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAddress
boost::optional< ::Ifc2x3::IfcAddressTypeEnum::Value > Ifc2x3::IfcAddress::Purpose() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } return ::Ifc2x3::IfcAddressTypeEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcAddress::setPurpose(boost::optional< ::Ifc2x3::IfcAddressTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcAddressTypeEnum::ToString(*v)));}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcAddress::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcAddress::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcAddress::UserDefinedPurpose() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcAddress::setUserDefinedPurpose(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }

::Ifc2x3::IfcPerson::list::ptr Ifc2x3::IfcAddress::OfPerson() const { return data_->getInverse(IFC2X3_IfcPerson_type, 7)->as<IfcPerson>(); }
::Ifc2x3::IfcOrganization::list::ptr Ifc2x3::IfcAddress::OfOrganization() const { return data_->getInverse(IFC2X3_IfcOrganization_type, 4)->as<IfcOrganization>(); }

const IfcParse::entity& Ifc2x3::IfcAddress::declaration() const { return *IFC2X3_IfcAddress_type; }
const IfcParse::entity& Ifc2x3::IfcAddress::Class() { return *IFC2X3_IfcAddress_type; }
Ifc2x3::IfcAddress::IfcAddress(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcAddress_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAddress::IfcAddress(boost::optional< ::Ifc2x3::IfcAddressTypeEnum::Value > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,::Ifc2x3::IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAirTerminalBoxType
::Ifc2x3::IfcAirTerminalBoxTypeEnum::Value Ifc2x3::IfcAirTerminalBoxType::PredefinedType() const {  return ::Ifc2x3::IfcAirTerminalBoxTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcAirTerminalBoxType::setPredefinedType(::Ifc2x3::IfcAirTerminalBoxTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAirTerminalBoxTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcAirTerminalBoxType::declaration() const { return *IFC2X3_IfcAirTerminalBoxType_type; }
const IfcParse::entity& Ifc2x3::IfcAirTerminalBoxType::Class() { return *IFC2X3_IfcAirTerminalBoxType_type; }
Ifc2x3::IfcAirTerminalBoxType::IfcAirTerminalBoxType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAirTerminalBoxType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAirTerminalBoxType::IfcAirTerminalBoxType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcAirTerminalBoxTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalBoxType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcAirTerminalBoxTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAirTerminalType
::Ifc2x3::IfcAirTerminalTypeEnum::Value Ifc2x3::IfcAirTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcAirTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcAirTerminalType::setPredefinedType(::Ifc2x3::IfcAirTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAirTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcAirTerminalType::declaration() const { return *IFC2X3_IfcAirTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcAirTerminalType::Class() { return *IFC2X3_IfcAirTerminalType_type; }
Ifc2x3::IfcAirTerminalType::IfcAirTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAirTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAirTerminalType::IfcAirTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcAirTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAirTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcAirTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAirToAirHeatRecoveryType
::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Value Ifc2x3::IfcAirToAirHeatRecoveryType::PredefinedType() const {  return ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcAirToAirHeatRecoveryType::setPredefinedType(::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcAirToAirHeatRecoveryType::declaration() const { return *IFC2X3_IfcAirToAirHeatRecoveryType_type; }
const IfcParse::entity& Ifc2x3::IfcAirToAirHeatRecoveryType::Class() { return *IFC2X3_IfcAirToAirHeatRecoveryType_type; }
Ifc2x3::IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAirToAirHeatRecoveryType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAirToAirHeatRecoveryType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcAirToAirHeatRecoveryTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAlarmType
::Ifc2x3::IfcAlarmTypeEnum::Value Ifc2x3::IfcAlarmType::PredefinedType() const {  return ::Ifc2x3::IfcAlarmTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcAlarmType::setPredefinedType(::Ifc2x3::IfcAlarmTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAlarmTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcAlarmType::declaration() const { return *IFC2X3_IfcAlarmType_type; }
const IfcParse::entity& Ifc2x3::IfcAlarmType::Class() { return *IFC2X3_IfcAlarmType_type; }
Ifc2x3::IfcAlarmType::IfcAlarmType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAlarmType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAlarmType::IfcAlarmType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcAlarmTypeEnum::Value v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAlarmType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcAlarmTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcAngularDimension


const IfcParse::entity& Ifc2x3::IfcAngularDimension::declaration() const { return *IFC2X3_IfcAngularDimension_type; }
const IfcParse::entity& Ifc2x3::IfcAngularDimension::Class() { return *IFC2X3_IfcAngularDimension_type; }
Ifc2x3::IfcAngularDimension::IfcAngularDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAngularDimension_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAngularDimension::IfcAngularDimension(aggregate_of_instance::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAngularDimension_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcAnnotation

::Ifc2x3::IfcRelContainedInSpatialStructure::list::ptr Ifc2x3::IfcAnnotation::ContainedInStructure() const { return data_->getInverse(IFC2X3_IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& Ifc2x3::IfcAnnotation::declaration() const { return *IFC2X3_IfcAnnotation_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotation::Class() { return *IFC2X3_IfcAnnotation_type; }
Ifc2x3::IfcAnnotation::IfcAnnotation(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotation::IfcAnnotation(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcAnnotationCurveOccurrence


const IfcParse::entity& Ifc2x3::IfcAnnotationCurveOccurrence::declaration() const { return *IFC2X3_IfcAnnotationCurveOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationCurveOccurrence::Class() { return *IFC2X3_IfcAnnotationCurveOccurrence_type; }
Ifc2x3::IfcAnnotationCurveOccurrence::IfcAnnotationCurveOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationCurveOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationCurveOccurrence::IfcAnnotationCurveOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationCurveOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAnnotationFillArea
::Ifc2x3::IfcCurve* Ifc2x3::IfcAnnotationFillArea::OuterBoundary() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcAnnotationFillArea::setOuterBoundary(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcCurve >::ptr > Ifc2x3::IfcAnnotationFillArea::InnerBoundaries() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcCurve >(); }
void Ifc2x3::IfcAnnotationFillArea::setInnerBoundaries(boost::optional< aggregate_of< ::Ifc2x3::IfcCurve >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcAnnotationFillArea::declaration() const { return *IFC2X3_IfcAnnotationFillArea_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationFillArea::Class() { return *IFC2X3_IfcAnnotationFillArea_type; }
Ifc2x3::IfcAnnotationFillArea::IfcAnnotationFillArea(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationFillArea_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationFillArea::IfcAnnotationFillArea(::Ifc2x3::IfcCurve* v1_OuterBoundary, boost::optional< aggregate_of< ::Ifc2x3::IfcCurve >::ptr > v2_InnerBoundaries) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationFillArea_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OuterBoundary));data_->setArgument(0,attr);} if (v2_InnerBoundaries) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_InnerBoundaries)->generalize());data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcAnnotationFillAreaOccurrence
::Ifc2x3::IfcPoint* Ifc2x3::IfcAnnotationFillAreaOccurrence::FillStyleTarget() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcPoint>(true); }
void Ifc2x3::IfcAnnotationFillAreaOccurrence::setFillStyleTarget(::Ifc2x3::IfcPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< ::Ifc2x3::IfcGlobalOrLocalEnum::Value > Ifc2x3::IfcAnnotationFillAreaOccurrence::GlobalOrLocal() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } return ::Ifc2x3::IfcGlobalOrLocalEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcAnnotationFillAreaOccurrence::setGlobalOrLocal(boost::optional< ::Ifc2x3::IfcGlobalOrLocalEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(*v)));}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcAnnotationFillAreaOccurrence::declaration() const { return *IFC2X3_IfcAnnotationFillAreaOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationFillAreaOccurrence::Class() { return *IFC2X3_IfcAnnotationFillAreaOccurrence_type; }
Ifc2x3::IfcAnnotationFillAreaOccurrence::IfcAnnotationFillAreaOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationFillAreaOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationFillAreaOccurrence::IfcAnnotationFillAreaOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, ::Ifc2x3::IfcPoint* v4_FillStyleTarget, boost::optional< ::Ifc2x3::IfcGlobalOrLocalEnum::Value > v5_GlobalOrLocal) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationFillAreaOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_FillStyleTarget));data_->setArgument(3,attr);} if (v5_GlobalOrLocal) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(*v5_GlobalOrLocal))));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcAnnotationOccurrence


const IfcParse::entity& Ifc2x3::IfcAnnotationOccurrence::declaration() const { return *IFC2X3_IfcAnnotationOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationOccurrence::Class() { return *IFC2X3_IfcAnnotationOccurrence_type; }
Ifc2x3::IfcAnnotationOccurrence::IfcAnnotationOccurrence(IfcEntityInstanceData* e) : IfcStyledItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationOccurrence::IfcAnnotationOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcStyledItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAnnotationSurface
::Ifc2x3::IfcGeometricRepresentationItem* Ifc2x3::IfcAnnotationSurface::Item() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcGeometricRepresentationItem>(true); }
void Ifc2x3::IfcAnnotationSurface::setItem(::Ifc2x3::IfcGeometricRepresentationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcTextureCoordinate* Ifc2x3::IfcAnnotationSurface::TextureCoordinates() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcTextureCoordinate>(true); }
void Ifc2x3::IfcAnnotationSurface::setTextureCoordinates(::Ifc2x3::IfcTextureCoordinate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcAnnotationSurface::declaration() const { return *IFC2X3_IfcAnnotationSurface_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationSurface::Class() { return *IFC2X3_IfcAnnotationSurface_type; }
Ifc2x3::IfcAnnotationSurface::IfcAnnotationSurface(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationSurface::IfcAnnotationSurface(::Ifc2x3::IfcGeometricRepresentationItem* v1_Item, ::Ifc2x3::IfcTextureCoordinate* v2_TextureCoordinates) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TextureCoordinates));data_->setArgument(1,attr);} }

// Function implementations for IfcAnnotationSurfaceOccurrence


const IfcParse::entity& Ifc2x3::IfcAnnotationSurfaceOccurrence::declaration() const { return *IFC2X3_IfcAnnotationSurfaceOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationSurfaceOccurrence::Class() { return *IFC2X3_IfcAnnotationSurfaceOccurrence_type; }
Ifc2x3::IfcAnnotationSurfaceOccurrence::IfcAnnotationSurfaceOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationSurfaceOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationSurfaceOccurrence::IfcAnnotationSurfaceOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationSurfaceOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAnnotationSymbolOccurrence


const IfcParse::entity& Ifc2x3::IfcAnnotationSymbolOccurrence::declaration() const { return *IFC2X3_IfcAnnotationSymbolOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationSymbolOccurrence::Class() { return *IFC2X3_IfcAnnotationSymbolOccurrence_type; }
Ifc2x3::IfcAnnotationSymbolOccurrence::IfcAnnotationSymbolOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationSymbolOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationSymbolOccurrence::IfcAnnotationSymbolOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationSymbolOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcAnnotationTextOccurrence


const IfcParse::entity& Ifc2x3::IfcAnnotationTextOccurrence::declaration() const { return *IFC2X3_IfcAnnotationTextOccurrence_type; }
const IfcParse::entity& Ifc2x3::IfcAnnotationTextOccurrence::Class() { return *IFC2X3_IfcAnnotationTextOccurrence_type; }
Ifc2x3::IfcAnnotationTextOccurrence::IfcAnnotationTextOccurrence(IfcEntityInstanceData* e) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAnnotationTextOccurrence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAnnotationTextOccurrence::IfcAnnotationTextOccurrence(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAnnotationTextOccurrence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcApplication
::Ifc2x3::IfcOrganization* Ifc2x3::IfcApplication::ApplicationDeveloper() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcOrganization>(true); }
void Ifc2x3::IfcApplication::setApplicationDeveloper(::Ifc2x3::IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string Ifc2x3::IfcApplication::Version() const {  std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcApplication::setVersion(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::string Ifc2x3::IfcApplication::ApplicationFullName() const {  std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcApplication::setApplicationFullName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::string Ifc2x3::IfcApplication::ApplicationIdentifier() const {  std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcApplication::setApplicationIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcApplication::declaration() const { return *IFC2X3_IfcApplication_type; }
const IfcParse::entity& Ifc2x3::IfcApplication::Class() { return *IFC2X3_IfcApplication_type; }
Ifc2x3::IfcApplication::IfcApplication(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcApplication_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcApplication::IfcApplication(::Ifc2x3::IfcOrganization* v1_ApplicationDeveloper, std::string v2_Version, std::string v3_ApplicationFullName, std::string v4_ApplicationIdentifier) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcApplication_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ApplicationDeveloper));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Version));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ApplicationFullName));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ApplicationIdentifier));data_->setArgument(3,attr);} }

// Function implementations for IfcAppliedValue
boost::optional< std::string > Ifc2x3::IfcAppliedValue::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcAppliedValue::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcAppliedValue::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcAppliedValue::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcAppliedValueSelect* Ifc2x3::IfcAppliedValue::AppliedValue() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAppliedValueSelect>(true); }
void Ifc2x3::IfcAppliedValue::setAppliedValue(::Ifc2x3::IfcAppliedValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcMeasureWithUnit* Ifc2x3::IfcAppliedValue::UnitBasis() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcMeasureWithUnit>(true); }
void Ifc2x3::IfcAppliedValue::setUnitBasis(::Ifc2x3::IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcAppliedValue::ApplicableDate() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcAppliedValue::setApplicableDate(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcAppliedValue::FixedUntilDate() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcAppliedValue::setFixedUntilDate(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

::Ifc2x3::IfcReferencesValueDocument::list::ptr Ifc2x3::IfcAppliedValue::ValuesReferenced() const { return data_->getInverse(IFC2X3_IfcReferencesValueDocument_type, 1)->as<IfcReferencesValueDocument>(); }
::Ifc2x3::IfcAppliedValueRelationship::list::ptr Ifc2x3::IfcAppliedValue::ValueOfComponents() const { return data_->getInverse(IFC2X3_IfcAppliedValueRelationship_type, 0)->as<IfcAppliedValueRelationship>(); }
::Ifc2x3::IfcAppliedValueRelationship::list::ptr Ifc2x3::IfcAppliedValue::IsComponentIn() const { return data_->getInverse(IFC2X3_IfcAppliedValueRelationship_type, 1)->as<IfcAppliedValueRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcAppliedValue::declaration() const { return *IFC2X3_IfcAppliedValue_type; }
const IfcParse::entity& Ifc2x3::IfcAppliedValue::Class() { return *IFC2X3_IfcAppliedValue_type; }
Ifc2x3::IfcAppliedValue::IfcAppliedValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcAppliedValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAppliedValue::IfcAppliedValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcAppliedValueSelect* v3_AppliedValue, ::Ifc2x3::IfcMeasureWithUnit* v4_UnitBasis, ::Ifc2x3::IfcDateTimeSelect* v5_ApplicableDate, ::Ifc2x3::IfcDateTimeSelect* v6_FixedUntilDate) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcAppliedValue_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));data_->setArgument(5,attr);} }

// Function implementations for IfcAppliedValueRelationship
::Ifc2x3::IfcAppliedValue* Ifc2x3::IfcAppliedValueRelationship::ComponentOfTotal() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAppliedValue>(true); }
void Ifc2x3::IfcAppliedValueRelationship::setComponentOfTotal(::Ifc2x3::IfcAppliedValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr Ifc2x3::IfcAppliedValueRelationship::Components() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcAppliedValue >(); }
void Ifc2x3::IfcAppliedValueRelationship::setComponents(aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
::Ifc2x3::IfcArithmeticOperatorEnum::Value Ifc2x3::IfcAppliedValueRelationship::ArithmeticOperator() const {  return ::Ifc2x3::IfcArithmeticOperatorEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcAppliedValueRelationship::setArithmeticOperator(::Ifc2x3::IfcArithmeticOperatorEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcArithmeticOperatorEnum::ToString(v)));data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcAppliedValueRelationship::Name() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcAppliedValueRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcAppliedValueRelationship::Description() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcAppliedValueRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcAppliedValueRelationship::declaration() const { return *IFC2X3_IfcAppliedValueRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcAppliedValueRelationship::Class() { return *IFC2X3_IfcAppliedValueRelationship_type; }
Ifc2x3::IfcAppliedValueRelationship::IfcAppliedValueRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcAppliedValueRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAppliedValueRelationship::IfcAppliedValueRelationship(::Ifc2x3::IfcAppliedValue* v1_ComponentOfTotal, aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr v2_Components, ::Ifc2x3::IfcArithmeticOperatorEnum::Value v3_ArithmeticOperator, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcAppliedValueRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ComponentOfTotal));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Components)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ArithmeticOperator,::Ifc2x3::IfcArithmeticOperatorEnum::ToString(v3_ArithmeticOperator))));data_->setArgument(2,attr);} if (v4_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Name));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Description));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcApproval
boost::optional< std::string > Ifc2x3::IfcApproval::Description() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcApproval::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcApproval::ApprovalDateTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcApproval::setApprovalDateTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcApproval::ApprovalStatus() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcApproval::setApprovalStatus(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcApproval::ApprovalLevel() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcApproval::setApprovalLevel(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcApproval::ApprovalQualifier() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcApproval::setApprovalQualifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
std::string Ifc2x3::IfcApproval::Name() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcApproval::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
std::string Ifc2x3::IfcApproval::Identifier() const {  std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcApproval::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

::Ifc2x3::IfcApprovalActorRelationship::list::ptr Ifc2x3::IfcApproval::Actors() const { return data_->getInverse(IFC2X3_IfcApprovalActorRelationship_type, 1)->as<IfcApprovalActorRelationship>(); }
::Ifc2x3::IfcApprovalRelationship::list::ptr Ifc2x3::IfcApproval::IsRelatedWith() const { return data_->getInverse(IFC2X3_IfcApprovalRelationship_type, 0)->as<IfcApprovalRelationship>(); }
::Ifc2x3::IfcApprovalRelationship::list::ptr Ifc2x3::IfcApproval::Relates() const { return data_->getInverse(IFC2X3_IfcApprovalRelationship_type, 1)->as<IfcApprovalRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcApproval::declaration() const { return *IFC2X3_IfcApproval_type; }
const IfcParse::entity& Ifc2x3::IfcApproval::Class() { return *IFC2X3_IfcApproval_type; }
Ifc2x3::IfcApproval::IfcApproval(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcApproval_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcApproval::IfcApproval(boost::optional< std::string > v1_Description, ::Ifc2x3::IfcDateTimeSelect* v2_ApprovalDateTime, boost::optional< std::string > v3_ApprovalStatus, boost::optional< std::string > v4_ApprovalLevel, boost::optional< std::string > v5_ApprovalQualifier, std::string v6_Name, std::string v7_Identifier) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcApproval_type);  if (v1_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Description));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ApprovalDateTime));data_->setArgument(1,attr);} if (v3_ApprovalStatus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ApprovalStatus));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ApprovalLevel) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ApprovalLevel));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApprovalQualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApprovalQualifier));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Name));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Identifier));data_->setArgument(6,attr);} }

// Function implementations for IfcApprovalActorRelationship
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcApprovalActorRelationship::Actor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcApprovalActorRelationship::setActor(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcApproval* Ifc2x3::IfcApprovalActorRelationship::Approval() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcApproval>(true); }
void Ifc2x3::IfcApprovalActorRelationship::setApproval(::Ifc2x3::IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcActorRole* Ifc2x3::IfcApprovalActorRelationship::Role() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcActorRole>(true); }
void Ifc2x3::IfcApprovalActorRelationship::setRole(::Ifc2x3::IfcActorRole* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcApprovalActorRelationship::declaration() const { return *IFC2X3_IfcApprovalActorRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcApprovalActorRelationship::Class() { return *IFC2X3_IfcApprovalActorRelationship_type; }
Ifc2x3::IfcApprovalActorRelationship::IfcApprovalActorRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcApprovalActorRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcApprovalActorRelationship::IfcApprovalActorRelationship(::Ifc2x3::IfcActorSelect* v1_Actor, ::Ifc2x3::IfcApproval* v2_Approval, ::Ifc2x3::IfcActorRole* v3_Role) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcApprovalActorRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Actor));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Approval));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Role));data_->setArgument(2,attr);} }

// Function implementations for IfcApprovalPropertyRelationship
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcApprovalPropertyRelationship::ApprovedProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcApprovalPropertyRelationship::setApprovedProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
::Ifc2x3::IfcApproval* Ifc2x3::IfcApprovalPropertyRelationship::Approval() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcApproval>(true); }
void Ifc2x3::IfcApprovalPropertyRelationship::setApproval(::Ifc2x3::IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcApprovalPropertyRelationship::declaration() const { return *IFC2X3_IfcApprovalPropertyRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcApprovalPropertyRelationship::Class() { return *IFC2X3_IfcApprovalPropertyRelationship_type; }
Ifc2x3::IfcApprovalPropertyRelationship::IfcApprovalPropertyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcApprovalPropertyRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcApprovalPropertyRelationship::IfcApprovalPropertyRelationship(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v1_ApprovedProperties, ::Ifc2x3::IfcApproval* v2_Approval) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcApprovalPropertyRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ApprovedProperties)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Approval));data_->setArgument(1,attr);} }

// Function implementations for IfcApprovalRelationship
::Ifc2x3::IfcApproval* Ifc2x3::IfcApprovalRelationship::RelatedApproval() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcApproval>(true); }
void Ifc2x3::IfcApprovalRelationship::setRelatedApproval(::Ifc2x3::IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcApproval* Ifc2x3::IfcApprovalRelationship::RelatingApproval() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcApproval>(true); }
void Ifc2x3::IfcApprovalRelationship::setRelatingApproval(::Ifc2x3::IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcApprovalRelationship::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcApprovalRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
std::string Ifc2x3::IfcApprovalRelationship::Name() const {  std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcApprovalRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcApprovalRelationship::declaration() const { return *IFC2X3_IfcApprovalRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcApprovalRelationship::Class() { return *IFC2X3_IfcApprovalRelationship_type; }
Ifc2x3::IfcApprovalRelationship::IfcApprovalRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcApprovalRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcApprovalRelationship::IfcApprovalRelationship(::Ifc2x3::IfcApproval* v1_RelatedApproval, ::Ifc2x3::IfcApproval* v2_RelatingApproval, boost::optional< std::string > v3_Description, std::string v4_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcApprovalRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatedApproval));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatingApproval));data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));data_->setArgument(3,attr);} }

// Function implementations for IfcArbitraryClosedProfileDef
::Ifc2x3::IfcCurve* Ifc2x3::IfcArbitraryClosedProfileDef::OuterCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcArbitraryClosedProfileDef::setOuterCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcArbitraryClosedProfileDef::declaration() const { return *IFC2X3_IfcArbitraryClosedProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcArbitraryClosedProfileDef::Class() { return *IFC2X3_IfcArbitraryClosedProfileDef_type; }
Ifc2x3::IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcArbitraryClosedProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcCurve* v3_OuterCurve) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcArbitraryClosedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));data_->setArgument(2,attr);} }

// Function implementations for IfcArbitraryOpenProfileDef
::Ifc2x3::IfcBoundedCurve* Ifc2x3::IfcArbitraryOpenProfileDef::Curve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcBoundedCurve>(true); }
void Ifc2x3::IfcArbitraryOpenProfileDef::setCurve(::Ifc2x3::IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcArbitraryOpenProfileDef::declaration() const { return *IFC2X3_IfcArbitraryOpenProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcArbitraryOpenProfileDef::Class() { return *IFC2X3_IfcArbitraryOpenProfileDef_type; }
Ifc2x3::IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcArbitraryOpenProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcBoundedCurve* v3_Curve) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcArbitraryOpenProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));data_->setArgument(2,attr);} }

// Function implementations for IfcArbitraryProfileDefWithVoids
aggregate_of< ::Ifc2x3::IfcCurve >::ptr Ifc2x3::IfcArbitraryProfileDefWithVoids::InnerCurves() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcCurve >(); }
void Ifc2x3::IfcArbitraryProfileDefWithVoids::setInnerCurves(aggregate_of< ::Ifc2x3::IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcArbitraryProfileDefWithVoids::declaration() const { return *IFC2X3_IfcArbitraryProfileDefWithVoids_type; }
const IfcParse::entity& Ifc2x3::IfcArbitraryProfileDefWithVoids::Class() { return *IFC2X3_IfcArbitraryProfileDefWithVoids_type; }
Ifc2x3::IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcEntityInstanceData* e) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcArbitraryProfileDefWithVoids_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcCurve* v3_OuterCurve, aggregate_of< ::Ifc2x3::IfcCurve >::ptr v4_InnerCurves) : IfcArbitraryClosedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcArbitraryProfileDefWithVoids_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_OuterCurve));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_InnerCurves)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcAsset
std::string Ifc2x3::IfcAsset::AssetID() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcAsset::setAssetID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcAsset::OriginalValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcAsset::setOriginalValue(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcAsset::CurrentValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcAsset::setCurrentValue(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcAsset::TotalReplacementCost() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcAsset::setTotalReplacementCost(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcAsset::Owner() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcAsset::setOwner(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcAsset::User() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcAsset::setUser(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
::Ifc2x3::IfcPerson* Ifc2x3::IfcAsset::ResponsiblePerson() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcPerson>(true); }
void Ifc2x3::IfcAsset::setResponsiblePerson(::Ifc2x3::IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcAsset::IncorporationDate() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcAsset::setIncorporationDate(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcAsset::DepreciatedValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(13)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcAsset::setDepreciatedValue(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcAsset::declaration() const { return *IFC2X3_IfcAsset_type; }
const IfcParse::entity& Ifc2x3::IfcAsset::Class() { return *IFC2X3_IfcAsset_type; }
Ifc2x3::IfcAsset::IfcAsset(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAsset_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAsset::IfcAsset(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_AssetID, ::Ifc2x3::IfcCostValue* v7_OriginalValue, ::Ifc2x3::IfcCostValue* v8_CurrentValue, ::Ifc2x3::IfcCostValue* v9_TotalReplacementCost, ::Ifc2x3::IfcActorSelect* v10_Owner, ::Ifc2x3::IfcActorSelect* v11_User, ::Ifc2x3::IfcPerson* v12_ResponsiblePerson, ::Ifc2x3::IfcCalendarDate* v13_IncorporationDate, ::Ifc2x3::IfcCostValue* v14_DepreciatedValue) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAsset_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_AssetID));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OriginalValue));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CurrentValue));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TotalReplacementCost));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Owner));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_User));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_ResponsiblePerson));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_IncorporationDate));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_DepreciatedValue));data_->setArgument(13,attr);} }

// Function implementations for IfcAsymmetricIShapeProfileDef
double Ifc2x3::IfcAsymmetricIShapeProfileDef::TopFlangeWidth() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcAsymmetricIShapeProfileDef::setTopFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcAsymmetricIShapeProfileDef::TopFlangeThickness() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcAsymmetricIShapeProfileDef::setTopFlangeThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcAsymmetricIShapeProfileDef::TopFlangeFilletRadius() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcAsymmetricIShapeProfileDef::setTopFlangeFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcAsymmetricIShapeProfileDef::CentreOfGravityInY() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcAsymmetricIShapeProfileDef::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcAsymmetricIShapeProfileDef::declaration() const { return *IFC2X3_IfcAsymmetricIShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcAsymmetricIShapeProfileDef::Class() { return *IFC2X3_IfcAsymmetricIShapeProfileDef_type; }
Ifc2x3::IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcEntityInstanceData* e) : IfcIShapeProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAsymmetricIShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, double v9_TopFlangeWidth, boost::optional< double > v10_TopFlangeThickness, boost::optional< double > v11_TopFlangeFilletRadius, boost::optional< double > v12_CentreOfGravityInY) : IfcIShapeProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAsymmetricIShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallWidth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TopFlangeWidth));data_->setArgument(8,attr);} if (v10_TopFlangeThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TopFlangeThickness));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TopFlangeFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TopFlangeFilletRadius));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CentreOfGravityInY));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcAxis1Placement
::Ifc2x3::IfcDirection* Ifc2x3::IfcAxis1Placement::Axis() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcAxis1Placement::setAxis(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcAxis1Placement::declaration() const { return *IFC2X3_IfcAxis1Placement_type; }
const IfcParse::entity& Ifc2x3::IfcAxis1Placement::Class() { return *IFC2X3_IfcAxis1Placement_type; }
Ifc2x3::IfcAxis1Placement::IfcAxis1Placement(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAxis1Placement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAxis1Placement::IfcAxis1Placement(::Ifc2x3::IfcCartesianPoint* v1_Location, ::Ifc2x3::IfcDirection* v2_Axis) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAxis1Placement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));data_->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement2D
::Ifc2x3::IfcDirection* Ifc2x3::IfcAxis2Placement2D::RefDirection() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcAxis2Placement2D::setRefDirection(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcAxis2Placement2D::declaration() const { return *IFC2X3_IfcAxis2Placement2D_type; }
const IfcParse::entity& Ifc2x3::IfcAxis2Placement2D::Class() { return *IFC2X3_IfcAxis2Placement2D_type; }
Ifc2x3::IfcAxis2Placement2D::IfcAxis2Placement2D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAxis2Placement2D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAxis2Placement2D::IfcAxis2Placement2D(::Ifc2x3::IfcCartesianPoint* v1_Location, ::Ifc2x3::IfcDirection* v2_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAxis2Placement2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RefDirection));data_->setArgument(1,attr);} }

// Function implementations for IfcAxis2Placement3D
::Ifc2x3::IfcDirection* Ifc2x3::IfcAxis2Placement3D::Axis() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcAxis2Placement3D::setAxis(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcDirection* Ifc2x3::IfcAxis2Placement3D::RefDirection() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcAxis2Placement3D::setRefDirection(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcAxis2Placement3D::declaration() const { return *IFC2X3_IfcAxis2Placement3D_type; }
const IfcParse::entity& Ifc2x3::IfcAxis2Placement3D::Class() { return *IFC2X3_IfcAxis2Placement3D_type; }
Ifc2x3::IfcAxis2Placement3D::IfcAxis2Placement3D(IfcEntityInstanceData* e) : IfcPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcAxis2Placement3D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcAxis2Placement3D::IfcAxis2Placement3D(::Ifc2x3::IfcCartesianPoint* v1_Location, ::Ifc2x3::IfcDirection* v2_Axis, ::Ifc2x3::IfcDirection* v3_RefDirection) : IfcPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcAxis2Placement3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RefDirection));data_->setArgument(2,attr);} }

// Function implementations for IfcBSplineCurve
int Ifc2x3::IfcBSplineCurve::Degree() const {  int v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcBSplineCurve::setDegree(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr Ifc2x3::IfcBSplineCurve::ControlPointsList() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcCartesianPoint >(); }
void Ifc2x3::IfcBSplineCurve::setControlPointsList(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
::Ifc2x3::IfcBSplineCurveForm::Value Ifc2x3::IfcBSplineCurve::CurveForm() const {  return ::Ifc2x3::IfcBSplineCurveForm::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcBSplineCurve::setCurveForm(::Ifc2x3::IfcBSplineCurveForm::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBSplineCurveForm::ToString(v)));data_->setArgument(2,attr);} }
boost::logic::tribool Ifc2x3::IfcBSplineCurve::ClosedCurve() const {  boost::logic::tribool v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBSplineCurve::setClosedCurve(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::logic::tribool Ifc2x3::IfcBSplineCurve::SelfIntersect() const {  boost::logic::tribool v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcBSplineCurve::setSelfIntersect(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcBSplineCurve::declaration() const { return *IFC2X3_IfcBSplineCurve_type; }
const IfcParse::entity& Ifc2x3::IfcBSplineCurve::Class() { return *IFC2X3_IfcBSplineCurve_type; }
Ifc2x3::IfcBSplineCurve::IfcBSplineCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBSplineCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBSplineCurve::IfcBSplineCurve(int v1_Degree, aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v2_ControlPointsList, ::Ifc2x3::IfcBSplineCurveForm::Value v3_CurveForm, boost::logic::tribool v4_ClosedCurve, boost::logic::tribool v5_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBSplineCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,::Ifc2x3::IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);} }

// Function implementations for IfcBeam


const IfcParse::entity& Ifc2x3::IfcBeam::declaration() const { return *IFC2X3_IfcBeam_type; }
const IfcParse::entity& Ifc2x3::IfcBeam::Class() { return *IFC2X3_IfcBeam_type; }
Ifc2x3::IfcBeam::IfcBeam(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBeam_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBeam::IfcBeam(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBeam_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBeamType
::Ifc2x3::IfcBeamTypeEnum::Value Ifc2x3::IfcBeamType::PredefinedType() const {  return ::Ifc2x3::IfcBeamTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcBeamType::setPredefinedType(::Ifc2x3::IfcBeamTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBeamTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcBeamType::declaration() const { return *IFC2X3_IfcBeamType_type; }
const IfcParse::entity& Ifc2x3::IfcBeamType::Class() { return *IFC2X3_IfcBeamType_type; }
Ifc2x3::IfcBeamType::IfcBeamType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBeamType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBeamType::IfcBeamType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcBeamTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBeamType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcBeamTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBezierCurve


const IfcParse::entity& Ifc2x3::IfcBezierCurve::declaration() const { return *IFC2X3_IfcBezierCurve_type; }
const IfcParse::entity& Ifc2x3::IfcBezierCurve::Class() { return *IFC2X3_IfcBezierCurve_type; }
Ifc2x3::IfcBezierCurve::IfcBezierCurve(IfcEntityInstanceData* e) : IfcBSplineCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBezierCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBezierCurve::IfcBezierCurve(int v1_Degree, aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v2_ControlPointsList, ::Ifc2x3::IfcBSplineCurveForm::Value v3_CurveForm, boost::logic::tribool v4_ClosedCurve, boost::logic::tribool v5_SelfIntersect) : IfcBSplineCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBezierCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,::Ifc2x3::IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);} }

// Function implementations for IfcBlobTexture
std::string Ifc2x3::IfcBlobTexture::RasterFormat() const {  std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcBlobTexture::setRasterFormat(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool Ifc2x3::IfcBlobTexture::RasterCode() const {  bool v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcBlobTexture::setRasterCode(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcBlobTexture::declaration() const { return *IFC2X3_IfcBlobTexture_type; }
const IfcParse::entity& Ifc2x3::IfcBlobTexture::Class() { return *IFC2X3_IfcBlobTexture_type; }
Ifc2x3::IfcBlobTexture::IfcBlobTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBlobTexture_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBlobTexture::IfcBlobTexture(bool v1_RepeatS, bool v2_RepeatT, ::Ifc2x3::IfcSurfaceTextureEnum::Value v3_TextureType, ::Ifc2x3::IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_RasterFormat, bool v6_RasterCode) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBlobTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,::Ifc2x3::IfcSurfaceTextureEnum::ToString(v3_TextureType))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RasterFormat));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RasterCode));data_->setArgument(5,attr);} }

// Function implementations for IfcBlock
double Ifc2x3::IfcBlock::XLength() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcBlock::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcBlock::YLength() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcBlock::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcBlock::ZLength() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBlock::setZLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcBlock::declaration() const { return *IFC2X3_IfcBlock_type; }
const IfcParse::entity& Ifc2x3::IfcBlock::Class() { return *IFC2X3_IfcBlock_type; }
Ifc2x3::IfcBlock::IfcBlock(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBlock_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBlock::IfcBlock(::Ifc2x3::IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_ZLength) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBlock_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZLength));data_->setArgument(3,attr);} }

// Function implementations for IfcBoilerType
::Ifc2x3::IfcBoilerTypeEnum::Value Ifc2x3::IfcBoilerType::PredefinedType() const {  return ::Ifc2x3::IfcBoilerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcBoilerType::setPredefinedType(::Ifc2x3::IfcBoilerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBoilerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoilerType::declaration() const { return *IFC2X3_IfcBoilerType_type; }
const IfcParse::entity& Ifc2x3::IfcBoilerType::Class() { return *IFC2X3_IfcBoilerType_type; }
Ifc2x3::IfcBoilerType::IfcBoilerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoilerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoilerType::IfcBoilerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcBoilerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoilerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcBoilerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBooleanClippingResult


const IfcParse::entity& Ifc2x3::IfcBooleanClippingResult::declaration() const { return *IFC2X3_IfcBooleanClippingResult_type; }
const IfcParse::entity& Ifc2x3::IfcBooleanClippingResult::Class() { return *IFC2X3_IfcBooleanClippingResult_type; }
Ifc2x3::IfcBooleanClippingResult::IfcBooleanClippingResult(IfcEntityInstanceData* e) : IfcBooleanResult((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBooleanClippingResult_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBooleanClippingResult::IfcBooleanClippingResult(::Ifc2x3::IfcBooleanOperator::Value v1_Operator, ::Ifc2x3::IfcBooleanOperand* v2_FirstOperand, ::Ifc2x3::IfcBooleanOperand* v3_SecondOperand) : IfcBooleanResult((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBooleanClippingResult_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,::Ifc2x3::IfcBooleanOperator::ToString(v1_Operator))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));data_->setArgument(2,attr);} }

// Function implementations for IfcBooleanResult
::Ifc2x3::IfcBooleanOperator::Value Ifc2x3::IfcBooleanResult::Operator() const {  return ::Ifc2x3::IfcBooleanOperator::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcBooleanResult::setOperator(::Ifc2x3::IfcBooleanOperator::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBooleanOperator::ToString(v)));data_->setArgument(0,attr);} }
::Ifc2x3::IfcBooleanOperand* Ifc2x3::IfcBooleanResult::FirstOperand() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcBooleanOperand>(true); }
void Ifc2x3::IfcBooleanResult::setFirstOperand(::Ifc2x3::IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcBooleanOperand* Ifc2x3::IfcBooleanResult::SecondOperand() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcBooleanOperand>(true); }
void Ifc2x3::IfcBooleanResult::setSecondOperand(::Ifc2x3::IfcBooleanOperand* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcBooleanResult::declaration() const { return *IFC2X3_IfcBooleanResult_type; }
const IfcParse::entity& Ifc2x3::IfcBooleanResult::Class() { return *IFC2X3_IfcBooleanResult_type; }
Ifc2x3::IfcBooleanResult::IfcBooleanResult(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBooleanResult_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBooleanResult::IfcBooleanResult(::Ifc2x3::IfcBooleanOperator::Value v1_Operator, ::Ifc2x3::IfcBooleanOperand* v2_FirstOperand, ::Ifc2x3::IfcBooleanOperand* v3_SecondOperand) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBooleanResult_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Operator,::Ifc2x3::IfcBooleanOperator::ToString(v1_Operator))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FirstOperand));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SecondOperand));data_->setArgument(2,attr);} }

// Function implementations for IfcBoundaryCondition
boost::optional< std::string > Ifc2x3::IfcBoundaryCondition::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcBoundaryCondition::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundaryCondition::declaration() const { return *IFC2X3_IfcBoundaryCondition_type; }
const IfcParse::entity& Ifc2x3::IfcBoundaryCondition::Class() { return *IFC2X3_IfcBoundaryCondition_type; }
Ifc2x3::IfcBoundaryCondition::IfcBoundaryCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcBoundaryCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundaryCondition::IfcBoundaryCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundaryCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcBoundaryEdgeCondition
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::LinearStiffnessByLengthX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setLinearStiffnessByLengthX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::LinearStiffnessByLengthY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setLinearStiffnessByLengthY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::LinearStiffnessByLengthZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setLinearStiffnessByLengthZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::RotationalStiffnessByLengthX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::RotationalStiffnessByLengthY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryEdgeCondition::RotationalStiffnessByLengthZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundaryEdgeCondition::declaration() const { return *IFC2X3_IfcBoundaryEdgeCondition_type; }
const IfcParse::entity& Ifc2x3::IfcBoundaryEdgeCondition::Class() { return *IFC2X3_IfcBoundaryEdgeCondition_type; }
Ifc2x3::IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundaryEdgeCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByLengthX, boost::optional< double > v3_LinearStiffnessByLengthY, boost::optional< double > v4_LinearStiffnessByLengthZ, boost::optional< double > v5_RotationalStiffnessByLengthX, boost::optional< double > v6_RotationalStiffnessByLengthY, boost::optional< double > v7_RotationalStiffnessByLengthZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundaryEdgeCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearStiffnessByLengthX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessByLengthX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearStiffnessByLengthY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessByLengthY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearStiffnessByLengthZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessByLengthZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalStiffnessByLengthX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessByLengthX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalStiffnessByLengthY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessByLengthY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalStiffnessByLengthZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessByLengthZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcBoundaryFaceCondition
boost::optional< double > Ifc2x3::IfcBoundaryFaceCondition::LinearStiffnessByAreaX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcBoundaryFaceCondition::setLinearStiffnessByAreaX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryFaceCondition::LinearStiffnessByAreaY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcBoundaryFaceCondition::setLinearStiffnessByAreaY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryFaceCondition::LinearStiffnessByAreaZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBoundaryFaceCondition::setLinearStiffnessByAreaZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundaryFaceCondition::declaration() const { return *IFC2X3_IfcBoundaryFaceCondition_type; }
const IfcParse::entity& Ifc2x3::IfcBoundaryFaceCondition::Class() { return *IFC2X3_IfcBoundaryFaceCondition_type; }
Ifc2x3::IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundaryFaceCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByAreaX, boost::optional< double > v3_LinearStiffnessByAreaY, boost::optional< double > v4_LinearStiffnessByAreaZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundaryFaceCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearStiffnessByAreaX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessByAreaX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearStiffnessByAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessByAreaY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearStiffnessByAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessByAreaZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcBoundaryNodeCondition
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::LinearStiffnessX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setLinearStiffnessX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::LinearStiffnessY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setLinearStiffnessY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::LinearStiffnessZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setLinearStiffnessZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::RotationalStiffnessX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setRotationalStiffnessX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::RotationalStiffnessY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setRotationalStiffnessY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcBoundaryNodeCondition::RotationalStiffnessZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcBoundaryNodeCondition::setRotationalStiffnessZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundaryNodeCondition::declaration() const { return *IFC2X3_IfcBoundaryNodeCondition_type; }
const IfcParse::entity& Ifc2x3::IfcBoundaryNodeCondition::Class() { return *IFC2X3_IfcBoundaryNodeCondition_type; }
Ifc2x3::IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(IfcEntityInstanceData* e) : IfcBoundaryCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundaryNodeCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ) : IfcBoundaryCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundaryNodeCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcBoundaryNodeConditionWarping
boost::optional< double > Ifc2x3::IfcBoundaryNodeConditionWarping::WarpingStiffness() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcBoundaryNodeConditionWarping::setWarpingStiffness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundaryNodeConditionWarping::declaration() const { return *IFC2X3_IfcBoundaryNodeConditionWarping_type; }
const IfcParse::entity& Ifc2x3::IfcBoundaryNodeConditionWarping::Class() { return *IFC2X3_IfcBoundaryNodeConditionWarping_type; }
Ifc2x3::IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(IfcEntityInstanceData* e) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundaryNodeConditionWarping_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ, boost::optional< double > v8_WarpingStiffness) : IfcBoundaryNodeCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundaryNodeConditionWarping_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearStiffnessX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearStiffnessY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearStiffnessZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalStiffnessX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalStiffnessX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalStiffnessY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalStiffnessY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalStiffnessZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalStiffnessZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WarpingStiffness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WarpingStiffness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBoundedCurve


const IfcParse::entity& Ifc2x3::IfcBoundedCurve::declaration() const { return *IFC2X3_IfcBoundedCurve_type; }
const IfcParse::entity& Ifc2x3::IfcBoundedCurve::Class() { return *IFC2X3_IfcBoundedCurve_type; }
Ifc2x3::IfcBoundedCurve::IfcBoundedCurve(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundedCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundedCurve::IfcBoundedCurve() : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundedCurve_type);  }

// Function implementations for IfcBoundedSurface


const IfcParse::entity& Ifc2x3::IfcBoundedSurface::declaration() const { return *IFC2X3_IfcBoundedSurface_type; }
const IfcParse::entity& Ifc2x3::IfcBoundedSurface::Class() { return *IFC2X3_IfcBoundedSurface_type; }
Ifc2x3::IfcBoundedSurface::IfcBoundedSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundedSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundedSurface::IfcBoundedSurface() : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundedSurface_type);  }

// Function implementations for IfcBoundingBox
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcBoundingBox::Corner() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcBoundingBox::setCorner(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcBoundingBox::XDim() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcBoundingBox::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcBoundingBox::YDim() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcBoundingBox::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcBoundingBox::ZDim() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcBoundingBox::setZDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoundingBox::declaration() const { return *IFC2X3_IfcBoundingBox_type; }
const IfcParse::entity& Ifc2x3::IfcBoundingBox::Class() { return *IFC2X3_IfcBoundingBox_type; }
Ifc2x3::IfcBoundingBox::IfcBoundingBox(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoundingBox_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoundingBox::IfcBoundingBox(::Ifc2x3::IfcCartesianPoint* v1_Corner, double v2_XDim, double v3_YDim, double v4_ZDim) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoundingBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Corner));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XDim));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YDim));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ZDim));data_->setArgument(3,attr);} }

// Function implementations for IfcBoxedHalfSpace
::Ifc2x3::IfcBoundingBox* Ifc2x3::IfcBoxedHalfSpace::Enclosure() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcBoundingBox>(true); }
void Ifc2x3::IfcBoxedHalfSpace::setEnclosure(::Ifc2x3::IfcBoundingBox* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcBoxedHalfSpace::declaration() const { return *IFC2X3_IfcBoxedHalfSpace_type; }
const IfcParse::entity& Ifc2x3::IfcBoxedHalfSpace::Class() { return *IFC2X3_IfcBoxedHalfSpace_type; }
Ifc2x3::IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBoxedHalfSpace_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBoxedHalfSpace::IfcBoxedHalfSpace(::Ifc2x3::IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, ::Ifc2x3::IfcBoundingBox* v3_Enclosure) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBoxedHalfSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Enclosure));data_->setArgument(2,attr);} }

// Function implementations for IfcBuilding
boost::optional< double > Ifc2x3::IfcBuilding::ElevationOfRefHeight() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcBuilding::setElevationOfRefHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcBuilding::ElevationOfTerrain() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcBuilding::setElevationOfTerrain(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
::Ifc2x3::IfcPostalAddress* Ifc2x3::IfcBuilding::BuildingAddress() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcPostalAddress>(true); }
void Ifc2x3::IfcBuilding::setBuildingAddress(::Ifc2x3::IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcBuilding::declaration() const { return *IFC2X3_IfcBuilding_type; }
const IfcParse::entity& Ifc2x3::IfcBuilding::Class() { return *IFC2X3_IfcBuilding_type; }
Ifc2x3::IfcBuilding::IfcBuilding(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuilding_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuilding::IfcBuilding(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, ::Ifc2x3::IfcElementCompositionEnum::Value v9_CompositionType, boost::optional< double > v10_ElevationOfRefHeight, boost::optional< double > v11_ElevationOfTerrain, ::Ifc2x3::IfcPostalAddress* v12_BuildingAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuilding_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(v9_CompositionType))));data_->setArgument(8,attr);} if (v10_ElevationOfRefHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_ElevationOfRefHeight));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ElevationOfTerrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationOfTerrain));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_BuildingAddress));data_->setArgument(11,attr);} }

// Function implementations for IfcBuildingElement


const IfcParse::entity& Ifc2x3::IfcBuildingElement::declaration() const { return *IFC2X3_IfcBuildingElement_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElement::Class() { return *IFC2X3_IfcBuildingElement_type; }
Ifc2x3::IfcBuildingElement::IfcBuildingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElement::IfcBuildingElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementComponent


const IfcParse::entity& Ifc2x3::IfcBuildingElementComponent::declaration() const { return *IFC2X3_IfcBuildingElementComponent_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElementComponent::Class() { return *IFC2X3_IfcBuildingElementComponent_type; }
Ifc2x3::IfcBuildingElementComponent::IfcBuildingElementComponent(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElementComponent_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElementComponent::IfcBuildingElementComponent(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementComponent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementPart


const IfcParse::entity& Ifc2x3::IfcBuildingElementPart::declaration() const { return *IFC2X3_IfcBuildingElementPart_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElementPart::Class() { return *IFC2X3_IfcBuildingElementPart_type; }
Ifc2x3::IfcBuildingElementPart::IfcBuildingElementPart(IfcEntityInstanceData* e) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElementPart_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElementPart::IfcBuildingElementPart(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementPart_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcBuildingElementProxy
boost::optional< ::Ifc2x3::IfcElementCompositionEnum::Value > Ifc2x3::IfcBuildingElementProxy::CompositionType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcElementCompositionEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcBuildingElementProxy::setCompositionType(boost::optional< ::Ifc2x3::IfcElementCompositionEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcElementCompositionEnum::ToString(*v)));}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcBuildingElementProxy::declaration() const { return *IFC2X3_IfcBuildingElementProxy_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElementProxy::Class() { return *IFC2X3_IfcBuildingElementProxy_type; }
Ifc2x3::IfcBuildingElementProxy::IfcBuildingElementProxy(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElementProxy_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElementProxy::IfcBuildingElementProxy(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcElementCompositionEnum::Value > v9_CompositionType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementProxy_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CompositionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(*v9_CompositionType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBuildingElementProxyType
::Ifc2x3::IfcBuildingElementProxyTypeEnum::Value Ifc2x3::IfcBuildingElementProxyType::PredefinedType() const {  return ::Ifc2x3::IfcBuildingElementProxyTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcBuildingElementProxyType::setPredefinedType(::Ifc2x3::IfcBuildingElementProxyTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBuildingElementProxyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcBuildingElementProxyType::declaration() const { return *IFC2X3_IfcBuildingElementProxyType_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElementProxyType::Class() { return *IFC2X3_IfcBuildingElementProxyType_type; }
Ifc2x3::IfcBuildingElementProxyType::IfcBuildingElementProxyType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElementProxyType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElementProxyType::IfcBuildingElementProxyType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcBuildingElementProxyTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementProxyType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcBuildingElementProxyTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcBuildingElementType


const IfcParse::entity& Ifc2x3::IfcBuildingElementType::declaration() const { return *IFC2X3_IfcBuildingElementType_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingElementType::Class() { return *IFC2X3_IfcBuildingElementType_type; }
Ifc2x3::IfcBuildingElementType::IfcBuildingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingElementType::IfcBuildingElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcBuildingStorey
boost::optional< double > Ifc2x3::IfcBuildingStorey::Elevation() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcBuildingStorey::setElevation(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcBuildingStorey::declaration() const { return *IFC2X3_IfcBuildingStorey_type; }
const IfcParse::entity& Ifc2x3::IfcBuildingStorey::Class() { return *IFC2X3_IfcBuildingStorey_type; }
Ifc2x3::IfcBuildingStorey::IfcBuildingStorey(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcBuildingStorey_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcBuildingStorey::IfcBuildingStorey(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, ::Ifc2x3::IfcElementCompositionEnum::Value v9_CompositionType, boost::optional< double > v10_Elevation) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcBuildingStorey_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(v9_CompositionType))));data_->setArgument(8,attr);} if (v10_Elevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Elevation));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcCShapeProfileDef
double Ifc2x3::IfcCShapeProfileDef::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcCShapeProfileDef::Width() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcCShapeProfileDef::setWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcCShapeProfileDef::WallThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcCShapeProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcCShapeProfileDef::Girth() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcCShapeProfileDef::setGirth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcCShapeProfileDef::InternalFilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcCShapeProfileDef::setInternalFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcCShapeProfileDef::CentreOfGravityInX() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcCShapeProfileDef::setCentreOfGravityInX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcCShapeProfileDef::declaration() const { return *IFC2X3_IfcCShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCShapeProfileDef::Class() { return *IFC2X3_IfcCShapeProfileDef_type; }
Ifc2x3::IfcCShapeProfileDef::IfcCShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCShapeProfileDef::IfcCShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_Width, double v6_WallThickness, double v7_Girth, boost::optional< double > v8_InternalFilletRadius, boost::optional< double > v9_CentreOfGravityInX) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Width));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Girth));data_->setArgument(6,attr);} if (v8_InternalFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_InternalFilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_CentreOfGravityInX));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCableCarrierFittingType
::Ifc2x3::IfcCableCarrierFittingTypeEnum::Value Ifc2x3::IfcCableCarrierFittingType::PredefinedType() const {  return ::Ifc2x3::IfcCableCarrierFittingTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCableCarrierFittingType::setPredefinedType(::Ifc2x3::IfcCableCarrierFittingTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCableCarrierFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCableCarrierFittingType::declaration() const { return *IFC2X3_IfcCableCarrierFittingType_type; }
const IfcParse::entity& Ifc2x3::IfcCableCarrierFittingType::Class() { return *IFC2X3_IfcCableCarrierFittingType_type; }
Ifc2x3::IfcCableCarrierFittingType::IfcCableCarrierFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCableCarrierFittingType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCableCarrierFittingType::IfcCableCarrierFittingType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCableCarrierFittingTypeEnum::Value v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCableCarrierFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCableCarrierSegmentType
::Ifc2x3::IfcCableCarrierSegmentTypeEnum::Value Ifc2x3::IfcCableCarrierSegmentType::PredefinedType() const {  return ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCableCarrierSegmentType::setPredefinedType(::Ifc2x3::IfcCableCarrierSegmentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCableCarrierSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCableCarrierSegmentType::declaration() const { return *IFC2X3_IfcCableCarrierSegmentType_type; }
const IfcParse::entity& Ifc2x3::IfcCableCarrierSegmentType::Class() { return *IFC2X3_IfcCableCarrierSegmentType_type; }
Ifc2x3::IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCableCarrierSegmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCableCarrierSegmentTypeEnum::Value v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCableCarrierSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCableCarrierSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCableSegmentType
::Ifc2x3::IfcCableSegmentTypeEnum::Value Ifc2x3::IfcCableSegmentType::PredefinedType() const {  return ::Ifc2x3::IfcCableSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCableSegmentType::setPredefinedType(::Ifc2x3::IfcCableSegmentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCableSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCableSegmentType::declaration() const { return *IFC2X3_IfcCableSegmentType_type; }
const IfcParse::entity& Ifc2x3::IfcCableSegmentType::Class() { return *IFC2X3_IfcCableSegmentType_type; }
Ifc2x3::IfcCableSegmentType::IfcCableSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCableSegmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCableSegmentType::IfcCableSegmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCableSegmentTypeEnum::Value v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCableSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCableSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCalendarDate
int Ifc2x3::IfcCalendarDate::DayComponent() const {  int v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCalendarDate::setDayComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int Ifc2x3::IfcCalendarDate::MonthComponent() const {  int v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCalendarDate::setMonthComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
int Ifc2x3::IfcCalendarDate::YearComponent() const {  int v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcCalendarDate::setYearComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcCalendarDate::declaration() const { return *IFC2X3_IfcCalendarDate_type; }
const IfcParse::entity& Ifc2x3::IfcCalendarDate::Class() { return *IFC2X3_IfcCalendarDate_type; }
Ifc2x3::IfcCalendarDate::IfcCalendarDate(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCalendarDate_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCalendarDate::IfcCalendarDate(int v1_DayComponent, int v2_MonthComponent, int v3_YearComponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCalendarDate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DayComponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MonthComponent));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YearComponent));data_->setArgument(2,attr);} }

// Function implementations for IfcCartesianPoint
std::vector< double > /*[1:3]*/ Ifc2x3::IfcCartesianPoint::Coordinates() const {  std::vector< double > /*[1:3]*/ v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCartesianPoint::setCoordinates(std::vector< double > /*[1:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcCartesianPoint::declaration() const { return *IFC2X3_IfcCartesianPoint_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianPoint::Class() { return *IFC2X3_IfcCartesianPoint_type; }
Ifc2x3::IfcCartesianPoint::IfcCartesianPoint(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianPoint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianPoint::IfcCartesianPoint(std::vector< double > /*[1:3]*/ v1_Coordinates) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianPoint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} }

// Function implementations for IfcCartesianTransformationOperator
::Ifc2x3::IfcDirection* Ifc2x3::IfcCartesianTransformationOperator::Axis1() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcCartesianTransformationOperator::setAxis1(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcDirection* Ifc2x3::IfcCartesianTransformationOperator::Axis2() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcCartesianTransformationOperator::setAxis2(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcCartesianTransformationOperator::LocalOrigin() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcCartesianTransformationOperator::setLocalOrigin(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcCartesianTransformationOperator::Scale() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCartesianTransformationOperator::setScale(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator::declaration() const { return *IFC2X3_IfcCartesianTransformationOperator_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator::Class() { return *IFC2X3_IfcCartesianTransformationOperator_type; }
Ifc2x3::IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianTransformationOperator_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(::Ifc2x3::IfcDirection* v1_Axis1, ::Ifc2x3::IfcDirection* v2_Axis2, ::Ifc2x3::IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianTransformationOperator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2D


const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator2D::declaration() const { return *IFC2X3_IfcCartesianTransformationOperator2D_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator2D::Class() { return *IFC2X3_IfcCartesianTransformationOperator2D_type; }
Ifc2x3::IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianTransformationOperator2D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(::Ifc2x3::IfcDirection* v1_Axis1, ::Ifc2x3::IfcDirection* v2_Axis2, ::Ifc2x3::IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianTransformationOperator2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCartesianTransformationOperator2DnonUniform
boost::optional< double > Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::Scale2() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::setScale2(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::declaration() const { return *IFC2X3_IfcCartesianTransformationOperator2DnonUniform_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::Class() { return *IFC2X3_IfcCartesianTransformationOperator2DnonUniform_type; }
Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianTransformationOperator2DnonUniform_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(::Ifc2x3::IfcDirection* v1_Axis1, ::Ifc2x3::IfcDirection* v2_Axis2, ::Ifc2x3::IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2) : IfcCartesianTransformationOperator2D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianTransformationOperator2DnonUniform_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Scale2));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcCartesianTransformationOperator3D
::Ifc2x3::IfcDirection* Ifc2x3::IfcCartesianTransformationOperator3D::Axis3() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcCartesianTransformationOperator3D::setAxis3(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator3D::declaration() const { return *IFC2X3_IfcCartesianTransformationOperator3D_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator3D::Class() { return *IFC2X3_IfcCartesianTransformationOperator3D_type; }
Ifc2x3::IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianTransformationOperator3D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(::Ifc2x3::IfcDirection* v1_Axis1, ::Ifc2x3::IfcDirection* v2_Axis2, ::Ifc2x3::IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, ::Ifc2x3::IfcDirection* v5_Axis3) : IfcCartesianTransformationOperator((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianTransformationOperator3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));data_->setArgument(4,attr);} }

// Function implementations for IfcCartesianTransformationOperator3DnonUniform
boost::optional< double > Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::Scale2() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::setScale2(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::Scale3() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::setScale3(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::declaration() const { return *IFC2X3_IfcCartesianTransformationOperator3DnonUniform_type; }
const IfcParse::entity& Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::Class() { return *IFC2X3_IfcCartesianTransformationOperator3DnonUniform_type; }
Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcEntityInstanceData* e) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCartesianTransformationOperator3DnonUniform_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(::Ifc2x3::IfcDirection* v1_Axis1, ::Ifc2x3::IfcDirection* v2_Axis2, ::Ifc2x3::IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, ::Ifc2x3::IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3) : IfcCartesianTransformationOperator3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCartesianTransformationOperator3DnonUniform_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Axis1));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Axis2));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LocalOrigin));data_->setArgument(2,attr);} if (v4_Scale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Scale));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Axis3));data_->setArgument(4,attr);} if (v6_Scale2) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Scale2));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Scale3) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scale3));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcCenterLineProfileDef
double Ifc2x3::IfcCenterLineProfileDef::Thickness() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCenterLineProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcCenterLineProfileDef::declaration() const { return *IFC2X3_IfcCenterLineProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCenterLineProfileDef::Class() { return *IFC2X3_IfcCenterLineProfileDef_type; }
Ifc2x3::IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcEntityInstanceData* e) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCenterLineProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCenterLineProfileDef::IfcCenterLineProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcBoundedCurve* v3_Curve, double v4_Thickness) : IfcArbitraryOpenProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCenterLineProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Curve));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Thickness));data_->setArgument(3,attr);} }

// Function implementations for IfcChamferEdgeFeature
boost::optional< double > Ifc2x3::IfcChamferEdgeFeature::Width() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcChamferEdgeFeature::setWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcChamferEdgeFeature::Height() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcChamferEdgeFeature::setHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcChamferEdgeFeature::declaration() const { return *IFC2X3_IfcChamferEdgeFeature_type; }
const IfcParse::entity& Ifc2x3::IfcChamferEdgeFeature::Class() { return *IFC2X3_IfcChamferEdgeFeature_type; }
Ifc2x3::IfcChamferEdgeFeature::IfcChamferEdgeFeature(IfcEntityInstanceData* e) : IfcEdgeFeature((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcChamferEdgeFeature_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcChamferEdgeFeature::IfcChamferEdgeFeature(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Width, boost::optional< double > v11_Height) : IfcEdgeFeature((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcChamferEdgeFeature_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Width) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Width));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_Height) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_Height));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcChillerType
::Ifc2x3::IfcChillerTypeEnum::Value Ifc2x3::IfcChillerType::PredefinedType() const {  return ::Ifc2x3::IfcChillerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcChillerType::setPredefinedType(::Ifc2x3::IfcChillerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcChillerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcChillerType::declaration() const { return *IFC2X3_IfcChillerType_type; }
const IfcParse::entity& Ifc2x3::IfcChillerType::Class() { return *IFC2X3_IfcChillerType_type; }
Ifc2x3::IfcChillerType::IfcChillerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcChillerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcChillerType::IfcChillerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcChillerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcChillerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcChillerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCircle
double Ifc2x3::IfcCircle::Radius() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCircle::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcCircle::declaration() const { return *IFC2X3_IfcCircle_type; }
const IfcParse::entity& Ifc2x3::IfcCircle::Class() { return *IFC2X3_IfcCircle_type; }
Ifc2x3::IfcCircle::IfcCircle(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCircle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCircle::IfcCircle(::Ifc2x3::IfcAxis2Placement* v1_Position, double v2_Radius) : IfcConic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCircle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} }

// Function implementations for IfcCircleHollowProfileDef
double Ifc2x3::IfcCircleHollowProfileDef::WallThickness() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcCircleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcCircleHollowProfileDef::declaration() const { return *IFC2X3_IfcCircleHollowProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCircleHollowProfileDef::Class() { return *IFC2X3_IfcCircleHollowProfileDef_type; }
Ifc2x3::IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcEntityInstanceData* e) : IfcCircleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCircleHollowProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Radius, double v5_WallThickness) : IfcCircleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCircleHollowProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WallThickness));data_->setArgument(4,attr);} }

// Function implementations for IfcCircleProfileDef
double Ifc2x3::IfcCircleProfileDef::Radius() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCircleProfileDef::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcCircleProfileDef::declaration() const { return *IFC2X3_IfcCircleProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCircleProfileDef::Class() { return *IFC2X3_IfcCircleProfileDef_type; }
Ifc2x3::IfcCircleProfileDef::IfcCircleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCircleProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCircleProfileDef::IfcCircleProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Radius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCircleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Radius));data_->setArgument(3,attr);} }

// Function implementations for IfcClassification
std::string Ifc2x3::IfcClassification::Source() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcClassification::setSource(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string Ifc2x3::IfcClassification::Edition() const {  std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcClassification::setEdition(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcClassification::EditionDate() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcClassification::setEditionDate(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
std::string Ifc2x3::IfcClassification::Name() const {  std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcClassification::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }

::Ifc2x3::IfcClassificationItem::list::ptr Ifc2x3::IfcClassification::Contains() const { return data_->getInverse(IFC2X3_IfcClassificationItem_type, 1)->as<IfcClassificationItem>(); }

const IfcParse::entity& Ifc2x3::IfcClassification::declaration() const { return *IFC2X3_IfcClassification_type; }
const IfcParse::entity& Ifc2x3::IfcClassification::Class() { return *IFC2X3_IfcClassification_type; }
Ifc2x3::IfcClassification::IfcClassification(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcClassification_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassification::IfcClassification(std::string v1_Source, std::string v2_Edition, ::Ifc2x3::IfcCalendarDate* v3_EditionDate, std::string v4_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassification_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Source));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Edition));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EditionDate));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));data_->setArgument(3,attr);} }

// Function implementations for IfcClassificationItem
::Ifc2x3::IfcClassificationNotationFacet* Ifc2x3::IfcClassificationItem::Notation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcClassificationNotationFacet>(true); }
void Ifc2x3::IfcClassificationItem::setNotation(::Ifc2x3::IfcClassificationNotationFacet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcClassification* Ifc2x3::IfcClassificationItem::ItemOf() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcClassification>(true); }
void Ifc2x3::IfcClassificationItem::setItemOf(::Ifc2x3::IfcClassification* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::string Ifc2x3::IfcClassificationItem::Title() const {  std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcClassificationItem::setTitle(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

::Ifc2x3::IfcClassificationItemRelationship::list::ptr Ifc2x3::IfcClassificationItem::IsClassifiedItemIn() const { return data_->getInverse(IFC2X3_IfcClassificationItemRelationship_type, 1)->as<IfcClassificationItemRelationship>(); }
::Ifc2x3::IfcClassificationItemRelationship::list::ptr Ifc2x3::IfcClassificationItem::IsClassifyingItemIn() const { return data_->getInverse(IFC2X3_IfcClassificationItemRelationship_type, 0)->as<IfcClassificationItemRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcClassificationItem::declaration() const { return *IFC2X3_IfcClassificationItem_type; }
const IfcParse::entity& Ifc2x3::IfcClassificationItem::Class() { return *IFC2X3_IfcClassificationItem_type; }
Ifc2x3::IfcClassificationItem::IfcClassificationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcClassificationItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassificationItem::IfcClassificationItem(::Ifc2x3::IfcClassificationNotationFacet* v1_Notation, ::Ifc2x3::IfcClassification* v2_ItemOf, std::string v3_Title) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassificationItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Notation));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ItemOf));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Title));data_->setArgument(2,attr);} }

// Function implementations for IfcClassificationItemRelationship
::Ifc2x3::IfcClassificationItem* Ifc2x3::IfcClassificationItemRelationship::RelatingItem() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcClassificationItem>(true); }
void Ifc2x3::IfcClassificationItemRelationship::setRelatingItem(::Ifc2x3::IfcClassificationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcClassificationItem >::ptr Ifc2x3::IfcClassificationItemRelationship::RelatedItems() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcClassificationItem >(); }
void Ifc2x3::IfcClassificationItemRelationship::setRelatedItems(aggregate_of< ::Ifc2x3::IfcClassificationItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcClassificationItemRelationship::declaration() const { return *IFC2X3_IfcClassificationItemRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcClassificationItemRelationship::Class() { return *IFC2X3_IfcClassificationItemRelationship_type; }
Ifc2x3::IfcClassificationItemRelationship::IfcClassificationItemRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcClassificationItemRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassificationItemRelationship::IfcClassificationItemRelationship(::Ifc2x3::IfcClassificationItem* v1_RelatingItem, aggregate_of< ::Ifc2x3::IfcClassificationItem >::ptr v2_RelatedItems) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassificationItemRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingItem));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedItems)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcClassificationNotation
aggregate_of< ::Ifc2x3::IfcClassificationNotationFacet >::ptr Ifc2x3::IfcClassificationNotation::NotationFacets() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcClassificationNotationFacet >(); }
void Ifc2x3::IfcClassificationNotation::setNotationFacets(aggregate_of< ::Ifc2x3::IfcClassificationNotationFacet >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcClassificationNotation::declaration() const { return *IFC2X3_IfcClassificationNotation_type; }
const IfcParse::entity& Ifc2x3::IfcClassificationNotation::Class() { return *IFC2X3_IfcClassificationNotation_type; }
Ifc2x3::IfcClassificationNotation::IfcClassificationNotation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcClassificationNotation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassificationNotation::IfcClassificationNotation(aggregate_of< ::Ifc2x3::IfcClassificationNotationFacet >::ptr v1_NotationFacets) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassificationNotation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_NotationFacets)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcClassificationNotationFacet
std::string Ifc2x3::IfcClassificationNotationFacet::NotationValue() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcClassificationNotationFacet::setNotationValue(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcClassificationNotationFacet::declaration() const { return *IFC2X3_IfcClassificationNotationFacet_type; }
const IfcParse::entity& Ifc2x3::IfcClassificationNotationFacet::Class() { return *IFC2X3_IfcClassificationNotationFacet_type; }
Ifc2x3::IfcClassificationNotationFacet::IfcClassificationNotationFacet(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcClassificationNotationFacet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassificationNotationFacet::IfcClassificationNotationFacet(std::string v1_NotationValue) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassificationNotationFacet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_NotationValue));data_->setArgument(0,attr);} }

// Function implementations for IfcClassificationReference
::Ifc2x3::IfcClassification* Ifc2x3::IfcClassificationReference::ReferencedSource() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcClassification>(true); }
void Ifc2x3::IfcClassificationReference::setReferencedSource(::Ifc2x3::IfcClassification* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcClassificationReference::declaration() const { return *IFC2X3_IfcClassificationReference_type; }
const IfcParse::entity& Ifc2x3::IfcClassificationReference::Class() { return *IFC2X3_IfcClassificationReference_type; }
Ifc2x3::IfcClassificationReference::IfcClassificationReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcClassificationReference_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClassificationReference::IfcClassificationReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name, ::Ifc2x3::IfcClassification* v4_ReferencedSource) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcClassificationReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReferencedSource));data_->setArgument(3,attr);} }

// Function implementations for IfcClosedShell


const IfcParse::entity& Ifc2x3::IfcClosedShell::declaration() const { return *IFC2X3_IfcClosedShell_type; }
const IfcParse::entity& Ifc2x3::IfcClosedShell::Class() { return *IFC2X3_IfcClosedShell_type; }
Ifc2x3::IfcClosedShell::IfcClosedShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcClosedShell_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcClosedShell::IfcClosedShell(aggregate_of< ::Ifc2x3::IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcClosedShell_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcCoilType
::Ifc2x3::IfcCoilTypeEnum::Value Ifc2x3::IfcCoilType::PredefinedType() const {  return ::Ifc2x3::IfcCoilTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCoilType::setPredefinedType(::Ifc2x3::IfcCoilTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCoilTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCoilType::declaration() const { return *IFC2X3_IfcCoilType_type; }
const IfcParse::entity& Ifc2x3::IfcCoilType::Class() { return *IFC2X3_IfcCoilType_type; }
Ifc2x3::IfcCoilType::IfcCoilType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCoilType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCoilType::IfcCoilType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCoilTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCoilType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCoilTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcColourRgb
double Ifc2x3::IfcColourRgb::Red() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcColourRgb::setRed(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcColourRgb::Green() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcColourRgb::setGreen(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcColourRgb::Blue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcColourRgb::setBlue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcColourRgb::declaration() const { return *IFC2X3_IfcColourRgb_type; }
const IfcParse::entity& Ifc2x3::IfcColourRgb::Class() { return *IFC2X3_IfcColourRgb_type; }
Ifc2x3::IfcColourRgb::IfcColourRgb(IfcEntityInstanceData* e) : IfcColourSpecification((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcColourRgb_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcColourRgb::IfcColourRgb(boost::optional< std::string > v1_Name, double v2_Red, double v3_Green, double v4_Blue) : IfcColourSpecification((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcColourRgb_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Red));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Green));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Blue));data_->setArgument(3,attr);} }

// Function implementations for IfcColourSpecification
boost::optional< std::string > Ifc2x3::IfcColourSpecification::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcColourSpecification::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcColourSpecification::declaration() const { return *IFC2X3_IfcColourSpecification_type; }
const IfcParse::entity& Ifc2x3::IfcColourSpecification::Class() { return *IFC2X3_IfcColourSpecification_type; }
Ifc2x3::IfcColourSpecification::IfcColourSpecification(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcColourSpecification_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcColourSpecification::IfcColourSpecification(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcColourSpecification_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcColumn


const IfcParse::entity& Ifc2x3::IfcColumn::declaration() const { return *IFC2X3_IfcColumn_type; }
const IfcParse::entity& Ifc2x3::IfcColumn::Class() { return *IFC2X3_IfcColumn_type; }
Ifc2x3::IfcColumn::IfcColumn(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcColumn_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcColumn::IfcColumn(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcColumn_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcColumnType
::Ifc2x3::IfcColumnTypeEnum::Value Ifc2x3::IfcColumnType::PredefinedType() const {  return ::Ifc2x3::IfcColumnTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcColumnType::setPredefinedType(::Ifc2x3::IfcColumnTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcColumnTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcColumnType::declaration() const { return *IFC2X3_IfcColumnType_type; }
const IfcParse::entity& Ifc2x3::IfcColumnType::Class() { return *IFC2X3_IfcColumnType_type; }
Ifc2x3::IfcColumnType::IfcColumnType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcColumnType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcColumnType::IfcColumnType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcColumnTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcColumnType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcColumnTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcComplexProperty
std::string Ifc2x3::IfcComplexProperty::UsageName() const {  std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcComplexProperty::setUsageName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcComplexProperty::HasProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcComplexProperty::setHasProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcComplexProperty::declaration() const { return *IFC2X3_IfcComplexProperty_type; }
const IfcParse::entity& Ifc2x3::IfcComplexProperty::Class() { return *IFC2X3_IfcComplexProperty_type; }
Ifc2x3::IfcComplexProperty::IfcComplexProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcComplexProperty_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcComplexProperty::IfcComplexProperty(std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_UsageName, aggregate_of< ::Ifc2x3::IfcProperty >::ptr v4_HasProperties) : IfcProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcComplexProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UsageName));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_HasProperties)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcCompositeCurve
aggregate_of< ::Ifc2x3::IfcCompositeCurveSegment >::ptr Ifc2x3::IfcCompositeCurve::Segments() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcCompositeCurveSegment >(); }
void Ifc2x3::IfcCompositeCurve::setSegments(aggregate_of< ::Ifc2x3::IfcCompositeCurveSegment >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
boost::logic::tribool Ifc2x3::IfcCompositeCurve::SelfIntersect() const {  boost::logic::tribool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCompositeCurve::setSelfIntersect(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcCompositeCurve::declaration() const { return *IFC2X3_IfcCompositeCurve_type; }
const IfcParse::entity& Ifc2x3::IfcCompositeCurve::Class() { return *IFC2X3_IfcCompositeCurve_type; }
Ifc2x3::IfcCompositeCurve::IfcCompositeCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCompositeCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCompositeCurve::IfcCompositeCurve(aggregate_of< ::Ifc2x3::IfcCompositeCurveSegment >::ptr v1_Segments, boost::logic::tribool v2_SelfIntersect) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCompositeCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Segments)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SelfIntersect));data_->setArgument(1,attr);} }

// Function implementations for IfcCompositeCurveSegment
::Ifc2x3::IfcTransitionCode::Value Ifc2x3::IfcCompositeCurveSegment::Transition() const {  return ::Ifc2x3::IfcTransitionCode::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcCompositeCurveSegment::setTransition(::Ifc2x3::IfcTransitionCode::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTransitionCode::ToString(v)));data_->setArgument(0,attr);} }
bool Ifc2x3::IfcCompositeCurveSegment::SameSense() const {  bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCompositeCurveSegment::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcCurve* Ifc2x3::IfcCompositeCurveSegment::ParentCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcCompositeCurveSegment::setParentCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

::Ifc2x3::IfcCompositeCurve::list::ptr Ifc2x3::IfcCompositeCurveSegment::UsingCurves() const { return data_->getInverse(IFC2X3_IfcCompositeCurve_type, 0)->as<IfcCompositeCurve>(); }

const IfcParse::entity& Ifc2x3::IfcCompositeCurveSegment::declaration() const { return *IFC2X3_IfcCompositeCurveSegment_type; }
const IfcParse::entity& Ifc2x3::IfcCompositeCurveSegment::Class() { return *IFC2X3_IfcCompositeCurveSegment_type; }
Ifc2x3::IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCompositeCurveSegment_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCompositeCurveSegment::IfcCompositeCurveSegment(::Ifc2x3::IfcTransitionCode::Value v1_Transition, bool v2_SameSense, ::Ifc2x3::IfcCurve* v3_ParentCurve) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCompositeCurveSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Transition,::Ifc2x3::IfcTransitionCode::ToString(v1_Transition))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SameSense));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentCurve));data_->setArgument(2,attr);} }

// Function implementations for IfcCompositeProfileDef
aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr Ifc2x3::IfcCompositeProfileDef::Profiles() const {  aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcProfileDef >(); }
void Ifc2x3::IfcCompositeProfileDef::setProfiles(aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcCompositeProfileDef::Label() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCompositeProfileDef::setLabel(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcCompositeProfileDef::declaration() const { return *IFC2X3_IfcCompositeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCompositeProfileDef::Class() { return *IFC2X3_IfcCompositeProfileDef_type; }
Ifc2x3::IfcCompositeProfileDef::IfcCompositeProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCompositeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCompositeProfileDef::IfcCompositeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr v3_Profiles, boost::optional< std::string > v4_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCompositeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Profiles)->generalize());data_->setArgument(2,attr);} if (v4_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Label));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcCompressorType
::Ifc2x3::IfcCompressorTypeEnum::Value Ifc2x3::IfcCompressorType::PredefinedType() const {  return ::Ifc2x3::IfcCompressorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCompressorType::setPredefinedType(::Ifc2x3::IfcCompressorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCompressorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCompressorType::declaration() const { return *IFC2X3_IfcCompressorType_type; }
const IfcParse::entity& Ifc2x3::IfcCompressorType::Class() { return *IFC2X3_IfcCompressorType_type; }
Ifc2x3::IfcCompressorType::IfcCompressorType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCompressorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCompressorType::IfcCompressorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCompressorTypeEnum::Value v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCompressorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCompressorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCondenserType
::Ifc2x3::IfcCondenserTypeEnum::Value Ifc2x3::IfcCondenserType::PredefinedType() const {  return ::Ifc2x3::IfcCondenserTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCondenserType::setPredefinedType(::Ifc2x3::IfcCondenserTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCondenserTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCondenserType::declaration() const { return *IFC2X3_IfcCondenserType_type; }
const IfcParse::entity& Ifc2x3::IfcCondenserType::Class() { return *IFC2X3_IfcCondenserType_type; }
Ifc2x3::IfcCondenserType::IfcCondenserType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCondenserType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCondenserType::IfcCondenserType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCondenserTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCondenserType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCondenserTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCondition


const IfcParse::entity& Ifc2x3::IfcCondition::declaration() const { return *IFC2X3_IfcCondition_type; }
const IfcParse::entity& Ifc2x3::IfcCondition::Class() { return *IFC2X3_IfcCondition_type; }
Ifc2x3::IfcCondition::IfcCondition(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCondition::IfcCondition(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCondition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcConditionCriterion
::Ifc2x3::IfcConditionCriterionSelect* Ifc2x3::IfcConditionCriterion::Criterion() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcConditionCriterionSelect>(true); }
void Ifc2x3::IfcConditionCriterion::setCriterion(::Ifc2x3::IfcConditionCriterionSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcConditionCriterion::CriterionDateTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcConditionCriterion::setCriterionDateTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcConditionCriterion::declaration() const { return *IFC2X3_IfcConditionCriterion_type; }
const IfcParse::entity& Ifc2x3::IfcConditionCriterion::Class() { return *IFC2X3_IfcConditionCriterion_type; }
Ifc2x3::IfcConditionCriterion::IfcConditionCriterion(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConditionCriterion_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConditionCriterion::IfcConditionCriterion(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcConditionCriterionSelect* v6_Criterion, ::Ifc2x3::IfcDateTimeSelect* v7_CriterionDateTime) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConditionCriterion_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Criterion));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CriterionDateTime));data_->setArgument(6,attr);} }

// Function implementations for IfcConic
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcConic::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcConic::setPosition(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcConic::declaration() const { return *IFC2X3_IfcConic_type; }
const IfcParse::entity& Ifc2x3::IfcConic::Class() { return *IFC2X3_IfcConic_type; }
Ifc2x3::IfcConic::IfcConic(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConic_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConic::IfcConic(::Ifc2x3::IfcAxis2Placement* v1_Position) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConic_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcConnectedFaceSet
aggregate_of< ::Ifc2x3::IfcFace >::ptr Ifc2x3::IfcConnectedFaceSet::CfsFaces() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcFace >(); }
void Ifc2x3::IfcConnectedFaceSet::setCfsFaces(aggregate_of< ::Ifc2x3::IfcFace >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectedFaceSet::declaration() const { return *IFC2X3_IfcConnectedFaceSet_type; }
const IfcParse::entity& Ifc2x3::IfcConnectedFaceSet::Class() { return *IFC2X3_IfcConnectedFaceSet_type; }
Ifc2x3::IfcConnectedFaceSet::IfcConnectedFaceSet(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectedFaceSet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectedFaceSet::IfcConnectedFaceSet(aggregate_of< ::Ifc2x3::IfcFace >::ptr v1_CfsFaces) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectedFaceSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcConnectionCurveGeometry
::Ifc2x3::IfcCurveOrEdgeCurve* Ifc2x3::IfcConnectionCurveGeometry::CurveOnRelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurveOrEdgeCurve>(true); }
void Ifc2x3::IfcConnectionCurveGeometry::setCurveOnRelatingElement(::Ifc2x3::IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcCurveOrEdgeCurve* Ifc2x3::IfcConnectionCurveGeometry::CurveOnRelatedElement() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCurveOrEdgeCurve>(true); }
void Ifc2x3::IfcConnectionCurveGeometry::setCurveOnRelatedElement(::Ifc2x3::IfcCurveOrEdgeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectionCurveGeometry::declaration() const { return *IFC2X3_IfcConnectionCurveGeometry_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionCurveGeometry::Class() { return *IFC2X3_IfcConnectionCurveGeometry_type; }
Ifc2x3::IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectionCurveGeometry_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(::Ifc2x3::IfcCurveOrEdgeCurve* v1_CurveOnRelatingElement, ::Ifc2x3::IfcCurveOrEdgeCurve* v2_CurveOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionCurveGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CurveOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConnectionGeometry


const IfcParse::entity& Ifc2x3::IfcConnectionGeometry::declaration() const { return *IFC2X3_IfcConnectionGeometry_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionGeometry::Class() { return *IFC2X3_IfcConnectionGeometry_type; }
Ifc2x3::IfcConnectionGeometry::IfcConnectionGeometry(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcConnectionGeometry_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionGeometry::IfcConnectionGeometry() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionGeometry_type);  }

// Function implementations for IfcConnectionPointEccentricity
boost::optional< double > Ifc2x3::IfcConnectionPointEccentricity::EccentricityInX() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcConnectionPointEccentricity::setEccentricityInX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcConnectionPointEccentricity::EccentricityInY() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcConnectionPointEccentricity::setEccentricityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcConnectionPointEccentricity::EccentricityInZ() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcConnectionPointEccentricity::setEccentricityInZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectionPointEccentricity::declaration() const { return *IFC2X3_IfcConnectionPointEccentricity_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionPointEccentricity::Class() { return *IFC2X3_IfcConnectionPointEccentricity_type; }
Ifc2x3::IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcEntityInstanceData* e) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectionPointEccentricity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(::Ifc2x3::IfcPointOrVertexPoint* v1_PointOnRelatingElement, ::Ifc2x3::IfcPointOrVertexPoint* v2_PointOnRelatedElement, boost::optional< double > v3_EccentricityInX, boost::optional< double > v4_EccentricityInY, boost::optional< double > v5_EccentricityInZ) : IfcConnectionPointGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionPointEccentricity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));data_->setArgument(1,attr);} if (v3_EccentricityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_EccentricityInX));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_EccentricityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EccentricityInY));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EccentricityInZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_EccentricityInZ));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcConnectionPointGeometry
::Ifc2x3::IfcPointOrVertexPoint* Ifc2x3::IfcConnectionPointGeometry::PointOnRelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcPointOrVertexPoint>(true); }
void Ifc2x3::IfcConnectionPointGeometry::setPointOnRelatingElement(::Ifc2x3::IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcPointOrVertexPoint* Ifc2x3::IfcConnectionPointGeometry::PointOnRelatedElement() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcPointOrVertexPoint>(true); }
void Ifc2x3::IfcConnectionPointGeometry::setPointOnRelatedElement(::Ifc2x3::IfcPointOrVertexPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectionPointGeometry::declaration() const { return *IFC2X3_IfcConnectionPointGeometry_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionPointGeometry::Class() { return *IFC2X3_IfcConnectionPointGeometry_type; }
Ifc2x3::IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectionPointGeometry_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionPointGeometry::IfcConnectionPointGeometry(::Ifc2x3::IfcPointOrVertexPoint* v1_PointOnRelatingElement, ::Ifc2x3::IfcPointOrVertexPoint* v2_PointOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionPointGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PointOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConnectionPortGeometry
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcConnectionPortGeometry::LocationAtRelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcConnectionPortGeometry::setLocationAtRelatingElement(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcConnectionPortGeometry::LocationAtRelatedElement() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcConnectionPortGeometry::setLocationAtRelatedElement(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcConnectionPortGeometry::ProfileOfPort() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcConnectionPortGeometry::setProfileOfPort(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectionPortGeometry::declaration() const { return *IFC2X3_IfcConnectionPortGeometry_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionPortGeometry::Class() { return *IFC2X3_IfcConnectionPortGeometry_type; }
Ifc2x3::IfcConnectionPortGeometry::IfcConnectionPortGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectionPortGeometry_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionPortGeometry::IfcConnectionPortGeometry(::Ifc2x3::IfcAxis2Placement* v1_LocationAtRelatingElement, ::Ifc2x3::IfcAxis2Placement* v2_LocationAtRelatedElement, ::Ifc2x3::IfcProfileDef* v3_ProfileOfPort) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionPortGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LocationAtRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LocationAtRelatedElement));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ProfileOfPort));data_->setArgument(2,attr);} }

// Function implementations for IfcConnectionSurfaceGeometry
::Ifc2x3::IfcSurfaceOrFaceSurface* Ifc2x3::IfcConnectionSurfaceGeometry::SurfaceOnRelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcSurfaceOrFaceSurface>(true); }
void Ifc2x3::IfcConnectionSurfaceGeometry::setSurfaceOnRelatingElement(::Ifc2x3::IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcSurfaceOrFaceSurface* Ifc2x3::IfcConnectionSurfaceGeometry::SurfaceOnRelatedElement() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcSurfaceOrFaceSurface>(true); }
void Ifc2x3::IfcConnectionSurfaceGeometry::setSurfaceOnRelatedElement(::Ifc2x3::IfcSurfaceOrFaceSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcConnectionSurfaceGeometry::declaration() const { return *IFC2X3_IfcConnectionSurfaceGeometry_type; }
const IfcParse::entity& Ifc2x3::IfcConnectionSurfaceGeometry::Class() { return *IFC2X3_IfcConnectionSurfaceGeometry_type; }
Ifc2x3::IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcEntityInstanceData* e) : IfcConnectionGeometry((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConnectionSurfaceGeometry_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(::Ifc2x3::IfcSurfaceOrFaceSurface* v1_SurfaceOnRelatingElement, ::Ifc2x3::IfcSurfaceOrFaceSurface* v2_SurfaceOnRelatedElement) : IfcConnectionGeometry((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConnectionSurfaceGeometry_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceOnRelatingElement));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SurfaceOnRelatedElement));data_->setArgument(1,attr);} }

// Function implementations for IfcConstraint
std::string Ifc2x3::IfcConstraint::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcConstraint::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstraint::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcConstraint::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcConstraintEnum::Value Ifc2x3::IfcConstraint::ConstraintGrade() const {  return ::Ifc2x3::IfcConstraintEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcConstraint::setConstraintGrade(::Ifc2x3::IfcConstraintEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcConstraintEnum::ToString(v)));data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstraint::ConstraintSource() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcConstraint::setConstraintSource(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcConstraint::CreatingActor() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcConstraint::setCreatingActor(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcConstraint::CreationTime() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcConstraint::setCreationTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstraint::UserDefinedGrade() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcConstraint::setUserDefinedGrade(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }

::Ifc2x3::IfcConstraintClassificationRelationship::list::ptr Ifc2x3::IfcConstraint::ClassifiedAs() const { return data_->getInverse(IFC2X3_IfcConstraintClassificationRelationship_type, 0)->as<IfcConstraintClassificationRelationship>(); }
::Ifc2x3::IfcConstraintRelationship::list::ptr Ifc2x3::IfcConstraint::RelatesConstraints() const { return data_->getInverse(IFC2X3_IfcConstraintRelationship_type, 2)->as<IfcConstraintRelationship>(); }
::Ifc2x3::IfcConstraintRelationship::list::ptr Ifc2x3::IfcConstraint::IsRelatedWith() const { return data_->getInverse(IFC2X3_IfcConstraintRelationship_type, 3)->as<IfcConstraintRelationship>(); }
::Ifc2x3::IfcPropertyConstraintRelationship::list::ptr Ifc2x3::IfcConstraint::PropertiesForConstraint() const { return data_->getInverse(IFC2X3_IfcPropertyConstraintRelationship_type, 0)->as<IfcPropertyConstraintRelationship>(); }
::Ifc2x3::IfcConstraintAggregationRelationship::list::ptr Ifc2x3::IfcConstraint::Aggregates() const { return data_->getInverse(IFC2X3_IfcConstraintAggregationRelationship_type, 2)->as<IfcConstraintAggregationRelationship>(); }
::Ifc2x3::IfcConstraintAggregationRelationship::list::ptr Ifc2x3::IfcConstraint::IsAggregatedIn() const { return data_->getInverse(IFC2X3_IfcConstraintAggregationRelationship_type, 3)->as<IfcConstraintAggregationRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcConstraint::declaration() const { return *IFC2X3_IfcConstraint_type; }
const IfcParse::entity& Ifc2x3::IfcConstraint::Class() { return *IFC2X3_IfcConstraint_type; }
Ifc2x3::IfcConstraint::IfcConstraint(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcConstraint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstraint::IfcConstraint(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcConstraintEnum::Value v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, ::Ifc2x3::IfcActorSelect* v5_CreatingActor, ::Ifc2x3::IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,::Ifc2x3::IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));data_->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcConstraintAggregationRelationship
boost::optional< std::string > Ifc2x3::IfcConstraintAggregationRelationship::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcConstraintAggregationRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstraintAggregationRelationship::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcConstraintAggregationRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcConstraint* Ifc2x3::IfcConstraintAggregationRelationship::RelatingConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcConstraint>(true); }
void Ifc2x3::IfcConstraintAggregationRelationship::setRelatingConstraint(::Ifc2x3::IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
aggregate_of< ::Ifc2x3::IfcConstraint >::ptr Ifc2x3::IfcConstraintAggregationRelationship::RelatedConstraints() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcConstraint >(); }
void Ifc2x3::IfcConstraintAggregationRelationship::setRelatedConstraints(aggregate_of< ::Ifc2x3::IfcConstraint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }
::Ifc2x3::IfcLogicalOperatorEnum::Value Ifc2x3::IfcConstraintAggregationRelationship::LogicalAggregator() const {  return ::Ifc2x3::IfcLogicalOperatorEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcConstraintAggregationRelationship::setLogicalAggregator(::Ifc2x3::IfcLogicalOperatorEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLogicalOperatorEnum::ToString(v)));data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcConstraintAggregationRelationship::declaration() const { return *IFC2X3_IfcConstraintAggregationRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcConstraintAggregationRelationship::Class() { return *IFC2X3_IfcConstraintAggregationRelationship_type; }
Ifc2x3::IfcConstraintAggregationRelationship::IfcConstraintAggregationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcConstraintAggregationRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstraintAggregationRelationship::IfcConstraintAggregationRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcConstraint* v3_RelatingConstraint, aggregate_of< ::Ifc2x3::IfcConstraint >::ptr v4_RelatedConstraints, ::Ifc2x3::IfcLogicalOperatorEnum::Value v5_LogicalAggregator) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraintAggregationRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingConstraint));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedConstraints)->generalize());data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_LogicalAggregator,::Ifc2x3::IfcLogicalOperatorEnum::ToString(v5_LogicalAggregator))));data_->setArgument(4,attr);} }

// Function implementations for IfcConstraintClassificationRelationship
::Ifc2x3::IfcConstraint* Ifc2x3::IfcConstraintClassificationRelationship::ClassifiedConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcConstraint>(true); }
void Ifc2x3::IfcConstraintClassificationRelationship::setClassifiedConstraint(::Ifc2x3::IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcConstraintClassificationRelationship::RelatedClassifications() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcConstraintClassificationRelationship::setRelatedClassifications(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcConstraintClassificationRelationship::declaration() const { return *IFC2X3_IfcConstraintClassificationRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcConstraintClassificationRelationship::Class() { return *IFC2X3_IfcConstraintClassificationRelationship_type; }
Ifc2x3::IfcConstraintClassificationRelationship::IfcConstraintClassificationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcConstraintClassificationRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstraintClassificationRelationship::IfcConstraintClassificationRelationship(::Ifc2x3::IfcConstraint* v1_ClassifiedConstraint, aggregate_of_instance::ptr v2_RelatedClassifications) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraintClassificationRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ClassifiedConstraint));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedClassifications));data_->setArgument(1,attr);} }

// Function implementations for IfcConstraintRelationship
boost::optional< std::string > Ifc2x3::IfcConstraintRelationship::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcConstraintRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstraintRelationship::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcConstraintRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcConstraint* Ifc2x3::IfcConstraintRelationship::RelatingConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcConstraint>(true); }
void Ifc2x3::IfcConstraintRelationship::setRelatingConstraint(::Ifc2x3::IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
aggregate_of< ::Ifc2x3::IfcConstraint >::ptr Ifc2x3::IfcConstraintRelationship::RelatedConstraints() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcConstraint >(); }
void Ifc2x3::IfcConstraintRelationship::setRelatedConstraints(aggregate_of< ::Ifc2x3::IfcConstraint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcConstraintRelationship::declaration() const { return *IFC2X3_IfcConstraintRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcConstraintRelationship::Class() { return *IFC2X3_IfcConstraintRelationship_type; }
Ifc2x3::IfcConstraintRelationship::IfcConstraintRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcConstraintRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstraintRelationship::IfcConstraintRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcConstraint* v3_RelatingConstraint, aggregate_of< ::Ifc2x3::IfcConstraint >::ptr v4_RelatedConstraints) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstraintRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingConstraint));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedConstraints)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcConstructionEquipmentResource


const IfcParse::entity& Ifc2x3::IfcConstructionEquipmentResource::declaration() const { return *IFC2X3_IfcConstructionEquipmentResource_type; }
const IfcParse::entity& Ifc2x3::IfcConstructionEquipmentResource::Class() { return *IFC2X3_IfcConstructionEquipmentResource_type; }
Ifc2x3::IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConstructionEquipmentResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstructionEquipmentResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} }

// Function implementations for IfcConstructionMaterialResource
boost::optional< aggregate_of_instance::ptr > Ifc2x3::IfcConstructionMaterialResource::Suppliers() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } aggregate_of_instance::ptr v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcConstructionMaterialResource::setSuppliers(boost::optional< aggregate_of_instance::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcConstructionMaterialResource::UsageRatio() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcConstructionMaterialResource::setUsageRatio(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcConstructionMaterialResource::declaration() const { return *IFC2X3_IfcConstructionMaterialResource_type; }
const IfcParse::entity& Ifc2x3::IfcConstructionMaterialResource::Class() { return *IFC2X3_IfcConstructionMaterialResource_type; }
Ifc2x3::IfcConstructionMaterialResource::IfcConstructionMaterialResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConstructionMaterialResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstructionMaterialResource::IfcConstructionMaterialResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< aggregate_of_instance::ptr > v10_Suppliers, boost::optional< double > v11_UsageRatio) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstructionMaterialResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} if (v10_Suppliers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Suppliers));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_UsageRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UsageRatio));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcConstructionProductResource


const IfcParse::entity& Ifc2x3::IfcConstructionProductResource::declaration() const { return *IFC2X3_IfcConstructionProductResource_type; }
const IfcParse::entity& Ifc2x3::IfcConstructionProductResource::Class() { return *IFC2X3_IfcConstructionProductResource_type; }
Ifc2x3::IfcConstructionProductResource::IfcConstructionProductResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConstructionProductResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstructionProductResource::IfcConstructionProductResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstructionProductResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} }

// Function implementations for IfcConstructionResource
boost::optional< std::string > Ifc2x3::IfcConstructionResource::ResourceIdentifier() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcConstructionResource::setResourceIdentifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcConstructionResource::ResourceGroup() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcConstructionResource::setResourceGroup(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > Ifc2x3::IfcConstructionResource::ResourceConsumption() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } return ::Ifc2x3::IfcResourceConsumptionEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcConstructionResource::setResourceConsumption(boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v)));}data_->setArgument(7,attr);} }
::Ifc2x3::IfcMeasureWithUnit* Ifc2x3::IfcConstructionResource::BaseQuantity() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcMeasureWithUnit>(true); }
void Ifc2x3::IfcConstructionResource::setBaseQuantity(::Ifc2x3::IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcConstructionResource::declaration() const { return *IFC2X3_IfcConstructionResource_type; }
const IfcParse::entity& Ifc2x3::IfcConstructionResource::Class() { return *IFC2X3_IfcConstructionResource_type; }
Ifc2x3::IfcConstructionResource::IfcConstructionResource(IfcEntityInstanceData* e) : IfcResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConstructionResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConstructionResource::IfcConstructionResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity) : IfcResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConstructionResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} }

// Function implementations for IfcContextDependentUnit
std::string Ifc2x3::IfcContextDependentUnit::Name() const {  std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcContextDependentUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcContextDependentUnit::declaration() const { return *IFC2X3_IfcContextDependentUnit_type; }
const IfcParse::entity& Ifc2x3::IfcContextDependentUnit::Class() { return *IFC2X3_IfcContextDependentUnit_type; }
Ifc2x3::IfcContextDependentUnit::IfcContextDependentUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcContextDependentUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcContextDependentUnit::IfcContextDependentUnit(::Ifc2x3::IfcDimensionalExponents* v1_Dimensions, ::Ifc2x3::IfcUnitEnum::Value v2_UnitType, std::string v3_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcContextDependentUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,::Ifc2x3::IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));data_->setArgument(2,attr);} }

// Function implementations for IfcControl

::Ifc2x3::IfcRelAssignsToControl::list::ptr Ifc2x3::IfcControl::Controls() const { return data_->getInverse(IFC2X3_IfcRelAssignsToControl_type, 6)->as<IfcRelAssignsToControl>(); }

const IfcParse::entity& Ifc2x3::IfcControl::declaration() const { return *IFC2X3_IfcControl_type; }
const IfcParse::entity& Ifc2x3::IfcControl::Class() { return *IFC2X3_IfcControl_type; }
Ifc2x3::IfcControl::IfcControl(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcControl_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcControl::IfcControl(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcControllerType
::Ifc2x3::IfcControllerTypeEnum::Value Ifc2x3::IfcControllerType::PredefinedType() const {  return ::Ifc2x3::IfcControllerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcControllerType::setPredefinedType(::Ifc2x3::IfcControllerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcControllerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcControllerType::declaration() const { return *IFC2X3_IfcControllerType_type; }
const IfcParse::entity& Ifc2x3::IfcControllerType::Class() { return *IFC2X3_IfcControllerType_type; }
Ifc2x3::IfcControllerType::IfcControllerType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcControllerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcControllerType::IfcControllerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcControllerTypeEnum::Value v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcControllerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcControllerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcConversionBasedUnit
std::string Ifc2x3::IfcConversionBasedUnit::Name() const {  std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcConversionBasedUnit::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcMeasureWithUnit* Ifc2x3::IfcConversionBasedUnit::ConversionFactor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcMeasureWithUnit>(true); }
void Ifc2x3::IfcConversionBasedUnit::setConversionFactor(::Ifc2x3::IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcConversionBasedUnit::declaration() const { return *IFC2X3_IfcConversionBasedUnit_type; }
const IfcParse::entity& Ifc2x3::IfcConversionBasedUnit::Class() { return *IFC2X3_IfcConversionBasedUnit_type; }
Ifc2x3::IfcConversionBasedUnit::IfcConversionBasedUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcConversionBasedUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcConversionBasedUnit::IfcConversionBasedUnit(::Ifc2x3::IfcDimensionalExponents* v1_Dimensions, ::Ifc2x3::IfcUnitEnum::Value v2_UnitType, std::string v3_Name, ::Ifc2x3::IfcMeasureWithUnit* v4_ConversionFactor) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcConversionBasedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,::Ifc2x3::IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Name));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ConversionFactor));data_->setArgument(3,attr);} }

// Function implementations for IfcCooledBeamType
::Ifc2x3::IfcCooledBeamTypeEnum::Value Ifc2x3::IfcCooledBeamType::PredefinedType() const {  return ::Ifc2x3::IfcCooledBeamTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCooledBeamType::setPredefinedType(::Ifc2x3::IfcCooledBeamTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCooledBeamTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCooledBeamType::declaration() const { return *IFC2X3_IfcCooledBeamType_type; }
const IfcParse::entity& Ifc2x3::IfcCooledBeamType::Class() { return *IFC2X3_IfcCooledBeamType_type; }
Ifc2x3::IfcCooledBeamType::IfcCooledBeamType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCooledBeamType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCooledBeamType::IfcCooledBeamType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCooledBeamTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCooledBeamType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCooledBeamTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCoolingTowerType
::Ifc2x3::IfcCoolingTowerTypeEnum::Value Ifc2x3::IfcCoolingTowerType::PredefinedType() const {  return ::Ifc2x3::IfcCoolingTowerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCoolingTowerType::setPredefinedType(::Ifc2x3::IfcCoolingTowerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCoolingTowerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCoolingTowerType::declaration() const { return *IFC2X3_IfcCoolingTowerType_type; }
const IfcParse::entity& Ifc2x3::IfcCoolingTowerType::Class() { return *IFC2X3_IfcCoolingTowerType_type; }
Ifc2x3::IfcCoolingTowerType::IfcCoolingTowerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCoolingTowerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCoolingTowerType::IfcCoolingTowerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCoolingTowerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCoolingTowerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCoolingTowerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCoordinatedUniversalTimeOffset
int Ifc2x3::IfcCoordinatedUniversalTimeOffset::HourOffset() const {  int v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCoordinatedUniversalTimeOffset::setHourOffset(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< int > Ifc2x3::IfcCoordinatedUniversalTimeOffset::MinuteOffset() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } int v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCoordinatedUniversalTimeOffset::setMinuteOffset(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcAheadOrBehind::Value Ifc2x3::IfcCoordinatedUniversalTimeOffset::Sense() const {  return ::Ifc2x3::IfcAheadOrBehind::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcCoordinatedUniversalTimeOffset::setSense(::Ifc2x3::IfcAheadOrBehind::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAheadOrBehind::ToString(v)));data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcCoordinatedUniversalTimeOffset::declaration() const { return *IFC2X3_IfcCoordinatedUniversalTimeOffset_type; }
const IfcParse::entity& Ifc2x3::IfcCoordinatedUniversalTimeOffset::Class() { return *IFC2X3_IfcCoordinatedUniversalTimeOffset_type; }
Ifc2x3::IfcCoordinatedUniversalTimeOffset::IfcCoordinatedUniversalTimeOffset(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCoordinatedUniversalTimeOffset_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCoordinatedUniversalTimeOffset::IfcCoordinatedUniversalTimeOffset(int v1_HourOffset, boost::optional< int > v2_MinuteOffset, ::Ifc2x3::IfcAheadOrBehind::Value v3_Sense) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCoordinatedUniversalTimeOffset_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HourOffset));data_->setArgument(0,attr);} if (v2_MinuteOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MinuteOffset));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Sense,::Ifc2x3::IfcAheadOrBehind::ToString(v3_Sense))));data_->setArgument(2,attr);} }

// Function implementations for IfcCostItem


const IfcParse::entity& Ifc2x3::IfcCostItem::declaration() const { return *IFC2X3_IfcCostItem_type; }
const IfcParse::entity& Ifc2x3::IfcCostItem::Class() { return *IFC2X3_IfcCostItem_type; }
Ifc2x3::IfcCostItem::IfcCostItem(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCostItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCostItem::IfcCostItem(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCostItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcCostSchedule
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcCostSchedule::SubmittedBy() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcCostSchedule::setSubmittedBy(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcCostSchedule::PreparedBy() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcCostSchedule::setPreparedBy(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcCostSchedule::SubmittedOn() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcCostSchedule::setSubmittedOn(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcCostSchedule::Status() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcCostSchedule::setStatus(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< aggregate_of_instance::ptr > Ifc2x3::IfcCostSchedule::TargetUsers() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } aggregate_of_instance::ptr v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcCostSchedule::setTargetUsers(boost::optional< aggregate_of_instance::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcCostSchedule::UpdateDate() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcCostSchedule::setUpdateDate(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
std::string Ifc2x3::IfcCostSchedule::ID() const {  std::string v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcCostSchedule::setID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
::Ifc2x3::IfcCostScheduleTypeEnum::Value Ifc2x3::IfcCostSchedule::PredefinedType() const {  return ::Ifc2x3::IfcCostScheduleTypeEnum::FromString(*data_->getArgument(12)); }
void Ifc2x3::IfcCostSchedule::setPredefinedType(::Ifc2x3::IfcCostScheduleTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCostScheduleTypeEnum::ToString(v)));data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcCostSchedule::declaration() const { return *IFC2X3_IfcCostSchedule_type; }
const IfcParse::entity& Ifc2x3::IfcCostSchedule::Class() { return *IFC2X3_IfcCostSchedule_type; }
Ifc2x3::IfcCostSchedule::IfcCostSchedule(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCostSchedule_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCostSchedule::IfcCostSchedule(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcActorSelect* v6_SubmittedBy, ::Ifc2x3::IfcActorSelect* v7_PreparedBy, ::Ifc2x3::IfcDateTimeSelect* v8_SubmittedOn, boost::optional< std::string > v9_Status, boost::optional< aggregate_of_instance::ptr > v10_TargetUsers, ::Ifc2x3::IfcDateTimeSelect* v11_UpdateDate, std::string v12_ID, ::Ifc2x3::IfcCostScheduleTypeEnum::Value v13_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCostSchedule_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_SubmittedBy));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_PreparedBy));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_SubmittedOn));data_->setArgument(7,attr);} if (v9_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Status));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_TargetUsers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TargetUsers));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_UpdateDate));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_ID));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v13_PredefinedType,::Ifc2x3::IfcCostScheduleTypeEnum::ToString(v13_PredefinedType))));data_->setArgument(12,attr);} }

// Function implementations for IfcCostValue
std::string Ifc2x3::IfcCostValue::CostType() const {  std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcCostValue::setCostType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcCostValue::Condition() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcCostValue::setCondition(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcCostValue::declaration() const { return *IFC2X3_IfcCostValue_type; }
const IfcParse::entity& Ifc2x3::IfcCostValue::Class() { return *IFC2X3_IfcCostValue_type; }
Ifc2x3::IfcCostValue::IfcCostValue(IfcEntityInstanceData* e) : IfcAppliedValue((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCostValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCostValue::IfcCostValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcAppliedValueSelect* v3_AppliedValue, ::Ifc2x3::IfcMeasureWithUnit* v4_UnitBasis, ::Ifc2x3::IfcDateTimeSelect* v5_ApplicableDate, ::Ifc2x3::IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_CostType, boost::optional< std::string > v8_Condition) : IfcAppliedValue((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCostValue_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CostType));data_->setArgument(6,attr);} if (v8_Condition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Condition));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcCovering
boost::optional< ::Ifc2x3::IfcCoveringTypeEnum::Value > Ifc2x3::IfcCovering::PredefinedType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcCoveringTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcCovering::setPredefinedType(boost::optional< ::Ifc2x3::IfcCoveringTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcCoveringTypeEnum::ToString(*v)));}data_->setArgument(8,attr);} }

::Ifc2x3::IfcRelCoversSpaces::list::ptr Ifc2x3::IfcCovering::CoversSpaces() const { return data_->getInverse(IFC2X3_IfcRelCoversSpaces_type, 5)->as<IfcRelCoversSpaces>(); }
::Ifc2x3::IfcRelCoversBldgElements::list::ptr Ifc2x3::IfcCovering::Covers() const { return data_->getInverse(IFC2X3_IfcRelCoversBldgElements_type, 5)->as<IfcRelCoversBldgElements>(); }

const IfcParse::entity& Ifc2x3::IfcCovering::declaration() const { return *IFC2X3_IfcCovering_type; }
const IfcParse::entity& Ifc2x3::IfcCovering::Class() { return *IFC2X3_IfcCovering_type; }
Ifc2x3::IfcCovering::IfcCovering(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCovering_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCovering::IfcCovering(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcCoveringTypeEnum::Value > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCovering_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,::Ifc2x3::IfcCoveringTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcCoveringType
::Ifc2x3::IfcCoveringTypeEnum::Value Ifc2x3::IfcCoveringType::PredefinedType() const {  return ::Ifc2x3::IfcCoveringTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCoveringType::setPredefinedType(::Ifc2x3::IfcCoveringTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCoveringTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCoveringType::declaration() const { return *IFC2X3_IfcCoveringType_type; }
const IfcParse::entity& Ifc2x3::IfcCoveringType::Class() { return *IFC2X3_IfcCoveringType_type; }
Ifc2x3::IfcCoveringType::IfcCoveringType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCoveringType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCoveringType::IfcCoveringType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCoveringTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCoveringType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCoveringTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCraneRailAShapeProfileDef
double Ifc2x3::IfcCraneRailAShapeProfileDef::OverallHeight() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::BaseWidth2() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setBaseWidth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcCraneRailAShapeProfileDef::Radius() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::HeadWidth() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setHeadWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::HeadDepth2() const {  double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setHeadDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::HeadDepth3() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setHeadDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::BaseWidth4() const {  double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setBaseWidth4(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::BaseDepth1() const {  double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setBaseDepth1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::BaseDepth2() const {  double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setBaseDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
double Ifc2x3::IfcCraneRailAShapeProfileDef::BaseDepth3() const {  double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setBaseDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
boost::optional< double > Ifc2x3::IfcCraneRailAShapeProfileDef::CentreOfGravityInY() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return boost::none; } double v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcCraneRailAShapeProfileDef::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(14,attr);} }


const IfcParse::entity& Ifc2x3::IfcCraneRailAShapeProfileDef::declaration() const { return *IFC2X3_IfcCraneRailAShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCraneRailAShapeProfileDef::Class() { return *IFC2X3_IfcCraneRailAShapeProfileDef_type; }
Ifc2x3::IfcCraneRailAShapeProfileDef::IfcCraneRailAShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCraneRailAShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCraneRailAShapeProfileDef::IfcCraneRailAShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_BaseWidth2, boost::optional< double > v6_Radius, double v7_HeadWidth, double v8_HeadDepth2, double v9_HeadDepth3, double v10_WebThickness, double v11_BaseWidth4, double v12_BaseDepth1, double v13_BaseDepth2, double v14_BaseDepth3, boost::optional< double > v15_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCraneRailAShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallHeight));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_BaseWidth2));data_->setArgument(4,attr);} if (v6_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Radius));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_HeadWidth));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_HeadDepth2));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_HeadDepth3));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_WebThickness));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseWidth4));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_BaseDepth1));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_BaseDepth2));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_BaseDepth3));data_->setArgument(13,attr);} if (v15_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_CentreOfGravityInY));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } }

// Function implementations for IfcCraneRailFShapeProfileDef
double Ifc2x3::IfcCraneRailFShapeProfileDef::OverallHeight() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setOverallHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::HeadWidth() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setHeadWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcCraneRailFShapeProfileDef::Radius() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::HeadDepth2() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setHeadDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::HeadDepth3() const {  double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setHeadDepth3(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::BaseDepth1() const {  double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setBaseDepth1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
double Ifc2x3::IfcCraneRailFShapeProfileDef::BaseDepth2() const {  double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setBaseDepth2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcCraneRailFShapeProfileDef::CentreOfGravityInY() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcCraneRailFShapeProfileDef::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcCraneRailFShapeProfileDef::declaration() const { return *IFC2X3_IfcCraneRailFShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcCraneRailFShapeProfileDef::Class() { return *IFC2X3_IfcCraneRailFShapeProfileDef_type; }
Ifc2x3::IfcCraneRailFShapeProfileDef::IfcCraneRailFShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCraneRailFShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCraneRailFShapeProfileDef::IfcCraneRailFShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_HeadWidth, boost::optional< double > v6_Radius, double v7_HeadDepth2, double v8_HeadDepth3, double v9_WebThickness, double v10_BaseDepth1, double v11_BaseDepth2, boost::optional< double > v12_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCraneRailFShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallHeight));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HeadWidth));data_->setArgument(4,attr);} if (v6_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Radius));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_HeadDepth2));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_HeadDepth3));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_WebThickness));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_BaseDepth1));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_BaseDepth2));data_->setArgument(10,attr);} if (v12_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_CentreOfGravityInY));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcCrewResource


const IfcParse::entity& Ifc2x3::IfcCrewResource::declaration() const { return *IFC2X3_IfcCrewResource_type; }
const IfcParse::entity& Ifc2x3::IfcCrewResource::Class() { return *IFC2X3_IfcCrewResource_type; }
Ifc2x3::IfcCrewResource::IfcCrewResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCrewResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCrewResource::IfcCrewResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCrewResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} }

// Function implementations for IfcCsgPrimitive3D
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcCsgPrimitive3D::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcCsgPrimitive3D::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcCsgPrimitive3D::declaration() const { return *IFC2X3_IfcCsgPrimitive3D_type; }
const IfcParse::entity& Ifc2x3::IfcCsgPrimitive3D::Class() { return *IFC2X3_IfcCsgPrimitive3D_type; }
Ifc2x3::IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCsgPrimitive3D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCsgPrimitive3D::IfcCsgPrimitive3D(::Ifc2x3::IfcAxis2Placement3D* v1_Position) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCsgPrimitive3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcCsgSolid
::Ifc2x3::IfcCsgSelect* Ifc2x3::IfcCsgSolid::TreeRootExpression() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCsgSelect>(true); }
void Ifc2x3::IfcCsgSolid::setTreeRootExpression(::Ifc2x3::IfcCsgSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcCsgSolid::declaration() const { return *IFC2X3_IfcCsgSolid_type; }
const IfcParse::entity& Ifc2x3::IfcCsgSolid::Class() { return *IFC2X3_IfcCsgSolid_type; }
Ifc2x3::IfcCsgSolid::IfcCsgSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCsgSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCsgSolid::IfcCsgSolid(::Ifc2x3::IfcCsgSelect* v1_TreeRootExpression) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCsgSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TreeRootExpression));data_->setArgument(0,attr);} }

// Function implementations for IfcCurrencyRelationship
::Ifc2x3::IfcMonetaryUnit* Ifc2x3::IfcCurrencyRelationship::RelatingMonetaryUnit() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcMonetaryUnit>(true); }
void Ifc2x3::IfcCurrencyRelationship::setRelatingMonetaryUnit(::Ifc2x3::IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcMonetaryUnit* Ifc2x3::IfcCurrencyRelationship::RelatedMonetaryUnit() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcMonetaryUnit>(true); }
void Ifc2x3::IfcCurrencyRelationship::setRelatedMonetaryUnit(::Ifc2x3::IfcMonetaryUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcCurrencyRelationship::ExchangeRate() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcCurrencyRelationship::setExchangeRate(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcDateAndTime* Ifc2x3::IfcCurrencyRelationship::RateDateTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcDateAndTime>(true); }
void Ifc2x3::IfcCurrencyRelationship::setRateDateTime(::Ifc2x3::IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcLibraryInformation* Ifc2x3::IfcCurrencyRelationship::RateSource() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcLibraryInformation>(true); }
void Ifc2x3::IfcCurrencyRelationship::setRateSource(::Ifc2x3::IfcLibraryInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurrencyRelationship::declaration() const { return *IFC2X3_IfcCurrencyRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcCurrencyRelationship::Class() { return *IFC2X3_IfcCurrencyRelationship_type; }
Ifc2x3::IfcCurrencyRelationship::IfcCurrencyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCurrencyRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurrencyRelationship::IfcCurrencyRelationship(::Ifc2x3::IfcMonetaryUnit* v1_RelatingMonetaryUnit, ::Ifc2x3::IfcMonetaryUnit* v2_RelatedMonetaryUnit, double v3_ExchangeRate, ::Ifc2x3::IfcDateAndTime* v4_RateDateTime, ::Ifc2x3::IfcLibraryInformation* v5_RateSource) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurrencyRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingMonetaryUnit));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedMonetaryUnit));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExchangeRate));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RateDateTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RateSource));data_->setArgument(4,attr);} }

// Function implementations for IfcCurtainWall


const IfcParse::entity& Ifc2x3::IfcCurtainWall::declaration() const { return *IFC2X3_IfcCurtainWall_type; }
const IfcParse::entity& Ifc2x3::IfcCurtainWall::Class() { return *IFC2X3_IfcCurtainWall_type; }
Ifc2x3::IfcCurtainWall::IfcCurtainWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCurtainWall_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurtainWall::IfcCurtainWall(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurtainWall_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcCurtainWallType
::Ifc2x3::IfcCurtainWallTypeEnum::Value Ifc2x3::IfcCurtainWallType::PredefinedType() const {  return ::Ifc2x3::IfcCurtainWallTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcCurtainWallType::setPredefinedType(::Ifc2x3::IfcCurtainWallTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCurtainWallTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurtainWallType::declaration() const { return *IFC2X3_IfcCurtainWallType_type; }
const IfcParse::entity& Ifc2x3::IfcCurtainWallType::Class() { return *IFC2X3_IfcCurtainWallType_type; }
Ifc2x3::IfcCurtainWallType::IfcCurtainWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCurtainWallType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurtainWallType::IfcCurtainWallType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcCurtainWallTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurtainWallType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcCurtainWallTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcCurve


const IfcParse::entity& Ifc2x3::IfcCurve::declaration() const { return *IFC2X3_IfcCurve_type; }
const IfcParse::entity& Ifc2x3::IfcCurve::Class() { return *IFC2X3_IfcCurve_type; }
Ifc2x3::IfcCurve::IfcCurve(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurve::IfcCurve() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurve_type);  }

// Function implementations for IfcCurveBoundedPlane
::Ifc2x3::IfcPlane* Ifc2x3::IfcCurveBoundedPlane::BasisSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcPlane>(true); }
void Ifc2x3::IfcCurveBoundedPlane::setBasisSurface(::Ifc2x3::IfcPlane* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcCurve* Ifc2x3::IfcCurveBoundedPlane::OuterBoundary() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcCurveBoundedPlane::setOuterBoundary(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
aggregate_of< ::Ifc2x3::IfcCurve >::ptr Ifc2x3::IfcCurveBoundedPlane::InnerBoundaries() const {  aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcCurve >(); }
void Ifc2x3::IfcCurveBoundedPlane::setInnerBoundaries(aggregate_of< ::Ifc2x3::IfcCurve >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurveBoundedPlane::declaration() const { return *IFC2X3_IfcCurveBoundedPlane_type; }
const IfcParse::entity& Ifc2x3::IfcCurveBoundedPlane::Class() { return *IFC2X3_IfcCurveBoundedPlane_type; }
Ifc2x3::IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCurveBoundedPlane_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurveBoundedPlane::IfcCurveBoundedPlane(::Ifc2x3::IfcPlane* v1_BasisSurface, ::Ifc2x3::IfcCurve* v2_OuterBoundary, aggregate_of< ::Ifc2x3::IfcCurve >::ptr v3_InnerBoundaries) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurveBoundedPlane_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OuterBoundary));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_InnerBoundaries)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcCurveStyle
::Ifc2x3::IfcCurveFontOrScaledCurveFontSelect* Ifc2x3::IfcCurveStyle::CurveFont() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCurveFontOrScaledCurveFontSelect>(true); }
void Ifc2x3::IfcCurveStyle::setCurveFont(::Ifc2x3::IfcCurveFontOrScaledCurveFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcCurveStyle::CurveWidth() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcCurveStyle::setCurveWidth(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcColour* Ifc2x3::IfcCurveStyle::CurveColour() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcColour>(true); }
void Ifc2x3::IfcCurveStyle::setCurveColour(::Ifc2x3::IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurveStyle::declaration() const { return *IFC2X3_IfcCurveStyle_type; }
const IfcParse::entity& Ifc2x3::IfcCurveStyle::Class() { return *IFC2X3_IfcCurveStyle_type; }
Ifc2x3::IfcCurveStyle::IfcCurveStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcCurveStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurveStyle::IfcCurveStyle(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcCurveFontOrScaledCurveFontSelect* v2_CurveFont, ::Ifc2x3::IfcSizeSelect* v3_CurveWidth, ::Ifc2x3::IfcColour* v4_CurveColour) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurveStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveWidth));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CurveColour));data_->setArgument(3,attr);} }

// Function implementations for IfcCurveStyleFont
boost::optional< std::string > Ifc2x3::IfcCurveStyleFont::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCurveStyleFont::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcCurveStyleFontPattern >::ptr Ifc2x3::IfcCurveStyleFont::PatternList() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcCurveStyleFontPattern >(); }
void Ifc2x3::IfcCurveStyleFont::setPatternList(aggregate_of< ::Ifc2x3::IfcCurveStyleFontPattern >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurveStyleFont::declaration() const { return *IFC2X3_IfcCurveStyleFont_type; }
const IfcParse::entity& Ifc2x3::IfcCurveStyleFont::Class() { return *IFC2X3_IfcCurveStyleFont_type; }
Ifc2x3::IfcCurveStyleFont::IfcCurveStyleFont(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCurveStyleFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurveStyleFont::IfcCurveStyleFont(boost::optional< std::string > v1_Name, aggregate_of< ::Ifc2x3::IfcCurveStyleFontPattern >::ptr v2_PatternList) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurveStyleFont_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PatternList)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcCurveStyleFontAndScaling
boost::optional< std::string > Ifc2x3::IfcCurveStyleFontAndScaling::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCurveStyleFontAndScaling::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
::Ifc2x3::IfcCurveStyleFontSelect* Ifc2x3::IfcCurveStyleFontAndScaling::CurveFont() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCurveStyleFontSelect>(true); }
void Ifc2x3::IfcCurveStyleFontAndScaling::setCurveFont(::Ifc2x3::IfcCurveStyleFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcCurveStyleFontAndScaling::CurveFontScaling() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcCurveStyleFontAndScaling::setCurveFontScaling(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurveStyleFontAndScaling::declaration() const { return *IFC2X3_IfcCurveStyleFontAndScaling_type; }
const IfcParse::entity& Ifc2x3::IfcCurveStyleFontAndScaling::Class() { return *IFC2X3_IfcCurveStyleFontAndScaling_type; }
Ifc2x3::IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCurveStyleFontAndScaling_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcCurveStyleFontSelect* v2_CurveFont, double v3_CurveFontScaling) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurveStyleFontAndScaling_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CurveFont));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CurveFontScaling));data_->setArgument(2,attr);} }

// Function implementations for IfcCurveStyleFontPattern
double Ifc2x3::IfcCurveStyleFontPattern::VisibleSegmentLength() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcCurveStyleFontPattern::setVisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcCurveStyleFontPattern::InvisibleSegmentLength() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcCurveStyleFontPattern::setInvisibleSegmentLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcCurveStyleFontPattern::declaration() const { return *IFC2X3_IfcCurveStyleFontPattern_type; }
const IfcParse::entity& Ifc2x3::IfcCurveStyleFontPattern::Class() { return *IFC2X3_IfcCurveStyleFontPattern_type; }
Ifc2x3::IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcCurveStyleFontPattern_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(double v1_VisibleSegmentLength, double v2_InvisibleSegmentLength) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcCurveStyleFontPattern_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VisibleSegmentLength));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_InvisibleSegmentLength));data_->setArgument(1,attr);} }

// Function implementations for IfcDamperType
::Ifc2x3::IfcDamperTypeEnum::Value Ifc2x3::IfcDamperType::PredefinedType() const {  return ::Ifc2x3::IfcDamperTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDamperType::setPredefinedType(::Ifc2x3::IfcDamperTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDamperTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDamperType::declaration() const { return *IFC2X3_IfcDamperType_type; }
const IfcParse::entity& Ifc2x3::IfcDamperType::Class() { return *IFC2X3_IfcDamperType_type; }
Ifc2x3::IfcDamperType::IfcDamperType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDamperType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDamperType::IfcDamperType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcDamperTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDamperType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcDamperTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDateAndTime
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcDateAndTime::DateComponent() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcDateAndTime::setDateComponent(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcLocalTime* Ifc2x3::IfcDateAndTime::TimeComponent() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcLocalTime>(true); }
void Ifc2x3::IfcDateAndTime::setTimeComponent(::Ifc2x3::IfcLocalTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcDateAndTime::declaration() const { return *IFC2X3_IfcDateAndTime_type; }
const IfcParse::entity& Ifc2x3::IfcDateAndTime::Class() { return *IFC2X3_IfcDateAndTime_type; }
Ifc2x3::IfcDateAndTime::IfcDateAndTime(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDateAndTime_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDateAndTime::IfcDateAndTime(::Ifc2x3::IfcCalendarDate* v1_DateComponent, ::Ifc2x3::IfcLocalTime* v2_TimeComponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDateAndTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DateComponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TimeComponent));data_->setArgument(1,attr);} }

// Function implementations for IfcDefinedSymbol
::Ifc2x3::IfcDefinedSymbolSelect* Ifc2x3::IfcDefinedSymbol::Definition() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDefinedSymbolSelect>(true); }
void Ifc2x3::IfcDefinedSymbol::setDefinition(::Ifc2x3::IfcDefinedSymbolSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcCartesianTransformationOperator2D* Ifc2x3::IfcDefinedSymbol::Target() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCartesianTransformationOperator2D>(true); }
void Ifc2x3::IfcDefinedSymbol::setTarget(::Ifc2x3::IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcDefinedSymbol::declaration() const { return *IFC2X3_IfcDefinedSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcDefinedSymbol::Class() { return *IFC2X3_IfcDefinedSymbol_type; }
Ifc2x3::IfcDefinedSymbol::IfcDefinedSymbol(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDefinedSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDefinedSymbol::IfcDefinedSymbol(::Ifc2x3::IfcDefinedSymbolSelect* v1_Definition, ::Ifc2x3::IfcCartesianTransformationOperator2D* v2_Target) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDefinedSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Definition));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Target));data_->setArgument(1,attr);} }

// Function implementations for IfcDerivedProfileDef
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcDerivedProfileDef::ParentProfile() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcDerivedProfileDef::setParentProfile(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcCartesianTransformationOperator2D* Ifc2x3::IfcDerivedProfileDef::Operator() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcCartesianTransformationOperator2D>(true); }
void Ifc2x3::IfcDerivedProfileDef::setOperator(::Ifc2x3::IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcDerivedProfileDef::Label() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcDerivedProfileDef::setLabel(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcDerivedProfileDef::declaration() const { return *IFC2X3_IfcDerivedProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcDerivedProfileDef::Class() { return *IFC2X3_IfcDerivedProfileDef_type; }
Ifc2x3::IfcDerivedProfileDef::IfcDerivedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDerivedProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDerivedProfileDef::IfcDerivedProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcProfileDef* v3_ParentProfile, ::Ifc2x3::IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< std::string > v5_Label) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDerivedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentProfile));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Operator));data_->setArgument(3,attr);} if (v5_Label) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Label));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcDerivedUnit
aggregate_of< ::Ifc2x3::IfcDerivedUnitElement >::ptr Ifc2x3::IfcDerivedUnit::Elements() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcDerivedUnitElement >(); }
void Ifc2x3::IfcDerivedUnit::setElements(aggregate_of< ::Ifc2x3::IfcDerivedUnitElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
::Ifc2x3::IfcDerivedUnitEnum::Value Ifc2x3::IfcDerivedUnit::UnitType() const {  return ::Ifc2x3::IfcDerivedUnitEnum::FromString(*data_->getArgument(1)); }
void Ifc2x3::IfcDerivedUnit::setUnitType(::Ifc2x3::IfcDerivedUnitEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDerivedUnitEnum::ToString(v)));data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcDerivedUnit::UserDefinedType() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcDerivedUnit::setUserDefinedType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcDerivedUnit::declaration() const { return *IFC2X3_IfcDerivedUnit_type; }
const IfcParse::entity& Ifc2x3::IfcDerivedUnit::Class() { return *IFC2X3_IfcDerivedUnit_type; }
Ifc2x3::IfcDerivedUnit::IfcDerivedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDerivedUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDerivedUnit::IfcDerivedUnit(aggregate_of< ::Ifc2x3::IfcDerivedUnitElement >::ptr v1_Elements, ::Ifc2x3::IfcDerivedUnitEnum::Value v2_UnitType, boost::optional< std::string > v3_UserDefinedType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDerivedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,::Ifc2x3::IfcDerivedUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} if (v3_UserDefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDerivedUnitElement
::Ifc2x3::IfcNamedUnit* Ifc2x3::IfcDerivedUnitElement::Unit() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcNamedUnit>(true); }
void Ifc2x3::IfcDerivedUnitElement::setUnit(::Ifc2x3::IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int Ifc2x3::IfcDerivedUnitElement::Exponent() const {  int v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcDerivedUnitElement::setExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcDerivedUnitElement::declaration() const { return *IFC2X3_IfcDerivedUnitElement_type; }
const IfcParse::entity& Ifc2x3::IfcDerivedUnitElement::Class() { return *IFC2X3_IfcDerivedUnitElement_type; }
Ifc2x3::IfcDerivedUnitElement::IfcDerivedUnitElement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDerivedUnitElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDerivedUnitElement::IfcDerivedUnitElement(::Ifc2x3::IfcNamedUnit* v1_Unit, int v2_Exponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDerivedUnitElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Unit));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Exponent));data_->setArgument(1,attr);} }

// Function implementations for IfcDiameterDimension


const IfcParse::entity& Ifc2x3::IfcDiameterDimension::declaration() const { return *IFC2X3_IfcDiameterDimension_type; }
const IfcParse::entity& Ifc2x3::IfcDiameterDimension::Class() { return *IFC2X3_IfcDiameterDimension_type; }
Ifc2x3::IfcDiameterDimension::IfcDiameterDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDiameterDimension_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDiameterDimension::IfcDiameterDimension(aggregate_of_instance::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDiameterDimension_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcDimensionCalloutRelationship


const IfcParse::entity& Ifc2x3::IfcDimensionCalloutRelationship::declaration() const { return *IFC2X3_IfcDimensionCalloutRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionCalloutRelationship::Class() { return *IFC2X3_IfcDimensionCalloutRelationship_type; }
Ifc2x3::IfcDimensionCalloutRelationship::IfcDimensionCalloutRelationship(IfcEntityInstanceData* e) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDimensionCalloutRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionCalloutRelationship::IfcDimensionCalloutRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDraughtingCallout* v3_RelatingDraughtingCallout, ::Ifc2x3::IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionCalloutRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));data_->setArgument(3,attr);} }

// Function implementations for IfcDimensionCurve

::Ifc2x3::IfcTerminatorSymbol::list::ptr Ifc2x3::IfcDimensionCurve::AnnotatedBySymbols() const { return data_->getInverse(IFC2X3_IfcTerminatorSymbol_type, 3)->as<IfcTerminatorSymbol>(); }

const IfcParse::entity& Ifc2x3::IfcDimensionCurve::declaration() const { return *IFC2X3_IfcDimensionCurve_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionCurve::Class() { return *IFC2X3_IfcDimensionCurve_type; }
Ifc2x3::IfcDimensionCurve::IfcDimensionCurve(IfcEntityInstanceData* e) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDimensionCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionCurve::IfcDimensionCurve(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDimensionCurveDirectedCallout


const IfcParse::entity& Ifc2x3::IfcDimensionCurveDirectedCallout::declaration() const { return *IFC2X3_IfcDimensionCurveDirectedCallout_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionCurveDirectedCallout::Class() { return *IFC2X3_IfcDimensionCurveDirectedCallout_type; }
Ifc2x3::IfcDimensionCurveDirectedCallout::IfcDimensionCurveDirectedCallout(IfcEntityInstanceData* e) : IfcDraughtingCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDimensionCurveDirectedCallout_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionCurveDirectedCallout::IfcDimensionCurveDirectedCallout(aggregate_of_instance::ptr v1_Contents) : IfcDraughtingCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionCurveDirectedCallout_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcDimensionCurveTerminator
::Ifc2x3::IfcDimensionExtentUsage::Value Ifc2x3::IfcDimensionCurveTerminator::Role() const {  return ::Ifc2x3::IfcDimensionExtentUsage::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcDimensionCurveTerminator::setRole(::Ifc2x3::IfcDimensionExtentUsage::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDimensionExtentUsage::ToString(v)));data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcDimensionCurveTerminator::declaration() const { return *IFC2X3_IfcDimensionCurveTerminator_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionCurveTerminator::Class() { return *IFC2X3_IfcDimensionCurveTerminator_type; }
Ifc2x3::IfcDimensionCurveTerminator::IfcDimensionCurveTerminator(IfcEntityInstanceData* e) : IfcTerminatorSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDimensionCurveTerminator_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionCurveTerminator::IfcDimensionCurveTerminator(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, ::Ifc2x3::IfcAnnotationCurveOccurrence* v4_AnnotatedCurve, ::Ifc2x3::IfcDimensionExtentUsage::Value v5_Role) : IfcTerminatorSymbol((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionCurveTerminator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AnnotatedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_Role,::Ifc2x3::IfcDimensionExtentUsage::ToString(v5_Role))));data_->setArgument(4,attr);} }

// Function implementations for IfcDimensionPair


const IfcParse::entity& Ifc2x3::IfcDimensionPair::declaration() const { return *IFC2X3_IfcDimensionPair_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionPair::Class() { return *IFC2X3_IfcDimensionPair_type; }
Ifc2x3::IfcDimensionPair::IfcDimensionPair(IfcEntityInstanceData* e) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDimensionPair_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionPair::IfcDimensionPair(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDraughtingCallout* v3_RelatingDraughtingCallout, ::Ifc2x3::IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcDraughtingCalloutRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionPair_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));data_->setArgument(3,attr);} }

// Function implementations for IfcDimensionalExponents
int Ifc2x3::IfcDimensionalExponents::LengthExponent() const {  int v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDimensionalExponents::setLengthExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
int Ifc2x3::IfcDimensionalExponents::MassExponent() const {  int v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcDimensionalExponents::setMassExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
int Ifc2x3::IfcDimensionalExponents::TimeExponent() const {  int v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcDimensionalExponents::setTimeExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
int Ifc2x3::IfcDimensionalExponents::ElectricCurrentExponent() const {  int v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcDimensionalExponents::setElectricCurrentExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
int Ifc2x3::IfcDimensionalExponents::ThermodynamicTemperatureExponent() const {  int v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcDimensionalExponents::setThermodynamicTemperatureExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
int Ifc2x3::IfcDimensionalExponents::AmountOfSubstanceExponent() const {  int v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcDimensionalExponents::setAmountOfSubstanceExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
int Ifc2x3::IfcDimensionalExponents::LuminousIntensityExponent() const {  int v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcDimensionalExponents::setLuminousIntensityExponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcDimensionalExponents::declaration() const { return *IFC2X3_IfcDimensionalExponents_type; }
const IfcParse::entity& Ifc2x3::IfcDimensionalExponents::Class() { return *IFC2X3_IfcDimensionalExponents_type; }
Ifc2x3::IfcDimensionalExponents::IfcDimensionalExponents(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDimensionalExponents_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDimensionalExponents::IfcDimensionalExponents(int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDimensionalExponents_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LengthExponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MassExponent));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TimeExponent));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ElectricCurrentExponent));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ThermodynamicTemperatureExponent));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_AmountOfSubstanceExponent));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LuminousIntensityExponent));data_->setArgument(6,attr);} }

// Function implementations for IfcDirection
std::vector< double > /*[2:3]*/ Ifc2x3::IfcDirection::DirectionRatios() const {  std::vector< double > /*[2:3]*/ v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDirection::setDirectionRatios(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcDirection::declaration() const { return *IFC2X3_IfcDirection_type; }
const IfcParse::entity& Ifc2x3::IfcDirection::Class() { return *IFC2X3_IfcDirection_type; }
Ifc2x3::IfcDirection::IfcDirection(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDirection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDirection::IfcDirection(std::vector< double > /*[2:3]*/ v1_DirectionRatios) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDirection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DirectionRatios));data_->setArgument(0,attr);} }

// Function implementations for IfcDiscreteAccessory


const IfcParse::entity& Ifc2x3::IfcDiscreteAccessory::declaration() const { return *IFC2X3_IfcDiscreteAccessory_type; }
const IfcParse::entity& Ifc2x3::IfcDiscreteAccessory::Class() { return *IFC2X3_IfcDiscreteAccessory_type; }
Ifc2x3::IfcDiscreteAccessory::IfcDiscreteAccessory(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDiscreteAccessory_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDiscreteAccessory::IfcDiscreteAccessory(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDiscreteAccessory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDiscreteAccessoryType


const IfcParse::entity& Ifc2x3::IfcDiscreteAccessoryType::declaration() const { return *IFC2X3_IfcDiscreteAccessoryType_type; }
const IfcParse::entity& Ifc2x3::IfcDiscreteAccessoryType::Class() { return *IFC2X3_IfcDiscreteAccessoryType_type; }
Ifc2x3::IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDiscreteAccessoryType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDiscreteAccessoryType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionChamberElement


const IfcParse::entity& Ifc2x3::IfcDistributionChamberElement::declaration() const { return *IFC2X3_IfcDistributionChamberElement_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionChamberElement::Class() { return *IFC2X3_IfcDistributionChamberElement_type; }
Ifc2x3::IfcDistributionChamberElement::IfcDistributionChamberElement(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionChamberElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionChamberElement::IfcDistributionChamberElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionChamberElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionChamberElementType
::Ifc2x3::IfcDistributionChamberElementTypeEnum::Value Ifc2x3::IfcDistributionChamberElementType::PredefinedType() const {  return ::Ifc2x3::IfcDistributionChamberElementTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDistributionChamberElementType::setPredefinedType(::Ifc2x3::IfcDistributionChamberElementTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDistributionChamberElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDistributionChamberElementType::declaration() const { return *IFC2X3_IfcDistributionChamberElementType_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionChamberElementType::Class() { return *IFC2X3_IfcDistributionChamberElementType_type; }
Ifc2x3::IfcDistributionChamberElementType::IfcDistributionChamberElementType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionChamberElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionChamberElementType::IfcDistributionChamberElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcDistributionChamberElementTypeEnum::Value v10_PredefinedType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionChamberElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcDistributionChamberElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDistributionControlElement
boost::optional< std::string > Ifc2x3::IfcDistributionControlElement::ControlElementId() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcDistributionControlElement::setControlElementId(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }

::Ifc2x3::IfcRelFlowControlElements::list::ptr Ifc2x3::IfcDistributionControlElement::AssignedToFlowElement() const { return data_->getInverse(IFC2X3_IfcRelFlowControlElements_type, 4)->as<IfcRelFlowControlElements>(); }

const IfcParse::entity& Ifc2x3::IfcDistributionControlElement::declaration() const { return *IFC2X3_IfcDistributionControlElement_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionControlElement::Class() { return *IFC2X3_IfcDistributionControlElement_type; }
Ifc2x3::IfcDistributionControlElement::IfcDistributionControlElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionControlElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionControlElement::IfcDistributionControlElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ControlElementId) : IfcDistributionElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionControlElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ControlElementId) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ControlElementId));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionControlElementType


const IfcParse::entity& Ifc2x3::IfcDistributionControlElementType::declaration() const { return *IFC2X3_IfcDistributionControlElementType_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionControlElementType::Class() { return *IFC2X3_IfcDistributionControlElementType_type; }
Ifc2x3::IfcDistributionControlElementType::IfcDistributionControlElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionControlElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionControlElementType::IfcDistributionControlElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionControlElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionElement


const IfcParse::entity& Ifc2x3::IfcDistributionElement::declaration() const { return *IFC2X3_IfcDistributionElement_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionElement::Class() { return *IFC2X3_IfcDistributionElement_type; }
Ifc2x3::IfcDistributionElement::IfcDistributionElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionElement::IfcDistributionElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionElementType


const IfcParse::entity& Ifc2x3::IfcDistributionElementType::declaration() const { return *IFC2X3_IfcDistributionElementType_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionElementType::Class() { return *IFC2X3_IfcDistributionElementType_type; }
Ifc2x3::IfcDistributionElementType::IfcDistributionElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionElementType::IfcDistributionElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionFlowElement

::Ifc2x3::IfcRelFlowControlElements::list::ptr Ifc2x3::IfcDistributionFlowElement::HasControlElements() const { return data_->getInverse(IFC2X3_IfcRelFlowControlElements_type, 5)->as<IfcRelFlowControlElements>(); }

const IfcParse::entity& Ifc2x3::IfcDistributionFlowElement::declaration() const { return *IFC2X3_IfcDistributionFlowElement_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionFlowElement::Class() { return *IFC2X3_IfcDistributionFlowElement_type; }
Ifc2x3::IfcDistributionFlowElement::IfcDistributionFlowElement(IfcEntityInstanceData* e) : IfcDistributionElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionFlowElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionFlowElement::IfcDistributionFlowElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionFlowElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDistributionFlowElementType


const IfcParse::entity& Ifc2x3::IfcDistributionFlowElementType::declaration() const { return *IFC2X3_IfcDistributionFlowElementType_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionFlowElementType::Class() { return *IFC2X3_IfcDistributionFlowElementType_type; }
Ifc2x3::IfcDistributionFlowElementType::IfcDistributionFlowElementType(IfcEntityInstanceData* e) : IfcDistributionElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionFlowElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionFlowElementType::IfcDistributionFlowElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionFlowElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcDistributionPort
boost::optional< ::Ifc2x3::IfcFlowDirectionEnum::Value > Ifc2x3::IfcDistributionPort::FlowDirection() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } return ::Ifc2x3::IfcFlowDirectionEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcDistributionPort::setFlowDirection(boost::optional< ::Ifc2x3::IfcFlowDirectionEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcFlowDirectionEnum::ToString(*v)));}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcDistributionPort::declaration() const { return *IFC2X3_IfcDistributionPort_type; }
const IfcParse::entity& Ifc2x3::IfcDistributionPort::Class() { return *IFC2X3_IfcDistributionPort_type; }
Ifc2x3::IfcDistributionPort::IfcDistributionPort(IfcEntityInstanceData* e) : IfcPort((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDistributionPort_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDistributionPort::IfcDistributionPort(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< ::Ifc2x3::IfcFlowDirectionEnum::Value > v8_FlowDirection) : IfcPort((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDistributionPort_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_FlowDirection) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_FlowDirection,::Ifc2x3::IfcFlowDirectionEnum::ToString(*v8_FlowDirection))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcDocumentElectronicFormat
boost::optional< std::string > Ifc2x3::IfcDocumentElectronicFormat::FileExtension() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDocumentElectronicFormat::setFileExtension(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentElectronicFormat::MimeContentType() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcDocumentElectronicFormat::setMimeContentType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentElectronicFormat::MimeSubtype() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcDocumentElectronicFormat::setMimeSubtype(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcDocumentElectronicFormat::declaration() const { return *IFC2X3_IfcDocumentElectronicFormat_type; }
const IfcParse::entity& Ifc2x3::IfcDocumentElectronicFormat::Class() { return *IFC2X3_IfcDocumentElectronicFormat_type; }
Ifc2x3::IfcDocumentElectronicFormat::IfcDocumentElectronicFormat(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDocumentElectronicFormat_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDocumentElectronicFormat::IfcDocumentElectronicFormat(boost::optional< std::string > v1_FileExtension, boost::optional< std::string > v2_MimeContentType, boost::optional< std::string > v3_MimeSubtype) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentElectronicFormat_type);  if (v1_FileExtension) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_FileExtension));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_MimeContentType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MimeContentType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_MimeSubtype) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_MimeSubtype));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDocumentInformation
std::string Ifc2x3::IfcDocumentInformation::DocumentId() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDocumentInformation::setDocumentId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string Ifc2x3::IfcDocumentInformation::Name() const {  std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcDocumentInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformation::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcDocumentInformation::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcDocumentReference >::ptr > Ifc2x3::IfcDocumentInformation::DocumentReferences() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcDocumentReference >(); }
void Ifc2x3::IfcDocumentInformation::setDocumentReferences(boost::optional< aggregate_of< ::Ifc2x3::IfcDocumentReference >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformation::Purpose() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcDocumentInformation::setPurpose(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformation::IntendedUse() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcDocumentInformation::setIntendedUse(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformation::Scope() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcDocumentInformation::setScope(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformation::Revision() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcDocumentInformation::setRevision(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcDocumentInformation::DocumentOwner() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcDocumentInformation::setDocumentOwner(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
boost::optional< aggregate_of_instance::ptr > Ifc2x3::IfcDocumentInformation::Editors() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } aggregate_of_instance::ptr v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcDocumentInformation::setEditors(boost::optional< aggregate_of_instance::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
::Ifc2x3::IfcDateAndTime* Ifc2x3::IfcDocumentInformation::CreationTime() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcDateAndTime>(true); }
void Ifc2x3::IfcDocumentInformation::setCreationTime(::Ifc2x3::IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
::Ifc2x3::IfcDateAndTime* Ifc2x3::IfcDocumentInformation::LastRevisionTime() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcDateAndTime>(true); }
void Ifc2x3::IfcDocumentInformation::setLastRevisionTime(::Ifc2x3::IfcDateAndTime* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
::Ifc2x3::IfcDocumentElectronicFormat* Ifc2x3::IfcDocumentInformation::ElectronicFormat() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcDocumentElectronicFormat>(true); }
void Ifc2x3::IfcDocumentInformation::setElectronicFormat(::Ifc2x3::IfcDocumentElectronicFormat* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcDocumentInformation::ValidFrom() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(13)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcDocumentInformation::setValidFrom(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcDocumentInformation::ValidUntil() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(14)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcDocumentInformation::setValidUntil(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
boost::optional< ::Ifc2x3::IfcDocumentConfidentialityEnum::Value > Ifc2x3::IfcDocumentInformation::Confidentiality() const { if(!data_->getArgument(15) || data_->getArgument(15)->isNull()) { return boost::none; } return ::Ifc2x3::IfcDocumentConfidentialityEnum::FromString(*data_->getArgument(15)); }
void Ifc2x3::IfcDocumentInformation::setConfidentiality(boost::optional< ::Ifc2x3::IfcDocumentConfidentialityEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcDocumentConfidentialityEnum::ToString(*v)));}data_->setArgument(15,attr);} }
boost::optional< ::Ifc2x3::IfcDocumentStatusEnum::Value > Ifc2x3::IfcDocumentInformation::Status() const { if(!data_->getArgument(16) || data_->getArgument(16)->isNull()) { return boost::none; } return ::Ifc2x3::IfcDocumentStatusEnum::FromString(*data_->getArgument(16)); }
void Ifc2x3::IfcDocumentInformation::setStatus(boost::optional< ::Ifc2x3::IfcDocumentStatusEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcDocumentStatusEnum::ToString(*v)));}data_->setArgument(16,attr);} }

::Ifc2x3::IfcDocumentInformationRelationship::list::ptr Ifc2x3::IfcDocumentInformation::IsPointedTo() const { return data_->getInverse(IFC2X3_IfcDocumentInformationRelationship_type, 1)->as<IfcDocumentInformationRelationship>(); }
::Ifc2x3::IfcDocumentInformationRelationship::list::ptr Ifc2x3::IfcDocumentInformation::IsPointer() const { return data_->getInverse(IFC2X3_IfcDocumentInformationRelationship_type, 0)->as<IfcDocumentInformationRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcDocumentInformation::declaration() const { return *IFC2X3_IfcDocumentInformation_type; }
const IfcParse::entity& Ifc2x3::IfcDocumentInformation::Class() { return *IFC2X3_IfcDocumentInformation_type; }
Ifc2x3::IfcDocumentInformation::IfcDocumentInformation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDocumentInformation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDocumentInformation::IfcDocumentInformation(std::string v1_DocumentId, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< aggregate_of< ::Ifc2x3::IfcDocumentReference >::ptr > v4_DocumentReferences, boost::optional< std::string > v5_Purpose, boost::optional< std::string > v6_IntendedUse, boost::optional< std::string > v7_Scope, boost::optional< std::string > v8_Revision, ::Ifc2x3::IfcActorSelect* v9_DocumentOwner, boost::optional< aggregate_of_instance::ptr > v10_Editors, ::Ifc2x3::IfcDateAndTime* v11_CreationTime, ::Ifc2x3::IfcDateAndTime* v12_LastRevisionTime, ::Ifc2x3::IfcDocumentElectronicFormat* v13_ElectronicFormat, ::Ifc2x3::IfcCalendarDate* v14_ValidFrom, ::Ifc2x3::IfcCalendarDate* v15_ValidUntil, boost::optional< ::Ifc2x3::IfcDocumentConfidentialityEnum::Value > v16_Confidentiality, boost::optional< ::Ifc2x3::IfcDocumentStatusEnum::Value > v17_Status) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentInformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DocumentId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DocumentReferences) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DocumentReferences)->generalize());data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Purpose));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_IntendedUse) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_IntendedUse));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Scope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Scope));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Revision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Revision));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_DocumentOwner));data_->setArgument(8,attr);} if (v10_Editors) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Editors));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CreationTime));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LastRevisionTime));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ElectronicFormat));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_ValidFrom));data_->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_ValidUntil));data_->setArgument(14,attr);} if (v16_Confidentiality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v16_Confidentiality,::Ifc2x3::IfcDocumentConfidentialityEnum::ToString(*v16_Confidentiality))));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v17_Status,::Ifc2x3::IfcDocumentStatusEnum::ToString(*v17_Status))));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } }

// Function implementations for IfcDocumentInformationRelationship
::Ifc2x3::IfcDocumentInformation* Ifc2x3::IfcDocumentInformationRelationship::RelatingDocument() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDocumentInformation>(true); }
void Ifc2x3::IfcDocumentInformationRelationship::setRelatingDocument(::Ifc2x3::IfcDocumentInformation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcDocumentInformation >::ptr Ifc2x3::IfcDocumentInformationRelationship::RelatedDocuments() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcDocumentInformation >(); }
void Ifc2x3::IfcDocumentInformationRelationship::setRelatedDocuments(aggregate_of< ::Ifc2x3::IfcDocumentInformation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcDocumentInformationRelationship::RelationshipType() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcDocumentInformationRelationship::setRelationshipType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcDocumentInformationRelationship::declaration() const { return *IFC2X3_IfcDocumentInformationRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcDocumentInformationRelationship::Class() { return *IFC2X3_IfcDocumentInformationRelationship_type; }
Ifc2x3::IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDocumentInformationRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(::Ifc2x3::IfcDocumentInformation* v1_RelatingDocument, aggregate_of< ::Ifc2x3::IfcDocumentInformation >::ptr v2_RelatedDocuments, boost::optional< std::string > v3_RelationshipType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentInformationRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingDocument));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedDocuments)->generalize());data_->setArgument(1,attr);} if (v3_RelationshipType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RelationshipType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDocumentReference

::Ifc2x3::IfcDocumentInformation::list::ptr Ifc2x3::IfcDocumentReference::ReferenceToDocument() const { return data_->getInverse(IFC2X3_IfcDocumentInformation_type, 3)->as<IfcDocumentInformation>(); }

const IfcParse::entity& Ifc2x3::IfcDocumentReference::declaration() const { return *IFC2X3_IfcDocumentReference_type; }
const IfcParse::entity& Ifc2x3::IfcDocumentReference::Class() { return *IFC2X3_IfcDocumentReference_type; }
Ifc2x3::IfcDocumentReference::IfcDocumentReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDocumentReference_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDocumentReference::IfcDocumentReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDocumentReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcDoor
boost::optional< double > Ifc2x3::IfcDoor::OverallHeight() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcDoor::setOverallHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcDoor::OverallWidth() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcDoor::setOverallWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDoor::declaration() const { return *IFC2X3_IfcDoor_type; }
const IfcParse::entity& Ifc2x3::IfcDoor::Class() { return *IFC2X3_IfcDoor_type; }
Ifc2x3::IfcDoor::IfcDoor(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDoor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDoor::IfcDoor(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDoor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcDoorLiningProperties
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::LiningDepth() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcDoorLiningProperties::setLiningDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::LiningThickness() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcDoorLiningProperties::setLiningThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::ThresholdDepth() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcDoorLiningProperties::setThresholdDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::ThresholdThickness() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcDoorLiningProperties::setThresholdThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::TransomThickness() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcDoorLiningProperties::setTransomThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::TransomOffset() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcDoorLiningProperties::setTransomOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::LiningOffset() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcDoorLiningProperties::setLiningOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::ThresholdOffset() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcDoorLiningProperties::setThresholdOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::CasingThickness() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcDoorLiningProperties::setCasingThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
boost::optional< double > Ifc2x3::IfcDoorLiningProperties::CasingDepth() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcDoorLiningProperties::setCasingDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(13,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcDoorLiningProperties::ShapeAspectStyle() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(14)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcDoorLiningProperties::setShapeAspectStyle(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }


const IfcParse::entity& Ifc2x3::IfcDoorLiningProperties::declaration() const { return *IFC2X3_IfcDoorLiningProperties_type; }
const IfcParse::entity& Ifc2x3::IfcDoorLiningProperties::Class() { return *IFC2X3_IfcDoorLiningProperties_type; }
Ifc2x3::IfcDoorLiningProperties::IfcDoorLiningProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDoorLiningProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDoorLiningProperties::IfcDoorLiningProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_ThresholdDepth, boost::optional< double > v8_ThresholdThickness, boost::optional< double > v9_TransomThickness, boost::optional< double > v10_TransomOffset, boost::optional< double > v11_LiningOffset, boost::optional< double > v12_ThresholdOffset, boost::optional< double > v13_CasingThickness, boost::optional< double > v14_CasingDepth, ::Ifc2x3::IfcShapeAspect* v15_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorLiningProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ThresholdDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ThresholdDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ThresholdThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_ThresholdThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_TransomThickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_TransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_TransomOffset));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_LiningOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_LiningOffset));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_ThresholdOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_ThresholdOffset));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_CasingThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_CasingThickness));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_CasingDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_CasingDepth));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_ShapeAspectStyle));data_->setArgument(14,attr);} }

// Function implementations for IfcDoorPanelProperties
boost::optional< double > Ifc2x3::IfcDoorPanelProperties::PanelDepth() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcDoorPanelProperties::setPanelDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
::Ifc2x3::IfcDoorPanelOperationEnum::Value Ifc2x3::IfcDoorPanelProperties::PanelOperation() const {  return ::Ifc2x3::IfcDoorPanelOperationEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcDoorPanelProperties::setPanelOperation(::Ifc2x3::IfcDoorPanelOperationEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDoorPanelOperationEnum::ToString(v)));data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcDoorPanelProperties::PanelWidth() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcDoorPanelProperties::setPanelWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
::Ifc2x3::IfcDoorPanelPositionEnum::Value Ifc2x3::IfcDoorPanelProperties::PanelPosition() const {  return ::Ifc2x3::IfcDoorPanelPositionEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcDoorPanelProperties::setPanelPosition(::Ifc2x3::IfcDoorPanelPositionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDoorPanelPositionEnum::ToString(v)));data_->setArgument(7,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcDoorPanelProperties::ShapeAspectStyle() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcDoorPanelProperties::setShapeAspectStyle(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcDoorPanelProperties::declaration() const { return *IFC2X3_IfcDoorPanelProperties_type; }
const IfcParse::entity& Ifc2x3::IfcDoorPanelProperties::Class() { return *IFC2X3_IfcDoorPanelProperties_type; }
Ifc2x3::IfcDoorPanelProperties::IfcDoorPanelProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDoorPanelProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDoorPanelProperties::IfcDoorPanelProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_PanelDepth, ::Ifc2x3::IfcDoorPanelOperationEnum::Value v6_PanelOperation, boost::optional< double > v7_PanelWidth, ::Ifc2x3::IfcDoorPanelPositionEnum::Value v8_PanelPosition, ::Ifc2x3::IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorPanelProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PanelDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PanelDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelOperation,::Ifc2x3::IfcDoorPanelOperationEnum::ToString(v6_PanelOperation))));data_->setArgument(5,attr);} if (v7_PanelWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_PanelWidth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PanelPosition,::Ifc2x3::IfcDoorPanelPositionEnum::ToString(v8_PanelPosition))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcDoorStyle
::Ifc2x3::IfcDoorStyleOperationEnum::Value Ifc2x3::IfcDoorStyle::OperationType() const {  return ::Ifc2x3::IfcDoorStyleOperationEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcDoorStyle::setOperationType(::Ifc2x3::IfcDoorStyleOperationEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDoorStyleOperationEnum::ToString(v)));data_->setArgument(8,attr);} }
::Ifc2x3::IfcDoorStyleConstructionEnum::Value Ifc2x3::IfcDoorStyle::ConstructionType() const {  return ::Ifc2x3::IfcDoorStyleConstructionEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDoorStyle::setConstructionType(::Ifc2x3::IfcDoorStyleConstructionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDoorStyleConstructionEnum::ToString(v)));data_->setArgument(9,attr);} }
bool Ifc2x3::IfcDoorStyle::ParameterTakesPrecedence() const {  bool v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcDoorStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool Ifc2x3::IfcDoorStyle::Sizeable() const {  bool v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcDoorStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcDoorStyle::declaration() const { return *IFC2X3_IfcDoorStyle_type; }
const IfcParse::entity& Ifc2x3::IfcDoorStyle::Class() { return *IFC2X3_IfcDoorStyle_type; }
Ifc2x3::IfcDoorStyle::IfcDoorStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDoorStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDoorStyle::IfcDoorStyle(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcDoorStyleOperationEnum::Value v9_OperationType, ::Ifc2x3::IfcDoorStyleConstructionEnum::Value v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDoorStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_OperationType,::Ifc2x3::IfcDoorStyleOperationEnum::ToString(v9_OperationType))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ConstructionType,::Ifc2x3::IfcDoorStyleConstructionEnum::ToString(v10_ConstructionType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));data_->setArgument(11,attr);} }

// Function implementations for IfcDraughtingCallout
aggregate_of_instance::ptr Ifc2x3::IfcDraughtingCallout::Contents() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDraughtingCallout::setContents(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }

::Ifc2x3::IfcDraughtingCalloutRelationship::list::ptr Ifc2x3::IfcDraughtingCallout::IsRelatedFromCallout() const { return data_->getInverse(IFC2X3_IfcDraughtingCalloutRelationship_type, 3)->as<IfcDraughtingCalloutRelationship>(); }
::Ifc2x3::IfcDraughtingCalloutRelationship::list::ptr Ifc2x3::IfcDraughtingCallout::IsRelatedToCallout() const { return data_->getInverse(IFC2X3_IfcDraughtingCalloutRelationship_type, 2)->as<IfcDraughtingCalloutRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcDraughtingCallout::declaration() const { return *IFC2X3_IfcDraughtingCallout_type; }
const IfcParse::entity& Ifc2x3::IfcDraughtingCallout::Class() { return *IFC2X3_IfcDraughtingCallout_type; }
Ifc2x3::IfcDraughtingCallout::IfcDraughtingCallout(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDraughtingCallout_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDraughtingCallout::IfcDraughtingCallout(aggregate_of_instance::ptr v1_Contents) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDraughtingCallout_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcDraughtingCalloutRelationship
boost::optional< std::string > Ifc2x3::IfcDraughtingCalloutRelationship::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcDraughtingCalloutRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcDraughtingCalloutRelationship::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcDraughtingCalloutRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcDraughtingCallout* Ifc2x3::IfcDraughtingCalloutRelationship::RelatingDraughtingCallout() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcDraughtingCallout>(true); }
void Ifc2x3::IfcDraughtingCalloutRelationship::setRelatingDraughtingCallout(::Ifc2x3::IfcDraughtingCallout* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcDraughtingCallout* Ifc2x3::IfcDraughtingCalloutRelationship::RelatedDraughtingCallout() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcDraughtingCallout>(true); }
void Ifc2x3::IfcDraughtingCalloutRelationship::setRelatedDraughtingCallout(::Ifc2x3::IfcDraughtingCallout* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcDraughtingCalloutRelationship::declaration() const { return *IFC2X3_IfcDraughtingCalloutRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcDraughtingCalloutRelationship::Class() { return *IFC2X3_IfcDraughtingCalloutRelationship_type; }
Ifc2x3::IfcDraughtingCalloutRelationship::IfcDraughtingCalloutRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcDraughtingCalloutRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDraughtingCalloutRelationship::IfcDraughtingCalloutRelationship(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDraughtingCallout* v3_RelatingDraughtingCallout, ::Ifc2x3::IfcDraughtingCallout* v4_RelatedDraughtingCallout) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcDraughtingCalloutRelationship_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingDraughtingCallout));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedDraughtingCallout));data_->setArgument(3,attr);} }

// Function implementations for IfcDraughtingPreDefinedColour


const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedColour::declaration() const { return *IFC2X3_IfcDraughtingPreDefinedColour_type; }
const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedColour::Class() { return *IFC2X3_IfcDraughtingPreDefinedColour_type; }
Ifc2x3::IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedColour((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDraughtingPreDefinedColour_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(std::string v1_Name) : IfcPreDefinedColour((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDraughtingPreDefinedColour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcDraughtingPreDefinedCurveFont


const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedCurveFont::declaration() const { return *IFC2X3_IfcDraughtingPreDefinedCurveFont_type; }
const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedCurveFont::Class() { return *IFC2X3_IfcDraughtingPreDefinedCurveFont_type; }
Ifc2x3::IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDraughtingPreDefinedCurveFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedCurveFont((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDraughtingPreDefinedCurveFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcDraughtingPreDefinedTextFont


const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedTextFont::declaration() const { return *IFC2X3_IfcDraughtingPreDefinedTextFont_type; }
const IfcParse::entity& Ifc2x3::IfcDraughtingPreDefinedTextFont::Class() { return *IFC2X3_IfcDraughtingPreDefinedTextFont_type; }
Ifc2x3::IfcDraughtingPreDefinedTextFont::IfcDraughtingPreDefinedTextFont(IfcEntityInstanceData* e) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDraughtingPreDefinedTextFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDraughtingPreDefinedTextFont::IfcDraughtingPreDefinedTextFont(std::string v1_Name) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDraughtingPreDefinedTextFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcDuctFittingType
::Ifc2x3::IfcDuctFittingTypeEnum::Value Ifc2x3::IfcDuctFittingType::PredefinedType() const {  return ::Ifc2x3::IfcDuctFittingTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDuctFittingType::setPredefinedType(::Ifc2x3::IfcDuctFittingTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDuctFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDuctFittingType::declaration() const { return *IFC2X3_IfcDuctFittingType_type; }
const IfcParse::entity& Ifc2x3::IfcDuctFittingType::Class() { return *IFC2X3_IfcDuctFittingType_type; }
Ifc2x3::IfcDuctFittingType::IfcDuctFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDuctFittingType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDuctFittingType::IfcDuctFittingType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcDuctFittingTypeEnum::Value v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcDuctFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDuctSegmentType
::Ifc2x3::IfcDuctSegmentTypeEnum::Value Ifc2x3::IfcDuctSegmentType::PredefinedType() const {  return ::Ifc2x3::IfcDuctSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDuctSegmentType::setPredefinedType(::Ifc2x3::IfcDuctSegmentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDuctSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDuctSegmentType::declaration() const { return *IFC2X3_IfcDuctSegmentType_type; }
const IfcParse::entity& Ifc2x3::IfcDuctSegmentType::Class() { return *IFC2X3_IfcDuctSegmentType_type; }
Ifc2x3::IfcDuctSegmentType::IfcDuctSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDuctSegmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDuctSegmentType::IfcDuctSegmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcDuctSegmentTypeEnum::Value v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcDuctSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcDuctSilencerType
::Ifc2x3::IfcDuctSilencerTypeEnum::Value Ifc2x3::IfcDuctSilencerType::PredefinedType() const {  return ::Ifc2x3::IfcDuctSilencerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcDuctSilencerType::setPredefinedType(::Ifc2x3::IfcDuctSilencerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDuctSilencerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcDuctSilencerType::declaration() const { return *IFC2X3_IfcDuctSilencerType_type; }
const IfcParse::entity& Ifc2x3::IfcDuctSilencerType::Class() { return *IFC2X3_IfcDuctSilencerType_type; }
Ifc2x3::IfcDuctSilencerType::IfcDuctSilencerType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcDuctSilencerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcDuctSilencerType::IfcDuctSilencerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcDuctSilencerTypeEnum::Value v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcDuctSilencerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcDuctSilencerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEdge
::Ifc2x3::IfcVertex* Ifc2x3::IfcEdge::EdgeStart() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcVertex>(true); }
void Ifc2x3::IfcEdge::setEdgeStart(::Ifc2x3::IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcVertex* Ifc2x3::IfcEdge::EdgeEnd() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcVertex>(true); }
void Ifc2x3::IfcEdge::setEdgeEnd(::Ifc2x3::IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcEdge::declaration() const { return *IFC2X3_IfcEdge_type; }
const IfcParse::entity& Ifc2x3::IfcEdge::Class() { return *IFC2X3_IfcEdge_type; }
Ifc2x3::IfcEdge::IfcEdge(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEdge_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEdge::IfcEdge(::Ifc2x3::IfcVertex* v1_EdgeStart, ::Ifc2x3::IfcVertex* v2_EdgeEnd) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEdge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);} }

// Function implementations for IfcEdgeCurve
::Ifc2x3::IfcCurve* Ifc2x3::IfcEdgeCurve::EdgeGeometry() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcEdgeCurve::setEdgeGeometry(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool Ifc2x3::IfcEdgeCurve::SameSense() const {  bool v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcEdgeCurve::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcEdgeCurve::declaration() const { return *IFC2X3_IfcEdgeCurve_type; }
const IfcParse::entity& Ifc2x3::IfcEdgeCurve::Class() { return *IFC2X3_IfcEdgeCurve_type; }
Ifc2x3::IfcEdgeCurve::IfcEdgeCurve(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEdgeCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEdgeCurve::IfcEdgeCurve(::Ifc2x3::IfcVertex* v1_EdgeStart, ::Ifc2x3::IfcVertex* v2_EdgeEnd, ::Ifc2x3::IfcCurve* v3_EdgeGeometry, bool v4_SameSense) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEdgeCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeGeometry));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SameSense));data_->setArgument(3,attr);} }

// Function implementations for IfcEdgeFeature
boost::optional< double > Ifc2x3::IfcEdgeFeature::FeatureLength() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcEdgeFeature::setFeatureLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcEdgeFeature::declaration() const { return *IFC2X3_IfcEdgeFeature_type; }
const IfcParse::entity& Ifc2x3::IfcEdgeFeature::Class() { return *IFC2X3_IfcEdgeFeature_type; }
Ifc2x3::IfcEdgeFeature::IfcEdgeFeature(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEdgeFeature_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEdgeFeature::IfcEdgeFeature(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEdgeFeature_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEdgeLoop
aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr Ifc2x3::IfcEdgeLoop::EdgeList() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcOrientedEdge >(); }
void Ifc2x3::IfcEdgeLoop::setEdgeList(aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcEdgeLoop::declaration() const { return *IFC2X3_IfcEdgeLoop_type; }
const IfcParse::entity& Ifc2x3::IfcEdgeLoop::Class() { return *IFC2X3_IfcEdgeLoop_type; }
Ifc2x3::IfcEdgeLoop::IfcEdgeLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEdgeLoop_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEdgeLoop::IfcEdgeLoop(aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr v1_EdgeList) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEdgeLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcElectricApplianceType
::Ifc2x3::IfcElectricApplianceTypeEnum::Value Ifc2x3::IfcElectricApplianceType::PredefinedType() const {  return ::Ifc2x3::IfcElectricApplianceTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricApplianceType::setPredefinedType(::Ifc2x3::IfcElectricApplianceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricApplianceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricApplianceType::declaration() const { return *IFC2X3_IfcElectricApplianceType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricApplianceType::Class() { return *IFC2X3_IfcElectricApplianceType_type; }
Ifc2x3::IfcElectricApplianceType::IfcElectricApplianceType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricApplianceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricApplianceType::IfcElectricApplianceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricApplianceTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricApplianceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricApplianceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricDistributionPoint
::Ifc2x3::IfcElectricDistributionPointFunctionEnum::Value Ifc2x3::IfcElectricDistributionPoint::DistributionPointFunction() const {  return ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcElectricDistributionPoint::setDistributionPointFunction(::Ifc2x3::IfcElectricDistributionPointFunctionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricDistributionPointFunctionEnum::ToString(v)));data_->setArgument(8,attr);} }
boost::optional< std::string > Ifc2x3::IfcElectricDistributionPoint::UserDefinedFunction() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcElectricDistributionPoint::setUserDefinedFunction(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricDistributionPoint::declaration() const { return *IFC2X3_IfcElectricDistributionPoint_type; }
const IfcParse::entity& Ifc2x3::IfcElectricDistributionPoint::Class() { return *IFC2X3_IfcElectricDistributionPoint_type; }
Ifc2x3::IfcElectricDistributionPoint::IfcElectricDistributionPoint(IfcEntityInstanceData* e) : IfcFlowController((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricDistributionPoint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricDistributionPoint::IfcElectricDistributionPoint(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcElectricDistributionPointFunctionEnum::Value v9_DistributionPointFunction, boost::optional< std::string > v10_UserDefinedFunction) : IfcFlowController((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricDistributionPoint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_DistributionPointFunction,::Ifc2x3::IfcElectricDistributionPointFunctionEnum::ToString(v9_DistributionPointFunction))));data_->setArgument(8,attr);} if (v10_UserDefinedFunction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedFunction));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcElectricFlowStorageDeviceType
::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Value Ifc2x3::IfcElectricFlowStorageDeviceType::PredefinedType() const {  return ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricFlowStorageDeviceType::setPredefinedType(::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricFlowStorageDeviceType::declaration() const { return *IFC2X3_IfcElectricFlowStorageDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricFlowStorageDeviceType::Class() { return *IFC2X3_IfcElectricFlowStorageDeviceType_type; }
Ifc2x3::IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricFlowStorageDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::Value v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricFlowStorageDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricFlowStorageDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricGeneratorType
::Ifc2x3::IfcElectricGeneratorTypeEnum::Value Ifc2x3::IfcElectricGeneratorType::PredefinedType() const {  return ::Ifc2x3::IfcElectricGeneratorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricGeneratorType::setPredefinedType(::Ifc2x3::IfcElectricGeneratorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricGeneratorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricGeneratorType::declaration() const { return *IFC2X3_IfcElectricGeneratorType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricGeneratorType::Class() { return *IFC2X3_IfcElectricGeneratorType_type; }
Ifc2x3::IfcElectricGeneratorType::IfcElectricGeneratorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricGeneratorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricGeneratorType::IfcElectricGeneratorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricGeneratorTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricGeneratorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricGeneratorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricHeaterType
::Ifc2x3::IfcElectricHeaterTypeEnum::Value Ifc2x3::IfcElectricHeaterType::PredefinedType() const {  return ::Ifc2x3::IfcElectricHeaterTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricHeaterType::setPredefinedType(::Ifc2x3::IfcElectricHeaterTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricHeaterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricHeaterType::declaration() const { return *IFC2X3_IfcElectricHeaterType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricHeaterType::Class() { return *IFC2X3_IfcElectricHeaterType_type; }
Ifc2x3::IfcElectricHeaterType::IfcElectricHeaterType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricHeaterType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricHeaterType::IfcElectricHeaterType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricHeaterTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricHeaterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricHeaterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricMotorType
::Ifc2x3::IfcElectricMotorTypeEnum::Value Ifc2x3::IfcElectricMotorType::PredefinedType() const {  return ::Ifc2x3::IfcElectricMotorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricMotorType::setPredefinedType(::Ifc2x3::IfcElectricMotorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricMotorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricMotorType::declaration() const { return *IFC2X3_IfcElectricMotorType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricMotorType::Class() { return *IFC2X3_IfcElectricMotorType_type; }
Ifc2x3::IfcElectricMotorType::IfcElectricMotorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricMotorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricMotorType::IfcElectricMotorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricMotorTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricMotorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricMotorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricTimeControlType
::Ifc2x3::IfcElectricTimeControlTypeEnum::Value Ifc2x3::IfcElectricTimeControlType::PredefinedType() const {  return ::Ifc2x3::IfcElectricTimeControlTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElectricTimeControlType::setPredefinedType(::Ifc2x3::IfcElectricTimeControlTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElectricTimeControlTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricTimeControlType::declaration() const { return *IFC2X3_IfcElectricTimeControlType_type; }
const IfcParse::entity& Ifc2x3::IfcElectricTimeControlType::Class() { return *IFC2X3_IfcElectricTimeControlType_type; }
Ifc2x3::IfcElectricTimeControlType::IfcElectricTimeControlType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricTimeControlType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricTimeControlType::IfcElectricTimeControlType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcElectricTimeControlTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricTimeControlType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElectricTimeControlTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElectricalBaseProperties
boost::optional< ::Ifc2x3::IfcElectricCurrentEnum::Value > Ifc2x3::IfcElectricalBaseProperties::ElectricCurrentType() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } return ::Ifc2x3::IfcElectricCurrentEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcElectricalBaseProperties::setElectricCurrentType(boost::optional< ::Ifc2x3::IfcElectricCurrentEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcElectricCurrentEnum::ToString(*v)));}data_->setArgument(6,attr);} }
double Ifc2x3::IfcElectricalBaseProperties::InputVoltage() const {  double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setInputVoltage(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double Ifc2x3::IfcElectricalBaseProperties::InputFrequency() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setInputFrequency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcElectricalBaseProperties::FullLoadCurrent() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setFullLoadCurrent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcElectricalBaseProperties::MinimumCircuitCurrent() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setMinimumCircuitCurrent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcElectricalBaseProperties::MaximumPowerInput() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setMaximumPowerInput(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcElectricalBaseProperties::RatedPowerInput() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setRatedPowerInput(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
int Ifc2x3::IfcElectricalBaseProperties::InputPhase() const {  int v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcElectricalBaseProperties::setInputPhase(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcElectricalBaseProperties::declaration() const { return *IFC2X3_IfcElectricalBaseProperties_type; }
const IfcParse::entity& Ifc2x3::IfcElectricalBaseProperties::Class() { return *IFC2X3_IfcElectricalBaseProperties_type; }
Ifc2x3::IfcElectricalBaseProperties::IfcElectricalBaseProperties(IfcEntityInstanceData* e) : IfcEnergyProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricalBaseProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricalBaseProperties::IfcElectricalBaseProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< ::Ifc2x3::IfcEnergySequenceEnum::Value > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence, boost::optional< ::Ifc2x3::IfcElectricCurrentEnum::Value > v7_ElectricCurrentType, double v8_InputVoltage, double v9_InputFrequency, boost::optional< double > v10_FullLoadCurrent, boost::optional< double > v11_MinimumCircuitCurrent, boost::optional< double > v12_MaximumPowerInput, boost::optional< double > v13_RatedPowerInput, int v14_InputPhase) : IfcEnergyProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricalBaseProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_EnergySequence,::Ifc2x3::IfcEnergySequenceEnum::ToString(*v5_EnergySequence))));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_UserDefinedEnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_UserDefinedEnergySequence));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ElectricCurrentType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v7_ElectricCurrentType,::Ifc2x3::IfcElectricCurrentEnum::ToString(*v7_ElectricCurrentType))));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_InputVoltage));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_InputFrequency));data_->setArgument(8,attr);} if (v10_FullLoadCurrent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FullLoadCurrent));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_MinimumCircuitCurrent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MinimumCircuitCurrent));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_MaximumPowerInput) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_MaximumPowerInput));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_RatedPowerInput) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_RatedPowerInput));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_InputPhase));data_->setArgument(13,attr);} }

// Function implementations for IfcElectricalCircuit


const IfcParse::entity& Ifc2x3::IfcElectricalCircuit::declaration() const { return *IFC2X3_IfcElectricalCircuit_type; }
const IfcParse::entity& Ifc2x3::IfcElectricalCircuit::Class() { return *IFC2X3_IfcElectricalCircuit_type; }
Ifc2x3::IfcElectricalCircuit::IfcElectricalCircuit(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricalCircuit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricalCircuit::IfcElectricalCircuit(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricalCircuit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcElectricalElement


const IfcParse::entity& Ifc2x3::IfcElectricalElement::declaration() const { return *IFC2X3_IfcElectricalElement_type; }
const IfcParse::entity& Ifc2x3::IfcElectricalElement::Class() { return *IFC2X3_IfcElectricalElement_type; }
Ifc2x3::IfcElectricalElement::IfcElectricalElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElectricalElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElectricalElement::IfcElectricalElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElectricalElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcElement
boost::optional< std::string > Ifc2x3::IfcElement::Tag() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcElement::setTag(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }

::Ifc2x3::IfcRelConnectsStructuralElement::list::ptr Ifc2x3::IfcElement::HasStructuralMember() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralElement_type, 4)->as<IfcRelConnectsStructuralElement>(); }
::Ifc2x3::IfcRelFillsElement::list::ptr Ifc2x3::IfcElement::FillsVoids() const { return data_->getInverse(IFC2X3_IfcRelFillsElement_type, 5)->as<IfcRelFillsElement>(); }
::Ifc2x3::IfcRelConnectsElements::list::ptr Ifc2x3::IfcElement::ConnectedTo() const { return data_->getInverse(IFC2X3_IfcRelConnectsElements_type, 5)->as<IfcRelConnectsElements>(); }
::Ifc2x3::IfcRelCoversBldgElements::list::ptr Ifc2x3::IfcElement::HasCoverings() const { return data_->getInverse(IFC2X3_IfcRelCoversBldgElements_type, 4)->as<IfcRelCoversBldgElements>(); }
::Ifc2x3::IfcRelProjectsElement::list::ptr Ifc2x3::IfcElement::HasProjections() const { return data_->getInverse(IFC2X3_IfcRelProjectsElement_type, 4)->as<IfcRelProjectsElement>(); }
::Ifc2x3::IfcRelReferencedInSpatialStructure::list::ptr Ifc2x3::IfcElement::ReferencedInStructures() const { return data_->getInverse(IFC2X3_IfcRelReferencedInSpatialStructure_type, 4)->as<IfcRelReferencedInSpatialStructure>(); }
::Ifc2x3::IfcRelConnectsPortToElement::list::ptr Ifc2x3::IfcElement::HasPorts() const { return data_->getInverse(IFC2X3_IfcRelConnectsPortToElement_type, 5)->as<IfcRelConnectsPortToElement>(); }
::Ifc2x3::IfcRelVoidsElement::list::ptr Ifc2x3::IfcElement::HasOpenings() const { return data_->getInverse(IFC2X3_IfcRelVoidsElement_type, 4)->as<IfcRelVoidsElement>(); }
::Ifc2x3::IfcRelConnectsWithRealizingElements::list::ptr Ifc2x3::IfcElement::IsConnectionRealization() const { return data_->getInverse(IFC2X3_IfcRelConnectsWithRealizingElements_type, 7)->as<IfcRelConnectsWithRealizingElements>(); }
::Ifc2x3::IfcRelSpaceBoundary::list::ptr Ifc2x3::IfcElement::ProvidesBoundaries() const { return data_->getInverse(IFC2X3_IfcRelSpaceBoundary_type, 5)->as<IfcRelSpaceBoundary>(); }
::Ifc2x3::IfcRelConnectsElements::list::ptr Ifc2x3::IfcElement::ConnectedFrom() const { return data_->getInverse(IFC2X3_IfcRelConnectsElements_type, 6)->as<IfcRelConnectsElements>(); }
::Ifc2x3::IfcRelContainedInSpatialStructure::list::ptr Ifc2x3::IfcElement::ContainedInStructure() const { return data_->getInverse(IFC2X3_IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& Ifc2x3::IfcElement::declaration() const { return *IFC2X3_IfcElement_type; }
const IfcParse::entity& Ifc2x3::IfcElement::Class() { return *IFC2X3_IfcElement_type; }
Ifc2x3::IfcElement::IfcElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElement::IfcElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcElementAssembly
boost::optional< ::Ifc2x3::IfcAssemblyPlaceEnum::Value > Ifc2x3::IfcElementAssembly::AssemblyPlace() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcAssemblyPlaceEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcElementAssembly::setAssemblyPlace(boost::optional< ::Ifc2x3::IfcAssemblyPlaceEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcAssemblyPlaceEnum::ToString(*v)));}data_->setArgument(8,attr);} }
::Ifc2x3::IfcElementAssemblyTypeEnum::Value Ifc2x3::IfcElementAssembly::PredefinedType() const {  return ::Ifc2x3::IfcElementAssemblyTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcElementAssembly::setPredefinedType(::Ifc2x3::IfcElementAssemblyTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElementAssemblyTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcElementAssembly::declaration() const { return *IFC2X3_IfcElementAssembly_type; }
const IfcParse::entity& Ifc2x3::IfcElementAssembly::Class() { return *IFC2X3_IfcElementAssembly_type; }
Ifc2x3::IfcElementAssembly::IfcElementAssembly(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementAssembly_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementAssembly::IfcElementAssembly(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcAssemblyPlaceEnum::Value > v9_AssemblyPlace, ::Ifc2x3::IfcElementAssemblyTypeEnum::Value v10_PredefinedType) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementAssembly_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_AssemblyPlace) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_AssemblyPlace,::Ifc2x3::IfcAssemblyPlaceEnum::ToString(*v9_AssemblyPlace))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcElementAssemblyTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcElementComponent


const IfcParse::entity& Ifc2x3::IfcElementComponent::declaration() const { return *IFC2X3_IfcElementComponent_type; }
const IfcParse::entity& Ifc2x3::IfcElementComponent::Class() { return *IFC2X3_IfcElementComponent_type; }
Ifc2x3::IfcElementComponent::IfcElementComponent(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementComponent_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementComponent::IfcElementComponent(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementComponent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcElementComponentType


const IfcParse::entity& Ifc2x3::IfcElementComponentType::declaration() const { return *IFC2X3_IfcElementComponentType_type; }
const IfcParse::entity& Ifc2x3::IfcElementComponentType::Class() { return *IFC2X3_IfcElementComponentType_type; }
Ifc2x3::IfcElementComponentType::IfcElementComponentType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementComponentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementComponentType::IfcElementComponentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementComponentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElementQuantity
boost::optional< std::string > Ifc2x3::IfcElementQuantity::MethodOfMeasurement() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcElementQuantity::setMethodOfMeasurement(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr Ifc2x3::IfcElementQuantity::Quantities() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcPhysicalQuantity >(); }
void Ifc2x3::IfcElementQuantity::setQuantities(aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcElementQuantity::declaration() const { return *IFC2X3_IfcElementQuantity_type; }
const IfcParse::entity& Ifc2x3::IfcElementQuantity::Class() { return *IFC2X3_IfcElementQuantity_type; }
Ifc2x3::IfcElementQuantity::IfcElementQuantity(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementQuantity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementQuantity::IfcElementQuantity(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_MethodOfMeasurement, aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr v6_Quantities) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MethodOfMeasurement) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MethodOfMeasurement));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Quantities)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcElementType
boost::optional< std::string > Ifc2x3::IfcElementType::ElementType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcElementType::setElementType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcElementType::declaration() const { return *IFC2X3_IfcElementType_type; }
const IfcParse::entity& Ifc2x3::IfcElementType::Class() { return *IFC2X3_IfcElementType_type; }
Ifc2x3::IfcElementType::IfcElementType(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementType::IfcElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcElementarySurface
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcElementarySurface::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcElementarySurface::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcElementarySurface::declaration() const { return *IFC2X3_IfcElementarySurface_type; }
const IfcParse::entity& Ifc2x3::IfcElementarySurface::Class() { return *IFC2X3_IfcElementarySurface_type; }
Ifc2x3::IfcElementarySurface::IfcElementarySurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcElementarySurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcElementarySurface::IfcElementarySurface(::Ifc2x3::IfcAxis2Placement3D* v1_Position) : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcElementarySurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcEllipse
double Ifc2x3::IfcEllipse::SemiAxis1() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcEllipse::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcEllipse::SemiAxis2() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcEllipse::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcEllipse::declaration() const { return *IFC2X3_IfcEllipse_type; }
const IfcParse::entity& Ifc2x3::IfcEllipse::Class() { return *IFC2X3_IfcEllipse_type; }
Ifc2x3::IfcEllipse::IfcEllipse(IfcEntityInstanceData* e) : IfcConic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEllipse_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEllipse::IfcEllipse(::Ifc2x3::IfcAxis2Placement* v1_Position, double v2_SemiAxis1, double v3_SemiAxis2) : IfcConic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEllipse_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SemiAxis1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SemiAxis2));data_->setArgument(2,attr);} }

// Function implementations for IfcEllipseProfileDef
double Ifc2x3::IfcEllipseProfileDef::SemiAxis1() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcEllipseProfileDef::setSemiAxis1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcEllipseProfileDef::SemiAxis2() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcEllipseProfileDef::setSemiAxis2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcEllipseProfileDef::declaration() const { return *IFC2X3_IfcEllipseProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcEllipseProfileDef::Class() { return *IFC2X3_IfcEllipseProfileDef_type; }
Ifc2x3::IfcEllipseProfileDef::IfcEllipseProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEllipseProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEllipseProfileDef::IfcEllipseProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_SemiAxis1, double v5_SemiAxis2) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEllipseProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SemiAxis1));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SemiAxis2));data_->setArgument(4,attr);} }

// Function implementations for IfcEnergyConversionDevice


const IfcParse::entity& Ifc2x3::IfcEnergyConversionDevice::declaration() const { return *IFC2X3_IfcEnergyConversionDevice_type; }
const IfcParse::entity& Ifc2x3::IfcEnergyConversionDevice::Class() { return *IFC2X3_IfcEnergyConversionDevice_type; }
Ifc2x3::IfcEnergyConversionDevice::IfcEnergyConversionDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEnergyConversionDevice_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEnergyConversionDevice::IfcEnergyConversionDevice(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergyConversionDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcEnergyConversionDeviceType


const IfcParse::entity& Ifc2x3::IfcEnergyConversionDeviceType::declaration() const { return *IFC2X3_IfcEnergyConversionDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcEnergyConversionDeviceType::Class() { return *IFC2X3_IfcEnergyConversionDeviceType_type; }
Ifc2x3::IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEnergyConversionDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergyConversionDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEnergyProperties
boost::optional< ::Ifc2x3::IfcEnergySequenceEnum::Value > Ifc2x3::IfcEnergyProperties::EnergySequence() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } return ::Ifc2x3::IfcEnergySequenceEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcEnergyProperties::setEnergySequence(boost::optional< ::Ifc2x3::IfcEnergySequenceEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcEnergySequenceEnum::ToString(*v)));}data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcEnergyProperties::UserDefinedEnergySequence() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcEnergyProperties::setUserDefinedEnergySequence(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcEnergyProperties::declaration() const { return *IFC2X3_IfcEnergyProperties_type; }
const IfcParse::entity& Ifc2x3::IfcEnergyProperties::Class() { return *IFC2X3_IfcEnergyProperties_type; }
Ifc2x3::IfcEnergyProperties::IfcEnergyProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEnergyProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEnergyProperties::IfcEnergyProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< ::Ifc2x3::IfcEnergySequenceEnum::Value > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEnergyProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_EnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v5_EnergySequence,::Ifc2x3::IfcEnergySequenceEnum::ToString(*v5_EnergySequence))));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_UserDefinedEnergySequence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_UserDefinedEnergySequence));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcEnvironmentalImpactValue
std::string Ifc2x3::IfcEnvironmentalImpactValue::ImpactType() const {  std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcEnvironmentalImpactValue::setImpactType(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Value Ifc2x3::IfcEnvironmentalImpactValue::Category() const {  return ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcEnvironmentalImpactValue::setCategory(::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::ToString(v)));data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcEnvironmentalImpactValue::UserDefinedCategory() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcEnvironmentalImpactValue::setUserDefinedCategory(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcEnvironmentalImpactValue::declaration() const { return *IFC2X3_IfcEnvironmentalImpactValue_type; }
const IfcParse::entity& Ifc2x3::IfcEnvironmentalImpactValue::Class() { return *IFC2X3_IfcEnvironmentalImpactValue_type; }
Ifc2x3::IfcEnvironmentalImpactValue::IfcEnvironmentalImpactValue(IfcEntityInstanceData* e) : IfcAppliedValue((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEnvironmentalImpactValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEnvironmentalImpactValue::IfcEnvironmentalImpactValue(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcAppliedValueSelect* v3_AppliedValue, ::Ifc2x3::IfcMeasureWithUnit* v4_UnitBasis, ::Ifc2x3::IfcDateTimeSelect* v5_ApplicableDate, ::Ifc2x3::IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_ImpactType, ::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::Value v8_Category, boost::optional< std::string > v9_UserDefinedCategory) : IfcAppliedValue((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEnvironmentalImpactValue_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AppliedValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_UnitBasis));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ApplicableDate));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FixedUntilDate));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ImpactType));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_Category,::Ifc2x3::IfcEnvironmentalImpactCategoryEnum::ToString(v8_Category))));data_->setArgument(7,attr);} if (v9_UserDefinedCategory) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_UserDefinedCategory));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcEquipmentElement


const IfcParse::entity& Ifc2x3::IfcEquipmentElement::declaration() const { return *IFC2X3_IfcEquipmentElement_type; }
const IfcParse::entity& Ifc2x3::IfcEquipmentElement::Class() { return *IFC2X3_IfcEquipmentElement_type; }
Ifc2x3::IfcEquipmentElement::IfcEquipmentElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEquipmentElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEquipmentElement::IfcEquipmentElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEquipmentElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcEquipmentStandard


const IfcParse::entity& Ifc2x3::IfcEquipmentStandard::declaration() const { return *IFC2X3_IfcEquipmentStandard_type; }
const IfcParse::entity& Ifc2x3::IfcEquipmentStandard::Class() { return *IFC2X3_IfcEquipmentStandard_type; }
Ifc2x3::IfcEquipmentStandard::IfcEquipmentStandard(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEquipmentStandard_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEquipmentStandard::IfcEquipmentStandard(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEquipmentStandard_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcEvaporativeCoolerType
::Ifc2x3::IfcEvaporativeCoolerTypeEnum::Value Ifc2x3::IfcEvaporativeCoolerType::PredefinedType() const {  return ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcEvaporativeCoolerType::setPredefinedType(::Ifc2x3::IfcEvaporativeCoolerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcEvaporativeCoolerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcEvaporativeCoolerType::declaration() const { return *IFC2X3_IfcEvaporativeCoolerType_type; }
const IfcParse::entity& Ifc2x3::IfcEvaporativeCoolerType::Class() { return *IFC2X3_IfcEvaporativeCoolerType_type; }
Ifc2x3::IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEvaporativeCoolerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcEvaporativeCoolerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporativeCoolerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcEvaporativeCoolerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcEvaporatorType
::Ifc2x3::IfcEvaporatorTypeEnum::Value Ifc2x3::IfcEvaporatorType::PredefinedType() const {  return ::Ifc2x3::IfcEvaporatorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcEvaporatorType::setPredefinedType(::Ifc2x3::IfcEvaporatorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcEvaporatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcEvaporatorType::declaration() const { return *IFC2X3_IfcEvaporatorType_type; }
const IfcParse::entity& Ifc2x3::IfcEvaporatorType::Class() { return *IFC2X3_IfcEvaporatorType_type; }
Ifc2x3::IfcEvaporatorType::IfcEvaporatorType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcEvaporatorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcEvaporatorType::IfcEvaporatorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcEvaporatorTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcEvaporatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcEvaporatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcExtendedMaterialProperties
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcExtendedMaterialProperties::ExtendedProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcExtendedMaterialProperties::setExtendedProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcExtendedMaterialProperties::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcExtendedMaterialProperties::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
std::string Ifc2x3::IfcExtendedMaterialProperties::Name() const {  std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcExtendedMaterialProperties::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcExtendedMaterialProperties::declaration() const { return *IFC2X3_IfcExtendedMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcExtendedMaterialProperties::Class() { return *IFC2X3_IfcExtendedMaterialProperties_type; }
Ifc2x3::IfcExtendedMaterialProperties::IfcExtendedMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExtendedMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExtendedMaterialProperties::IfcExtendedMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, aggregate_of< ::Ifc2x3::IfcProperty >::ptr v2_ExtendedProperties, boost::optional< std::string > v3_Description, std::string v4_Name) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExtendedMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ExtendedProperties)->generalize());data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Name));data_->setArgument(3,attr);} }

// Function implementations for IfcExternalReference
boost::optional< std::string > Ifc2x3::IfcExternalReference::Location() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcExternalReference::setLocation(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcExternalReference::ItemReference() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcExternalReference::setItemReference(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcExternalReference::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcExternalReference::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcExternalReference::declaration() const { return *IFC2X3_IfcExternalReference_type; }
const IfcParse::entity& Ifc2x3::IfcExternalReference::Class() { return *IFC2X3_IfcExternalReference_type; }
Ifc2x3::IfcExternalReference::IfcExternalReference(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcExternalReference_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExternalReference::IfcExternalReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcExternalReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedHatchStyle


const IfcParse::entity& Ifc2x3::IfcExternallyDefinedHatchStyle::declaration() const { return *IFC2X3_IfcExternallyDefinedHatchStyle_type; }
const IfcParse::entity& Ifc2x3::IfcExternallyDefinedHatchStyle::Class() { return *IFC2X3_IfcExternallyDefinedHatchStyle_type; }
Ifc2x3::IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExternallyDefinedHatchStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExternallyDefinedHatchStyle_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedSurfaceStyle


const IfcParse::entity& Ifc2x3::IfcExternallyDefinedSurfaceStyle::declaration() const { return *IFC2X3_IfcExternallyDefinedSurfaceStyle_type; }
const IfcParse::entity& Ifc2x3::IfcExternallyDefinedSurfaceStyle::Class() { return *IFC2X3_IfcExternallyDefinedSurfaceStyle_type; }
Ifc2x3::IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExternallyDefinedSurfaceStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExternallyDefinedSurfaceStyle_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedSymbol


const IfcParse::entity& Ifc2x3::IfcExternallyDefinedSymbol::declaration() const { return *IFC2X3_IfcExternallyDefinedSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcExternallyDefinedSymbol::Class() { return *IFC2X3_IfcExternallyDefinedSymbol_type; }
Ifc2x3::IfcExternallyDefinedSymbol::IfcExternallyDefinedSymbol(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExternallyDefinedSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExternallyDefinedSymbol::IfcExternallyDefinedSymbol(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExternallyDefinedSymbol_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExternallyDefinedTextFont


const IfcParse::entity& Ifc2x3::IfcExternallyDefinedTextFont::declaration() const { return *IFC2X3_IfcExternallyDefinedTextFont_type; }
const IfcParse::entity& Ifc2x3::IfcExternallyDefinedTextFont::Class() { return *IFC2X3_IfcExternallyDefinedTextFont_type; }
Ifc2x3::IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExternallyDefinedTextFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExternallyDefinedTextFont_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcExtrudedAreaSolid
::Ifc2x3::IfcDirection* Ifc2x3::IfcExtrudedAreaSolid::ExtrudedDirection() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcExtrudedAreaSolid::setExtrudedDirection(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcExtrudedAreaSolid::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcExtrudedAreaSolid::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcExtrudedAreaSolid::declaration() const { return *IFC2X3_IfcExtrudedAreaSolid_type; }
const IfcParse::entity& Ifc2x3::IfcExtrudedAreaSolid::Class() { return *IFC2X3_IfcExtrudedAreaSolid_type; }
Ifc2x3::IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcExtrudedAreaSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(::Ifc2x3::IfcProfileDef* v1_SweptArea, ::Ifc2x3::IfcAxis2Placement3D* v2_Position, ::Ifc2x3::IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcExtrudedAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} }

// Function implementations for IfcFace
aggregate_of< ::Ifc2x3::IfcFaceBound >::ptr Ifc2x3::IfcFace::Bounds() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcFaceBound >(); }
void Ifc2x3::IfcFace::setBounds(aggregate_of< ::Ifc2x3::IfcFaceBound >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcFace::declaration() const { return *IFC2X3_IfcFace_type; }
const IfcParse::entity& Ifc2x3::IfcFace::Class() { return *IFC2X3_IfcFace_type; }
Ifc2x3::IfcFace::IfcFace(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFace_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFace::IfcFace(aggregate_of< ::Ifc2x3::IfcFaceBound >::ptr v1_Bounds) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcFaceBasedSurfaceModel
aggregate_of< ::Ifc2x3::IfcConnectedFaceSet >::ptr Ifc2x3::IfcFaceBasedSurfaceModel::FbsmFaces() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcConnectedFaceSet >(); }
void Ifc2x3::IfcFaceBasedSurfaceModel::setFbsmFaces(aggregate_of< ::Ifc2x3::IfcConnectedFaceSet >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcFaceBasedSurfaceModel::declaration() const { return *IFC2X3_IfcFaceBasedSurfaceModel_type; }
const IfcParse::entity& Ifc2x3::IfcFaceBasedSurfaceModel::Class() { return *IFC2X3_IfcFaceBasedSurfaceModel_type; }
Ifc2x3::IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFaceBasedSurfaceModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(aggregate_of< ::Ifc2x3::IfcConnectedFaceSet >::ptr v1_FbsmFaces) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFaceBasedSurfaceModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_FbsmFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcFaceBound
::Ifc2x3::IfcLoop* Ifc2x3::IfcFaceBound::Bound() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcLoop>(true); }
void Ifc2x3::IfcFaceBound::setBound(::Ifc2x3::IfcLoop* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool Ifc2x3::IfcFaceBound::Orientation() const {  bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcFaceBound::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcFaceBound::declaration() const { return *IFC2X3_IfcFaceBound_type; }
const IfcParse::entity& Ifc2x3::IfcFaceBound::Class() { return *IFC2X3_IfcFaceBound_type; }
Ifc2x3::IfcFaceBound::IfcFaceBound(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFaceBound_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFaceBound::IfcFaceBound(::Ifc2x3::IfcLoop* v1_Bound, bool v2_Orientation) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFaceBound_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));data_->setArgument(1,attr);} }

// Function implementations for IfcFaceOuterBound


const IfcParse::entity& Ifc2x3::IfcFaceOuterBound::declaration() const { return *IFC2X3_IfcFaceOuterBound_type; }
const IfcParse::entity& Ifc2x3::IfcFaceOuterBound::Class() { return *IFC2X3_IfcFaceOuterBound_type; }
Ifc2x3::IfcFaceOuterBound::IfcFaceOuterBound(IfcEntityInstanceData* e) : IfcFaceBound((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFaceOuterBound_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFaceOuterBound::IfcFaceOuterBound(::Ifc2x3::IfcLoop* v1_Bound, bool v2_Orientation) : IfcFaceBound((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFaceOuterBound_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bound));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Orientation));data_->setArgument(1,attr);} }

// Function implementations for IfcFaceSurface
::Ifc2x3::IfcSurface* Ifc2x3::IfcFaceSurface::FaceSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcSurface>(true); }
void Ifc2x3::IfcFaceSurface::setFaceSurface(::Ifc2x3::IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool Ifc2x3::IfcFaceSurface::SameSense() const {  bool v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcFaceSurface::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcFaceSurface::declaration() const { return *IFC2X3_IfcFaceSurface_type; }
const IfcParse::entity& Ifc2x3::IfcFaceSurface::Class() { return *IFC2X3_IfcFaceSurface_type; }
Ifc2x3::IfcFaceSurface::IfcFaceSurface(IfcEntityInstanceData* e) : IfcFace((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFaceSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFaceSurface::IfcFaceSurface(aggregate_of< ::Ifc2x3::IfcFaceBound >::ptr v1_Bounds, ::Ifc2x3::IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFace((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFaceSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Bounds)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FaceSurface));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));data_->setArgument(2,attr);} }

// Function implementations for IfcFacetedBrep


const IfcParse::entity& Ifc2x3::IfcFacetedBrep::declaration() const { return *IFC2X3_IfcFacetedBrep_type; }
const IfcParse::entity& Ifc2x3::IfcFacetedBrep::Class() { return *IFC2X3_IfcFacetedBrep_type; }
Ifc2x3::IfcFacetedBrep::IfcFacetedBrep(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFacetedBrep_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFacetedBrep::IfcFacetedBrep(::Ifc2x3::IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFacetedBrep_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);} }

// Function implementations for IfcFacetedBrepWithVoids
aggregate_of< ::Ifc2x3::IfcClosedShell >::ptr Ifc2x3::IfcFacetedBrepWithVoids::Voids() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcClosedShell >(); }
void Ifc2x3::IfcFacetedBrepWithVoids::setVoids(aggregate_of< ::Ifc2x3::IfcClosedShell >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcFacetedBrepWithVoids::declaration() const { return *IFC2X3_IfcFacetedBrepWithVoids_type; }
const IfcParse::entity& Ifc2x3::IfcFacetedBrepWithVoids::Class() { return *IFC2X3_IfcFacetedBrepWithVoids_type; }
Ifc2x3::IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcEntityInstanceData* e) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFacetedBrepWithVoids_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(::Ifc2x3::IfcClosedShell* v1_Outer, aggregate_of< ::Ifc2x3::IfcClosedShell >::ptr v2_Voids) : IfcManifoldSolidBrep((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFacetedBrepWithVoids_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Voids)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcFailureConnectionCondition
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::TensionFailureX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setTensionFailureX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::TensionFailureY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setTensionFailureY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::TensionFailureZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setTensionFailureZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::CompressionFailureX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setCompressionFailureX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::CompressionFailureY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setCompressionFailureY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcFailureConnectionCondition::CompressionFailureZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcFailureConnectionCondition::setCompressionFailureZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcFailureConnectionCondition::declaration() const { return *IFC2X3_IfcFailureConnectionCondition_type; }
const IfcParse::entity& Ifc2x3::IfcFailureConnectionCondition::Class() { return *IFC2X3_IfcFailureConnectionCondition_type; }
Ifc2x3::IfcFailureConnectionCondition::IfcFailureConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFailureConnectionCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFailureConnectionCondition::IfcFailureConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_TensionFailureX, boost::optional< double > v3_TensionFailureY, boost::optional< double > v4_TensionFailureZ, boost::optional< double > v5_CompressionFailureX, boost::optional< double > v6_CompressionFailureY, boost::optional< double > v7_CompressionFailureZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFailureConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_TensionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TensionFailureX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_TensionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TensionFailureY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_TensionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TensionFailureZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_CompressionFailureX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CompressionFailureX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_CompressionFailureY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_CompressionFailureY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CompressionFailureZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CompressionFailureZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcFanType
::Ifc2x3::IfcFanTypeEnum::Value Ifc2x3::IfcFanType::PredefinedType() const {  return ::Ifc2x3::IfcFanTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFanType::setPredefinedType(::Ifc2x3::IfcFanTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFanTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFanType::declaration() const { return *IFC2X3_IfcFanType_type; }
const IfcParse::entity& Ifc2x3::IfcFanType::Class() { return *IFC2X3_IfcFanType_type; }
Ifc2x3::IfcFanType::IfcFanType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFanType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFanType::IfcFanType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcFanTypeEnum::Value v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFanType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcFanTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFastener


const IfcParse::entity& Ifc2x3::IfcFastener::declaration() const { return *IFC2X3_IfcFastener_type; }
const IfcParse::entity& Ifc2x3::IfcFastener::Class() { return *IFC2X3_IfcFastener_type; }
Ifc2x3::IfcFastener::IfcFastener(IfcEntityInstanceData* e) : IfcElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFastener_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFastener::IfcFastener(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFastener_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFastenerType


const IfcParse::entity& Ifc2x3::IfcFastenerType::declaration() const { return *IFC2X3_IfcFastenerType_type; }
const IfcParse::entity& Ifc2x3::IfcFastenerType::Class() { return *IFC2X3_IfcFastenerType_type; }
Ifc2x3::IfcFastenerType::IfcFastenerType(IfcEntityInstanceData* e) : IfcElementComponentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFastenerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFastenerType::IfcFastenerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementComponentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFastenerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFeatureElement


const IfcParse::entity& Ifc2x3::IfcFeatureElement::declaration() const { return *IFC2X3_IfcFeatureElement_type; }
const IfcParse::entity& Ifc2x3::IfcFeatureElement::Class() { return *IFC2X3_IfcFeatureElement_type; }
Ifc2x3::IfcFeatureElement::IfcFeatureElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFeatureElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFeatureElement::IfcFeatureElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFeatureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementAddition

::Ifc2x3::IfcRelProjectsElement::list::ptr Ifc2x3::IfcFeatureElementAddition::ProjectsElements() const { return data_->getInverse(IFC2X3_IfcRelProjectsElement_type, 5)->as<IfcRelProjectsElement>(); }

const IfcParse::entity& Ifc2x3::IfcFeatureElementAddition::declaration() const { return *IFC2X3_IfcFeatureElementAddition_type; }
const IfcParse::entity& Ifc2x3::IfcFeatureElementAddition::Class() { return *IFC2X3_IfcFeatureElementAddition_type; }
Ifc2x3::IfcFeatureElementAddition::IfcFeatureElementAddition(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFeatureElementAddition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFeatureElementAddition::IfcFeatureElementAddition(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFeatureElementAddition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFeatureElementSubtraction

::Ifc2x3::IfcRelVoidsElement::list::ptr Ifc2x3::IfcFeatureElementSubtraction::VoidsElements() const { return data_->getInverse(IFC2X3_IfcRelVoidsElement_type, 5)->as<IfcRelVoidsElement>(); }

const IfcParse::entity& Ifc2x3::IfcFeatureElementSubtraction::declaration() const { return *IFC2X3_IfcFeatureElementSubtraction_type; }
const IfcParse::entity& Ifc2x3::IfcFeatureElementSubtraction::Class() { return *IFC2X3_IfcFeatureElementSubtraction_type; }
Ifc2x3::IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(IfcEntityInstanceData* e) : IfcFeatureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFeatureElementSubtraction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFeatureElementSubtraction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFillAreaStyle
aggregate_of_instance::ptr Ifc2x3::IfcFillAreaStyle::FillStyles() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcFillAreaStyle::setFillStyles(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcFillAreaStyle::declaration() const { return *IFC2X3_IfcFillAreaStyle_type; }
const IfcParse::entity& Ifc2x3::IfcFillAreaStyle::Class() { return *IFC2X3_IfcFillAreaStyle_type; }
Ifc2x3::IfcFillAreaStyle::IfcFillAreaStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFillAreaStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFillAreaStyle::IfcFillAreaStyle(boost::optional< std::string > v1_Name, aggregate_of_instance::ptr v2_FillStyles) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFillAreaStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_FillStyles));data_->setArgument(1,attr);} }

// Function implementations for IfcFillAreaStyleHatching
::Ifc2x3::IfcCurveStyle* Ifc2x3::IfcFillAreaStyleHatching::HatchLineAppearance() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurveStyle>(true); }
void Ifc2x3::IfcFillAreaStyleHatching::setHatchLineAppearance(::Ifc2x3::IfcCurveStyle* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcHatchLineDistanceSelect* Ifc2x3::IfcFillAreaStyleHatching::StartOfNextHatchLine() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcHatchLineDistanceSelect>(true); }
void Ifc2x3::IfcFillAreaStyleHatching::setStartOfNextHatchLine(::Ifc2x3::IfcHatchLineDistanceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcFillAreaStyleHatching::PointOfReferenceHatchLine() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcFillAreaStyleHatching::setPointOfReferenceHatchLine(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcFillAreaStyleHatching::PatternStart() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcFillAreaStyleHatching::setPatternStart(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcFillAreaStyleHatching::HatchLineAngle() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcFillAreaStyleHatching::setHatchLineAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcFillAreaStyleHatching::declaration() const { return *IFC2X3_IfcFillAreaStyleHatching_type; }
const IfcParse::entity& Ifc2x3::IfcFillAreaStyleHatching::Class() { return *IFC2X3_IfcFillAreaStyleHatching_type; }
Ifc2x3::IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFillAreaStyleHatching_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(::Ifc2x3::IfcCurveStyle* v1_HatchLineAppearance, ::Ifc2x3::IfcHatchLineDistanceSelect* v2_StartOfNextHatchLine, ::Ifc2x3::IfcCartesianPoint* v3_PointOfReferenceHatchLine, ::Ifc2x3::IfcCartesianPoint* v4_PatternStart, double v5_HatchLineAngle) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFillAreaStyleHatching_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HatchLineAppearance));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartOfNextHatchLine));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointOfReferenceHatchLine));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PatternStart));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HatchLineAngle));data_->setArgument(4,attr);} }

// Function implementations for IfcFillAreaStyleTileSymbolWithStyle
::Ifc2x3::IfcAnnotationSymbolOccurrence* Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::Symbol() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAnnotationSymbolOccurrence>(true); }
void Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::setSymbol(::Ifc2x3::IfcAnnotationSymbolOccurrence* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::declaration() const { return *IFC2X3_IfcFillAreaStyleTileSymbolWithStyle_type; }
const IfcParse::entity& Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::Class() { return *IFC2X3_IfcFillAreaStyleTileSymbolWithStyle_type; }
Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::IfcFillAreaStyleTileSymbolWithStyle(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFillAreaStyleTileSymbolWithStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFillAreaStyleTileSymbolWithStyle::IfcFillAreaStyleTileSymbolWithStyle(::Ifc2x3::IfcAnnotationSymbolOccurrence* v1_Symbol) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFillAreaStyleTileSymbolWithStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Symbol));data_->setArgument(0,attr);} }

// Function implementations for IfcFillAreaStyleTiles
::Ifc2x3::IfcOneDirectionRepeatFactor* Ifc2x3::IfcFillAreaStyleTiles::TilingPattern() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcOneDirectionRepeatFactor>(true); }
void Ifc2x3::IfcFillAreaStyleTiles::setTilingPattern(::Ifc2x3::IfcOneDirectionRepeatFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcFillAreaStyleTiles::Tiles() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcFillAreaStyleTiles::setTiles(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcFillAreaStyleTiles::TilingScale() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcFillAreaStyleTiles::setTilingScale(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcFillAreaStyleTiles::declaration() const { return *IFC2X3_IfcFillAreaStyleTiles_type; }
const IfcParse::entity& Ifc2x3::IfcFillAreaStyleTiles::Class() { return *IFC2X3_IfcFillAreaStyleTiles_type; }
Ifc2x3::IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFillAreaStyleTiles_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(::Ifc2x3::IfcOneDirectionRepeatFactor* v1_TilingPattern, aggregate_of_instance::ptr v2_Tiles, double v3_TilingScale) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFillAreaStyleTiles_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TilingPattern));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Tiles));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TilingScale));data_->setArgument(2,attr);} }

// Function implementations for IfcFilterType
::Ifc2x3::IfcFilterTypeEnum::Value Ifc2x3::IfcFilterType::PredefinedType() const {  return ::Ifc2x3::IfcFilterTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFilterType::setPredefinedType(::Ifc2x3::IfcFilterTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFilterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFilterType::declaration() const { return *IFC2X3_IfcFilterType_type; }
const IfcParse::entity& Ifc2x3::IfcFilterType::Class() { return *IFC2X3_IfcFilterType_type; }
Ifc2x3::IfcFilterType::IfcFilterType(IfcEntityInstanceData* e) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFilterType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFilterType::IfcFilterType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcFilterTypeEnum::Value v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFilterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcFilterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFireSuppressionTerminalType
::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Value Ifc2x3::IfcFireSuppressionTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFireSuppressionTerminalType::setPredefinedType(::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFireSuppressionTerminalType::declaration() const { return *IFC2X3_IfcFireSuppressionTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcFireSuppressionTerminalType::Class() { return *IFC2X3_IfcFireSuppressionTerminalType_type; }
Ifc2x3::IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFireSuppressionTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFireSuppressionTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcFireSuppressionTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFlowController


const IfcParse::entity& Ifc2x3::IfcFlowController::declaration() const { return *IFC2X3_IfcFlowController_type; }
const IfcParse::entity& Ifc2x3::IfcFlowController::Class() { return *IFC2X3_IfcFlowController_type; }
Ifc2x3::IfcFlowController::IfcFlowController(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowController_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowController::IfcFlowController(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowController_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowControllerType


const IfcParse::entity& Ifc2x3::IfcFlowControllerType::declaration() const { return *IFC2X3_IfcFlowControllerType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowControllerType::Class() { return *IFC2X3_IfcFlowControllerType_type; }
Ifc2x3::IfcFlowControllerType::IfcFlowControllerType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowControllerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowControllerType::IfcFlowControllerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowControllerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowFitting


const IfcParse::entity& Ifc2x3::IfcFlowFitting::declaration() const { return *IFC2X3_IfcFlowFitting_type; }
const IfcParse::entity& Ifc2x3::IfcFlowFitting::Class() { return *IFC2X3_IfcFlowFitting_type; }
Ifc2x3::IfcFlowFitting::IfcFlowFitting(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowFitting_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowFitting::IfcFlowFitting(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowFitting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowFittingType


const IfcParse::entity& Ifc2x3::IfcFlowFittingType::declaration() const { return *IFC2X3_IfcFlowFittingType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowFittingType::Class() { return *IFC2X3_IfcFlowFittingType_type; }
Ifc2x3::IfcFlowFittingType::IfcFlowFittingType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowFittingType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowFittingType::IfcFlowFittingType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowInstrumentType
::Ifc2x3::IfcFlowInstrumentTypeEnum::Value Ifc2x3::IfcFlowInstrumentType::PredefinedType() const {  return ::Ifc2x3::IfcFlowInstrumentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFlowInstrumentType::setPredefinedType(::Ifc2x3::IfcFlowInstrumentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFlowInstrumentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFlowInstrumentType::declaration() const { return *IFC2X3_IfcFlowInstrumentType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowInstrumentType::Class() { return *IFC2X3_IfcFlowInstrumentType_type; }
Ifc2x3::IfcFlowInstrumentType::IfcFlowInstrumentType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowInstrumentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowInstrumentType::IfcFlowInstrumentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcFlowInstrumentTypeEnum::Value v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowInstrumentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcFlowInstrumentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFlowMeterType
::Ifc2x3::IfcFlowMeterTypeEnum::Value Ifc2x3::IfcFlowMeterType::PredefinedType() const {  return ::Ifc2x3::IfcFlowMeterTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFlowMeterType::setPredefinedType(::Ifc2x3::IfcFlowMeterTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFlowMeterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFlowMeterType::declaration() const { return *IFC2X3_IfcFlowMeterType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowMeterType::Class() { return *IFC2X3_IfcFlowMeterType_type; }
Ifc2x3::IfcFlowMeterType::IfcFlowMeterType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowMeterType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowMeterType::IfcFlowMeterType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcFlowMeterTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowMeterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcFlowMeterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcFlowMovingDevice


const IfcParse::entity& Ifc2x3::IfcFlowMovingDevice::declaration() const { return *IFC2X3_IfcFlowMovingDevice_type; }
const IfcParse::entity& Ifc2x3::IfcFlowMovingDevice::Class() { return *IFC2X3_IfcFlowMovingDevice_type; }
Ifc2x3::IfcFlowMovingDevice::IfcFlowMovingDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowMovingDevice_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowMovingDevice::IfcFlowMovingDevice(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowMovingDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowMovingDeviceType


const IfcParse::entity& Ifc2x3::IfcFlowMovingDeviceType::declaration() const { return *IFC2X3_IfcFlowMovingDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowMovingDeviceType::Class() { return *IFC2X3_IfcFlowMovingDeviceType_type; }
Ifc2x3::IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowMovingDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowMovingDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowSegment


const IfcParse::entity& Ifc2x3::IfcFlowSegment::declaration() const { return *IFC2X3_IfcFlowSegment_type; }
const IfcParse::entity& Ifc2x3::IfcFlowSegment::Class() { return *IFC2X3_IfcFlowSegment_type; }
Ifc2x3::IfcFlowSegment::IfcFlowSegment(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowSegment_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowSegment::IfcFlowSegment(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowSegment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowSegmentType


const IfcParse::entity& Ifc2x3::IfcFlowSegmentType::declaration() const { return *IFC2X3_IfcFlowSegmentType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowSegmentType::Class() { return *IFC2X3_IfcFlowSegmentType_type; }
Ifc2x3::IfcFlowSegmentType::IfcFlowSegmentType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowSegmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowSegmentType::IfcFlowSegmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowStorageDevice


const IfcParse::entity& Ifc2x3::IfcFlowStorageDevice::declaration() const { return *IFC2X3_IfcFlowStorageDevice_type; }
const IfcParse::entity& Ifc2x3::IfcFlowStorageDevice::Class() { return *IFC2X3_IfcFlowStorageDevice_type; }
Ifc2x3::IfcFlowStorageDevice::IfcFlowStorageDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowStorageDevice_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowStorageDevice::IfcFlowStorageDevice(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowStorageDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowStorageDeviceType


const IfcParse::entity& Ifc2x3::IfcFlowStorageDeviceType::declaration() const { return *IFC2X3_IfcFlowStorageDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowStorageDeviceType::Class() { return *IFC2X3_IfcFlowStorageDeviceType_type; }
Ifc2x3::IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowStorageDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowStorageDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowTerminal


const IfcParse::entity& Ifc2x3::IfcFlowTerminal::declaration() const { return *IFC2X3_IfcFlowTerminal_type; }
const IfcParse::entity& Ifc2x3::IfcFlowTerminal::Class() { return *IFC2X3_IfcFlowTerminal_type; }
Ifc2x3::IfcFlowTerminal::IfcFlowTerminal(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowTerminal_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowTerminal::IfcFlowTerminal(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowTerminal_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowTerminalType


const IfcParse::entity& Ifc2x3::IfcFlowTerminalType::declaration() const { return *IFC2X3_IfcFlowTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowTerminalType::Class() { return *IFC2X3_IfcFlowTerminalType_type; }
Ifc2x3::IfcFlowTerminalType::IfcFlowTerminalType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowTerminalType::IfcFlowTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFlowTreatmentDevice


const IfcParse::entity& Ifc2x3::IfcFlowTreatmentDevice::declaration() const { return *IFC2X3_IfcFlowTreatmentDevice_type; }
const IfcParse::entity& Ifc2x3::IfcFlowTreatmentDevice::Class() { return *IFC2X3_IfcFlowTreatmentDevice_type; }
Ifc2x3::IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(IfcEntityInstanceData* e) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowTreatmentDevice_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcDistributionFlowElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowTreatmentDevice_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFlowTreatmentDeviceType


const IfcParse::entity& Ifc2x3::IfcFlowTreatmentDeviceType::declaration() const { return *IFC2X3_IfcFlowTreatmentDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcFlowTreatmentDeviceType::Class() { return *IFC2X3_IfcFlowTreatmentDeviceType_type; }
Ifc2x3::IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(IfcEntityInstanceData* e) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFlowTreatmentDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcDistributionFlowElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFlowTreatmentDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFluidFlowProperties
::Ifc2x3::IfcPropertySourceEnum::Value Ifc2x3::IfcFluidFlowProperties::PropertySource() const {  return ::Ifc2x3::IfcPropertySourceEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcFluidFlowProperties::setPropertySource(::Ifc2x3::IfcPropertySourceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPropertySourceEnum::ToString(v)));data_->setArgument(4,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::FlowConditionTimeSeries() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setFlowConditionTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::VelocityTimeSeries() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setVelocityTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::FlowrateTimeSeries() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setFlowrateTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcMaterial* Ifc2x3::IfcFluidFlowProperties::Fluid() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcMaterial>(true); }
void Ifc2x3::IfcFluidFlowProperties::setFluid(::Ifc2x3::IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::PressureTimeSeries() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setPressureTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
boost::optional< std::string > Ifc2x3::IfcFluidFlowProperties::UserDefinedPropertySource() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } std::string v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcFluidFlowProperties::setUserDefinedPropertySource(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcFluidFlowProperties::TemperatureSingleValue() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcFluidFlowProperties::setTemperatureSingleValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcFluidFlowProperties::WetBulbTemperatureSingleValue() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcFluidFlowProperties::setWetBulbTemperatureSingleValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::WetBulbTemperatureTimeSeries() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(13)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setWetBulbTemperatureTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcFluidFlowProperties::TemperatureTimeSeries() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(14)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcFluidFlowProperties::setTemperatureTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
::Ifc2x3::IfcDerivedMeasureValue* Ifc2x3::IfcFluidFlowProperties::FlowrateSingleValue() const { if(!data_->getArgument(15) || data_->getArgument(15)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(15)))->as<::Ifc2x3::IfcDerivedMeasureValue>(true); }
void Ifc2x3::IfcFluidFlowProperties::setFlowrateSingleValue(::Ifc2x3::IfcDerivedMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
boost::optional< double > Ifc2x3::IfcFluidFlowProperties::FlowConditionSingleValue() const { if(!data_->getArgument(16) || data_->getArgument(16)->isNull()) { return boost::none; } double v = *data_->getArgument(16); return v; }
void Ifc2x3::IfcFluidFlowProperties::setFlowConditionSingleValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(16,attr);} }
boost::optional< double > Ifc2x3::IfcFluidFlowProperties::VelocitySingleValue() const { if(!data_->getArgument(17) || data_->getArgument(17)->isNull()) { return boost::none; } double v = *data_->getArgument(17); return v; }
void Ifc2x3::IfcFluidFlowProperties::setVelocitySingleValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(17,attr);} }
boost::optional< double > Ifc2x3::IfcFluidFlowProperties::PressureSingleValue() const { if(!data_->getArgument(18) || data_->getArgument(18)->isNull()) { return boost::none; } double v = *data_->getArgument(18); return v; }
void Ifc2x3::IfcFluidFlowProperties::setPressureSingleValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(18,attr);} }


const IfcParse::entity& Ifc2x3::IfcFluidFlowProperties::declaration() const { return *IFC2X3_IfcFluidFlowProperties_type; }
const IfcParse::entity& Ifc2x3::IfcFluidFlowProperties::Class() { return *IFC2X3_IfcFluidFlowProperties_type; }
Ifc2x3::IfcFluidFlowProperties::IfcFluidFlowProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFluidFlowProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFluidFlowProperties::IfcFluidFlowProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcPropertySourceEnum::Value v5_PropertySource, ::Ifc2x3::IfcTimeSeries* v6_FlowConditionTimeSeries, ::Ifc2x3::IfcTimeSeries* v7_VelocityTimeSeries, ::Ifc2x3::IfcTimeSeries* v8_FlowrateTimeSeries, ::Ifc2x3::IfcMaterial* v9_Fluid, ::Ifc2x3::IfcTimeSeries* v10_PressureTimeSeries, boost::optional< std::string > v11_UserDefinedPropertySource, boost::optional< double > v12_TemperatureSingleValue, boost::optional< double > v13_WetBulbTemperatureSingleValue, ::Ifc2x3::IfcTimeSeries* v14_WetBulbTemperatureTimeSeries, ::Ifc2x3::IfcTimeSeries* v15_TemperatureTimeSeries, ::Ifc2x3::IfcDerivedMeasureValue* v16_FlowrateSingleValue, boost::optional< double > v17_FlowConditionSingleValue, boost::optional< double > v18_VelocitySingleValue, boost::optional< double > v19_PressureSingleValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFluidFlowProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_PropertySource,::Ifc2x3::IfcPropertySourceEnum::ToString(v5_PropertySource))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FlowConditionTimeSeries));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_VelocityTimeSeries));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_FlowrateTimeSeries));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Fluid));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_PressureTimeSeries));data_->setArgument(9,attr);} if (v11_UserDefinedPropertySource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UserDefinedPropertySource));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_TemperatureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_TemperatureSingleValue));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_WetBulbTemperatureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_WetBulbTemperatureSingleValue));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_WetBulbTemperatureTimeSeries));data_->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_TemperatureTimeSeries));data_->setArgument(14,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v16_FlowrateSingleValue));data_->setArgument(15,attr);} if (v17_FlowConditionSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_FlowConditionSingleValue));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_VelocitySingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_VelocitySingleValue));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_PressureSingleValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_PressureSingleValue));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } }

// Function implementations for IfcFooting
::Ifc2x3::IfcFootingTypeEnum::Value Ifc2x3::IfcFooting::PredefinedType() const {  return ::Ifc2x3::IfcFootingTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcFooting::setPredefinedType(::Ifc2x3::IfcFootingTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcFootingTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcFooting::declaration() const { return *IFC2X3_IfcFooting_type; }
const IfcParse::entity& Ifc2x3::IfcFooting::Class() { return *IFC2X3_IfcFooting_type; }
Ifc2x3::IfcFooting::IfcFooting(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFooting_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFooting::IfcFooting(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcFootingTypeEnum::Value v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFooting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_PredefinedType,::Ifc2x3::IfcFootingTypeEnum::ToString(v9_PredefinedType))));data_->setArgument(8,attr);} }

// Function implementations for IfcFuelProperties
boost::optional< double > Ifc2x3::IfcFuelProperties::CombustionTemperature() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcFuelProperties::setCombustionTemperature(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcFuelProperties::CarbonContent() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcFuelProperties::setCarbonContent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcFuelProperties::LowerHeatingValue() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcFuelProperties::setLowerHeatingValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcFuelProperties::HigherHeatingValue() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcFuelProperties::setHigherHeatingValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcFuelProperties::declaration() const { return *IFC2X3_IfcFuelProperties_type; }
const IfcParse::entity& Ifc2x3::IfcFuelProperties::Class() { return *IFC2X3_IfcFuelProperties_type; }
Ifc2x3::IfcFuelProperties::IfcFuelProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFuelProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFuelProperties::IfcFuelProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_CombustionTemperature, boost::optional< double > v3_CarbonContent, boost::optional< double > v4_LowerHeatingValue, boost::optional< double > v5_HigherHeatingValue) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFuelProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_CombustionTemperature) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_CombustionTemperature));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_CarbonContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_CarbonContent));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LowerHeatingValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LowerHeatingValue));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_HigherHeatingValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_HigherHeatingValue));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcFurnishingElement


const IfcParse::entity& Ifc2x3::IfcFurnishingElement::declaration() const { return *IFC2X3_IfcFurnishingElement_type; }
const IfcParse::entity& Ifc2x3::IfcFurnishingElement::Class() { return *IFC2X3_IfcFurnishingElement_type; }
Ifc2x3::IfcFurnishingElement::IfcFurnishingElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFurnishingElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFurnishingElement::IfcFurnishingElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFurnishingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcFurnishingElementType


const IfcParse::entity& Ifc2x3::IfcFurnishingElementType::declaration() const { return *IFC2X3_IfcFurnishingElementType_type; }
const IfcParse::entity& Ifc2x3::IfcFurnishingElementType::Class() { return *IFC2X3_IfcFurnishingElementType_type; }
Ifc2x3::IfcFurnishingElementType::IfcFurnishingElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFurnishingElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFurnishingElementType::IfcFurnishingElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFurnishingElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcFurnitureStandard


const IfcParse::entity& Ifc2x3::IfcFurnitureStandard::declaration() const { return *IFC2X3_IfcFurnitureStandard_type; }
const IfcParse::entity& Ifc2x3::IfcFurnitureStandard::Class() { return *IFC2X3_IfcFurnitureStandard_type; }
Ifc2x3::IfcFurnitureStandard::IfcFurnitureStandard(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFurnitureStandard_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFurnitureStandard::IfcFurnitureStandard(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFurnitureStandard_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcFurnitureType
::Ifc2x3::IfcAssemblyPlaceEnum::Value Ifc2x3::IfcFurnitureType::AssemblyPlace() const {  return ::Ifc2x3::IfcAssemblyPlaceEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcFurnitureType::setAssemblyPlace(::Ifc2x3::IfcAssemblyPlaceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAssemblyPlaceEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcFurnitureType::declaration() const { return *IFC2X3_IfcFurnitureType_type; }
const IfcParse::entity& Ifc2x3::IfcFurnitureType::Class() { return *IFC2X3_IfcFurnitureType_type; }
Ifc2x3::IfcFurnitureType::IfcFurnitureType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcFurnitureType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcFurnitureType::IfcFurnitureType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcAssemblyPlaceEnum::Value v10_AssemblyPlace) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcFurnitureType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_AssemblyPlace,::Ifc2x3::IfcAssemblyPlaceEnum::ToString(v10_AssemblyPlace))));data_->setArgument(9,attr);} }

// Function implementations for IfcGasTerminalType
::Ifc2x3::IfcGasTerminalTypeEnum::Value Ifc2x3::IfcGasTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcGasTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcGasTerminalType::setPredefinedType(::Ifc2x3::IfcGasTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcGasTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcGasTerminalType::declaration() const { return *IFC2X3_IfcGasTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcGasTerminalType::Class() { return *IFC2X3_IfcGasTerminalType_type; }
Ifc2x3::IfcGasTerminalType::IfcGasTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGasTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGasTerminalType::IfcGasTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcGasTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGasTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcGasTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcGeneralMaterialProperties
boost::optional< double > Ifc2x3::IfcGeneralMaterialProperties::MolecularWeight() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcGeneralMaterialProperties::setMolecularWeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralMaterialProperties::Porosity() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcGeneralMaterialProperties::setPorosity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralMaterialProperties::MassDensity() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcGeneralMaterialProperties::setMassDensity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcGeneralMaterialProperties::declaration() const { return *IFC2X3_IfcGeneralMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcGeneralMaterialProperties::Class() { return *IFC2X3_IfcGeneralMaterialProperties_type; }
Ifc2x3::IfcGeneralMaterialProperties::IfcGeneralMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeneralMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeneralMaterialProperties::IfcGeneralMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_MolecularWeight, boost::optional< double > v3_Porosity, boost::optional< double > v4_MassDensity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeneralMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_MolecularWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MolecularWeight));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Porosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Porosity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_MassDensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MassDensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcGeneralProfileProperties
boost::optional< double > Ifc2x3::IfcGeneralProfileProperties::PhysicalWeight() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcGeneralProfileProperties::setPhysicalWeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralProfileProperties::Perimeter() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcGeneralProfileProperties::setPerimeter(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralProfileProperties::MinimumPlateThickness() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcGeneralProfileProperties::setMinimumPlateThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralProfileProperties::MaximumPlateThickness() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcGeneralProfileProperties::setMaximumPlateThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcGeneralProfileProperties::CrossSectionArea() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcGeneralProfileProperties::setCrossSectionArea(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcGeneralProfileProperties::declaration() const { return *IFC2X3_IfcGeneralProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcGeneralProfileProperties::Class() { return *IFC2X3_IfcGeneralProfileProperties_type; }
Ifc2x3::IfcGeneralProfileProperties::IfcGeneralProfileProperties(IfcEntityInstanceData* e) : IfcProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeneralProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeneralProfileProperties::IfcGeneralProfileProperties(boost::optional< std::string > v1_ProfileName, ::Ifc2x3::IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea) : IfcProfileProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeneralProfileProperties_type);  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));data_->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcGeometricCurveSet


const IfcParse::entity& Ifc2x3::IfcGeometricCurveSet::declaration() const { return *IFC2X3_IfcGeometricCurveSet_type; }
const IfcParse::entity& Ifc2x3::IfcGeometricCurveSet::Class() { return *IFC2X3_IfcGeometricCurveSet_type; }
Ifc2x3::IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntityInstanceData* e) : IfcGeometricSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeometricCurveSet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeometricCurveSet::IfcGeometricCurveSet(aggregate_of_instance::ptr v1_Elements) : IfcGeometricSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricCurveSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));data_->setArgument(0,attr);} }

// Function implementations for IfcGeometricRepresentationContext
int Ifc2x3::IfcGeometricRepresentationContext::CoordinateSpaceDimension() const {  int v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcGeometricRepresentationContext::setCoordinateSpaceDimension(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcGeometricRepresentationContext::Precision() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcGeometricRepresentationContext::setPrecision(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcGeometricRepresentationContext::WorldCoordinateSystem() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcGeometricRepresentationContext::setWorldCoordinateSystem(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcDirection* Ifc2x3::IfcGeometricRepresentationContext::TrueNorth() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcGeometricRepresentationContext::setTrueNorth(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }

::Ifc2x3::IfcGeometricRepresentationSubContext::list::ptr Ifc2x3::IfcGeometricRepresentationContext::HasSubContexts() const { return data_->getInverse(IFC2X3_IfcGeometricRepresentationSubContext_type, 6)->as<IfcGeometricRepresentationSubContext>(); }

const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationContext::declaration() const { return *IFC2X3_IfcGeometricRepresentationContext_type; }
const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationContext::Class() { return *IFC2X3_IfcGeometricRepresentationContext_type; }
Ifc2x3::IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(IfcEntityInstanceData* e) : IfcRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeometricRepresentationContext_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, int v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, ::Ifc2x3::IfcAxis2Placement* v5_WorldCoordinateSystem, ::Ifc2x3::IfcDirection* v6_TrueNorth) : IfcRepresentationContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricRepresentationContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CoordinateSpaceDimension));data_->setArgument(2,attr);} if (v4_Precision) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Precision));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WorldCoordinateSystem));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TrueNorth));data_->setArgument(5,attr);} }

// Function implementations for IfcGeometricRepresentationItem


const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationItem::declaration() const { return *IFC2X3_IfcGeometricRepresentationItem_type; }
const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationItem::Class() { return *IFC2X3_IfcGeometricRepresentationItem_type; }
Ifc2x3::IfcGeometricRepresentationItem::IfcGeometricRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeometricRepresentationItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeometricRepresentationItem::IfcGeometricRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricRepresentationItem_type);  }

// Function implementations for IfcGeometricRepresentationSubContext
::Ifc2x3::IfcGeometricRepresentationContext* Ifc2x3::IfcGeometricRepresentationSubContext::ParentContext() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcGeometricRepresentationContext>(true); }
void Ifc2x3::IfcGeometricRepresentationSubContext::setParentContext(::Ifc2x3::IfcGeometricRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcGeometricRepresentationSubContext::TargetScale() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcGeometricRepresentationSubContext::setTargetScale(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcGeometricProjectionEnum::Value Ifc2x3::IfcGeometricRepresentationSubContext::TargetView() const {  return ::Ifc2x3::IfcGeometricProjectionEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcGeometricRepresentationSubContext::setTargetView(::Ifc2x3::IfcGeometricProjectionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcGeometricProjectionEnum::ToString(v)));data_->setArgument(8,attr);} }
boost::optional< std::string > Ifc2x3::IfcGeometricRepresentationSubContext::UserDefinedTargetView() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcGeometricRepresentationSubContext::setUserDefinedTargetView(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationSubContext::declaration() const { return *IFC2X3_IfcGeometricRepresentationSubContext_type; }
const IfcParse::entity& Ifc2x3::IfcGeometricRepresentationSubContext::Class() { return *IFC2X3_IfcGeometricRepresentationSubContext_type; }
Ifc2x3::IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(IfcEntityInstanceData* e) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeometricRepresentationSubContext_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, ::Ifc2x3::IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< double > v8_TargetScale, ::Ifc2x3::IfcGeometricProjectionEnum::Value v9_TargetView, boost::optional< std::string > v10_UserDefinedTargetView) : IfcGeometricRepresentationContext((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricRepresentationSubContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ParentContext));data_->setArgument(6,attr);} if (v8_TargetScale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TargetScale));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_TargetView,::Ifc2x3::IfcGeometricProjectionEnum::ToString(v9_TargetView))));data_->setArgument(8,attr);} if (v10_UserDefinedTargetView) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_UserDefinedTargetView));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcGeometricSet
aggregate_of_instance::ptr Ifc2x3::IfcGeometricSet::Elements() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcGeometricSet::setElements(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcGeometricSet::declaration() const { return *IFC2X3_IfcGeometricSet_type; }
const IfcParse::entity& Ifc2x3::IfcGeometricSet::Class() { return *IFC2X3_IfcGeometricSet_type; }
Ifc2x3::IfcGeometricSet::IfcGeometricSet(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGeometricSet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGeometricSet::IfcGeometricSet(aggregate_of_instance::ptr v1_Elements) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGeometricSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Elements));data_->setArgument(0,attr);} }

// Function implementations for IfcGrid
aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr Ifc2x3::IfcGrid::UAxes() const {  aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcGridAxis >(); }
void Ifc2x3::IfcGrid::setUAxes(aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(7,attr);} }
aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr Ifc2x3::IfcGrid::VAxes() const {  aggregate_of_instance::ptr es = *data_->getArgument(8); return es->as< ::Ifc2x3::IfcGridAxis >(); }
void Ifc2x3::IfcGrid::setVAxes(aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(8,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr > Ifc2x3::IfcGrid::WAxes() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(9); return es->as< ::Ifc2x3::IfcGridAxis >(); }
void Ifc2x3::IfcGrid::setWAxes(boost::optional< aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(9,attr);} }

::Ifc2x3::IfcRelContainedInSpatialStructure::list::ptr Ifc2x3::IfcGrid::ContainedInStructure() const { return data_->getInverse(IFC2X3_IfcRelContainedInSpatialStructure_type, 4)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& Ifc2x3::IfcGrid::declaration() const { return *IFC2X3_IfcGrid_type; }
const IfcParse::entity& Ifc2x3::IfcGrid::Class() { return *IFC2X3_IfcGrid_type; }
Ifc2x3::IfcGrid::IfcGrid(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGrid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGrid::IfcGrid(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v8_UAxes, aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v9_VAxes, boost::optional< aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr > v10_WAxes) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGrid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_UAxes)->generalize());data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_VAxes)->generalize());data_->setArgument(8,attr);} if (v10_WAxes) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WAxes)->generalize());data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcGridAxis
boost::optional< std::string > Ifc2x3::IfcGridAxis::AxisTag() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcGridAxis::setAxisTag(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
::Ifc2x3::IfcCurve* Ifc2x3::IfcGridAxis::AxisCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcGridAxis::setAxisCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
bool Ifc2x3::IfcGridAxis::SameSense() const {  bool v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcGridAxis::setSameSense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }

::Ifc2x3::IfcGrid::list::ptr Ifc2x3::IfcGridAxis::PartOfW() const { return data_->getInverse(IFC2X3_IfcGrid_type, 9)->as<IfcGrid>(); }
::Ifc2x3::IfcGrid::list::ptr Ifc2x3::IfcGridAxis::PartOfV() const { return data_->getInverse(IFC2X3_IfcGrid_type, 8)->as<IfcGrid>(); }
::Ifc2x3::IfcGrid::list::ptr Ifc2x3::IfcGridAxis::PartOfU() const { return data_->getInverse(IFC2X3_IfcGrid_type, 7)->as<IfcGrid>(); }
::Ifc2x3::IfcVirtualGridIntersection::list::ptr Ifc2x3::IfcGridAxis::HasIntersections() const { return data_->getInverse(IFC2X3_IfcVirtualGridIntersection_type, 0)->as<IfcVirtualGridIntersection>(); }

const IfcParse::entity& Ifc2x3::IfcGridAxis::declaration() const { return *IFC2X3_IfcGridAxis_type; }
const IfcParse::entity& Ifc2x3::IfcGridAxis::Class() { return *IFC2X3_IfcGridAxis_type; }
Ifc2x3::IfcGridAxis::IfcGridAxis(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcGridAxis_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGridAxis::IfcGridAxis(boost::optional< std::string > v1_AxisTag, ::Ifc2x3::IfcCurve* v2_AxisCurve, bool v3_SameSense) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcGridAxis_type);  if (v1_AxisTag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_AxisTag));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AxisCurve));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SameSense));data_->setArgument(2,attr);} }

// Function implementations for IfcGridPlacement
::Ifc2x3::IfcVirtualGridIntersection* Ifc2x3::IfcGridPlacement::PlacementLocation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcVirtualGridIntersection>(true); }
void Ifc2x3::IfcGridPlacement::setPlacementLocation(::Ifc2x3::IfcVirtualGridIntersection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcVirtualGridIntersection* Ifc2x3::IfcGridPlacement::PlacementRefDirection() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcVirtualGridIntersection>(true); }
void Ifc2x3::IfcGridPlacement::setPlacementRefDirection(::Ifc2x3::IfcVirtualGridIntersection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcGridPlacement::declaration() const { return *IFC2X3_IfcGridPlacement_type; }
const IfcParse::entity& Ifc2x3::IfcGridPlacement::Class() { return *IFC2X3_IfcGridPlacement_type; }
Ifc2x3::IfcGridPlacement::IfcGridPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGridPlacement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGridPlacement::IfcGridPlacement(::Ifc2x3::IfcVirtualGridIntersection* v1_PlacementLocation, ::Ifc2x3::IfcVirtualGridIntersection* v2_PlacementRefDirection) : IfcObjectPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGridPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementLocation));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PlacementRefDirection));data_->setArgument(1,attr);} }

// Function implementations for IfcGroup

::Ifc2x3::IfcRelAssignsToGroup::list::ptr Ifc2x3::IfcGroup::IsGroupedBy() const { return data_->getInverse(IFC2X3_IfcRelAssignsToGroup_type, 6)->as<IfcRelAssignsToGroup>(); }

const IfcParse::entity& Ifc2x3::IfcGroup::declaration() const { return *IFC2X3_IfcGroup_type; }
const IfcParse::entity& Ifc2x3::IfcGroup::Class() { return *IFC2X3_IfcGroup_type; }
Ifc2x3::IfcGroup::IfcGroup(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcGroup_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcGroup::IfcGroup(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcHalfSpaceSolid
::Ifc2x3::IfcSurface* Ifc2x3::IfcHalfSpaceSolid::BaseSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcSurface>(true); }
void Ifc2x3::IfcHalfSpaceSolid::setBaseSurface(::Ifc2x3::IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool Ifc2x3::IfcHalfSpaceSolid::AgreementFlag() const {  bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcHalfSpaceSolid::setAgreementFlag(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcHalfSpaceSolid::declaration() const { return *IFC2X3_IfcHalfSpaceSolid_type; }
const IfcParse::entity& Ifc2x3::IfcHalfSpaceSolid::Class() { return *IFC2X3_IfcHalfSpaceSolid_type; }
Ifc2x3::IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcHalfSpaceSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcHalfSpaceSolid::IfcHalfSpaceSolid(::Ifc2x3::IfcSurface* v1_BaseSurface, bool v2_AgreementFlag) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcHalfSpaceSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);} }

// Function implementations for IfcHeatExchangerType
::Ifc2x3::IfcHeatExchangerTypeEnum::Value Ifc2x3::IfcHeatExchangerType::PredefinedType() const {  return ::Ifc2x3::IfcHeatExchangerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcHeatExchangerType::setPredefinedType(::Ifc2x3::IfcHeatExchangerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcHeatExchangerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcHeatExchangerType::declaration() const { return *IFC2X3_IfcHeatExchangerType_type; }
const IfcParse::entity& Ifc2x3::IfcHeatExchangerType::Class() { return *IFC2X3_IfcHeatExchangerType_type; }
Ifc2x3::IfcHeatExchangerType::IfcHeatExchangerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcHeatExchangerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcHeatExchangerType::IfcHeatExchangerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcHeatExchangerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcHeatExchangerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcHeatExchangerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcHumidifierType
::Ifc2x3::IfcHumidifierTypeEnum::Value Ifc2x3::IfcHumidifierType::PredefinedType() const {  return ::Ifc2x3::IfcHumidifierTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcHumidifierType::setPredefinedType(::Ifc2x3::IfcHumidifierTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcHumidifierTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcHumidifierType::declaration() const { return *IFC2X3_IfcHumidifierType_type; }
const IfcParse::entity& Ifc2x3::IfcHumidifierType::Class() { return *IFC2X3_IfcHumidifierType_type; }
Ifc2x3::IfcHumidifierType::IfcHumidifierType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcHumidifierType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcHumidifierType::IfcHumidifierType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcHumidifierTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcHumidifierType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcHumidifierTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcHygroscopicMaterialProperties
boost::optional< double > Ifc2x3::IfcHygroscopicMaterialProperties::UpperVaporResistanceFactor() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcHygroscopicMaterialProperties::setUpperVaporResistanceFactor(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcHygroscopicMaterialProperties::LowerVaporResistanceFactor() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcHygroscopicMaterialProperties::setLowerVaporResistanceFactor(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcHygroscopicMaterialProperties::IsothermalMoistureCapacity() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcHygroscopicMaterialProperties::setIsothermalMoistureCapacity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcHygroscopicMaterialProperties::VaporPermeability() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcHygroscopicMaterialProperties::setVaporPermeability(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcHygroscopicMaterialProperties::MoistureDiffusivity() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcHygroscopicMaterialProperties::setMoistureDiffusivity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcHygroscopicMaterialProperties::declaration() const { return *IFC2X3_IfcHygroscopicMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcHygroscopicMaterialProperties::Class() { return *IFC2X3_IfcHygroscopicMaterialProperties_type; }
Ifc2x3::IfcHygroscopicMaterialProperties::IfcHygroscopicMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcHygroscopicMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcHygroscopicMaterialProperties::IfcHygroscopicMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_UpperVaporResistanceFactor, boost::optional< double > v3_LowerVaporResistanceFactor, boost::optional< double > v4_IsothermalMoistureCapacity, boost::optional< double > v5_VaporPermeability, boost::optional< double > v6_MoistureDiffusivity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcHygroscopicMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_UpperVaporResistanceFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_UpperVaporResistanceFactor));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LowerVaporResistanceFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LowerVaporResistanceFactor));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_IsothermalMoistureCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_IsothermalMoistureCapacity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_VaporPermeability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_VaporPermeability));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MoistureDiffusivity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MoistureDiffusivity));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcIShapeProfileDef
double Ifc2x3::IfcIShapeProfileDef::OverallWidth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcIShapeProfileDef::setOverallWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcIShapeProfileDef::OverallDepth() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcIShapeProfileDef::setOverallDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcIShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcIShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcIShapeProfileDef::FlangeThickness() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcIShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcIShapeProfileDef::FilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcIShapeProfileDef::setFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcIShapeProfileDef::declaration() const { return *IFC2X3_IfcIShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcIShapeProfileDef::Class() { return *IFC2X3_IfcIShapeProfileDef_type; }
Ifc2x3::IfcIShapeProfileDef::IfcIShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcIShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcIShapeProfileDef::IfcIShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcIShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OverallWidth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_OverallDepth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcImageTexture
std::string Ifc2x3::IfcImageTexture::UrlReference() const {  std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcImageTexture::setUrlReference(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcImageTexture::declaration() const { return *IFC2X3_IfcImageTexture_type; }
const IfcParse::entity& Ifc2x3::IfcImageTexture::Class() { return *IFC2X3_IfcImageTexture_type; }
Ifc2x3::IfcImageTexture::IfcImageTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcImageTexture_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcImageTexture::IfcImageTexture(bool v1_RepeatS, bool v2_RepeatT, ::Ifc2x3::IfcSurfaceTextureEnum::Value v3_TextureType, ::Ifc2x3::IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_UrlReference) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcImageTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,::Ifc2x3::IfcSurfaceTextureEnum::ToString(v3_TextureType))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_UrlReference));data_->setArgument(4,attr);} }

// Function implementations for IfcInventory
::Ifc2x3::IfcInventoryTypeEnum::Value Ifc2x3::IfcInventory::InventoryType() const {  return ::Ifc2x3::IfcInventoryTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcInventory::setInventoryType(::Ifc2x3::IfcInventoryTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcInventoryTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcInventory::Jurisdiction() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcInventory::setJurisdiction(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
aggregate_of< ::Ifc2x3::IfcPerson >::ptr Ifc2x3::IfcInventory::ResponsiblePersons() const {  aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcPerson >(); }
void Ifc2x3::IfcInventory::setResponsiblePersons(aggregate_of< ::Ifc2x3::IfcPerson >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(7,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcInventory::LastUpdateDate() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcInventory::setLastUpdateDate(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcInventory::CurrentValue() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcInventory::setCurrentValue(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
::Ifc2x3::IfcCostValue* Ifc2x3::IfcInventory::OriginalValue() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcCostValue>(true); }
void Ifc2x3::IfcInventory::setOriginalValue(::Ifc2x3::IfcCostValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcInventory::declaration() const { return *IFC2X3_IfcInventory_type; }
const IfcParse::entity& Ifc2x3::IfcInventory::Class() { return *IFC2X3_IfcInventory_type; }
Ifc2x3::IfcInventory::IfcInventory(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcInventory_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcInventory::IfcInventory(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcInventoryTypeEnum::Value v6_InventoryType, ::Ifc2x3::IfcActorSelect* v7_Jurisdiction, aggregate_of< ::Ifc2x3::IfcPerson >::ptr v8_ResponsiblePersons, ::Ifc2x3::IfcCalendarDate* v9_LastUpdateDate, ::Ifc2x3::IfcCostValue* v10_CurrentValue, ::Ifc2x3::IfcCostValue* v11_OriginalValue) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcInventory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_InventoryType,::Ifc2x3::IfcInventoryTypeEnum::ToString(v6_InventoryType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Jurisdiction));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ResponsiblePersons)->generalize());data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_LastUpdateDate));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_CurrentValue));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_OriginalValue));data_->setArgument(10,attr);} }

// Function implementations for IfcIrregularTimeSeries
aggregate_of< ::Ifc2x3::IfcIrregularTimeSeriesValue >::ptr Ifc2x3::IfcIrregularTimeSeries::Values() const {  aggregate_of_instance::ptr es = *data_->getArgument(8); return es->as< ::Ifc2x3::IfcIrregularTimeSeriesValue >(); }
void Ifc2x3::IfcIrregularTimeSeries::setValues(aggregate_of< ::Ifc2x3::IfcIrregularTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcIrregularTimeSeries::declaration() const { return *IFC2X3_IfcIrregularTimeSeries_type; }
const IfcParse::entity& Ifc2x3::IfcIrregularTimeSeries::Class() { return *IFC2X3_IfcIrregularTimeSeries_type; }
Ifc2x3::IfcIrregularTimeSeries::IfcIrregularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcIrregularTimeSeries_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcIrregularTimeSeries::IfcIrregularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDateTimeSelect* v3_StartTime, ::Ifc2x3::IfcDateTimeSelect* v4_EndTime, ::Ifc2x3::IfcTimeSeriesDataTypeEnum::Value v5_TimeSeriesDataType, ::Ifc2x3::IfcDataOriginEnum::Value v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, ::Ifc2x3::IfcUnit* v8_Unit, aggregate_of< ::Ifc2x3::IfcIrregularTimeSeriesValue >::ptr v9_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcIrregularTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,::Ifc2x3::IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,::Ifc2x3::IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_Values)->generalize());data_->setArgument(8,attr);} }

// Function implementations for IfcIrregularTimeSeriesValue
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcIrregularTimeSeriesValue::TimeStamp() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcIrregularTimeSeriesValue::setTimeStamp(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcIrregularTimeSeriesValue::ListValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcIrregularTimeSeriesValue::setListValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcIrregularTimeSeriesValue::declaration() const { return *IFC2X3_IfcIrregularTimeSeriesValue_type; }
const IfcParse::entity& Ifc2x3::IfcIrregularTimeSeriesValue::Class() { return *IFC2X3_IfcIrregularTimeSeriesValue_type; }
Ifc2x3::IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcIrregularTimeSeriesValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(::Ifc2x3::IfcDateTimeSelect* v1_TimeStamp, aggregate_of_instance::ptr v2_ListValues) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcIrregularTimeSeriesValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TimeStamp));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ListValues));data_->setArgument(1,attr);} }

// Function implementations for IfcJunctionBoxType
::Ifc2x3::IfcJunctionBoxTypeEnum::Value Ifc2x3::IfcJunctionBoxType::PredefinedType() const {  return ::Ifc2x3::IfcJunctionBoxTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcJunctionBoxType::setPredefinedType(::Ifc2x3::IfcJunctionBoxTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcJunctionBoxTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcJunctionBoxType::declaration() const { return *IFC2X3_IfcJunctionBoxType_type; }
const IfcParse::entity& Ifc2x3::IfcJunctionBoxType::Class() { return *IFC2X3_IfcJunctionBoxType_type; }
Ifc2x3::IfcJunctionBoxType::IfcJunctionBoxType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcJunctionBoxType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcJunctionBoxType::IfcJunctionBoxType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcJunctionBoxTypeEnum::Value v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcJunctionBoxType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcJunctionBoxTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLShapeProfileDef
double Ifc2x3::IfcLShapeProfileDef::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcLShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::Width() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcLShapeProfileDef::setWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
double Ifc2x3::IfcLShapeProfileDef::Thickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcLShapeProfileDef::setThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::FilletRadius() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcLShapeProfileDef::setFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::EdgeRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcLShapeProfileDef::setEdgeRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::LegSlope() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcLShapeProfileDef::setLegSlope(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::CentreOfGravityInX() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcLShapeProfileDef::setCentreOfGravityInX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcLShapeProfileDef::CentreOfGravityInY() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcLShapeProfileDef::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcLShapeProfileDef::declaration() const { return *IFC2X3_IfcLShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcLShapeProfileDef::Class() { return *IFC2X3_IfcLShapeProfileDef_type; }
Ifc2x3::IfcLShapeProfileDef::IfcLShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLShapeProfileDef::IfcLShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Depth, boost::optional< double > v5_Width, double v6_Thickness, boost::optional< double > v7_FilletRadius, boost::optional< double > v8_EdgeRadius, boost::optional< double > v9_LegSlope, boost::optional< double > v10_CentreOfGravityInX, boost::optional< double > v11_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} if (v5_Width) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Width));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Thickness));data_->setArgument(5,attr);} if (v7_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FilletRadius));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_EdgeRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_LegSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_LegSlope));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_CentreOfGravityInX));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CentreOfGravityInY));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcLaborResource
boost::optional< std::string > Ifc2x3::IfcLaborResource::SkillSet() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcLaborResource::setSkillSet(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcLaborResource::declaration() const { return *IFC2X3_IfcLaborResource_type; }
const IfcParse::entity& Ifc2x3::IfcLaborResource::Class() { return *IFC2X3_IfcLaborResource_type; }
Ifc2x3::IfcLaborResource::IfcLaborResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLaborResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLaborResource::IfcLaborResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< std::string > v10_SkillSet) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLaborResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);} if (v10_SkillSet) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SkillSet));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcLampType
::Ifc2x3::IfcLampTypeEnum::Value Ifc2x3::IfcLampType::PredefinedType() const {  return ::Ifc2x3::IfcLampTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcLampType::setPredefinedType(::Ifc2x3::IfcLampTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLampTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcLampType::declaration() const { return *IFC2X3_IfcLampType_type; }
const IfcParse::entity& Ifc2x3::IfcLampType::Class() { return *IFC2X3_IfcLampType_type; }
Ifc2x3::IfcLampType::IfcLampType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLampType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLampType::IfcLampType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcLampTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLampType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcLampTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLibraryInformation
std::string Ifc2x3::IfcLibraryInformation::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcLibraryInformation::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcLibraryInformation::Version() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcLibraryInformation::setVersion(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcOrganization* Ifc2x3::IfcLibraryInformation::Publisher() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcOrganization>(true); }
void Ifc2x3::IfcLibraryInformation::setPublisher(::Ifc2x3::IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcCalendarDate* Ifc2x3::IfcLibraryInformation::VersionDate() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcCalendarDate>(true); }
void Ifc2x3::IfcLibraryInformation::setVersionDate(::Ifc2x3::IfcCalendarDate* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcLibraryReference >::ptr > Ifc2x3::IfcLibraryInformation::LibraryReference() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcLibraryReference >(); }
void Ifc2x3::IfcLibraryInformation::setLibraryReference(boost::optional< aggregate_of< ::Ifc2x3::IfcLibraryReference >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcLibraryInformation::declaration() const { return *IFC2X3_IfcLibraryInformation_type; }
const IfcParse::entity& Ifc2x3::IfcLibraryInformation::Class() { return *IFC2X3_IfcLibraryInformation_type; }
Ifc2x3::IfcLibraryInformation::IfcLibraryInformation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcLibraryInformation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLibraryInformation::IfcLibraryInformation(std::string v1_Name, boost::optional< std::string > v2_Version, ::Ifc2x3::IfcOrganization* v3_Publisher, ::Ifc2x3::IfcCalendarDate* v4_VersionDate, boost::optional< aggregate_of< ::Ifc2x3::IfcLibraryReference >::ptr > v5_LibraryReference) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcLibraryInformation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Version) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Version));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Publisher));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_VersionDate));data_->setArgument(3,attr);} if (v5_LibraryReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LibraryReference)->generalize());data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcLibraryReference

::Ifc2x3::IfcLibraryInformation::list::ptr Ifc2x3::IfcLibraryReference::ReferenceIntoLibrary() const { return data_->getInverse(IFC2X3_IfcLibraryInformation_type, 4)->as<IfcLibraryInformation>(); }

const IfcParse::entity& Ifc2x3::IfcLibraryReference::declaration() const { return *IFC2X3_IfcLibraryReference_type; }
const IfcParse::entity& Ifc2x3::IfcLibraryReference::Class() { return *IFC2X3_IfcLibraryReference_type; }
Ifc2x3::IfcLibraryReference::IfcLibraryReference(IfcEntityInstanceData* e) : IfcExternalReference((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLibraryReference_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLibraryReference::IfcLibraryReference(boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name) : IfcExternalReference((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLibraryReference_type);  if (v1_Location) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Location));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ItemReference) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ItemReference));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcLightDistributionData
double Ifc2x3::IfcLightDistributionData::MainPlaneAngle() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcLightDistributionData::setMainPlaneAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::vector< double > /*[1:?]*/ Ifc2x3::IfcLightDistributionData::SecondaryPlaneAngle() const {  std::vector< double > /*[1:?]*/ v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcLightDistributionData::setSecondaryPlaneAngle(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
std::vector< double > /*[1:?]*/ Ifc2x3::IfcLightDistributionData::LuminousIntensity() const {  std::vector< double > /*[1:?]*/ v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcLightDistributionData::setLuminousIntensity(std::vector< double > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightDistributionData::declaration() const { return *IFC2X3_IfcLightDistributionData_type; }
const IfcParse::entity& Ifc2x3::IfcLightDistributionData::Class() { return *IFC2X3_IfcLightDistributionData_type; }
Ifc2x3::IfcLightDistributionData::IfcLightDistributionData(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcLightDistributionData_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightDistributionData::IfcLightDistributionData(double v1_MainPlaneAngle, std::vector< double > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< double > /*[1:?]*/ v3_LuminousIntensity) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightDistributionData_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MainPlaneAngle));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SecondaryPlaneAngle));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_LuminousIntensity));data_->setArgument(2,attr);} }

// Function implementations for IfcLightFixtureType
::Ifc2x3::IfcLightFixtureTypeEnum::Value Ifc2x3::IfcLightFixtureType::PredefinedType() const {  return ::Ifc2x3::IfcLightFixtureTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcLightFixtureType::setPredefinedType(::Ifc2x3::IfcLightFixtureTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLightFixtureTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightFixtureType::declaration() const { return *IFC2X3_IfcLightFixtureType_type; }
const IfcParse::entity& Ifc2x3::IfcLightFixtureType::Class() { return *IFC2X3_IfcLightFixtureType_type; }
Ifc2x3::IfcLightFixtureType::IfcLightFixtureType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightFixtureType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightFixtureType::IfcLightFixtureType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcLightFixtureTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightFixtureType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcLightFixtureTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcLightIntensityDistribution
::Ifc2x3::IfcLightDistributionCurveEnum::Value Ifc2x3::IfcLightIntensityDistribution::LightDistributionCurve() const {  return ::Ifc2x3::IfcLightDistributionCurveEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcLightIntensityDistribution::setLightDistributionCurve(::Ifc2x3::IfcLightDistributionCurveEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLightDistributionCurveEnum::ToString(v)));data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcLightDistributionData >::ptr Ifc2x3::IfcLightIntensityDistribution::DistributionData() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcLightDistributionData >(); }
void Ifc2x3::IfcLightIntensityDistribution::setDistributionData(aggregate_of< ::Ifc2x3::IfcLightDistributionData >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightIntensityDistribution::declaration() const { return *IFC2X3_IfcLightIntensityDistribution_type; }
const IfcParse::entity& Ifc2x3::IfcLightIntensityDistribution::Class() { return *IFC2X3_IfcLightIntensityDistribution_type; }
Ifc2x3::IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcLightIntensityDistribution_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightIntensityDistribution::IfcLightIntensityDistribution(::Ifc2x3::IfcLightDistributionCurveEnum::Value v1_LightDistributionCurve, aggregate_of< ::Ifc2x3::IfcLightDistributionData >::ptr v2_DistributionData) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightIntensityDistribution_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_LightDistributionCurve,::Ifc2x3::IfcLightDistributionCurveEnum::ToString(v1_LightDistributionCurve))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DistributionData)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcLightSource
boost::optional< std::string > Ifc2x3::IfcLightSource::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcLightSource::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcLightSource::LightColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcLightSource::setLightColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcLightSource::AmbientIntensity() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcLightSource::setAmbientIntensity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcLightSource::Intensity() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcLightSource::setIntensity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightSource::declaration() const { return *IFC2X3_IfcLightSource_type; }
const IfcParse::entity& Ifc2x3::IfcLightSource::Class() { return *IFC2X3_IfcLightSource_type; }
Ifc2x3::IfcLightSource::IfcLightSource(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSource::IfcLightSource(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSource_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcLightSourceAmbient


const IfcParse::entity& Ifc2x3::IfcLightSourceAmbient::declaration() const { return *IFC2X3_IfcLightSourceAmbient_type; }
const IfcParse::entity& Ifc2x3::IfcLightSourceAmbient::Class() { return *IFC2X3_IfcLightSourceAmbient_type; }
Ifc2x3::IfcLightSourceAmbient::IfcLightSourceAmbient(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSourceAmbient_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSourceAmbient::IfcLightSourceAmbient(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSourceAmbient_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcLightSourceDirectional
::Ifc2x3::IfcDirection* Ifc2x3::IfcLightSourceDirectional::Orientation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcLightSourceDirectional::setOrientation(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightSourceDirectional::declaration() const { return *IFC2X3_IfcLightSourceDirectional_type; }
const IfcParse::entity& Ifc2x3::IfcLightSourceDirectional::Class() { return *IFC2X3_IfcLightSourceDirectional_type; }
Ifc2x3::IfcLightSourceDirectional::IfcLightSourceDirectional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSourceDirectional_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSourceDirectional::IfcLightSourceDirectional(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, ::Ifc2x3::IfcDirection* v5_Orientation) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSourceDirectional_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Orientation));data_->setArgument(4,attr);} }

// Function implementations for IfcLightSourceGoniometric
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcLightSourceGoniometric::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcLightSourceGoniometric::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcLightSourceGoniometric::ColourAppearance() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcLightSourceGoniometric::setColourAppearance(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcLightSourceGoniometric::ColourTemperature() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcLightSourceGoniometric::setColourTemperature(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double Ifc2x3::IfcLightSourceGoniometric::LuminousFlux() const {  double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcLightSourceGoniometric::setLuminousFlux(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcLightEmissionSourceEnum::Value Ifc2x3::IfcLightSourceGoniometric::LightEmissionSource() const {  return ::Ifc2x3::IfcLightEmissionSourceEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcLightSourceGoniometric::setLightEmissionSource(::Ifc2x3::IfcLightEmissionSourceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLightEmissionSourceEnum::ToString(v)));data_->setArgument(8,attr);} }
::Ifc2x3::IfcLightDistributionDataSourceSelect* Ifc2x3::IfcLightSourceGoniometric::LightDistributionDataSource() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcLightDistributionDataSourceSelect>(true); }
void Ifc2x3::IfcLightSourceGoniometric::setLightDistributionDataSource(::Ifc2x3::IfcLightDistributionDataSourceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightSourceGoniometric::declaration() const { return *IFC2X3_IfcLightSourceGoniometric_type; }
const IfcParse::entity& Ifc2x3::IfcLightSourceGoniometric::Class() { return *IFC2X3_IfcLightSourceGoniometric_type; }
Ifc2x3::IfcLightSourceGoniometric::IfcLightSourceGoniometric(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSourceGoniometric_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSourceGoniometric::IfcLightSourceGoniometric(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, ::Ifc2x3::IfcAxis2Placement3D* v5_Position, ::Ifc2x3::IfcColourRgb* v6_ColourAppearance, double v7_ColourTemperature, double v8_LuminousFlux, ::Ifc2x3::IfcLightEmissionSourceEnum::Value v9_LightEmissionSource, ::Ifc2x3::IfcLightDistributionDataSourceSelect* v10_LightDistributionDataSource) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSourceGoniometric_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ColourAppearance));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ColourTemperature));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LuminousFlux));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_LightEmissionSource,::Ifc2x3::IfcLightEmissionSourceEnum::ToString(v9_LightEmissionSource))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_LightDistributionDataSource));data_->setArgument(9,attr);} }

// Function implementations for IfcLightSourcePositional
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcLightSourcePositional::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcLightSourcePositional::setPosition(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcLightSourcePositional::Radius() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcLightSourcePositional::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcLightSourcePositional::ConstantAttenuation() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcLightSourcePositional::setConstantAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
double Ifc2x3::IfcLightSourcePositional::DistanceAttenuation() const {  double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcLightSourcePositional::setDistanceAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
double Ifc2x3::IfcLightSourcePositional::QuadricAttenuation() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcLightSourcePositional::setQuadricAttenuation(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightSourcePositional::declaration() const { return *IFC2X3_IfcLightSourcePositional_type; }
const IfcParse::entity& Ifc2x3::IfcLightSourcePositional::Class() { return *IFC2X3_IfcLightSourcePositional_type; }
Ifc2x3::IfcLightSourcePositional::IfcLightSourcePositional(IfcEntityInstanceData* e) : IfcLightSource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSourcePositional_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSourcePositional::IfcLightSourcePositional(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, ::Ifc2x3::IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation) : IfcLightSource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSourcePositional_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));data_->setArgument(8,attr);} }

// Function implementations for IfcLightSourceSpot
::Ifc2x3::IfcDirection* Ifc2x3::IfcLightSourceSpot::Orientation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcLightSourceSpot::setOrientation(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcLightSourceSpot::ConcentrationExponent() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcLightSourceSpot::setConcentrationExponent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
double Ifc2x3::IfcLightSourceSpot::SpreadAngle() const {  double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcLightSourceSpot::setSpreadAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
double Ifc2x3::IfcLightSourceSpot::BeamWidthAngle() const {  double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcLightSourceSpot::setBeamWidthAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcLightSourceSpot::declaration() const { return *IFC2X3_IfcLightSourceSpot_type; }
const IfcParse::entity& Ifc2x3::IfcLightSourceSpot::Class() { return *IFC2X3_IfcLightSourceSpot_type; }
Ifc2x3::IfcLightSourceSpot::IfcLightSourceSpot(IfcEntityInstanceData* e) : IfcLightSourcePositional((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLightSourceSpot_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLightSourceSpot::IfcLightSourceSpot(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, ::Ifc2x3::IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation, ::Ifc2x3::IfcDirection* v10_Orientation, boost::optional< double > v11_ConcentrationExponent, double v12_SpreadAngle, double v13_BeamWidthAngle) : IfcLightSourcePositional((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLightSourceSpot_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LightColour));data_->setArgument(1,attr);} if (v3_AmbientIntensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_AmbientIntensity));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Intensity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Intensity));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Position));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Radius));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConstantAttenuation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_DistanceAttenuation));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_QuadricAttenuation));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Orientation));data_->setArgument(9,attr);} if (v11_ConcentrationExponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ConcentrationExponent));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_SpreadAngle));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_BeamWidthAngle));data_->setArgument(12,attr);} }

// Function implementations for IfcLine
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcLine::Pnt() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcLine::setPnt(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcVector* Ifc2x3::IfcLine::Dir() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcVector>(true); }
void Ifc2x3::IfcLine::setDir(::Ifc2x3::IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcLine::declaration() const { return *IFC2X3_IfcLine_type; }
const IfcParse::entity& Ifc2x3::IfcLine::Class() { return *IFC2X3_IfcLine_type; }
Ifc2x3::IfcLine::IfcLine(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLine_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLine::IfcLine(::Ifc2x3::IfcCartesianPoint* v1_Pnt, ::Ifc2x3::IfcVector* v2_Dir) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLine_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Pnt));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Dir));data_->setArgument(1,attr);} }

// Function implementations for IfcLinearDimension


const IfcParse::entity& Ifc2x3::IfcLinearDimension::declaration() const { return *IFC2X3_IfcLinearDimension_type; }
const IfcParse::entity& Ifc2x3::IfcLinearDimension::Class() { return *IFC2X3_IfcLinearDimension_type; }
Ifc2x3::IfcLinearDimension::IfcLinearDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLinearDimension_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLinearDimension::IfcLinearDimension(aggregate_of_instance::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLinearDimension_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcLocalPlacement
::Ifc2x3::IfcObjectPlacement* Ifc2x3::IfcLocalPlacement::PlacementRelTo() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcObjectPlacement>(true); }
void Ifc2x3::IfcLocalPlacement::setPlacementRelTo(::Ifc2x3::IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcLocalPlacement::RelativePlacement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcLocalPlacement::setRelativePlacement(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcLocalPlacement::declaration() const { return *IFC2X3_IfcLocalPlacement_type; }
const IfcParse::entity& Ifc2x3::IfcLocalPlacement::Class() { return *IFC2X3_IfcLocalPlacement_type; }
Ifc2x3::IfcLocalPlacement::IfcLocalPlacement(IfcEntityInstanceData* e) : IfcObjectPlacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLocalPlacement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLocalPlacement::IfcLocalPlacement(::Ifc2x3::IfcObjectPlacement* v1_PlacementRelTo, ::Ifc2x3::IfcAxis2Placement* v2_RelativePlacement) : IfcObjectPlacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLocalPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_PlacementRelTo));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelativePlacement));data_->setArgument(1,attr);} }

// Function implementations for IfcLocalTime
int Ifc2x3::IfcLocalTime::HourComponent() const {  int v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcLocalTime::setHourComponent(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< int > Ifc2x3::IfcLocalTime::MinuteComponent() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } int v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcLocalTime::setMinuteComponent(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcLocalTime::SecondComponent() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcLocalTime::setSecondComponent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
::Ifc2x3::IfcCoordinatedUniversalTimeOffset* Ifc2x3::IfcLocalTime::Zone() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcCoordinatedUniversalTimeOffset>(true); }
void Ifc2x3::IfcLocalTime::setZone(::Ifc2x3::IfcCoordinatedUniversalTimeOffset* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< int > Ifc2x3::IfcLocalTime::DaylightSavingOffset() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } int v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcLocalTime::setDaylightSavingOffset(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcLocalTime::declaration() const { return *IFC2X3_IfcLocalTime_type; }
const IfcParse::entity& Ifc2x3::IfcLocalTime::Class() { return *IFC2X3_IfcLocalTime_type; }
Ifc2x3::IfcLocalTime::IfcLocalTime(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcLocalTime_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLocalTime::IfcLocalTime(int v1_HourComponent, boost::optional< int > v2_MinuteComponent, boost::optional< double > v3_SecondComponent, ::Ifc2x3::IfcCoordinatedUniversalTimeOffset* v4_Zone, boost::optional< int > v5_DaylightSavingOffset) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcLocalTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_HourComponent));data_->setArgument(0,attr);} if (v2_MinuteComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_MinuteComponent));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SecondComponent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SecondComponent));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Zone));data_->setArgument(3,attr);} if (v5_DaylightSavingOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DaylightSavingOffset));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcLoop


const IfcParse::entity& Ifc2x3::IfcLoop::declaration() const { return *IFC2X3_IfcLoop_type; }
const IfcParse::entity& Ifc2x3::IfcLoop::Class() { return *IFC2X3_IfcLoop_type; }
Ifc2x3::IfcLoop::IfcLoop(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcLoop_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcLoop::IfcLoop() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcLoop_type);  }

// Function implementations for IfcManifoldSolidBrep
::Ifc2x3::IfcClosedShell* Ifc2x3::IfcManifoldSolidBrep::Outer() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcClosedShell>(true); }
void Ifc2x3::IfcManifoldSolidBrep::setOuter(::Ifc2x3::IfcClosedShell* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcManifoldSolidBrep::declaration() const { return *IFC2X3_IfcManifoldSolidBrep_type; }
const IfcParse::entity& Ifc2x3::IfcManifoldSolidBrep::Class() { return *IFC2X3_IfcManifoldSolidBrep_type; }
Ifc2x3::IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcManifoldSolidBrep_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcManifoldSolidBrep::IfcManifoldSolidBrep(::Ifc2x3::IfcClosedShell* v1_Outer) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcManifoldSolidBrep_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Outer));data_->setArgument(0,attr);} }

// Function implementations for IfcMappedItem
::Ifc2x3::IfcRepresentationMap* Ifc2x3::IfcMappedItem::MappingSource() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcRepresentationMap>(true); }
void Ifc2x3::IfcMappedItem::setMappingSource(::Ifc2x3::IfcRepresentationMap* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcCartesianTransformationOperator* Ifc2x3::IfcMappedItem::MappingTarget() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCartesianTransformationOperator>(true); }
void Ifc2x3::IfcMappedItem::setMappingTarget(::Ifc2x3::IfcCartesianTransformationOperator* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcMappedItem::declaration() const { return *IFC2X3_IfcMappedItem_type; }
const IfcParse::entity& Ifc2x3::IfcMappedItem::Class() { return *IFC2X3_IfcMappedItem_type; }
Ifc2x3::IfcMappedItem::IfcMappedItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMappedItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMappedItem::IfcMappedItem(::Ifc2x3::IfcRepresentationMap* v1_MappingSource, ::Ifc2x3::IfcCartesianTransformationOperator* v2_MappingTarget) : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMappedItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingSource));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappingTarget));data_->setArgument(1,attr);} }

// Function implementations for IfcMaterial
std::string Ifc2x3::IfcMaterial::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcMaterial::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }

::Ifc2x3::IfcMaterialDefinitionRepresentation::list::ptr Ifc2x3::IfcMaterial::HasRepresentation() const { return data_->getInverse(IFC2X3_IfcMaterialDefinitionRepresentation_type, 3)->as<IfcMaterialDefinitionRepresentation>(); }
::Ifc2x3::IfcMaterialClassificationRelationship::list::ptr Ifc2x3::IfcMaterial::ClassifiedAs() const { return data_->getInverse(IFC2X3_IfcMaterialClassificationRelationship_type, 1)->as<IfcMaterialClassificationRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcMaterial::declaration() const { return *IFC2X3_IfcMaterial_type; }
const IfcParse::entity& Ifc2x3::IfcMaterial::Class() { return *IFC2X3_IfcMaterial_type; }
Ifc2x3::IfcMaterial::IfcMaterial(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterial_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterial::IfcMaterial(std::string v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterial_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcMaterialClassificationRelationship
aggregate_of_instance::ptr Ifc2x3::IfcMaterialClassificationRelationship::MaterialClassifications() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcMaterialClassificationRelationship::setMaterialClassifications(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcMaterial* Ifc2x3::IfcMaterialClassificationRelationship::ClassifiedMaterial() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcMaterial>(true); }
void Ifc2x3::IfcMaterialClassificationRelationship::setClassifiedMaterial(::Ifc2x3::IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialClassificationRelationship::declaration() const { return *IFC2X3_IfcMaterialClassificationRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialClassificationRelationship::Class() { return *IFC2X3_IfcMaterialClassificationRelationship_type; }
Ifc2x3::IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialClassificationRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(aggregate_of_instance::ptr v1_MaterialClassifications, ::Ifc2x3::IfcMaterial* v2_ClassifiedMaterial) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialClassificationRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialClassifications));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ClassifiedMaterial));data_->setArgument(1,attr);} }

// Function implementations for IfcMaterialDefinitionRepresentation
::Ifc2x3::IfcMaterial* Ifc2x3::IfcMaterialDefinitionRepresentation::RepresentedMaterial() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcMaterial>(true); }
void Ifc2x3::IfcMaterialDefinitionRepresentation::setRepresentedMaterial(::Ifc2x3::IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialDefinitionRepresentation::declaration() const { return *IFC2X3_IfcMaterialDefinitionRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialDefinitionRepresentation::Class() { return *IFC2X3_IfcMaterialDefinitionRepresentation_type; }
Ifc2x3::IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMaterialDefinitionRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, aggregate_of< ::Ifc2x3::IfcRepresentation >::ptr v3_Representations, ::Ifc2x3::IfcMaterial* v4_RepresentedMaterial) : IfcProductRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialDefinitionRepresentation_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RepresentedMaterial));data_->setArgument(3,attr);} }

// Function implementations for IfcMaterialLayer
::Ifc2x3::IfcMaterial* Ifc2x3::IfcMaterialLayer::Material() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcMaterial>(true); }
void Ifc2x3::IfcMaterialLayer::setMaterial(::Ifc2x3::IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcMaterialLayer::LayerThickness() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcMaterialLayer::setLayerThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< boost::logic::tribool > Ifc2x3::IfcMaterialLayer::IsVentilated() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } boost::logic::tribool v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcMaterialLayer::setIsVentilated(boost::optional< boost::logic::tribool > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }

::Ifc2x3::IfcMaterialLayerSet::list::ptr Ifc2x3::IfcMaterialLayer::ToMaterialLayerSet() const { return data_->getInverse(IFC2X3_IfcMaterialLayerSet_type, 0)->as<IfcMaterialLayerSet>(); }

const IfcParse::entity& Ifc2x3::IfcMaterialLayer::declaration() const { return *IFC2X3_IfcMaterialLayer_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialLayer::Class() { return *IFC2X3_IfcMaterialLayer_type; }
Ifc2x3::IfcMaterialLayer::IfcMaterialLayer(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialLayer_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialLayer::IfcMaterialLayer(::Ifc2x3::IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< boost::logic::tribool > v3_IsVentilated) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialLayer_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LayerThickness));data_->setArgument(1,attr);} if (v3_IsVentilated) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_IsVentilated));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcMaterialLayerSet
aggregate_of< ::Ifc2x3::IfcMaterialLayer >::ptr Ifc2x3::IfcMaterialLayerSet::MaterialLayers() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcMaterialLayer >(); }
void Ifc2x3::IfcMaterialLayerSet::setMaterialLayers(aggregate_of< ::Ifc2x3::IfcMaterialLayer >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcMaterialLayerSet::LayerSetName() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcMaterialLayerSet::setLayerSetName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialLayerSet::declaration() const { return *IFC2X3_IfcMaterialLayerSet_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialLayerSet::Class() { return *IFC2X3_IfcMaterialLayerSet_type; }
Ifc2x3::IfcMaterialLayerSet::IfcMaterialLayerSet(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialLayerSet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialLayerSet::IfcMaterialLayerSet(aggregate_of< ::Ifc2x3::IfcMaterialLayer >::ptr v1_MaterialLayers, boost::optional< std::string > v2_LayerSetName) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialLayerSet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MaterialLayers)->generalize());data_->setArgument(0,attr);} if (v2_LayerSetName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LayerSetName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcMaterialLayerSetUsage
::Ifc2x3::IfcMaterialLayerSet* Ifc2x3::IfcMaterialLayerSetUsage::ForLayerSet() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcMaterialLayerSet>(true); }
void Ifc2x3::IfcMaterialLayerSetUsage::setForLayerSet(::Ifc2x3::IfcMaterialLayerSet* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcLayerSetDirectionEnum::Value Ifc2x3::IfcMaterialLayerSetUsage::LayerSetDirection() const {  return ::Ifc2x3::IfcLayerSetDirectionEnum::FromString(*data_->getArgument(1)); }
void Ifc2x3::IfcMaterialLayerSetUsage::setLayerSetDirection(::Ifc2x3::IfcLayerSetDirectionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLayerSetDirectionEnum::ToString(v)));data_->setArgument(1,attr);} }
::Ifc2x3::IfcDirectionSenseEnum::Value Ifc2x3::IfcMaterialLayerSetUsage::DirectionSense() const {  return ::Ifc2x3::IfcDirectionSenseEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcMaterialLayerSetUsage::setDirectionSense(::Ifc2x3::IfcDirectionSenseEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDirectionSenseEnum::ToString(v)));data_->setArgument(2,attr);} }
double Ifc2x3::IfcMaterialLayerSetUsage::OffsetFromReferenceLine() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcMaterialLayerSetUsage::setOffsetFromReferenceLine(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialLayerSetUsage::declaration() const { return *IFC2X3_IfcMaterialLayerSetUsage_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialLayerSetUsage::Class() { return *IFC2X3_IfcMaterialLayerSetUsage_type; }
Ifc2x3::IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialLayerSetUsage_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(::Ifc2x3::IfcMaterialLayerSet* v1_ForLayerSet, ::Ifc2x3::IfcLayerSetDirectionEnum::Value v2_LayerSetDirection, ::Ifc2x3::IfcDirectionSenseEnum::Value v3_DirectionSense, double v4_OffsetFromReferenceLine) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialLayerSetUsage_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ForLayerSet));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_LayerSetDirection,::Ifc2x3::IfcLayerSetDirectionEnum::ToString(v2_LayerSetDirection))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_DirectionSense,::Ifc2x3::IfcDirectionSenseEnum::ToString(v3_DirectionSense))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_OffsetFromReferenceLine));data_->setArgument(3,attr);} }

// Function implementations for IfcMaterialList
aggregate_of< ::Ifc2x3::IfcMaterial >::ptr Ifc2x3::IfcMaterialList::Materials() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcMaterial >(); }
void Ifc2x3::IfcMaterialList::setMaterials(aggregate_of< ::Ifc2x3::IfcMaterial >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialList::declaration() const { return *IFC2X3_IfcMaterialList_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialList::Class() { return *IFC2X3_IfcMaterialList_type; }
Ifc2x3::IfcMaterialList::IfcMaterialList(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialList_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialList::IfcMaterialList(aggregate_of< ::Ifc2x3::IfcMaterial >::ptr v1_Materials) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialList_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Materials)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcMaterialProperties
::Ifc2x3::IfcMaterial* Ifc2x3::IfcMaterialProperties::Material() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcMaterial>(true); }
void Ifc2x3::IfcMaterialProperties::setMaterial(::Ifc2x3::IfcMaterial* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcMaterialProperties::declaration() const { return *IFC2X3_IfcMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcMaterialProperties::Class() { return *IFC2X3_IfcMaterialProperties_type; }
Ifc2x3::IfcMaterialProperties::IfcMaterialProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMaterialProperties::IfcMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} }

// Function implementations for IfcMeasureWithUnit
::Ifc2x3::IfcValue* Ifc2x3::IfcMeasureWithUnit::ValueComponent() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcValue>(true); }
void Ifc2x3::IfcMeasureWithUnit::setValueComponent(::Ifc2x3::IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcMeasureWithUnit::UnitComponent() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcMeasureWithUnit::setUnitComponent(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcMeasureWithUnit::declaration() const { return *IFC2X3_IfcMeasureWithUnit_type; }
const IfcParse::entity& Ifc2x3::IfcMeasureWithUnit::Class() { return *IFC2X3_IfcMeasureWithUnit_type; }
Ifc2x3::IfcMeasureWithUnit::IfcMeasureWithUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMeasureWithUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMeasureWithUnit::IfcMeasureWithUnit(::Ifc2x3::IfcValue* v1_ValueComponent, ::Ifc2x3::IfcUnit* v2_UnitComponent) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMeasureWithUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ValueComponent));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_UnitComponent));data_->setArgument(1,attr);} }

// Function implementations for IfcMechanicalConcreteMaterialProperties
boost::optional< double > Ifc2x3::IfcMechanicalConcreteMaterialProperties::CompressiveStrength() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setCompressiveStrength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalConcreteMaterialProperties::MaxAggregateSize() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setMaxAggregateSize(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcMechanicalConcreteMaterialProperties::AdmixturesDescription() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setAdmixturesDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< std::string > Ifc2x3::IfcMechanicalConcreteMaterialProperties::Workability() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setWorkability(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalConcreteMaterialProperties::ProtectivePoreRatio() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setProtectivePoreRatio(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< std::string > Ifc2x3::IfcMechanicalConcreteMaterialProperties::WaterImpermeability() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } std::string v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcMechanicalConcreteMaterialProperties::setWaterImpermeability(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcMechanicalConcreteMaterialProperties::declaration() const { return *IFC2X3_IfcMechanicalConcreteMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcMechanicalConcreteMaterialProperties::Class() { return *IFC2X3_IfcMechanicalConcreteMaterialProperties_type; }
Ifc2x3::IfcMechanicalConcreteMaterialProperties::IfcMechanicalConcreteMaterialProperties(IfcEntityInstanceData* e) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMechanicalConcreteMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMechanicalConcreteMaterialProperties::IfcMechanicalConcreteMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_CompressiveStrength, boost::optional< double > v8_MaxAggregateSize, boost::optional< std::string > v9_AdmixturesDescription, boost::optional< std::string > v10_Workability, boost::optional< double > v11_ProtectivePoreRatio, boost::optional< std::string > v12_WaterImpermeability) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMechanicalConcreteMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CompressiveStrength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CompressiveStrength));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_MaxAggregateSize) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MaxAggregateSize));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_AdmixturesDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_AdmixturesDescription));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Workability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Workability));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProtectivePoreRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ProtectivePoreRatio));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_WaterImpermeability) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WaterImpermeability));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcMechanicalFastener
boost::optional< double > Ifc2x3::IfcMechanicalFastener::NominalDiameter() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcMechanicalFastener::setNominalDiameter(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalFastener::NominalLength() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcMechanicalFastener::setNominalLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcMechanicalFastener::declaration() const { return *IFC2X3_IfcMechanicalFastener_type; }
const IfcParse::entity& Ifc2x3::IfcMechanicalFastener::Class() { return *IFC2X3_IfcMechanicalFastener_type; }
Ifc2x3::IfcMechanicalFastener::IfcMechanicalFastener(IfcEntityInstanceData* e) : IfcFastener((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMechanicalFastener_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMechanicalFastener::IfcMechanicalFastener(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_NominalDiameter, boost::optional< double > v10_NominalLength) : IfcFastener((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMechanicalFastener_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_NominalDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NominalDiameter));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_NominalLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NominalLength));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcMechanicalFastenerType


const IfcParse::entity& Ifc2x3::IfcMechanicalFastenerType::declaration() const { return *IFC2X3_IfcMechanicalFastenerType_type; }
const IfcParse::entity& Ifc2x3::IfcMechanicalFastenerType::Class() { return *IFC2X3_IfcMechanicalFastenerType_type; }
Ifc2x3::IfcMechanicalFastenerType::IfcMechanicalFastenerType(IfcEntityInstanceData* e) : IfcFastenerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMechanicalFastenerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMechanicalFastenerType::IfcMechanicalFastenerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcFastenerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMechanicalFastenerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcMechanicalMaterialProperties
boost::optional< double > Ifc2x3::IfcMechanicalMaterialProperties::DynamicViscosity() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcMechanicalMaterialProperties::setDynamicViscosity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalMaterialProperties::YoungModulus() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcMechanicalMaterialProperties::setYoungModulus(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalMaterialProperties::ShearModulus() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcMechanicalMaterialProperties::setShearModulus(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalMaterialProperties::PoissonRatio() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcMechanicalMaterialProperties::setPoissonRatio(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalMaterialProperties::ThermalExpansionCoefficient() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcMechanicalMaterialProperties::setThermalExpansionCoefficient(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcMechanicalMaterialProperties::declaration() const { return *IFC2X3_IfcMechanicalMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcMechanicalMaterialProperties::Class() { return *IFC2X3_IfcMechanicalMaterialProperties_type; }
Ifc2x3::IfcMechanicalMaterialProperties::IfcMechanicalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMechanicalMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMechanicalMaterialProperties::IfcMechanicalMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMechanicalMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcMechanicalSteelMaterialProperties
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::YieldStress() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setYieldStress(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::UltimateStress() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setUltimateStress(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::UltimateStrain() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setUltimateStrain(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::HardeningModule() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setHardeningModule(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::ProportionalStress() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setProportionalStress(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcMechanicalSteelMaterialProperties::PlasticStrain() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setPlasticStrain(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcRelaxation >::ptr > Ifc2x3::IfcMechanicalSteelMaterialProperties::Relaxations() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(12); return es->as< ::Ifc2x3::IfcRelaxation >(); }
void Ifc2x3::IfcMechanicalSteelMaterialProperties::setRelaxations(boost::optional< aggregate_of< ::Ifc2x3::IfcRelaxation >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcMechanicalSteelMaterialProperties::declaration() const { return *IFC2X3_IfcMechanicalSteelMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcMechanicalSteelMaterialProperties::Class() { return *IFC2X3_IfcMechanicalSteelMaterialProperties_type; }
Ifc2x3::IfcMechanicalSteelMaterialProperties::IfcMechanicalSteelMaterialProperties(IfcEntityInstanceData* e) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMechanicalSteelMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMechanicalSteelMaterialProperties::IfcMechanicalSteelMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_YieldStress, boost::optional< double > v8_UltimateStress, boost::optional< double > v9_UltimateStrain, boost::optional< double > v10_HardeningModule, boost::optional< double > v11_ProportionalStress, boost::optional< double > v12_PlasticStrain, boost::optional< aggregate_of< ::Ifc2x3::IfcRelaxation >::ptr > v13_Relaxations) : IfcMechanicalMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMechanicalSteelMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_DynamicViscosity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DynamicViscosity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_YoungModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_YoungModulus));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ShearModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ShearModulus));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PoissonRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PoissonRatio));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ThermalExpansionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalExpansionCoefficient));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_YieldStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_YieldStress));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_UltimateStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_UltimateStress));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_UltimateStrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_UltimateStrain));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_HardeningModule) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_HardeningModule));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_ProportionalStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ProportionalStress));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_PlasticStrain) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_PlasticStrain));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_Relaxations) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_Relaxations)->generalize());data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcMember


const IfcParse::entity& Ifc2x3::IfcMember::declaration() const { return *IFC2X3_IfcMember_type; }
const IfcParse::entity& Ifc2x3::IfcMember::Class() { return *IFC2X3_IfcMember_type; }
Ifc2x3::IfcMember::IfcMember(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMember_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMember::IfcMember(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcMemberType
::Ifc2x3::IfcMemberTypeEnum::Value Ifc2x3::IfcMemberType::PredefinedType() const {  return ::Ifc2x3::IfcMemberTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcMemberType::setPredefinedType(::Ifc2x3::IfcMemberTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcMemberTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcMemberType::declaration() const { return *IFC2X3_IfcMemberType_type; }
const IfcParse::entity& Ifc2x3::IfcMemberType::Class() { return *IFC2X3_IfcMemberType_type; }
Ifc2x3::IfcMemberType::IfcMemberType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMemberType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMemberType::IfcMemberType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcMemberTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMemberType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcMemberTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcMetric
::Ifc2x3::IfcBenchmarkEnum::Value Ifc2x3::IfcMetric::Benchmark() const {  return ::Ifc2x3::IfcBenchmarkEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcMetric::setBenchmark(::Ifc2x3::IfcBenchmarkEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcBenchmarkEnum::ToString(v)));data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcMetric::ValueSource() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcMetric::setValueSource(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
::Ifc2x3::IfcMetricValueSelect* Ifc2x3::IfcMetric::DataValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcMetricValueSelect>(true); }
void Ifc2x3::IfcMetric::setDataValue(::Ifc2x3::IfcMetricValueSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcMetric::declaration() const { return *IFC2X3_IfcMetric_type; }
const IfcParse::entity& Ifc2x3::IfcMetric::Class() { return *IFC2X3_IfcMetric_type; }
Ifc2x3::IfcMetric::IfcMetric(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMetric_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMetric::IfcMetric(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcConstraintEnum::Value v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, ::Ifc2x3::IfcActorSelect* v5_CreatingActor, ::Ifc2x3::IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, ::Ifc2x3::IfcBenchmarkEnum::Value v8_Benchmark, boost::optional< std::string > v9_ValueSource, ::Ifc2x3::IfcMetricValueSelect* v10_DataValue) : IfcConstraint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMetric_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,::Ifc2x3::IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));data_->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_Benchmark,::Ifc2x3::IfcBenchmarkEnum::ToString(v8_Benchmark))));data_->setArgument(7,attr);} if (v9_ValueSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ValueSource));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DataValue));data_->setArgument(9,attr);} }

// Function implementations for IfcMonetaryUnit
::Ifc2x3::IfcCurrencyEnum::Value Ifc2x3::IfcMonetaryUnit::Currency() const {  return ::Ifc2x3::IfcCurrencyEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcMonetaryUnit::setCurrency(::Ifc2x3::IfcCurrencyEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcCurrencyEnum::ToString(v)));data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcMonetaryUnit::declaration() const { return *IFC2X3_IfcMonetaryUnit_type; }
const IfcParse::entity& Ifc2x3::IfcMonetaryUnit::Class() { return *IFC2X3_IfcMonetaryUnit_type; }
Ifc2x3::IfcMonetaryUnit::IfcMonetaryUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcMonetaryUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMonetaryUnit::IfcMonetaryUnit(::Ifc2x3::IfcCurrencyEnum::Value v1_Currency) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcMonetaryUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_Currency,::Ifc2x3::IfcCurrencyEnum::ToString(v1_Currency))));data_->setArgument(0,attr);} }

// Function implementations for IfcMotorConnectionType
::Ifc2x3::IfcMotorConnectionTypeEnum::Value Ifc2x3::IfcMotorConnectionType::PredefinedType() const {  return ::Ifc2x3::IfcMotorConnectionTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcMotorConnectionType::setPredefinedType(::Ifc2x3::IfcMotorConnectionTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcMotorConnectionTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcMotorConnectionType::declaration() const { return *IFC2X3_IfcMotorConnectionType_type; }
const IfcParse::entity& Ifc2x3::IfcMotorConnectionType::Class() { return *IFC2X3_IfcMotorConnectionType_type; }
Ifc2x3::IfcMotorConnectionType::IfcMotorConnectionType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMotorConnectionType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMotorConnectionType::IfcMotorConnectionType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcMotorConnectionTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMotorConnectionType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcMotorConnectionTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcMove
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcMove::MoveFrom() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcMove::setMoveFrom(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcMove::MoveTo() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcMove::setMoveTo(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcMove::PunchList() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcMove::setPunchList(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcMove::declaration() const { return *IFC2X3_IfcMove_type; }
const IfcParse::entity& Ifc2x3::IfcMove::Class() { return *IFC2X3_IfcMove_type; }
Ifc2x3::IfcMove::IfcMove(IfcEntityInstanceData* e) : IfcTask((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcMove_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcMove::IfcMove(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, ::Ifc2x3::IfcSpatialStructureElement* v11_MoveFrom, ::Ifc2x3::IfcSpatialStructureElement* v12_MoveTo, boost::optional< std::vector< std::string > /*[1:?]*/ > v13_PunchList) : IfcTask((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcMove_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));data_->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));data_->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_MoveFrom));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_MoveTo));data_->setArgument(11,attr);} if (v13_PunchList) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_PunchList));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcNamedUnit
::Ifc2x3::IfcDimensionalExponents* Ifc2x3::IfcNamedUnit::Dimensions() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDimensionalExponents>(true); }
void Ifc2x3::IfcNamedUnit::setDimensions(::Ifc2x3::IfcDimensionalExponents* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcUnitEnum::Value Ifc2x3::IfcNamedUnit::UnitType() const {  return ::Ifc2x3::IfcUnitEnum::FromString(*data_->getArgument(1)); }
void Ifc2x3::IfcNamedUnit::setUnitType(::Ifc2x3::IfcUnitEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcUnitEnum::ToString(v)));data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcNamedUnit::declaration() const { return *IFC2X3_IfcNamedUnit_type; }
const IfcParse::entity& Ifc2x3::IfcNamedUnit::Class() { return *IFC2X3_IfcNamedUnit_type; }
Ifc2x3::IfcNamedUnit::IfcNamedUnit(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcNamedUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcNamedUnit::IfcNamedUnit(::Ifc2x3::IfcDimensionalExponents* v1_Dimensions, ::Ifc2x3::IfcUnitEnum::Value v2_UnitType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcNamedUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Dimensions));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,::Ifc2x3::IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} }

// Function implementations for IfcObject
boost::optional< std::string > Ifc2x3::IfcObject::ObjectType() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcObject::setObjectType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }

::Ifc2x3::IfcRelDefines::list::ptr Ifc2x3::IfcObject::IsDefinedBy() const { return data_->getInverse(IFC2X3_IfcRelDefines_type, 4)->as<IfcRelDefines>(); }

const IfcParse::entity& Ifc2x3::IfcObject::declaration() const { return *IFC2X3_IfcObject_type; }
const IfcParse::entity& Ifc2x3::IfcObject::Class() { return *IFC2X3_IfcObject_type; }
Ifc2x3::IfcObject::IfcObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcObject_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcObject::IfcObject(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObjectDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcObject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcObjectDefinition

::Ifc2x3::IfcRelAssigns::list::ptr Ifc2x3::IfcObjectDefinition::HasAssignments() const { return data_->getInverse(IFC2X3_IfcRelAssigns_type, 4)->as<IfcRelAssigns>(); }
::Ifc2x3::IfcRelDecomposes::list::ptr Ifc2x3::IfcObjectDefinition::IsDecomposedBy() const { return data_->getInverse(IFC2X3_IfcRelDecomposes_type, 4)->as<IfcRelDecomposes>(); }
::Ifc2x3::IfcRelDecomposes::list::ptr Ifc2x3::IfcObjectDefinition::Decomposes() const { return data_->getInverse(IFC2X3_IfcRelDecomposes_type, 5)->as<IfcRelDecomposes>(); }
::Ifc2x3::IfcRelAssociates::list::ptr Ifc2x3::IfcObjectDefinition::HasAssociations() const { return data_->getInverse(IFC2X3_IfcRelAssociates_type, 4)->as<IfcRelAssociates>(); }

const IfcParse::entity& Ifc2x3::IfcObjectDefinition::declaration() const { return *IFC2X3_IfcObjectDefinition_type; }
const IfcParse::entity& Ifc2x3::IfcObjectDefinition::Class() { return *IFC2X3_IfcObjectDefinition_type; }
Ifc2x3::IfcObjectDefinition::IfcObjectDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcObjectDefinition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcObjectDefinition::IfcObjectDefinition(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcObjectPlacement

::Ifc2x3::IfcProduct::list::ptr Ifc2x3::IfcObjectPlacement::PlacesObject() const { return data_->getInverse(IFC2X3_IfcProduct_type, 5)->as<IfcProduct>(); }
::Ifc2x3::IfcLocalPlacement::list::ptr Ifc2x3::IfcObjectPlacement::ReferencedByPlacements() const { return data_->getInverse(IFC2X3_IfcLocalPlacement_type, 0)->as<IfcLocalPlacement>(); }

const IfcParse::entity& Ifc2x3::IfcObjectPlacement::declaration() const { return *IFC2X3_IfcObjectPlacement_type; }
const IfcParse::entity& Ifc2x3::IfcObjectPlacement::Class() { return *IFC2X3_IfcObjectPlacement_type; }
Ifc2x3::IfcObjectPlacement::IfcObjectPlacement(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcObjectPlacement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcObjectPlacement::IfcObjectPlacement() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcObjectPlacement_type);  }

// Function implementations for IfcObjective
::Ifc2x3::IfcMetric* Ifc2x3::IfcObjective::BenchmarkValues() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcMetric>(true); }
void Ifc2x3::IfcObjective::setBenchmarkValues(::Ifc2x3::IfcMetric* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcMetric* Ifc2x3::IfcObjective::ResultValues() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcMetric>(true); }
void Ifc2x3::IfcObjective::setResultValues(::Ifc2x3::IfcMetric* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcObjectiveEnum::Value Ifc2x3::IfcObjective::ObjectiveQualifier() const {  return ::Ifc2x3::IfcObjectiveEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcObjective::setObjectiveQualifier(::Ifc2x3::IfcObjectiveEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcObjectiveEnum::ToString(v)));data_->setArgument(9,attr);} }
boost::optional< std::string > Ifc2x3::IfcObjective::UserDefinedQualifier() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } std::string v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcObjective::setUserDefinedQualifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcObjective::declaration() const { return *IFC2X3_IfcObjective_type; }
const IfcParse::entity& Ifc2x3::IfcObjective::Class() { return *IFC2X3_IfcObjective_type; }
Ifc2x3::IfcObjective::IfcObjective(IfcEntityInstanceData* e) : IfcConstraint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcObjective_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcObjective::IfcObjective(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcConstraintEnum::Value v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, ::Ifc2x3::IfcActorSelect* v5_CreatingActor, ::Ifc2x3::IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, ::Ifc2x3::IfcMetric* v8_BenchmarkValues, ::Ifc2x3::IfcMetric* v9_ResultValues, ::Ifc2x3::IfcObjectiveEnum::Value v10_ObjectiveQualifier, boost::optional< std::string > v11_UserDefinedQualifier) : IfcConstraint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcObjective_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_ConstraintGrade,::Ifc2x3::IfcConstraintEnum::ToString(v3_ConstraintGrade))));data_->setArgument(2,attr);} if (v4_ConstraintSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ConstraintSource));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CreatingActor));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CreationTime));data_->setArgument(5,attr);} if (v7_UserDefinedGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedGrade));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_BenchmarkValues));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ResultValues));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_ObjectiveQualifier,::Ifc2x3::IfcObjectiveEnum::ToString(v10_ObjectiveQualifier))));data_->setArgument(9,attr);} if (v11_UserDefinedQualifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_UserDefinedQualifier));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcOccupant
::Ifc2x3::IfcOccupantTypeEnum::Value Ifc2x3::IfcOccupant::PredefinedType() const {  return ::Ifc2x3::IfcOccupantTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcOccupant::setPredefinedType(::Ifc2x3::IfcOccupantTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcOccupantTypeEnum::ToString(v)));data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcOccupant::declaration() const { return *IFC2X3_IfcOccupant_type; }
const IfcParse::entity& Ifc2x3::IfcOccupant::Class() { return *IFC2X3_IfcOccupant_type; }
Ifc2x3::IfcOccupant::IfcOccupant(IfcEntityInstanceData* e) : IfcActor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOccupant_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOccupant::IfcOccupant(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcActorSelect* v6_TheActor, ::Ifc2x3::IfcOccupantTypeEnum::Value v7_PredefinedType) : IfcActor((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOccupant_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TheActor));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,::Ifc2x3::IfcOccupantTypeEnum::ToString(v7_PredefinedType))));data_->setArgument(6,attr);} }

// Function implementations for IfcOffsetCurve2D
::Ifc2x3::IfcCurve* Ifc2x3::IfcOffsetCurve2D::BasisCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcOffsetCurve2D::setBasisCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcOffsetCurve2D::Distance() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcOffsetCurve2D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::logic::tribool Ifc2x3::IfcOffsetCurve2D::SelfIntersect() const {  boost::logic::tribool v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcOffsetCurve2D::setSelfIntersect(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcOffsetCurve2D::declaration() const { return *IFC2X3_IfcOffsetCurve2D_type; }
const IfcParse::entity& Ifc2x3::IfcOffsetCurve2D::Class() { return *IFC2X3_IfcOffsetCurve2D_type; }
Ifc2x3::IfcOffsetCurve2D::IfcOffsetCurve2D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOffsetCurve2D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOffsetCurve2D::IfcOffsetCurve2D(::Ifc2x3::IfcCurve* v1_BasisCurve, double v2_Distance, boost::logic::tribool v3_SelfIntersect) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOffsetCurve2D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));data_->setArgument(2,attr);} }

// Function implementations for IfcOffsetCurve3D
::Ifc2x3::IfcCurve* Ifc2x3::IfcOffsetCurve3D::BasisCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcOffsetCurve3D::setBasisCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcOffsetCurve3D::Distance() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcOffsetCurve3D::setDistance(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::logic::tribool Ifc2x3::IfcOffsetCurve3D::SelfIntersect() const {  boost::logic::tribool v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcOffsetCurve3D::setSelfIntersect(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcDirection* Ifc2x3::IfcOffsetCurve3D::RefDirection() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcOffsetCurve3D::setRefDirection(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcOffsetCurve3D::declaration() const { return *IFC2X3_IfcOffsetCurve3D_type; }
const IfcParse::entity& Ifc2x3::IfcOffsetCurve3D::Class() { return *IFC2X3_IfcOffsetCurve3D_type; }
Ifc2x3::IfcOffsetCurve3D::IfcOffsetCurve3D(IfcEntityInstanceData* e) : IfcCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOffsetCurve3D_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOffsetCurve3D::IfcOffsetCurve3D(::Ifc2x3::IfcCurve* v1_BasisCurve, double v2_Distance, boost::logic::tribool v3_SelfIntersect, ::Ifc2x3::IfcDirection* v4_RefDirection) : IfcCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOffsetCurve3D_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Distance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_SelfIntersect));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RefDirection));data_->setArgument(3,attr);} }

// Function implementations for IfcOneDirectionRepeatFactor
::Ifc2x3::IfcVector* Ifc2x3::IfcOneDirectionRepeatFactor::RepeatFactor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcVector>(true); }
void Ifc2x3::IfcOneDirectionRepeatFactor::setRepeatFactor(::Ifc2x3::IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcOneDirectionRepeatFactor::declaration() const { return *IFC2X3_IfcOneDirectionRepeatFactor_type; }
const IfcParse::entity& Ifc2x3::IfcOneDirectionRepeatFactor::Class() { return *IFC2X3_IfcOneDirectionRepeatFactor_type; }
Ifc2x3::IfcOneDirectionRepeatFactor::IfcOneDirectionRepeatFactor(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOneDirectionRepeatFactor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOneDirectionRepeatFactor::IfcOneDirectionRepeatFactor(::Ifc2x3::IfcVector* v1_RepeatFactor) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOneDirectionRepeatFactor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatFactor));data_->setArgument(0,attr);} }

// Function implementations for IfcOpenShell


const IfcParse::entity& Ifc2x3::IfcOpenShell::declaration() const { return *IFC2X3_IfcOpenShell_type; }
const IfcParse::entity& Ifc2x3::IfcOpenShell::Class() { return *IFC2X3_IfcOpenShell_type; }
Ifc2x3::IfcOpenShell::IfcOpenShell(IfcEntityInstanceData* e) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOpenShell_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOpenShell::IfcOpenShell(aggregate_of< ::Ifc2x3::IfcFace >::ptr v1_CfsFaces) : IfcConnectedFaceSet((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOpenShell_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_CfsFaces)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcOpeningElement

::Ifc2x3::IfcRelFillsElement::list::ptr Ifc2x3::IfcOpeningElement::HasFillings() const { return data_->getInverse(IFC2X3_IfcRelFillsElement_type, 4)->as<IfcRelFillsElement>(); }

const IfcParse::entity& Ifc2x3::IfcOpeningElement::declaration() const { return *IFC2X3_IfcOpeningElement_type; }
const IfcParse::entity& Ifc2x3::IfcOpeningElement::Class() { return *IFC2X3_IfcOpeningElement_type; }
Ifc2x3::IfcOpeningElement::IfcOpeningElement(IfcEntityInstanceData* e) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOpeningElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOpeningElement::IfcOpeningElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElementSubtraction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOpeningElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcOpticalMaterialProperties
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::VisibleTransmittance() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setVisibleTransmittance(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::SolarTransmittance() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setSolarTransmittance(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::ThermalIrTransmittance() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setThermalIrTransmittance(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::ThermalIrEmissivityBack() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setThermalIrEmissivityBack(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::ThermalIrEmissivityFront() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setThermalIrEmissivityFront(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::VisibleReflectanceBack() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setVisibleReflectanceBack(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::VisibleReflectanceFront() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setVisibleReflectanceFront(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::SolarReflectanceFront() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setSolarReflectanceFront(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcOpticalMaterialProperties::SolarReflectanceBack() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcOpticalMaterialProperties::setSolarReflectanceBack(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcOpticalMaterialProperties::declaration() const { return *IFC2X3_IfcOpticalMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcOpticalMaterialProperties::Class() { return *IFC2X3_IfcOpticalMaterialProperties_type; }
Ifc2x3::IfcOpticalMaterialProperties::IfcOpticalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOpticalMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOpticalMaterialProperties::IfcOpticalMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_VisibleTransmittance, boost::optional< double > v3_SolarTransmittance, boost::optional< double > v4_ThermalIrTransmittance, boost::optional< double > v5_ThermalIrEmissivityBack, boost::optional< double > v6_ThermalIrEmissivityFront, boost::optional< double > v7_VisibleReflectanceBack, boost::optional< double > v8_VisibleReflectanceFront, boost::optional< double > v9_SolarReflectanceFront, boost::optional< double > v10_SolarReflectanceBack) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOpticalMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_VisibleTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_VisibleTransmittance));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SolarTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SolarTransmittance));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ThermalIrTransmittance) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ThermalIrTransmittance));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ThermalIrEmissivityBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ThermalIrEmissivityBack));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ThermalIrEmissivityFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ThermalIrEmissivityFront));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_VisibleReflectanceBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_VisibleReflectanceBack));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_VisibleReflectanceFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_VisibleReflectanceFront));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SolarReflectanceFront) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SolarReflectanceFront));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_SolarReflectanceBack) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SolarReflectanceBack));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcOrderAction
std::string Ifc2x3::IfcOrderAction::ActionID() const {  std::string v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcOrderAction::setActionID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcOrderAction::declaration() const { return *IFC2X3_IfcOrderAction_type; }
const IfcParse::entity& Ifc2x3::IfcOrderAction::Class() { return *IFC2X3_IfcOrderAction_type; }
Ifc2x3::IfcOrderAction::IfcOrderAction(IfcEntityInstanceData* e) : IfcTask((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOrderAction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOrderAction::IfcOrderAction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, std::string v11_ActionID) : IfcTask((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOrderAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));data_->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));data_->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ActionID));data_->setArgument(10,attr);} }

// Function implementations for IfcOrganization
boost::optional< std::string > Ifc2x3::IfcOrganization::Id() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcOrganization::setId(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
std::string Ifc2x3::IfcOrganization::Name() const {  std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcOrganization::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcOrganization::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcOrganization::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > Ifc2x3::IfcOrganization::Roles() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcActorRole >(); }
void Ifc2x3::IfcOrganization::setRoles(boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(3,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > Ifc2x3::IfcOrganization::Addresses() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcAddress >(); }
void Ifc2x3::IfcOrganization::setAddresses(boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(4,attr);} }

::Ifc2x3::IfcOrganizationRelationship::list::ptr Ifc2x3::IfcOrganization::IsRelatedBy() const { return data_->getInverse(IFC2X3_IfcOrganizationRelationship_type, 3)->as<IfcOrganizationRelationship>(); }
::Ifc2x3::IfcOrganizationRelationship::list::ptr Ifc2x3::IfcOrganization::Relates() const { return data_->getInverse(IFC2X3_IfcOrganizationRelationship_type, 2)->as<IfcOrganizationRelationship>(); }
::Ifc2x3::IfcPersonAndOrganization::list::ptr Ifc2x3::IfcOrganization::Engages() const { return data_->getInverse(IFC2X3_IfcPersonAndOrganization_type, 1)->as<IfcPersonAndOrganization>(); }

const IfcParse::entity& Ifc2x3::IfcOrganization::declaration() const { return *IFC2X3_IfcOrganization_type; }
const IfcParse::entity& Ifc2x3::IfcOrganization::Class() { return *IFC2X3_IfcOrganization_type; }
Ifc2x3::IfcOrganization::IfcOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcOrganization_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOrganization::IfcOrganization(boost::optional< std::string > v1_Id, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v4_Roles, boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > v5_Addresses) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcOrganization_type);  if (v1_Id) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Id));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Name));data_->setArgument(1,attr);} if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Roles)->generalize());data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Addresses)->generalize());data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcOrganizationRelationship
std::string Ifc2x3::IfcOrganizationRelationship::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcOrganizationRelationship::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcOrganizationRelationship::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcOrganizationRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcOrganization* Ifc2x3::IfcOrganizationRelationship::RelatingOrganization() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcOrganization>(true); }
void Ifc2x3::IfcOrganizationRelationship::setRelatingOrganization(::Ifc2x3::IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
aggregate_of< ::Ifc2x3::IfcOrganization >::ptr Ifc2x3::IfcOrganizationRelationship::RelatedOrganizations() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcOrganization >(); }
void Ifc2x3::IfcOrganizationRelationship::setRelatedOrganizations(aggregate_of< ::Ifc2x3::IfcOrganization >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcOrganizationRelationship::declaration() const { return *IFC2X3_IfcOrganizationRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcOrganizationRelationship::Class() { return *IFC2X3_IfcOrganizationRelationship_type; }
Ifc2x3::IfcOrganizationRelationship::IfcOrganizationRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcOrganizationRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOrganizationRelationship::IfcOrganizationRelationship(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcOrganization* v3_RelatingOrganization, aggregate_of< ::Ifc2x3::IfcOrganization >::ptr v4_RelatedOrganizations) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcOrganizationRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_RelatingOrganization));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_RelatedOrganizations)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcOrientedEdge
::Ifc2x3::IfcEdge* Ifc2x3::IfcOrientedEdge::EdgeElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcEdge>(true); }
void Ifc2x3::IfcOrientedEdge::setEdgeElement(::Ifc2x3::IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool Ifc2x3::IfcOrientedEdge::Orientation() const {  bool v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcOrientedEdge::setOrientation(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcOrientedEdge::declaration() const { return *IFC2X3_IfcOrientedEdge_type; }
const IfcParse::entity& Ifc2x3::IfcOrientedEdge::Class() { return *IFC2X3_IfcOrientedEdge_type; }
Ifc2x3::IfcOrientedEdge::IfcOrientedEdge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOrientedEdge_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOrientedEdge::IfcOrientedEdge(::Ifc2x3::IfcEdge* v3_EdgeElement, bool v4_Orientation) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOrientedEdge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EdgeElement));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Orientation));data_->setArgument(3,attr);} }

// Function implementations for IfcOutletType
::Ifc2x3::IfcOutletTypeEnum::Value Ifc2x3::IfcOutletType::PredefinedType() const {  return ::Ifc2x3::IfcOutletTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcOutletType::setPredefinedType(::Ifc2x3::IfcOutletTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcOutletTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcOutletType::declaration() const { return *IFC2X3_IfcOutletType_type; }
const IfcParse::entity& Ifc2x3::IfcOutletType::Class() { return *IFC2X3_IfcOutletType_type; }
Ifc2x3::IfcOutletType::IfcOutletType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcOutletType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOutletType::IfcOutletType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcOutletTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcOutletType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcOutletTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcOwnerHistory
::Ifc2x3::IfcPersonAndOrganization* Ifc2x3::IfcOwnerHistory::OwningUser() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcPersonAndOrganization>(true); }
void Ifc2x3::IfcOwnerHistory::setOwningUser(::Ifc2x3::IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcApplication* Ifc2x3::IfcOwnerHistory::OwningApplication() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcApplication>(true); }
void Ifc2x3::IfcOwnerHistory::setOwningApplication(::Ifc2x3::IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< ::Ifc2x3::IfcStateEnum::Value > Ifc2x3::IfcOwnerHistory::State() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } return ::Ifc2x3::IfcStateEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcOwnerHistory::setState(boost::optional< ::Ifc2x3::IfcStateEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcStateEnum::ToString(*v)));}data_->setArgument(2,attr);} }
::Ifc2x3::IfcChangeActionEnum::Value Ifc2x3::IfcOwnerHistory::ChangeAction() const {  return ::Ifc2x3::IfcChangeActionEnum::FromString(*data_->getArgument(3)); }
void Ifc2x3::IfcOwnerHistory::setChangeAction(::Ifc2x3::IfcChangeActionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcChangeActionEnum::ToString(v)));data_->setArgument(3,attr);} }
boost::optional< int > Ifc2x3::IfcOwnerHistory::LastModifiedDate() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } int v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcOwnerHistory::setLastModifiedDate(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
::Ifc2x3::IfcPersonAndOrganization* Ifc2x3::IfcOwnerHistory::LastModifyingUser() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcPersonAndOrganization>(true); }
void Ifc2x3::IfcOwnerHistory::setLastModifyingUser(::Ifc2x3::IfcPersonAndOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcApplication* Ifc2x3::IfcOwnerHistory::LastModifyingApplication() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcApplication>(true); }
void Ifc2x3::IfcOwnerHistory::setLastModifyingApplication(::Ifc2x3::IfcApplication* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
int Ifc2x3::IfcOwnerHistory::CreationDate() const {  int v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcOwnerHistory::setCreationDate(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcOwnerHistory::declaration() const { return *IFC2X3_IfcOwnerHistory_type; }
const IfcParse::entity& Ifc2x3::IfcOwnerHistory::Class() { return *IFC2X3_IfcOwnerHistory_type; }
Ifc2x3::IfcOwnerHistory::IfcOwnerHistory(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcOwnerHistory_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcOwnerHistory::IfcOwnerHistory(::Ifc2x3::IfcPersonAndOrganization* v1_OwningUser, ::Ifc2x3::IfcApplication* v2_OwningApplication, boost::optional< ::Ifc2x3::IfcStateEnum::Value > v3_State, ::Ifc2x3::IfcChangeActionEnum::Value v4_ChangeAction, boost::optional< int > v5_LastModifiedDate, ::Ifc2x3::IfcPersonAndOrganization* v6_LastModifyingUser, ::Ifc2x3::IfcApplication* v7_LastModifyingApplication, int v8_CreationDate) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcOwnerHistory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_OwningUser));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwningApplication));data_->setArgument(1,attr);} if (v3_State) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_State,::Ifc2x3::IfcStateEnum::ToString(*v3_State))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_ChangeAction,::Ifc2x3::IfcChangeActionEnum::ToString(v4_ChangeAction))));data_->setArgument(3,attr);} if (v5_LastModifiedDate) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LastModifiedDate));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LastModifyingUser));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LastModifyingApplication));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_CreationDate));data_->setArgument(7,attr);} }

// Function implementations for IfcParameterizedProfileDef
::Ifc2x3::IfcAxis2Placement2D* Ifc2x3::IfcParameterizedProfileDef::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAxis2Placement2D>(true); }
void Ifc2x3::IfcParameterizedProfileDef::setPosition(::Ifc2x3::IfcAxis2Placement2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcParameterizedProfileDef::declaration() const { return *IFC2X3_IfcParameterizedProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcParameterizedProfileDef::Class() { return *IFC2X3_IfcParameterizedProfileDef_type; }
Ifc2x3::IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcEntityInstanceData* e) : IfcProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcParameterizedProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcParameterizedProfileDef::IfcParameterizedProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position) : IfcProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcParameterizedProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);} }

// Function implementations for IfcPath
aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr Ifc2x3::IfcPath::EdgeList() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcOrientedEdge >(); }
void Ifc2x3::IfcPath::setEdgeList(aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPath::declaration() const { return *IFC2X3_IfcPath_type; }
const IfcParse::entity& Ifc2x3::IfcPath::Class() { return *IFC2X3_IfcPath_type; }
Ifc2x3::IfcPath::IfcPath(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPath_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPath::IfcPath(aggregate_of< ::Ifc2x3::IfcOrientedEdge >::ptr v1_EdgeList) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPath_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeList)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPerformanceHistory
std::string Ifc2x3::IfcPerformanceHistory::LifeCyclePhase() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPerformanceHistory::setLifeCyclePhase(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcPerformanceHistory::declaration() const { return *IFC2X3_IfcPerformanceHistory_type; }
const IfcParse::entity& Ifc2x3::IfcPerformanceHistory::Class() { return *IFC2X3_IfcPerformanceHistory_type; }
Ifc2x3::IfcPerformanceHistory::IfcPerformanceHistory(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPerformanceHistory_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPerformanceHistory::IfcPerformanceHistory(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_LifeCyclePhase) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPerformanceHistory_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LifeCyclePhase));data_->setArgument(5,attr);} }

// Function implementations for IfcPermeableCoveringProperties
::Ifc2x3::IfcPermeableCoveringOperationEnum::Value Ifc2x3::IfcPermeableCoveringProperties::OperationType() const {  return ::Ifc2x3::IfcPermeableCoveringOperationEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcPermeableCoveringProperties::setOperationType(::Ifc2x3::IfcPermeableCoveringOperationEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPermeableCoveringOperationEnum::ToString(v)));data_->setArgument(4,attr);} }
::Ifc2x3::IfcWindowPanelPositionEnum::Value Ifc2x3::IfcPermeableCoveringProperties::PanelPosition() const {  return ::Ifc2x3::IfcWindowPanelPositionEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcPermeableCoveringProperties::setPanelPosition(::Ifc2x3::IfcWindowPanelPositionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWindowPanelPositionEnum::ToString(v)));data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcPermeableCoveringProperties::FrameDepth() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcPermeableCoveringProperties::setFrameDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcPermeableCoveringProperties::FrameThickness() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcPermeableCoveringProperties::setFrameThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcPermeableCoveringProperties::ShapeAspectStyle() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcPermeableCoveringProperties::setShapeAspectStyle(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcPermeableCoveringProperties::declaration() const { return *IFC2X3_IfcPermeableCoveringProperties_type; }
const IfcParse::entity& Ifc2x3::IfcPermeableCoveringProperties::Class() { return *IFC2X3_IfcPermeableCoveringProperties_type; }
Ifc2x3::IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPermeableCoveringProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcPermeableCoveringOperationEnum::Value v5_OperationType, ::Ifc2x3::IfcWindowPanelPositionEnum::Value v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, ::Ifc2x3::IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPermeableCoveringProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,::Ifc2x3::IfcPermeableCoveringOperationEnum::ToString(v5_OperationType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,::Ifc2x3::IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));data_->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcPermit
std::string Ifc2x3::IfcPermit::PermitID() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPermit::setPermitID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcPermit::declaration() const { return *IFC2X3_IfcPermit_type; }
const IfcParse::entity& Ifc2x3::IfcPermit::Class() { return *IFC2X3_IfcPermit_type; }
Ifc2x3::IfcPermit::IfcPermit(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPermit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPermit::IfcPermit(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_PermitID) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPermit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_PermitID));data_->setArgument(5,attr);} }

// Function implementations for IfcPerson
boost::optional< std::string > Ifc2x3::IfcPerson::Id() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPerson::setId(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcPerson::FamilyName() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPerson::setFamilyName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcPerson::GivenName() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPerson::setGivenName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcPerson::MiddleNames() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPerson::setMiddleNames(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcPerson::PrefixTitles() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPerson::setPrefixTitles(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcPerson::SuffixTitles() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPerson::setSuffixTitles(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > Ifc2x3::IfcPerson::Roles() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(6); return es->as< ::Ifc2x3::IfcActorRole >(); }
void Ifc2x3::IfcPerson::setRoles(boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(6,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > Ifc2x3::IfcPerson::Addresses() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcAddress >(); }
void Ifc2x3::IfcPerson::setAddresses(boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(7,attr);} }

::Ifc2x3::IfcPersonAndOrganization::list::ptr Ifc2x3::IfcPerson::EngagedIn() const { return data_->getInverse(IFC2X3_IfcPersonAndOrganization_type, 0)->as<IfcPersonAndOrganization>(); }

const IfcParse::entity& Ifc2x3::IfcPerson::declaration() const { return *IFC2X3_IfcPerson_type; }
const IfcParse::entity& Ifc2x3::IfcPerson::Class() { return *IFC2X3_IfcPerson_type; }
Ifc2x3::IfcPerson::IfcPerson(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPerson_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPerson::IfcPerson(boost::optional< std::string > v1_Id, boost::optional< std::string > v2_FamilyName, boost::optional< std::string > v3_GivenName, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< std::string > /*[1:?]*/ > v6_SuffixTitles, boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v7_Roles, boost::optional< aggregate_of< ::Ifc2x3::IfcAddress >::ptr > v8_Addresses) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPerson_type);  if (v1_Id) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Id));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_FamilyName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_FamilyName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_GivenName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_GivenName));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_MiddleNames) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_MiddleNames));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_PrefixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_PrefixTitles));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_SuffixTitles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_SuffixTitles));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Roles)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Addresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Addresses)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcPersonAndOrganization
::Ifc2x3::IfcPerson* Ifc2x3::IfcPersonAndOrganization::ThePerson() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcPerson>(true); }
void Ifc2x3::IfcPersonAndOrganization::setThePerson(::Ifc2x3::IfcPerson* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcOrganization* Ifc2x3::IfcPersonAndOrganization::TheOrganization() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcOrganization>(true); }
void Ifc2x3::IfcPersonAndOrganization::setTheOrganization(::Ifc2x3::IfcOrganization* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > Ifc2x3::IfcPersonAndOrganization::Roles() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcActorRole >(); }
void Ifc2x3::IfcPersonAndOrganization::setRoles(boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcPersonAndOrganization::declaration() const { return *IFC2X3_IfcPersonAndOrganization_type; }
const IfcParse::entity& Ifc2x3::IfcPersonAndOrganization::Class() { return *IFC2X3_IfcPersonAndOrganization_type; }
Ifc2x3::IfcPersonAndOrganization::IfcPersonAndOrganization(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPersonAndOrganization_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPersonAndOrganization::IfcPersonAndOrganization(::Ifc2x3::IfcPerson* v1_ThePerson, ::Ifc2x3::IfcOrganization* v2_TheOrganization, boost::optional< aggregate_of< ::Ifc2x3::IfcActorRole >::ptr > v3_Roles) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPersonAndOrganization_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ThePerson));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TheOrganization));data_->setArgument(1,attr);} if (v3_Roles) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Roles)->generalize());data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcPhysicalComplexQuantity
aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr Ifc2x3::IfcPhysicalComplexQuantity::HasQuantities() const {  aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcPhysicalQuantity >(); }
void Ifc2x3::IfcPhysicalComplexQuantity::setHasQuantities(aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(2,attr);} }
std::string Ifc2x3::IfcPhysicalComplexQuantity::Discrimination() const {  std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPhysicalComplexQuantity::setDiscrimination(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcPhysicalComplexQuantity::Quality() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPhysicalComplexQuantity::setQuality(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcPhysicalComplexQuantity::Usage() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPhysicalComplexQuantity::setUsage(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcPhysicalComplexQuantity::declaration() const { return *IFC2X3_IfcPhysicalComplexQuantity_type; }
const IfcParse::entity& Ifc2x3::IfcPhysicalComplexQuantity::Class() { return *IFC2X3_IfcPhysicalComplexQuantity_type; }
Ifc2x3::IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPhysicalComplexQuantity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of< ::Ifc2x3::IfcPhysicalQuantity >::ptr v3_HasQuantities, std::string v4_Discrimination, boost::optional< std::string > v5_Quality, boost::optional< std::string > v6_Usage) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPhysicalComplexQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_HasQuantities)->generalize());data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Discrimination));data_->setArgument(3,attr);} if (v5_Quality) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Quality));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_Usage) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_Usage));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcPhysicalQuantity
std::string Ifc2x3::IfcPhysicalQuantity::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPhysicalQuantity::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcPhysicalQuantity::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPhysicalQuantity::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }

::Ifc2x3::IfcPhysicalComplexQuantity::list::ptr Ifc2x3::IfcPhysicalQuantity::PartOfComplex() const { return data_->getInverse(IFC2X3_IfcPhysicalComplexQuantity_type, 2)->as<IfcPhysicalComplexQuantity>(); }

const IfcParse::entity& Ifc2x3::IfcPhysicalQuantity::declaration() const { return *IFC2X3_IfcPhysicalQuantity_type; }
const IfcParse::entity& Ifc2x3::IfcPhysicalQuantity::Class() { return *IFC2X3_IfcPhysicalQuantity_type; }
Ifc2x3::IfcPhysicalQuantity::IfcPhysicalQuantity(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPhysicalQuantity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPhysicalQuantity::IfcPhysicalQuantity(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPhysicalQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcPhysicalSimpleQuantity
::Ifc2x3::IfcNamedUnit* Ifc2x3::IfcPhysicalSimpleQuantity::Unit() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcNamedUnit>(true); }
void Ifc2x3::IfcPhysicalSimpleQuantity::setUnit(::Ifc2x3::IfcNamedUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcPhysicalSimpleQuantity::declaration() const { return *IFC2X3_IfcPhysicalSimpleQuantity_type; }
const IfcParse::entity& Ifc2x3::IfcPhysicalSimpleQuantity::Class() { return *IFC2X3_IfcPhysicalSimpleQuantity_type; }
Ifc2x3::IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(IfcEntityInstanceData* e) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPhysicalSimpleQuantity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit) : IfcPhysicalQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPhysicalSimpleQuantity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);} }

// Function implementations for IfcPile
::Ifc2x3::IfcPileTypeEnum::Value Ifc2x3::IfcPile::PredefinedType() const {  return ::Ifc2x3::IfcPileTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcPile::setPredefinedType(::Ifc2x3::IfcPileTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPileTypeEnum::ToString(v)));data_->setArgument(8,attr);} }
boost::optional< ::Ifc2x3::IfcPileConstructionEnum::Value > Ifc2x3::IfcPile::ConstructionType() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } return ::Ifc2x3::IfcPileConstructionEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcPile::setConstructionType(boost::optional< ::Ifc2x3::IfcPileConstructionEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcPileConstructionEnum::ToString(*v)));}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPile::declaration() const { return *IFC2X3_IfcPile_type; }
const IfcParse::entity& Ifc2x3::IfcPile::Class() { return *IFC2X3_IfcPile_type; }
Ifc2x3::IfcPile::IfcPile(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPile_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPile::IfcPile(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcPileTypeEnum::Value v9_PredefinedType, boost::optional< ::Ifc2x3::IfcPileConstructionEnum::Value > v10_ConstructionType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPile_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_PredefinedType,::Ifc2x3::IfcPileTypeEnum::ToString(v9_PredefinedType))));data_->setArgument(8,attr);} if (v10_ConstructionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v10_ConstructionType,::Ifc2x3::IfcPileConstructionEnum::ToString(*v10_ConstructionType))));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcPipeFittingType
::Ifc2x3::IfcPipeFittingTypeEnum::Value Ifc2x3::IfcPipeFittingType::PredefinedType() const {  return ::Ifc2x3::IfcPipeFittingTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcPipeFittingType::setPredefinedType(::Ifc2x3::IfcPipeFittingTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPipeFittingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPipeFittingType::declaration() const { return *IFC2X3_IfcPipeFittingType_type; }
const IfcParse::entity& Ifc2x3::IfcPipeFittingType::Class() { return *IFC2X3_IfcPipeFittingType_type; }
Ifc2x3::IfcPipeFittingType::IfcPipeFittingType(IfcEntityInstanceData* e) : IfcFlowFittingType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPipeFittingType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPipeFittingType::IfcPipeFittingType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcPipeFittingTypeEnum::Value v10_PredefinedType) : IfcFlowFittingType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeFittingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcPipeFittingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPipeSegmentType
::Ifc2x3::IfcPipeSegmentTypeEnum::Value Ifc2x3::IfcPipeSegmentType::PredefinedType() const {  return ::Ifc2x3::IfcPipeSegmentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcPipeSegmentType::setPredefinedType(::Ifc2x3::IfcPipeSegmentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPipeSegmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPipeSegmentType::declaration() const { return *IFC2X3_IfcPipeSegmentType_type; }
const IfcParse::entity& Ifc2x3::IfcPipeSegmentType::Class() { return *IFC2X3_IfcPipeSegmentType_type; }
Ifc2x3::IfcPipeSegmentType::IfcPipeSegmentType(IfcEntityInstanceData* e) : IfcFlowSegmentType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPipeSegmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPipeSegmentType::IfcPipeSegmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcPipeSegmentTypeEnum::Value v10_PredefinedType) : IfcFlowSegmentType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPipeSegmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcPipeSegmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPixelTexture
int Ifc2x3::IfcPixelTexture::Width() const {  int v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPixelTexture::setWidth(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
int Ifc2x3::IfcPixelTexture::Height() const {  int v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPixelTexture::setHeight(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
int Ifc2x3::IfcPixelTexture::ColourComponents() const {  int v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcPixelTexture::setColourComponents(int v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
std::vector< boost::dynamic_bitset<> > /*[1:?]*/ Ifc2x3::IfcPixelTexture::Pixel() const {  std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcPixelTexture::setPixel(std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcPixelTexture::declaration() const { return *IFC2X3_IfcPixelTexture_type; }
const IfcParse::entity& Ifc2x3::IfcPixelTexture::Class() { return *IFC2X3_IfcPixelTexture_type; }
Ifc2x3::IfcPixelTexture::IfcPixelTexture(IfcEntityInstanceData* e) : IfcSurfaceTexture((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPixelTexture_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPixelTexture::IfcPixelTexture(bool v1_RepeatS, bool v2_RepeatT, ::Ifc2x3::IfcSurfaceTextureEnum::Value v3_TextureType, ::Ifc2x3::IfcCartesianTransformationOperator2D* v4_TextureTransform, int v5_Width, int v6_Height, int v7_ColourComponents, std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v8_Pixel) : IfcSurfaceTexture((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPixelTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,::Ifc2x3::IfcSurfaceTextureEnum::ToString(v3_TextureType))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Width));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Height));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ColourComponents));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Pixel));data_->setArgument(7,attr);} }

// Function implementations for IfcPlacement
::Ifc2x3::IfcCartesianPoint* Ifc2x3::IfcPlacement::Location() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCartesianPoint>(true); }
void Ifc2x3::IfcPlacement::setLocation(::Ifc2x3::IfcCartesianPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPlacement::declaration() const { return *IFC2X3_IfcPlacement_type; }
const IfcParse::entity& Ifc2x3::IfcPlacement::Class() { return *IFC2X3_IfcPlacement_type; }
Ifc2x3::IfcPlacement::IfcPlacement(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlacement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlacement::IfcPlacement(::Ifc2x3::IfcCartesianPoint* v1_Location) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlacement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Location));data_->setArgument(0,attr);} }

// Function implementations for IfcPlanarBox
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcPlanarBox::Placement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcPlanarBox::setPlacement(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcPlanarBox::declaration() const { return *IFC2X3_IfcPlanarBox_type; }
const IfcParse::entity& Ifc2x3::IfcPlanarBox::Class() { return *IFC2X3_IfcPlanarBox_type; }
Ifc2x3::IfcPlanarBox::IfcPlanarBox(IfcEntityInstanceData* e) : IfcPlanarExtent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlanarBox_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlanarBox::IfcPlanarBox(double v1_SizeInX, double v2_SizeInY, ::Ifc2x3::IfcAxis2Placement* v3_Placement) : IfcPlanarExtent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlanarBox_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Placement));data_->setArgument(2,attr);} }

// Function implementations for IfcPlanarExtent
double Ifc2x3::IfcPlanarExtent::SizeInX() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPlanarExtent::setSizeInX(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcPlanarExtent::SizeInY() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPlanarExtent::setSizeInY(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcPlanarExtent::declaration() const { return *IFC2X3_IfcPlanarExtent_type; }
const IfcParse::entity& Ifc2x3::IfcPlanarExtent::Class() { return *IFC2X3_IfcPlanarExtent_type; }
Ifc2x3::IfcPlanarExtent::IfcPlanarExtent(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlanarExtent_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlanarExtent::IfcPlanarExtent(double v1_SizeInX, double v2_SizeInY) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlanarExtent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SizeInX));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SizeInY));data_->setArgument(1,attr);} }

// Function implementations for IfcPlane


const IfcParse::entity& Ifc2x3::IfcPlane::declaration() const { return *IFC2X3_IfcPlane_type; }
const IfcParse::entity& Ifc2x3::IfcPlane::Class() { return *IFC2X3_IfcPlane_type; }
Ifc2x3::IfcPlane::IfcPlane(IfcEntityInstanceData* e) : IfcElementarySurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlane_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlane::IfcPlane(::Ifc2x3::IfcAxis2Placement3D* v1_Position) : IfcElementarySurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlane_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);} }

// Function implementations for IfcPlate


const IfcParse::entity& Ifc2x3::IfcPlate::declaration() const { return *IFC2X3_IfcPlate_type; }
const IfcParse::entity& Ifc2x3::IfcPlate::Class() { return *IFC2X3_IfcPlate_type; }
Ifc2x3::IfcPlate::IfcPlate(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlate_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlate::IfcPlate(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlate_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcPlateType
::Ifc2x3::IfcPlateTypeEnum::Value Ifc2x3::IfcPlateType::PredefinedType() const {  return ::Ifc2x3::IfcPlateTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcPlateType::setPredefinedType(::Ifc2x3::IfcPlateTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPlateTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPlateType::declaration() const { return *IFC2X3_IfcPlateType_type; }
const IfcParse::entity& Ifc2x3::IfcPlateType::Class() { return *IFC2X3_IfcPlateType_type; }
Ifc2x3::IfcPlateType::IfcPlateType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPlateType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPlateType::IfcPlateType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcPlateTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPlateType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcPlateTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcPoint


const IfcParse::entity& Ifc2x3::IfcPoint::declaration() const { return *IFC2X3_IfcPoint_type; }
const IfcParse::entity& Ifc2x3::IfcPoint::Class() { return *IFC2X3_IfcPoint_type; }
Ifc2x3::IfcPoint::IfcPoint(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPoint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPoint::IfcPoint() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPoint_type);  }

// Function implementations for IfcPointOnCurve
::Ifc2x3::IfcCurve* Ifc2x3::IfcPointOnCurve::BasisCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcPointOnCurve::setBasisCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcPointOnCurve::PointParameter() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPointOnCurve::setPointParameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcPointOnCurve::declaration() const { return *IFC2X3_IfcPointOnCurve_type; }
const IfcParse::entity& Ifc2x3::IfcPointOnCurve::Class() { return *IFC2X3_IfcPointOnCurve_type; }
Ifc2x3::IfcPointOnCurve::IfcPointOnCurve(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPointOnCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPointOnCurve::IfcPointOnCurve(::Ifc2x3::IfcCurve* v1_BasisCurve, double v2_PointParameter) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPointOnCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameter));data_->setArgument(1,attr);} }

// Function implementations for IfcPointOnSurface
::Ifc2x3::IfcSurface* Ifc2x3::IfcPointOnSurface::BasisSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcSurface>(true); }
void Ifc2x3::IfcPointOnSurface::setBasisSurface(::Ifc2x3::IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcPointOnSurface::PointParameterU() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPointOnSurface::setPointParameterU(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcPointOnSurface::PointParameterV() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPointOnSurface::setPointParameterV(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcPointOnSurface::declaration() const { return *IFC2X3_IfcPointOnSurface_type; }
const IfcParse::entity& Ifc2x3::IfcPointOnSurface::Class() { return *IFC2X3_IfcPointOnSurface_type; }
Ifc2x3::IfcPointOnSurface::IfcPointOnSurface(IfcEntityInstanceData* e) : IfcPoint((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPointOnSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPointOnSurface::IfcPointOnSurface(::Ifc2x3::IfcSurface* v1_BasisSurface, double v2_PointParameterU, double v3_PointParameterV) : IfcPoint((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPointOnSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_PointParameterU));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_PointParameterV));data_->setArgument(2,attr);} }

// Function implementations for IfcPolyLoop
aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr Ifc2x3::IfcPolyLoop::Polygon() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcCartesianPoint >(); }
void Ifc2x3::IfcPolyLoop::setPolygon(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPolyLoop::declaration() const { return *IFC2X3_IfcPolyLoop_type; }
const IfcParse::entity& Ifc2x3::IfcPolyLoop::Class() { return *IFC2X3_IfcPolyLoop_type; }
Ifc2x3::IfcPolyLoop::IfcPolyLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPolyLoop_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPolyLoop::IfcPolyLoop(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v1_Polygon) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPolyLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Polygon)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPolygonalBoundedHalfSpace
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcPolygonalBoundedHalfSpace::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcPolygonalBoundedHalfSpace::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcBoundedCurve* Ifc2x3::IfcPolygonalBoundedHalfSpace::PolygonalBoundary() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcBoundedCurve>(true); }
void Ifc2x3::IfcPolygonalBoundedHalfSpace::setPolygonalBoundary(::Ifc2x3::IfcBoundedCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPolygonalBoundedHalfSpace::declaration() const { return *IFC2X3_IfcPolygonalBoundedHalfSpace_type; }
const IfcParse::entity& Ifc2x3::IfcPolygonalBoundedHalfSpace::Class() { return *IFC2X3_IfcPolygonalBoundedHalfSpace_type; }
Ifc2x3::IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcEntityInstanceData* e) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPolygonalBoundedHalfSpace_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(::Ifc2x3::IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, ::Ifc2x3::IfcAxis2Placement3D* v3_Position, ::Ifc2x3::IfcBoundedCurve* v4_PolygonalBoundary) : IfcHalfSpaceSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPolygonalBoundedHalfSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BaseSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_AgreementFlag));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PolygonalBoundary));data_->setArgument(3,attr);} }

// Function implementations for IfcPolyline
aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr Ifc2x3::IfcPolyline::Points() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcCartesianPoint >(); }
void Ifc2x3::IfcPolyline::setPoints(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPolyline::declaration() const { return *IFC2X3_IfcPolyline_type; }
const IfcParse::entity& Ifc2x3::IfcPolyline::Class() { return *IFC2X3_IfcPolyline_type; }
Ifc2x3::IfcPolyline::IfcPolyline(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPolyline_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPolyline::IfcPolyline(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v1_Points) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPolyline_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Points)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcPort

::Ifc2x3::IfcRelConnectsPortToElement::list::ptr Ifc2x3::IfcPort::ContainedIn() const { return data_->getInverse(IFC2X3_IfcRelConnectsPortToElement_type, 4)->as<IfcRelConnectsPortToElement>(); }
::Ifc2x3::IfcRelConnectsPorts::list::ptr Ifc2x3::IfcPort::ConnectedFrom() const { return data_->getInverse(IFC2X3_IfcRelConnectsPorts_type, 5)->as<IfcRelConnectsPorts>(); }
::Ifc2x3::IfcRelConnectsPorts::list::ptr Ifc2x3::IfcPort::ConnectedTo() const { return data_->getInverse(IFC2X3_IfcRelConnectsPorts_type, 4)->as<IfcRelConnectsPorts>(); }

const IfcParse::entity& Ifc2x3::IfcPort::declaration() const { return *IFC2X3_IfcPort_type; }
const IfcParse::entity& Ifc2x3::IfcPort::Class() { return *IFC2X3_IfcPort_type; }
Ifc2x3::IfcPort::IfcPort(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPort_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPort::IfcPort(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPort_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcPostalAddress
boost::optional< std::string > Ifc2x3::IfcPostalAddress::InternalLocation() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPostalAddress::setInternalLocation(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcPostalAddress::AddressLines() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPostalAddress::setAddressLines(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcPostalAddress::PostalBox() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPostalAddress::setPostalBox(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcPostalAddress::Town() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcPostalAddress::setTown(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcPostalAddress::Region() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcPostalAddress::setRegion(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcPostalAddress::PostalCode() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcPostalAddress::setPostalCode(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< std::string > Ifc2x3::IfcPostalAddress::Country() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcPostalAddress::setCountry(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPostalAddress::declaration() const { return *IFC2X3_IfcPostalAddress_type; }
const IfcParse::entity& Ifc2x3::IfcPostalAddress::Class() { return *IFC2X3_IfcPostalAddress_type; }
Ifc2x3::IfcPostalAddress::IfcPostalAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPostalAddress_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPostalAddress::IfcPostalAddress(boost::optional< ::Ifc2x3::IfcAddressTypeEnum::Value > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::string > v4_InternalLocation, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_AddressLines, boost::optional< std::string > v6_PostalBox, boost::optional< std::string > v7_Town, boost::optional< std::string > v8_Region, boost::optional< std::string > v9_PostalCode, boost::optional< std::string > v10_Country) : IfcAddress((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPostalAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,::Ifc2x3::IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_InternalLocation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_InternalLocation));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_AddressLines) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_AddressLines));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PostalBox) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PostalBox));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Town) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Town));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Region) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Region));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PostalCode) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_PostalCode));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Country) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Country));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcPreDefinedColour


const IfcParse::entity& Ifc2x3::IfcPreDefinedColour::declaration() const { return *IFC2X3_IfcPreDefinedColour_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedColour::Class() { return *IFC2X3_IfcPreDefinedColour_type; }
Ifc2x3::IfcPreDefinedColour::IfcPreDefinedColour(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedColour_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedColour::IfcPreDefinedColour(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedColour_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedCurveFont


const IfcParse::entity& Ifc2x3::IfcPreDefinedCurveFont::declaration() const { return *IFC2X3_IfcPreDefinedCurveFont_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedCurveFont::Class() { return *IFC2X3_IfcPreDefinedCurveFont_type; }
Ifc2x3::IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedCurveFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedCurveFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedDimensionSymbol


const IfcParse::entity& Ifc2x3::IfcPreDefinedDimensionSymbol::declaration() const { return *IFC2X3_IfcPreDefinedDimensionSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedDimensionSymbol::Class() { return *IFC2X3_IfcPreDefinedDimensionSymbol_type; }
Ifc2x3::IfcPreDefinedDimensionSymbol::IfcPreDefinedDimensionSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedDimensionSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedDimensionSymbol::IfcPreDefinedDimensionSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedDimensionSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedItem
std::string Ifc2x3::IfcPreDefinedItem::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPreDefinedItem::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPreDefinedItem::declaration() const { return *IFC2X3_IfcPreDefinedItem_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedItem::Class() { return *IFC2X3_IfcPreDefinedItem_type; }
Ifc2x3::IfcPreDefinedItem::IfcPreDefinedItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedItem::IfcPreDefinedItem(std::string v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedPointMarkerSymbol


const IfcParse::entity& Ifc2x3::IfcPreDefinedPointMarkerSymbol::declaration() const { return *IFC2X3_IfcPreDefinedPointMarkerSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedPointMarkerSymbol::Class() { return *IFC2X3_IfcPreDefinedPointMarkerSymbol_type; }
Ifc2x3::IfcPreDefinedPointMarkerSymbol::IfcPreDefinedPointMarkerSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedPointMarkerSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedPointMarkerSymbol::IfcPreDefinedPointMarkerSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedPointMarkerSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedSymbol


const IfcParse::entity& Ifc2x3::IfcPreDefinedSymbol::declaration() const { return *IFC2X3_IfcPreDefinedSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedSymbol::Class() { return *IFC2X3_IfcPreDefinedSymbol_type; }
Ifc2x3::IfcPreDefinedSymbol::IfcPreDefinedSymbol(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedSymbol::IfcPreDefinedSymbol(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedTerminatorSymbol


const IfcParse::entity& Ifc2x3::IfcPreDefinedTerminatorSymbol::declaration() const { return *IFC2X3_IfcPreDefinedTerminatorSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedTerminatorSymbol::Class() { return *IFC2X3_IfcPreDefinedTerminatorSymbol_type; }
Ifc2x3::IfcPreDefinedTerminatorSymbol::IfcPreDefinedTerminatorSymbol(IfcEntityInstanceData* e) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedTerminatorSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedTerminatorSymbol::IfcPreDefinedTerminatorSymbol(std::string v1_Name) : IfcPreDefinedSymbol((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedTerminatorSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPreDefinedTextFont


const IfcParse::entity& Ifc2x3::IfcPreDefinedTextFont::declaration() const { return *IFC2X3_IfcPreDefinedTextFont_type; }
const IfcParse::entity& Ifc2x3::IfcPreDefinedTextFont::Class() { return *IFC2X3_IfcPreDefinedTextFont_type; }
Ifc2x3::IfcPreDefinedTextFont::IfcPreDefinedTextFont(IfcEntityInstanceData* e) : IfcPreDefinedItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPreDefinedTextFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPreDefinedTextFont::IfcPreDefinedTextFont(std::string v1_Name) : IfcPreDefinedItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPreDefinedTextFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} }

// Function implementations for IfcPresentationLayerAssignment
std::string Ifc2x3::IfcPresentationLayerAssignment::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPresentationLayerAssignment::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcPresentationLayerAssignment::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPresentationLayerAssignment::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcPresentationLayerAssignment::AssignedItems() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPresentationLayerAssignment::setAssignedItems(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcPresentationLayerAssignment::Identifier() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPresentationLayerAssignment::setIdentifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPresentationLayerAssignment::declaration() const { return *IFC2X3_IfcPresentationLayerAssignment_type; }
const IfcParse::entity& Ifc2x3::IfcPresentationLayerAssignment::Class() { return *IFC2X3_IfcPresentationLayerAssignment_type; }
Ifc2x3::IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPresentationLayerAssignment_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of_instance::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPresentationLayerAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));data_->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPresentationLayerWithStyle
boost::logic::tribool Ifc2x3::IfcPresentationLayerWithStyle::LayerOn() const {  boost::logic::tribool v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPresentationLayerWithStyle::setLayerOn(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
boost::logic::tribool Ifc2x3::IfcPresentationLayerWithStyle::LayerFrozen() const {  boost::logic::tribool v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcPresentationLayerWithStyle::setLayerFrozen(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::logic::tribool Ifc2x3::IfcPresentationLayerWithStyle::LayerBlocked() const {  boost::logic::tribool v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcPresentationLayerWithStyle::setLayerBlocked(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcPresentationLayerWithStyle::LayerStyles() const {  aggregate_of_instance::ptr v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcPresentationLayerWithStyle::setLayerStyles(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcPresentationLayerWithStyle::declaration() const { return *IFC2X3_IfcPresentationLayerWithStyle_type; }
const IfcParse::entity& Ifc2x3::IfcPresentationLayerWithStyle::Class() { return *IFC2X3_IfcPresentationLayerWithStyle_type; }
Ifc2x3::IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(IfcEntityInstanceData* e) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPresentationLayerWithStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of_instance::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier, boost::logic::tribool v5_LayerOn, boost::logic::tribool v6_LayerFrozen, boost::logic::tribool v7_LayerBlocked, aggregate_of_instance::ptr v8_LayerStyles) : IfcPresentationLayerAssignment((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPresentationLayerWithStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AssignedItems));data_->setArgument(2,attr);} if (v4_Identifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Identifier));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_LayerOn));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_LayerFrozen));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LayerBlocked));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LayerStyles));data_->setArgument(7,attr);} }

// Function implementations for IfcPresentationStyle
boost::optional< std::string > Ifc2x3::IfcPresentationStyle::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPresentationStyle::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPresentationStyle::declaration() const { return *IFC2X3_IfcPresentationStyle_type; }
const IfcParse::entity& Ifc2x3::IfcPresentationStyle::Class() { return *IFC2X3_IfcPresentationStyle_type; }
Ifc2x3::IfcPresentationStyle::IfcPresentationStyle(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPresentationStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPresentationStyle::IfcPresentationStyle(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPresentationStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcPresentationStyleAssignment
aggregate_of_instance::ptr Ifc2x3::IfcPresentationStyleAssignment::Styles() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPresentationStyleAssignment::setStyles(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcPresentationStyleAssignment::declaration() const { return *IFC2X3_IfcPresentationStyleAssignment_type; }
const IfcParse::entity& Ifc2x3::IfcPresentationStyleAssignment::Class() { return *IFC2X3_IfcPresentationStyleAssignment_type; }
Ifc2x3::IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPresentationStyleAssignment_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(aggregate_of_instance::ptr v1_Styles) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPresentationStyleAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Styles));data_->setArgument(0,attr);} }

// Function implementations for IfcProcedure
std::string Ifc2x3::IfcProcedure::ProcedureID() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcProcedure::setProcedureID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcProcedureTypeEnum::Value Ifc2x3::IfcProcedure::ProcedureType() const {  return ::Ifc2x3::IfcProcedureTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcProcedure::setProcedureType(::Ifc2x3::IfcProcedureTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProcedureTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcProcedure::UserDefinedProcedureType() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcProcedure::setUserDefinedProcedureType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcProcedure::declaration() const { return *IFC2X3_IfcProcedure_type; }
const IfcParse::entity& Ifc2x3::IfcProcedure::Class() { return *IFC2X3_IfcProcedure_type; }
Ifc2x3::IfcProcedure::IfcProcedure(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProcedure_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProcedure::IfcProcedure(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ProcedureID, ::Ifc2x3::IfcProcedureTypeEnum::Value v7_ProcedureType, boost::optional< std::string > v8_UserDefinedProcedureType) : IfcProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProcedure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ProcedureID));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ProcedureType,::Ifc2x3::IfcProcedureTypeEnum::ToString(v7_ProcedureType))));data_->setArgument(6,attr);} if (v8_UserDefinedProcedureType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_UserDefinedProcedureType));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcProcess

::Ifc2x3::IfcRelAssignsToProcess::list::ptr Ifc2x3::IfcProcess::OperatesOn() const { return data_->getInverse(IFC2X3_IfcRelAssignsToProcess_type, 6)->as<IfcRelAssignsToProcess>(); }
::Ifc2x3::IfcRelSequence::list::ptr Ifc2x3::IfcProcess::IsSuccessorFrom() const { return data_->getInverse(IFC2X3_IfcRelSequence_type, 5)->as<IfcRelSequence>(); }
::Ifc2x3::IfcRelSequence::list::ptr Ifc2x3::IfcProcess::IsPredecessorTo() const { return data_->getInverse(IFC2X3_IfcRelSequence_type, 4)->as<IfcRelSequence>(); }

const IfcParse::entity& Ifc2x3::IfcProcess::declaration() const { return *IFC2X3_IfcProcess_type; }
const IfcParse::entity& Ifc2x3::IfcProcess::Class() { return *IFC2X3_IfcProcess_type; }
Ifc2x3::IfcProcess::IfcProcess(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProcess_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProcess::IfcProcess(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProcess_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcProduct
::Ifc2x3::IfcObjectPlacement* Ifc2x3::IfcProduct::ObjectPlacement() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcObjectPlacement>(true); }
void Ifc2x3::IfcProduct::setObjectPlacement(::Ifc2x3::IfcObjectPlacement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcProductRepresentation* Ifc2x3::IfcProduct::Representation() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcProductRepresentation>(true); }
void Ifc2x3::IfcProduct::setRepresentation(::Ifc2x3::IfcProductRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }

::Ifc2x3::IfcRelAssignsToProduct::list::ptr Ifc2x3::IfcProduct::ReferencedBy() const { return data_->getInverse(IFC2X3_IfcRelAssignsToProduct_type, 6)->as<IfcRelAssignsToProduct>(); }

const IfcParse::entity& Ifc2x3::IfcProduct::declaration() const { return *IFC2X3_IfcProduct_type; }
const IfcParse::entity& Ifc2x3::IfcProduct::Class() { return *IFC2X3_IfcProduct_type; }
Ifc2x3::IfcProduct::IfcProduct(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProduct_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProduct::IfcProduct(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcProductDefinitionShape

::Ifc2x3::IfcProduct::list::ptr Ifc2x3::IfcProductDefinitionShape::ShapeOfProduct() const { return data_->getInverse(IFC2X3_IfcProduct_type, 6)->as<IfcProduct>(); }
::Ifc2x3::IfcShapeAspect::list::ptr Ifc2x3::IfcProductDefinitionShape::HasShapeAspects() const { return data_->getInverse(IFC2X3_IfcShapeAspect_type, 4)->as<IfcShapeAspect>(); }

const IfcParse::entity& Ifc2x3::IfcProductDefinitionShape::declaration() const { return *IFC2X3_IfcProductDefinitionShape_type; }
const IfcParse::entity& Ifc2x3::IfcProductDefinitionShape::Class() { return *IFC2X3_IfcProductDefinitionShape_type; }
Ifc2x3::IfcProductDefinitionShape::IfcProductDefinitionShape(IfcEntityInstanceData* e) : IfcProductRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProductDefinitionShape_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProductDefinitionShape::IfcProductDefinitionShape(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, aggregate_of< ::Ifc2x3::IfcRepresentation >::ptr v3_Representations) : IfcProductRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProductDefinitionShape_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcProductRepresentation
boost::optional< std::string > Ifc2x3::IfcProductRepresentation::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcProductRepresentation::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcProductRepresentation::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcProductRepresentation::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
aggregate_of< ::Ifc2x3::IfcRepresentation >::ptr Ifc2x3::IfcProductRepresentation::Representations() const {  aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcRepresentation >(); }
void Ifc2x3::IfcProductRepresentation::setRepresentations(aggregate_of< ::Ifc2x3::IfcRepresentation >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcProductRepresentation::declaration() const { return *IFC2X3_IfcProductRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcProductRepresentation::Class() { return *IFC2X3_IfcProductRepresentation_type; }
Ifc2x3::IfcProductRepresentation::IfcProductRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcProductRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProductRepresentation::IfcProductRepresentation(boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, aggregate_of< ::Ifc2x3::IfcRepresentation >::ptr v3_Representations) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcProductRepresentation_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Representations)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcProductsOfCombustionProperties
boost::optional< double > Ifc2x3::IfcProductsOfCombustionProperties::SpecificHeatCapacity() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcProductsOfCombustionProperties::setSpecificHeatCapacity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcProductsOfCombustionProperties::N20Content() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcProductsOfCombustionProperties::setN20Content(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcProductsOfCombustionProperties::COContent() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcProductsOfCombustionProperties::setCOContent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcProductsOfCombustionProperties::CO2Content() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcProductsOfCombustionProperties::setCO2Content(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcProductsOfCombustionProperties::declaration() const { return *IFC2X3_IfcProductsOfCombustionProperties_type; }
const IfcParse::entity& Ifc2x3::IfcProductsOfCombustionProperties::Class() { return *IFC2X3_IfcProductsOfCombustionProperties_type; }
Ifc2x3::IfcProductsOfCombustionProperties::IfcProductsOfCombustionProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProductsOfCombustionProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProductsOfCombustionProperties::IfcProductsOfCombustionProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_N20Content, boost::optional< double > v4_COContent, boost::optional< double > v5_CO2Content) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProductsOfCombustionProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_SpecificHeatCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SpecificHeatCapacity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_N20Content) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_N20Content));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_COContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_COContent));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_CO2Content) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_CO2Content));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcProfileDef
::Ifc2x3::IfcProfileTypeEnum::Value Ifc2x3::IfcProfileDef::ProfileType() const {  return ::Ifc2x3::IfcProfileTypeEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcProfileDef::setProfileType(::Ifc2x3::IfcProfileTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProfileTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcProfileDef::ProfileName() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcProfileDef::setProfileName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcProfileDef::declaration() const { return *IFC2X3_IfcProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcProfileDef::Class() { return *IFC2X3_IfcProfileDef_type; }
Ifc2x3::IfcProfileDef::IfcProfileDef(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProfileDef::IfcProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcProfileProperties
boost::optional< std::string > Ifc2x3::IfcProfileProperties::ProfileName() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcProfileProperties::setProfileName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcProfileProperties::ProfileDefinition() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcProfileProperties::setProfileDefinition(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcProfileProperties::declaration() const { return *IFC2X3_IfcProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcProfileProperties::Class() { return *IFC2X3_IfcProfileProperties_type; }
Ifc2x3::IfcProfileProperties::IfcProfileProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProfileProperties::IfcProfileProperties(boost::optional< std::string > v1_ProfileName, ::Ifc2x3::IfcProfileDef* v2_ProfileDefinition) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcProfileProperties_type);  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));data_->setArgument(1,attr);} }

// Function implementations for IfcProject
boost::optional< std::string > Ifc2x3::IfcProject::LongName() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcProject::setLongName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcProject::Phase() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcProject::setPhase(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
aggregate_of< ::Ifc2x3::IfcRepresentationContext >::ptr Ifc2x3::IfcProject::RepresentationContexts() const {  aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcRepresentationContext >(); }
void Ifc2x3::IfcProject::setRepresentationContexts(aggregate_of< ::Ifc2x3::IfcRepresentationContext >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(7,attr);} }
::Ifc2x3::IfcUnitAssignment* Ifc2x3::IfcProject::UnitsInContext() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcUnitAssignment>(true); }
void Ifc2x3::IfcProject::setUnitsInContext(::Ifc2x3::IfcUnitAssignment* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcProject::declaration() const { return *IFC2X3_IfcProject_type; }
const IfcParse::entity& Ifc2x3::IfcProject::Class() { return *IFC2X3_IfcProject_type; }
Ifc2x3::IfcProject::IfcProject(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProject_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProject::IfcProject(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, aggregate_of< ::Ifc2x3::IfcRepresentationContext >::ptr v8_RepresentationContexts, ::Ifc2x3::IfcUnitAssignment* v9_UnitsInContext) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LongName));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_Phase) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Phase));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RepresentationContexts)->generalize());data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_UnitsInContext));data_->setArgument(8,attr);} }

// Function implementations for IfcProjectOrder
std::string Ifc2x3::IfcProjectOrder::ID() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcProjectOrder::setID(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcProjectOrderTypeEnum::Value Ifc2x3::IfcProjectOrder::PredefinedType() const {  return ::Ifc2x3::IfcProjectOrderTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcProjectOrder::setPredefinedType(::Ifc2x3::IfcProjectOrderTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProjectOrderTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcProjectOrder::Status() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcProjectOrder::setStatus(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcProjectOrder::declaration() const { return *IFC2X3_IfcProjectOrder_type; }
const IfcParse::entity& Ifc2x3::IfcProjectOrder::Class() { return *IFC2X3_IfcProjectOrder_type; }
Ifc2x3::IfcProjectOrder::IfcProjectOrder(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProjectOrder_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProjectOrder::IfcProjectOrder(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ID, ::Ifc2x3::IfcProjectOrderTypeEnum::Value v7_PredefinedType, boost::optional< std::string > v8_Status) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrder_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ID));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,::Ifc2x3::IfcProjectOrderTypeEnum::ToString(v7_PredefinedType))));data_->setArgument(6,attr);} if (v8_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Status));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcProjectOrderRecord
aggregate_of< ::Ifc2x3::IfcRelAssignsToProjectOrder >::ptr Ifc2x3::IfcProjectOrderRecord::Records() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcRelAssignsToProjectOrder >(); }
void Ifc2x3::IfcProjectOrderRecord::setRecords(aggregate_of< ::Ifc2x3::IfcRelAssignsToProjectOrder >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }
::Ifc2x3::IfcProjectOrderRecordTypeEnum::Value Ifc2x3::IfcProjectOrderRecord::PredefinedType() const {  return ::Ifc2x3::IfcProjectOrderRecordTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcProjectOrderRecord::setPredefinedType(::Ifc2x3::IfcProjectOrderRecordTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProjectOrderRecordTypeEnum::ToString(v)));data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcProjectOrderRecord::declaration() const { return *IFC2X3_IfcProjectOrderRecord_type; }
const IfcParse::entity& Ifc2x3::IfcProjectOrderRecord::Class() { return *IFC2X3_IfcProjectOrderRecord_type; }
Ifc2x3::IfcProjectOrderRecord::IfcProjectOrderRecord(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProjectOrderRecord_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProjectOrderRecord::IfcProjectOrderRecord(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, aggregate_of< ::Ifc2x3::IfcRelAssignsToProjectOrder >::ptr v6_Records, ::Ifc2x3::IfcProjectOrderRecordTypeEnum::Value v7_PredefinedType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectOrderRecord_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Records)->generalize());data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PredefinedType,::Ifc2x3::IfcProjectOrderRecordTypeEnum::ToString(v7_PredefinedType))));data_->setArgument(6,attr);} }

// Function implementations for IfcProjectionCurve


const IfcParse::entity& Ifc2x3::IfcProjectionCurve::declaration() const { return *IFC2X3_IfcProjectionCurve_type; }
const IfcParse::entity& Ifc2x3::IfcProjectionCurve::Class() { return *IFC2X3_IfcProjectionCurve_type; }
Ifc2x3::IfcProjectionCurve::IfcProjectionCurve(IfcEntityInstanceData* e) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProjectionCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProjectionCurve::IfcProjectionCurve(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcAnnotationCurveOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectionCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcProjectionElement


const IfcParse::entity& Ifc2x3::IfcProjectionElement::declaration() const { return *IFC2X3_IfcProjectionElement_type; }
const IfcParse::entity& Ifc2x3::IfcProjectionElement::Class() { return *IFC2X3_IfcProjectionElement_type; }
Ifc2x3::IfcProjectionElement::IfcProjectionElement(IfcEntityInstanceData* e) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProjectionElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProjectionElement::IfcProjectionElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcFeatureElementAddition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProjectionElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcProperty
std::string Ifc2x3::IfcProperty::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcProperty::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcProperty::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcProperty::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }

::Ifc2x3::IfcPropertyDependencyRelationship::list::ptr Ifc2x3::IfcProperty::PropertyForDependance() const { return data_->getInverse(IFC2X3_IfcPropertyDependencyRelationship_type, 0)->as<IfcPropertyDependencyRelationship>(); }
::Ifc2x3::IfcPropertyDependencyRelationship::list::ptr Ifc2x3::IfcProperty::PropertyDependsOn() const { return data_->getInverse(IFC2X3_IfcPropertyDependencyRelationship_type, 1)->as<IfcPropertyDependencyRelationship>(); }
::Ifc2x3::IfcComplexProperty::list::ptr Ifc2x3::IfcProperty::PartOfComplex() const { return data_->getInverse(IFC2X3_IfcComplexProperty_type, 3)->as<IfcComplexProperty>(); }

const IfcParse::entity& Ifc2x3::IfcProperty::declaration() const { return *IFC2X3_IfcProperty_type; }
const IfcParse::entity& Ifc2x3::IfcProperty::Class() { return *IFC2X3_IfcProperty_type; }
Ifc2x3::IfcProperty::IfcProperty(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcProperty_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProperty::IfcProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcPropertyBoundedValue
::Ifc2x3::IfcValue* Ifc2x3::IfcPropertyBoundedValue::UpperBoundValue() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcValue>(true); }
void Ifc2x3::IfcPropertyBoundedValue::setUpperBoundValue(::Ifc2x3::IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcValue* Ifc2x3::IfcPropertyBoundedValue::LowerBoundValue() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcValue>(true); }
void Ifc2x3::IfcPropertyBoundedValue::setLowerBoundValue(::Ifc2x3::IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertyBoundedValue::Unit() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertyBoundedValue::setUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyBoundedValue::declaration() const { return *IFC2X3_IfcPropertyBoundedValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyBoundedValue::Class() { return *IFC2X3_IfcPropertyBoundedValue_type; }
Ifc2x3::IfcPropertyBoundedValue::IfcPropertyBoundedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyBoundedValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyBoundedValue::IfcPropertyBoundedValue(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcValue* v3_UpperBoundValue, ::Ifc2x3::IfcValue* v4_LowerBoundValue, ::Ifc2x3::IfcUnit* v5_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyBoundedValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_UpperBoundValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LowerBoundValue));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_Unit));data_->setArgument(4,attr);} }

// Function implementations for IfcPropertyConstraintRelationship
::Ifc2x3::IfcConstraint* Ifc2x3::IfcPropertyConstraintRelationship::RelatingConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcConstraint>(true); }
void Ifc2x3::IfcPropertyConstraintRelationship::setRelatingConstraint(::Ifc2x3::IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcPropertyConstraintRelationship::RelatedProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcPropertyConstraintRelationship::setRelatedProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyConstraintRelationship::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyConstraintRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyConstraintRelationship::Description() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPropertyConstraintRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyConstraintRelationship::declaration() const { return *IFC2X3_IfcPropertyConstraintRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyConstraintRelationship::Class() { return *IFC2X3_IfcPropertyConstraintRelationship_type; }
Ifc2x3::IfcPropertyConstraintRelationship::IfcPropertyConstraintRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPropertyConstraintRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyConstraintRelationship::IfcPropertyConstraintRelationship(::Ifc2x3::IfcConstraint* v1_RelatingConstraint, aggregate_of< ::Ifc2x3::IfcProperty >::ptr v2_RelatedProperties, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyConstraintRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelatingConstraint));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RelatedProperties)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertyDefinition

::Ifc2x3::IfcRelAssociates::list::ptr Ifc2x3::IfcPropertyDefinition::HasAssociations() const { return data_->getInverse(IFC2X3_IfcRelAssociates_type, 4)->as<IfcRelAssociates>(); }

const IfcParse::entity& Ifc2x3::IfcPropertyDefinition::declaration() const { return *IFC2X3_IfcPropertyDefinition_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyDefinition::Class() { return *IFC2X3_IfcPropertyDefinition_type; }
Ifc2x3::IfcPropertyDefinition::IfcPropertyDefinition(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyDefinition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyDefinition::IfcPropertyDefinition(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertyDependencyRelationship
::Ifc2x3::IfcProperty* Ifc2x3::IfcPropertyDependencyRelationship::DependingProperty() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcProperty>(true); }
void Ifc2x3::IfcPropertyDependencyRelationship::setDependingProperty(::Ifc2x3::IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcProperty* Ifc2x3::IfcPropertyDependencyRelationship::DependantProperty() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcProperty>(true); }
void Ifc2x3::IfcPropertyDependencyRelationship::setDependantProperty(::Ifc2x3::IfcProperty* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyDependencyRelationship::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyDependencyRelationship::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyDependencyRelationship::Description() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPropertyDependencyRelationship::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyDependencyRelationship::Expression() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPropertyDependencyRelationship::setExpression(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyDependencyRelationship::declaration() const { return *IFC2X3_IfcPropertyDependencyRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyDependencyRelationship::Class() { return *IFC2X3_IfcPropertyDependencyRelationship_type; }
Ifc2x3::IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPropertyDependencyRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(::Ifc2x3::IfcProperty* v1_DependingProperty, ::Ifc2x3::IfcProperty* v2_DependantProperty, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_Expression) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyDependencyRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DependingProperty));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DependantProperty));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcPropertyEnumeratedValue
aggregate_of_instance::ptr Ifc2x3::IfcPropertyEnumeratedValue::EnumerationValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyEnumeratedValue::setEnumerationValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcPropertyEnumeration* Ifc2x3::IfcPropertyEnumeratedValue::EnumerationReference() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcPropertyEnumeration>(true); }
void Ifc2x3::IfcPropertyEnumeratedValue::setEnumerationReference(::Ifc2x3::IfcPropertyEnumeration* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyEnumeratedValue::declaration() const { return *IFC2X3_IfcPropertyEnumeratedValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyEnumeratedValue::Class() { return *IFC2X3_IfcPropertyEnumeratedValue_type; }
Ifc2x3::IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyEnumeratedValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of_instance::ptr v3_EnumerationValues, ::Ifc2x3::IfcPropertyEnumeration* v4_EnumerationReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyEnumeratedValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EnumerationValues));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EnumerationReference));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyEnumeration
std::string Ifc2x3::IfcPropertyEnumeration::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcPropertyEnumeration::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcPropertyEnumeration::EnumerationValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcPropertyEnumeration::setEnumerationValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertyEnumeration::Unit() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertyEnumeration::setUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyEnumeration::declaration() const { return *IFC2X3_IfcPropertyEnumeration_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyEnumeration::Class() { return *IFC2X3_IfcPropertyEnumeration_type; }
Ifc2x3::IfcPropertyEnumeration::IfcPropertyEnumeration(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcPropertyEnumeration_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyEnumeration::IfcPropertyEnumeration(std::string v1_Name, aggregate_of_instance::ptr v2_EnumerationValues, ::Ifc2x3::IfcUnit* v3_Unit) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyEnumeration_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EnumerationValues));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);} }

// Function implementations for IfcPropertyListValue
aggregate_of_instance::ptr Ifc2x3::IfcPropertyListValue::ListValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyListValue::setListValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertyListValue::Unit() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertyListValue::setUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyListValue::declaration() const { return *IFC2X3_IfcPropertyListValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyListValue::Class() { return *IFC2X3_IfcPropertyListValue_type; }
Ifc2x3::IfcPropertyListValue::IfcPropertyListValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyListValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyListValue::IfcPropertyListValue(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of_instance::ptr v3_ListValues, ::Ifc2x3::IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyListValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ListValues));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyReferenceValue
boost::optional< std::string > Ifc2x3::IfcPropertyReferenceValue::UsageName() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyReferenceValue::setUsageName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
::Ifc2x3::IfcObjectReferenceSelect* Ifc2x3::IfcPropertyReferenceValue::PropertyReference() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcObjectReferenceSelect>(true); }
void Ifc2x3::IfcPropertyReferenceValue::setPropertyReference(::Ifc2x3::IfcObjectReferenceSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyReferenceValue::declaration() const { return *IFC2X3_IfcPropertyReferenceValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyReferenceValue::Class() { return *IFC2X3_IfcPropertyReferenceValue_type; }
Ifc2x3::IfcPropertyReferenceValue::IfcPropertyReferenceValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyReferenceValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyReferenceValue::IfcPropertyReferenceValue(std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UsageName, ::Ifc2x3::IfcObjectReferenceSelect* v4_PropertyReference) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyReferenceValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UsageName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UsageName));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_PropertyReference));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertySet
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcPropertySet::HasProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcPropertySet::setHasProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertySet::declaration() const { return *IFC2X3_IfcPropertySet_type; }
const IfcParse::entity& Ifc2x3::IfcPropertySet::Class() { return *IFC2X3_IfcPropertySet_type; }
Ifc2x3::IfcPropertySet::IfcPropertySet(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertySet_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertySet::IfcPropertySet(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcProperty >::ptr v5_HasProperties) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertySet_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_HasProperties)->generalize());data_->setArgument(4,attr);} }

// Function implementations for IfcPropertySetDefinition

::Ifc2x3::IfcRelDefinesByProperties::list::ptr Ifc2x3::IfcPropertySetDefinition::PropertyDefinitionOf() const { return data_->getInverse(IFC2X3_IfcRelDefinesByProperties_type, 5)->as<IfcRelDefinesByProperties>(); }
::Ifc2x3::IfcTypeObject::list::ptr Ifc2x3::IfcPropertySetDefinition::DefinesType() const { return data_->getInverse(IFC2X3_IfcTypeObject_type, 5)->as<IfcTypeObject>(); }

const IfcParse::entity& Ifc2x3::IfcPropertySetDefinition::declaration() const { return *IFC2X3_IfcPropertySetDefinition_type; }
const IfcParse::entity& Ifc2x3::IfcPropertySetDefinition::Class() { return *IFC2X3_IfcPropertySetDefinition_type; }
Ifc2x3::IfcPropertySetDefinition::IfcPropertySetDefinition(IfcEntityInstanceData* e) : IfcPropertyDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertySetDefinition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertySetDefinition::IfcPropertySetDefinition(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcPropertyDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertySetDefinition_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcPropertySingleValue
::Ifc2x3::IfcValue* Ifc2x3::IfcPropertySingleValue::NominalValue() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcValue>(true); }
void Ifc2x3::IfcPropertySingleValue::setNominalValue(::Ifc2x3::IfcValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertySingleValue::Unit() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertySingleValue::setUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertySingleValue::declaration() const { return *IFC2X3_IfcPropertySingleValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertySingleValue::Class() { return *IFC2X3_IfcPropertySingleValue_type; }
Ifc2x3::IfcPropertySingleValue::IfcPropertySingleValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertySingleValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertySingleValue::IfcPropertySingleValue(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcValue* v3_NominalValue, ::Ifc2x3::IfcUnit* v4_Unit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertySingleValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_NominalValue));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Unit));data_->setArgument(3,attr);} }

// Function implementations for IfcPropertyTableValue
aggregate_of_instance::ptr Ifc2x3::IfcPropertyTableValue::DefiningValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcPropertyTableValue::setDefiningValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcPropertyTableValue::DefinedValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcPropertyTableValue::setDefinedValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcPropertyTableValue::Expression() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcPropertyTableValue::setExpression(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertyTableValue::DefiningUnit() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertyTableValue::setDefiningUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcPropertyTableValue::DefinedUnit() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcPropertyTableValue::setDefinedUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcPropertyTableValue::declaration() const { return *IFC2X3_IfcPropertyTableValue_type; }
const IfcParse::entity& Ifc2x3::IfcPropertyTableValue::Class() { return *IFC2X3_IfcPropertyTableValue_type; }
Ifc2x3::IfcPropertyTableValue::IfcPropertyTableValue(IfcEntityInstanceData* e) : IfcSimpleProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPropertyTableValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPropertyTableValue::IfcPropertyTableValue(std::string v1_Name, boost::optional< std::string > v2_Description, aggregate_of_instance::ptr v3_DefiningValues, aggregate_of_instance::ptr v4_DefinedValues, boost::optional< std::string > v5_Expression, ::Ifc2x3::IfcUnit* v6_DefiningUnit, ::Ifc2x3::IfcUnit* v7_DefinedUnit) : IfcSimpleProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPropertyTableValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DefiningValues));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_DefinedValues));data_->setArgument(3,attr);} if (v5_Expression) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_Expression));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_DefiningUnit));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_DefinedUnit));data_->setArgument(6,attr);} }

// Function implementations for IfcProtectiveDeviceType
::Ifc2x3::IfcProtectiveDeviceTypeEnum::Value Ifc2x3::IfcProtectiveDeviceType::PredefinedType() const {  return ::Ifc2x3::IfcProtectiveDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcProtectiveDeviceType::setPredefinedType(::Ifc2x3::IfcProtectiveDeviceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProtectiveDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcProtectiveDeviceType::declaration() const { return *IFC2X3_IfcProtectiveDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcProtectiveDeviceType::Class() { return *IFC2X3_IfcProtectiveDeviceType_type; }
Ifc2x3::IfcProtectiveDeviceType::IfcProtectiveDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProtectiveDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProtectiveDeviceType::IfcProtectiveDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcProtectiveDeviceTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProtectiveDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcProtectiveDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcProxy
::Ifc2x3::IfcObjectTypeEnum::Value Ifc2x3::IfcProxy::ProxyType() const {  return ::Ifc2x3::IfcObjectTypeEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcProxy::setProxyType(::Ifc2x3::IfcObjectTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcObjectTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcProxy::Tag() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcProxy::setTag(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcProxy::declaration() const { return *IFC2X3_IfcProxy_type; }
const IfcParse::entity& Ifc2x3::IfcProxy::Class() { return *IFC2X3_IfcProxy_type; }
Ifc2x3::IfcProxy::IfcProxy(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcProxy_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcProxy::IfcProxy(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcObjectTypeEnum::Value v8_ProxyType, boost::optional< std::string > v9_Tag) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcProxy_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ProxyType,::Ifc2x3::IfcObjectTypeEnum::ToString(v8_ProxyType))));data_->setArgument(7,attr);} if (v9_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Tag));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcPumpType
::Ifc2x3::IfcPumpTypeEnum::Value Ifc2x3::IfcPumpType::PredefinedType() const {  return ::Ifc2x3::IfcPumpTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcPumpType::setPredefinedType(::Ifc2x3::IfcPumpTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPumpTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcPumpType::declaration() const { return *IFC2X3_IfcPumpType_type; }
const IfcParse::entity& Ifc2x3::IfcPumpType::Class() { return *IFC2X3_IfcPumpType_type; }
Ifc2x3::IfcPumpType::IfcPumpType(IfcEntityInstanceData* e) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcPumpType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcPumpType::IfcPumpType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcPumpTypeEnum::Value v10_PredefinedType) : IfcFlowMovingDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcPumpType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcPumpTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcQuantityArea
double Ifc2x3::IfcQuantityArea::AreaValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityArea::setAreaValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityArea::declaration() const { return *IFC2X3_IfcQuantityArea_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityArea::Class() { return *IFC2X3_IfcQuantityArea_type; }
Ifc2x3::IfcQuantityArea::IfcQuantityArea(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityArea_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityArea::IfcQuantityArea(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_AreaValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityArea_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AreaValue));data_->setArgument(3,attr);} }

// Function implementations for IfcQuantityCount
double Ifc2x3::IfcQuantityCount::CountValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityCount::setCountValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityCount::declaration() const { return *IFC2X3_IfcQuantityCount_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityCount::Class() { return *IFC2X3_IfcQuantityCount_type; }
Ifc2x3::IfcQuantityCount::IfcQuantityCount(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityCount_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityCount::IfcQuantityCount(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_CountValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityCount_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_CountValue));data_->setArgument(3,attr);} }

// Function implementations for IfcQuantityLength
double Ifc2x3::IfcQuantityLength::LengthValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityLength::setLengthValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityLength::declaration() const { return *IFC2X3_IfcQuantityLength_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityLength::Class() { return *IFC2X3_IfcQuantityLength_type; }
Ifc2x3::IfcQuantityLength::IfcQuantityLength(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityLength_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityLength::IfcQuantityLength(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_LengthValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityLength_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LengthValue));data_->setArgument(3,attr);} }

// Function implementations for IfcQuantityTime
double Ifc2x3::IfcQuantityTime::TimeValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityTime::setTimeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityTime::declaration() const { return *IFC2X3_IfcQuantityTime_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityTime::Class() { return *IFC2X3_IfcQuantityTime_type; }
Ifc2x3::IfcQuantityTime::IfcQuantityTime(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityTime_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityTime::IfcQuantityTime(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_TimeValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityTime_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TimeValue));data_->setArgument(3,attr);} }

// Function implementations for IfcQuantityVolume
double Ifc2x3::IfcQuantityVolume::VolumeValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityVolume::setVolumeValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityVolume::declaration() const { return *IFC2X3_IfcQuantityVolume_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityVolume::Class() { return *IFC2X3_IfcQuantityVolume_type; }
Ifc2x3::IfcQuantityVolume::IfcQuantityVolume(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityVolume_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityVolume::IfcQuantityVolume(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_VolumeValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityVolume_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_VolumeValue));data_->setArgument(3,attr);} }

// Function implementations for IfcQuantityWeight
double Ifc2x3::IfcQuantityWeight::WeightValue() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcQuantityWeight::setWeightValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcQuantityWeight::declaration() const { return *IFC2X3_IfcQuantityWeight_type; }
const IfcParse::entity& Ifc2x3::IfcQuantityWeight::Class() { return *IFC2X3_IfcQuantityWeight_type; }
Ifc2x3::IfcQuantityWeight::IfcQuantityWeight(IfcEntityInstanceData* e) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcQuantityWeight_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcQuantityWeight::IfcQuantityWeight(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcNamedUnit* v3_Unit, double v4_WeightValue) : IfcPhysicalSimpleQuantity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcQuantityWeight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Unit));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_WeightValue));data_->setArgument(3,attr);} }

// Function implementations for IfcRadiusDimension


const IfcParse::entity& Ifc2x3::IfcRadiusDimension::declaration() const { return *IFC2X3_IfcRadiusDimension_type; }
const IfcParse::entity& Ifc2x3::IfcRadiusDimension::Class() { return *IFC2X3_IfcRadiusDimension_type; }
Ifc2x3::IfcRadiusDimension::IfcRadiusDimension(IfcEntityInstanceData* e) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRadiusDimension_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRadiusDimension::IfcRadiusDimension(aggregate_of_instance::ptr v1_Contents) : IfcDimensionCurveDirectedCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRadiusDimension_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcRailing
boost::optional< ::Ifc2x3::IfcRailingTypeEnum::Value > Ifc2x3::IfcRailing::PredefinedType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcRailingTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcRailing::setPredefinedType(boost::optional< ::Ifc2x3::IfcRailingTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcRailingTypeEnum::ToString(*v)));}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRailing::declaration() const { return *IFC2X3_IfcRailing_type; }
const IfcParse::entity& Ifc2x3::IfcRailing::Class() { return *IFC2X3_IfcRailing_type; }
Ifc2x3::IfcRailing::IfcRailing(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRailing_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRailing::IfcRailing(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcRailingTypeEnum::Value > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRailing_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,::Ifc2x3::IfcRailingTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRailingType
::Ifc2x3::IfcRailingTypeEnum::Value Ifc2x3::IfcRailingType::PredefinedType() const {  return ::Ifc2x3::IfcRailingTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcRailingType::setPredefinedType(::Ifc2x3::IfcRailingTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRailingTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcRailingType::declaration() const { return *IFC2X3_IfcRailingType_type; }
const IfcParse::entity& Ifc2x3::IfcRailingType::Class() { return *IFC2X3_IfcRailingType_type; }
Ifc2x3::IfcRailingType::IfcRailingType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRailingType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRailingType::IfcRailingType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcRailingTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRailingType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcRailingTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRamp
::Ifc2x3::IfcRampTypeEnum::Value Ifc2x3::IfcRamp::ShapeType() const {  return ::Ifc2x3::IfcRampTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcRamp::setShapeType(::Ifc2x3::IfcRampTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRampTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRamp::declaration() const { return *IFC2X3_IfcRamp_type; }
const IfcParse::entity& Ifc2x3::IfcRamp::Class() { return *IFC2X3_IfcRamp_type; }
Ifc2x3::IfcRamp::IfcRamp(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRamp_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRamp::IfcRamp(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcRampTypeEnum::Value v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRamp_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,::Ifc2x3::IfcRampTypeEnum::ToString(v9_ShapeType))));data_->setArgument(8,attr);} }

// Function implementations for IfcRampFlight


const IfcParse::entity& Ifc2x3::IfcRampFlight::declaration() const { return *IFC2X3_IfcRampFlight_type; }
const IfcParse::entity& Ifc2x3::IfcRampFlight::Class() { return *IFC2X3_IfcRampFlight_type; }
Ifc2x3::IfcRampFlight::IfcRampFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRampFlight_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRampFlight::IfcRampFlight(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRampFlight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcRampFlightType
::Ifc2x3::IfcRampFlightTypeEnum::Value Ifc2x3::IfcRampFlightType::PredefinedType() const {  return ::Ifc2x3::IfcRampFlightTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcRampFlightType::setPredefinedType(::Ifc2x3::IfcRampFlightTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRampFlightTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcRampFlightType::declaration() const { return *IFC2X3_IfcRampFlightType_type; }
const IfcParse::entity& Ifc2x3::IfcRampFlightType::Class() { return *IFC2X3_IfcRampFlightType_type; }
Ifc2x3::IfcRampFlightType::IfcRampFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRampFlightType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRampFlightType::IfcRampFlightType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcRampFlightTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRampFlightType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcRampFlightTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcRationalBezierCurve
std::vector< double > /*[2:?]*/ Ifc2x3::IfcRationalBezierCurve::WeightsData() const {  std::vector< double > /*[2:?]*/ v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRationalBezierCurve::setWeightsData(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRationalBezierCurve::declaration() const { return *IFC2X3_IfcRationalBezierCurve_type; }
const IfcParse::entity& Ifc2x3::IfcRationalBezierCurve::Class() { return *IFC2X3_IfcRationalBezierCurve_type; }
Ifc2x3::IfcRationalBezierCurve::IfcRationalBezierCurve(IfcEntityInstanceData* e) : IfcBezierCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRationalBezierCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRationalBezierCurve::IfcRationalBezierCurve(int v1_Degree, aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v2_ControlPointsList, ::Ifc2x3::IfcBSplineCurveForm::Value v3_CurveForm, boost::logic::tribool v4_ClosedCurve, boost::logic::tribool v5_SelfIntersect, std::vector< double > /*[2:?]*/ v6_WeightsData) : IfcBezierCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRationalBezierCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Degree));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ControlPointsList)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_CurveForm,::Ifc2x3::IfcBSplineCurveForm::ToString(v3_CurveForm))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ClosedCurve));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SelfIntersect));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WeightsData));data_->setArgument(5,attr);} }

// Function implementations for IfcRectangleHollowProfileDef
double Ifc2x3::IfcRectangleHollowProfileDef::WallThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRectangleHollowProfileDef::setWallThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcRectangleHollowProfileDef::InnerFilletRadius() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcRectangleHollowProfileDef::setInnerFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcRectangleHollowProfileDef::OuterFilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcRectangleHollowProfileDef::setOuterFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRectangleHollowProfileDef::declaration() const { return *IFC2X3_IfcRectangleHollowProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcRectangleHollowProfileDef::Class() { return *IFC2X3_IfcRectangleHollowProfileDef_type; }
Ifc2x3::IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRectangleHollowProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_WallThickness, boost::optional< double > v7_InnerFilletRadius, boost::optional< double > v8_OuterFilletRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRectangleHollowProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WallThickness));data_->setArgument(5,attr);} if (v7_InnerFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_InnerFilletRadius));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_OuterFilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_OuterFilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcRectangleProfileDef
double Ifc2x3::IfcRectangleProfileDef::XDim() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRectangleProfileDef::setXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcRectangleProfileDef::YDim() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcRectangleProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcRectangleProfileDef::declaration() const { return *IFC2X3_IfcRectangleProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcRectangleProfileDef::Class() { return *IFC2X3_IfcRectangleProfileDef_type; }
Ifc2x3::IfcRectangleProfileDef::IfcRectangleProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRectangleProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRectangleProfileDef::IfcRectangleProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRectangleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);} }

// Function implementations for IfcRectangularPyramid
double Ifc2x3::IfcRectangularPyramid::XLength() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRectangularPyramid::setXLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcRectangularPyramid::YLength() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRectangularPyramid::setYLength(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcRectangularPyramid::Height() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRectangularPyramid::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcRectangularPyramid::declaration() const { return *IFC2X3_IfcRectangularPyramid_type; }
const IfcParse::entity& Ifc2x3::IfcRectangularPyramid::Class() { return *IFC2X3_IfcRectangularPyramid_type; }
Ifc2x3::IfcRectangularPyramid::IfcRectangularPyramid(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRectangularPyramid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRectangularPyramid::IfcRectangularPyramid(::Ifc2x3::IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_Height) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRectangularPyramid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_XLength));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_YLength));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Height));data_->setArgument(3,attr);} }

// Function implementations for IfcRectangularTrimmedSurface
::Ifc2x3::IfcSurface* Ifc2x3::IfcRectangularTrimmedSurface::BasisSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcSurface>(true); }
void Ifc2x3::IfcRectangularTrimmedSurface::setBasisSurface(::Ifc2x3::IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcRectangularTrimmedSurface::U1() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setU1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcRectangularTrimmedSurface::V1() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setV1(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcRectangularTrimmedSurface::U2() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setU2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcRectangularTrimmedSurface::V2() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setV2(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
bool Ifc2x3::IfcRectangularTrimmedSurface::Usense() const {  bool v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setUsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
bool Ifc2x3::IfcRectangularTrimmedSurface::Vsense() const {  bool v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcRectangularTrimmedSurface::setVsense(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRectangularTrimmedSurface::declaration() const { return *IFC2X3_IfcRectangularTrimmedSurface_type; }
const IfcParse::entity& Ifc2x3::IfcRectangularTrimmedSurface::Class() { return *IFC2X3_IfcRectangularTrimmedSurface_type; }
Ifc2x3::IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcEntityInstanceData* e) : IfcBoundedSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRectangularTrimmedSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(::Ifc2x3::IfcSurface* v1_BasisSurface, double v2_U1, double v3_V1, double v4_U2, double v5_V2, bool v6_Usense, bool v7_Vsense) : IfcBoundedSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRectangularTrimmedSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisSurface));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_U1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_V1));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_U2));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_V2));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Usense));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Vsense));data_->setArgument(6,attr);} }

// Function implementations for IfcReferencesValueDocument
::Ifc2x3::IfcDocumentSelect* Ifc2x3::IfcReferencesValueDocument::ReferencedDocument() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDocumentSelect>(true); }
void Ifc2x3::IfcReferencesValueDocument::setReferencedDocument(::Ifc2x3::IfcDocumentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr Ifc2x3::IfcReferencesValueDocument::ReferencingValues() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcAppliedValue >(); }
void Ifc2x3::IfcReferencesValueDocument::setReferencingValues(aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcReferencesValueDocument::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcReferencesValueDocument::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcReferencesValueDocument::Description() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcReferencesValueDocument::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcReferencesValueDocument::declaration() const { return *IFC2X3_IfcReferencesValueDocument_type; }
const IfcParse::entity& Ifc2x3::IfcReferencesValueDocument::Class() { return *IFC2X3_IfcReferencesValueDocument_type; }
Ifc2x3::IfcReferencesValueDocument::IfcReferencesValueDocument(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcReferencesValueDocument_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReferencesValueDocument::IfcReferencesValueDocument(::Ifc2x3::IfcDocumentSelect* v1_ReferencedDocument, aggregate_of< ::Ifc2x3::IfcAppliedValue >::ptr v2_ReferencingValues, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcReferencesValueDocument_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ReferencedDocument));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ReferencingValues)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRegularTimeSeries
double Ifc2x3::IfcRegularTimeSeries::TimeStep() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcRegularTimeSeries::setTimeStep(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
aggregate_of< ::Ifc2x3::IfcTimeSeriesValue >::ptr Ifc2x3::IfcRegularTimeSeries::Values() const {  aggregate_of_instance::ptr es = *data_->getArgument(9); return es->as< ::Ifc2x3::IfcTimeSeriesValue >(); }
void Ifc2x3::IfcRegularTimeSeries::setValues(aggregate_of< ::Ifc2x3::IfcTimeSeriesValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcRegularTimeSeries::declaration() const { return *IFC2X3_IfcRegularTimeSeries_type; }
const IfcParse::entity& Ifc2x3::IfcRegularTimeSeries::Class() { return *IFC2X3_IfcRegularTimeSeries_type; }
Ifc2x3::IfcRegularTimeSeries::IfcRegularTimeSeries(IfcEntityInstanceData* e) : IfcTimeSeries((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRegularTimeSeries_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRegularTimeSeries::IfcRegularTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDateTimeSelect* v3_StartTime, ::Ifc2x3::IfcDateTimeSelect* v4_EndTime, ::Ifc2x3::IfcTimeSeriesDataTypeEnum::Value v5_TimeSeriesDataType, ::Ifc2x3::IfcDataOriginEnum::Value v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, ::Ifc2x3::IfcUnit* v8_Unit, double v9_TimeStep, aggregate_of< ::Ifc2x3::IfcTimeSeriesValue >::ptr v10_Values) : IfcTimeSeries((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRegularTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,::Ifc2x3::IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,::Ifc2x3::IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_TimeStep));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_Values)->generalize());data_->setArgument(9,attr);} }

// Function implementations for IfcReinforcementBarProperties
double Ifc2x3::IfcReinforcementBarProperties::TotalCrossSectionArea() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcReinforcementBarProperties::setTotalCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
std::string Ifc2x3::IfcReinforcementBarProperties::SteelGrade() const {  std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcReinforcementBarProperties::setSteelGrade(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > Ifc2x3::IfcReinforcementBarProperties::BarSurface() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcReinforcementBarProperties::setBarSurface(boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcReinforcingBarSurfaceEnum::ToString(*v)));}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcReinforcementBarProperties::EffectiveDepth() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcReinforcementBarProperties::setEffectiveDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcReinforcementBarProperties::NominalBarDiameter() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcReinforcementBarProperties::setNominalBarDiameter(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcReinforcementBarProperties::BarCount() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcReinforcementBarProperties::setBarCount(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcReinforcementBarProperties::declaration() const { return *IFC2X3_IfcReinforcementBarProperties_type; }
const IfcParse::entity& Ifc2x3::IfcReinforcementBarProperties::Class() { return *IFC2X3_IfcReinforcementBarProperties_type; }
Ifc2x3::IfcReinforcementBarProperties::IfcReinforcementBarProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcReinforcementBarProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReinforcementBarProperties::IfcReinforcementBarProperties(double v1_TotalCrossSectionArea, std::string v2_SteelGrade, boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > v3_BarSurface, boost::optional< double > v4_EffectiveDepth, boost::optional< double > v5_NominalBarDiameter, boost::optional< double > v6_BarCount) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcementBarProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TotalCrossSectionArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SteelGrade));data_->setArgument(1,attr);} if (v3_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_BarSurface,::Ifc2x3::IfcReinforcingBarSurfaceEnum::ToString(*v3_BarSurface))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_EffectiveDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_EffectiveDepth));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_NominalBarDiameter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_NominalBarDiameter));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_BarCount) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_BarCount));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcReinforcementDefinitionProperties
boost::optional< std::string > Ifc2x3::IfcReinforcementDefinitionProperties::DefinitionType() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcReinforcementDefinitionProperties::setDefinitionType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcSectionReinforcementProperties >::ptr Ifc2x3::IfcReinforcementDefinitionProperties::ReinforcementSectionDefinitions() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcSectionReinforcementProperties >(); }
void Ifc2x3::IfcReinforcementDefinitionProperties::setReinforcementSectionDefinitions(aggregate_of< ::Ifc2x3::IfcSectionReinforcementProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcReinforcementDefinitionProperties::declaration() const { return *IFC2X3_IfcReinforcementDefinitionProperties_type; }
const IfcParse::entity& Ifc2x3::IfcReinforcementDefinitionProperties::Class() { return *IFC2X3_IfcReinforcementDefinitionProperties_type; }
Ifc2x3::IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcReinforcementDefinitionProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_DefinitionType, aggregate_of< ::Ifc2x3::IfcSectionReinforcementProperties >::ptr v6_ReinforcementSectionDefinitions) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcementDefinitionProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_DefinitionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DefinitionType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReinforcementSectionDefinitions)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcReinforcingBar
double Ifc2x3::IfcReinforcingBar::NominalDiameter() const {  double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcReinforcingBar::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
double Ifc2x3::IfcReinforcingBar::CrossSectionArea() const {  double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcReinforcingBar::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcReinforcingBar::BarLength() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcReinforcingBar::setBarLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
::Ifc2x3::IfcReinforcingBarRoleEnum::Value Ifc2x3::IfcReinforcingBar::BarRole() const {  return ::Ifc2x3::IfcReinforcingBarRoleEnum::FromString(*data_->getArgument(12)); }
void Ifc2x3::IfcReinforcingBar::setBarRole(::Ifc2x3::IfcReinforcingBarRoleEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcReinforcingBarRoleEnum::ToString(v)));data_->setArgument(12,attr);} }
boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > Ifc2x3::IfcReinforcingBar::BarSurface() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } return ::Ifc2x3::IfcReinforcingBarSurfaceEnum::FromString(*data_->getArgument(13)); }
void Ifc2x3::IfcReinforcingBar::setBarSurface(boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcReinforcingBarSurfaceEnum::ToString(*v)));}data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcReinforcingBar::declaration() const { return *IFC2X3_IfcReinforcingBar_type; }
const IfcParse::entity& Ifc2x3::IfcReinforcingBar::Class() { return *IFC2X3_IfcReinforcingBar_type; }
Ifc2x3::IfcReinforcingBar::IfcReinforcingBar(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcReinforcingBar_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReinforcingBar::IfcReinforcingBar(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, double v10_NominalDiameter, double v11_CrossSectionArea, boost::optional< double > v12_BarLength, ::Ifc2x3::IfcReinforcingBarRoleEnum::Value v13_BarRole, boost::optional< ::Ifc2x3::IfcReinforcingBarSurfaceEnum::Value > v14_BarSurface) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingBar_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_NominalDiameter));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CrossSectionArea));data_->setArgument(10,attr);} if (v12_BarLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_BarLength));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v13_BarRole,::Ifc2x3::IfcReinforcingBarRoleEnum::ToString(v13_BarRole))));data_->setArgument(12,attr);} if (v14_BarSurface) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_BarSurface,::Ifc2x3::IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } }

// Function implementations for IfcReinforcingElement
boost::optional< std::string > Ifc2x3::IfcReinforcingElement::SteelGrade() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcReinforcingElement::setSteelGrade(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcReinforcingElement::declaration() const { return *IFC2X3_IfcReinforcingElement_type; }
const IfcParse::entity& Ifc2x3::IfcReinforcingElement::Class() { return *IFC2X3_IfcReinforcingElement_type; }
Ifc2x3::IfcReinforcingElement::IfcReinforcingElement(IfcEntityInstanceData* e) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcReinforcingElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReinforcingElement::IfcReinforcingElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade) : IfcBuildingElementComponent((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcReinforcingMesh
boost::optional< double > Ifc2x3::IfcReinforcingMesh::MeshLength() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcReinforcingMesh::setMeshLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcReinforcingMesh::MeshWidth() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcReinforcingMesh::setMeshWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
double Ifc2x3::IfcReinforcingMesh::LongitudinalBarNominalDiameter() const {  double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcReinforcingMesh::setLongitudinalBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
double Ifc2x3::IfcReinforcingMesh::TransverseBarNominalDiameter() const {  double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcReinforcingMesh::setTransverseBarNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
double Ifc2x3::IfcReinforcingMesh::LongitudinalBarCrossSectionArea() const {  double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcReinforcingMesh::setLongitudinalBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }
double Ifc2x3::IfcReinforcingMesh::TransverseBarCrossSectionArea() const {  double v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcReinforcingMesh::setTransverseBarCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(14,attr);} }
double Ifc2x3::IfcReinforcingMesh::LongitudinalBarSpacing() const {  double v = *data_->getArgument(15); return v; }
void Ifc2x3::IfcReinforcingMesh::setLongitudinalBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(15,attr);} }
double Ifc2x3::IfcReinforcingMesh::TransverseBarSpacing() const {  double v = *data_->getArgument(16); return v; }
void Ifc2x3::IfcReinforcingMesh::setTransverseBarSpacing(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(16,attr);} }


const IfcParse::entity& Ifc2x3::IfcReinforcingMesh::declaration() const { return *IFC2X3_IfcReinforcingMesh_type; }
const IfcParse::entity& Ifc2x3::IfcReinforcingMesh::Class() { return *IFC2X3_IfcReinforcingMesh_type; }
Ifc2x3::IfcReinforcingMesh::IfcReinforcingMesh(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcReinforcingMesh_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcReinforcingMesh::IfcReinforcingMesh(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_MeshLength, boost::optional< double > v11_MeshWidth, double v12_LongitudinalBarNominalDiameter, double v13_TransverseBarNominalDiameter, double v14_LongitudinalBarCrossSectionArea, double v15_TransverseBarCrossSectionArea, double v16_LongitudinalBarSpacing, double v17_TransverseBarSpacing) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcReinforcingMesh_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_MeshLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MeshLength));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_MeshWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MeshWidth));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LongitudinalBarNominalDiameter));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_TransverseBarNominalDiameter));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_LongitudinalBarCrossSectionArea));data_->setArgument(13,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v15_TransverseBarCrossSectionArea));data_->setArgument(14,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v16_LongitudinalBarSpacing));data_->setArgument(15,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v17_TransverseBarSpacing));data_->setArgument(16,attr);} }

// Function implementations for IfcRelAggregates


const IfcParse::entity& Ifc2x3::IfcRelAggregates::declaration() const { return *IFC2X3_IfcRelAggregates_type; }
const IfcParse::entity& Ifc2x3::IfcRelAggregates::Class() { return *IFC2X3_IfcRelAggregates_type; }
Ifc2x3::IfcRelAggregates::IfcRelAggregates(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAggregates_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAggregates::IfcRelAggregates(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcObjectDefinition* v5_RelatingObject, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAggregates_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssigns
aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr Ifc2x3::IfcRelAssigns::RelatedObjects() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcObjectDefinition >(); }
void Ifc2x3::IfcRelAssigns::setRelatedObjects(aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }
boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > Ifc2x3::IfcRelAssigns::RelatedObjectsType() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } return ::Ifc2x3::IfcObjectTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcRelAssigns::setRelatedObjectsType(boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcObjectTypeEnum::ToString(*v)));}data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssigns::declaration() const { return *IFC2X3_IfcRelAssigns_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssigns::Class() { return *IFC2X3_IfcRelAssigns_type; }
Ifc2x3::IfcRelAssigns::IfcRelAssigns(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssigns_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssigns::IfcRelAssigns(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssigns_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcRelAssignsTasks
::Ifc2x3::IfcScheduleTimeControl* Ifc2x3::IfcRelAssignsTasks::TimeForTask() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcScheduleTimeControl>(true); }
void Ifc2x3::IfcRelAssignsTasks::setTimeForTask(::Ifc2x3::IfcScheduleTimeControl* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsTasks::declaration() const { return *IFC2X3_IfcRelAssignsTasks_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsTasks::Class() { return *IFC2X3_IfcRelAssignsTasks_type; }
Ifc2x3::IfcRelAssignsTasks::IfcRelAssignsTasks(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsTasks_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsTasks::IfcRelAssignsTasks(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcControl* v7_RelatingControl, ::Ifc2x3::IfcScheduleTimeControl* v8_TimeForTask) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsTasks_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_TimeForTask));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToActor
::Ifc2x3::IfcActor* Ifc2x3::IfcRelAssignsToActor::RelatingActor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcActor>(true); }
void Ifc2x3::IfcRelAssignsToActor::setRelatingActor(::Ifc2x3::IfcActor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcActorRole* Ifc2x3::IfcRelAssignsToActor::ActingRole() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcActorRole>(true); }
void Ifc2x3::IfcRelAssignsToActor::setActingRole(::Ifc2x3::IfcActorRole* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToActor::declaration() const { return *IFC2X3_IfcRelAssignsToActor_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToActor::Class() { return *IFC2X3_IfcRelAssignsToActor_type; }
Ifc2x3::IfcRelAssignsToActor::IfcRelAssignsToActor(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToActor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToActor::IfcRelAssignsToActor(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcActor* v7_RelatingActor, ::Ifc2x3::IfcActorRole* v8_ActingRole) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToActor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingActor));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ActingRole));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToControl
::Ifc2x3::IfcControl* Ifc2x3::IfcRelAssignsToControl::RelatingControl() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcControl>(true); }
void Ifc2x3::IfcRelAssignsToControl::setRelatingControl(::Ifc2x3::IfcControl* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToControl::declaration() const { return *IFC2X3_IfcRelAssignsToControl_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToControl::Class() { return *IFC2X3_IfcRelAssignsToControl_type; }
Ifc2x3::IfcRelAssignsToControl::IfcRelAssignsToControl(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToControl_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToControl::IfcRelAssignsToControl(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcControl* v7_RelatingControl) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToGroup
::Ifc2x3::IfcGroup* Ifc2x3::IfcRelAssignsToGroup::RelatingGroup() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcGroup>(true); }
void Ifc2x3::IfcRelAssignsToGroup::setRelatingGroup(::Ifc2x3::IfcGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToGroup::declaration() const { return *IFC2X3_IfcRelAssignsToGroup_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToGroup::Class() { return *IFC2X3_IfcRelAssignsToGroup_type; }
Ifc2x3::IfcRelAssignsToGroup::IfcRelAssignsToGroup(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToGroup_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToGroup::IfcRelAssignsToGroup(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcGroup* v7_RelatingGroup) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingGroup));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToProcess
::Ifc2x3::IfcProcess* Ifc2x3::IfcRelAssignsToProcess::RelatingProcess() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcProcess>(true); }
void Ifc2x3::IfcRelAssignsToProcess::setRelatingProcess(::Ifc2x3::IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcMeasureWithUnit* Ifc2x3::IfcRelAssignsToProcess::QuantityInProcess() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcMeasureWithUnit>(true); }
void Ifc2x3::IfcRelAssignsToProcess::setQuantityInProcess(::Ifc2x3::IfcMeasureWithUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToProcess::declaration() const { return *IFC2X3_IfcRelAssignsToProcess_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToProcess::Class() { return *IFC2X3_IfcRelAssignsToProcess_type; }
Ifc2x3::IfcRelAssignsToProcess::IfcRelAssignsToProcess(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToProcess_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToProcess::IfcRelAssignsToProcess(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcProcess* v7_RelatingProcess, ::Ifc2x3::IfcMeasureWithUnit* v8_QuantityInProcess) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToProcess_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProcess));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_QuantityInProcess));data_->setArgument(7,attr);} }

// Function implementations for IfcRelAssignsToProduct
::Ifc2x3::IfcProduct* Ifc2x3::IfcRelAssignsToProduct::RelatingProduct() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcProduct>(true); }
void Ifc2x3::IfcRelAssignsToProduct::setRelatingProduct(::Ifc2x3::IfcProduct* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToProduct::declaration() const { return *IFC2X3_IfcRelAssignsToProduct_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToProduct::Class() { return *IFC2X3_IfcRelAssignsToProduct_type; }
Ifc2x3::IfcRelAssignsToProduct::IfcRelAssignsToProduct(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToProduct_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToProduct::IfcRelAssignsToProduct(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcProduct* v7_RelatingProduct) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingProduct));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToProjectOrder


const IfcParse::entity& Ifc2x3::IfcRelAssignsToProjectOrder::declaration() const { return *IFC2X3_IfcRelAssignsToProjectOrder_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToProjectOrder::Class() { return *IFC2X3_IfcRelAssignsToProjectOrder_type; }
Ifc2x3::IfcRelAssignsToProjectOrder::IfcRelAssignsToProjectOrder(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToProjectOrder_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToProjectOrder::IfcRelAssignsToProjectOrder(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcControl* v7_RelatingControl) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToProjectOrder_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssignsToResource
::Ifc2x3::IfcResource* Ifc2x3::IfcRelAssignsToResource::RelatingResource() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcResource>(true); }
void Ifc2x3::IfcRelAssignsToResource::setRelatingResource(::Ifc2x3::IfcResource* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssignsToResource::declaration() const { return *IFC2X3_IfcRelAssignsToResource_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssignsToResource::Class() { return *IFC2X3_IfcRelAssignsToResource_type; }
Ifc2x3::IfcRelAssignsToResource::IfcRelAssignsToResource(IfcEntityInstanceData* e) : IfcRelAssigns((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssignsToResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssignsToResource::IfcRelAssignsToResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcResource* v7_RelatingResource) : IfcRelAssigns((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssignsToResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingResource));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssociates
aggregate_of< ::Ifc2x3::IfcRoot >::ptr Ifc2x3::IfcRelAssociates::RelatedObjects() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcRoot >(); }
void Ifc2x3::IfcRelAssociates::setRelatedObjects(aggregate_of< ::Ifc2x3::IfcRoot >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociates::declaration() const { return *IFC2X3_IfcRelAssociates_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociates::Class() { return *IFC2X3_IfcRelAssociates_type; }
Ifc2x3::IfcRelAssociates::IfcRelAssociates(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociates_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociates::IfcRelAssociates(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociates_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} }

// Function implementations for IfcRelAssociatesAppliedValue
::Ifc2x3::IfcAppliedValue* Ifc2x3::IfcRelAssociatesAppliedValue::RelatingAppliedValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcAppliedValue>(true); }
void Ifc2x3::IfcRelAssociatesAppliedValue::setRelatingAppliedValue(::Ifc2x3::IfcAppliedValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesAppliedValue::declaration() const { return *IFC2X3_IfcRelAssociatesAppliedValue_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesAppliedValue::Class() { return *IFC2X3_IfcRelAssociatesAppliedValue_type; }
Ifc2x3::IfcRelAssociatesAppliedValue::IfcRelAssociatesAppliedValue(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesAppliedValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesAppliedValue::IfcRelAssociatesAppliedValue(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcAppliedValue* v6_RelatingAppliedValue) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesAppliedValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingAppliedValue));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesApproval
::Ifc2x3::IfcApproval* Ifc2x3::IfcRelAssociatesApproval::RelatingApproval() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcApproval>(true); }
void Ifc2x3::IfcRelAssociatesApproval::setRelatingApproval(::Ifc2x3::IfcApproval* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesApproval::declaration() const { return *IFC2X3_IfcRelAssociatesApproval_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesApproval::Class() { return *IFC2X3_IfcRelAssociatesApproval_type; }
Ifc2x3::IfcRelAssociatesApproval::IfcRelAssociatesApproval(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesApproval_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesApproval::IfcRelAssociatesApproval(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcApproval* v6_RelatingApproval) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesApproval_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingApproval));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesClassification
::Ifc2x3::IfcClassificationNotationSelect* Ifc2x3::IfcRelAssociatesClassification::RelatingClassification() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcClassificationNotationSelect>(true); }
void Ifc2x3::IfcRelAssociatesClassification::setRelatingClassification(::Ifc2x3::IfcClassificationNotationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesClassification::declaration() const { return *IFC2X3_IfcRelAssociatesClassification_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesClassification::Class() { return *IFC2X3_IfcRelAssociatesClassification_type; }
Ifc2x3::IfcRelAssociatesClassification::IfcRelAssociatesClassification(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesClassification_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesClassification::IfcRelAssociatesClassification(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcClassificationNotationSelect* v6_RelatingClassification) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesClassification_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingClassification));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesConstraint
std::string Ifc2x3::IfcRelAssociatesConstraint::Intent() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRelAssociatesConstraint::setIntent(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcConstraint* Ifc2x3::IfcRelAssociatesConstraint::RelatingConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcConstraint>(true); }
void Ifc2x3::IfcRelAssociatesConstraint::setRelatingConstraint(::Ifc2x3::IfcConstraint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesConstraint::declaration() const { return *IFC2X3_IfcRelAssociatesConstraint_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesConstraint::Class() { return *IFC2X3_IfcRelAssociatesConstraint_type; }
Ifc2x3::IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesConstraint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, std::string v6_Intent, ::Ifc2x3::IfcConstraint* v7_RelatingConstraint) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesConstraint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Intent));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingConstraint));data_->setArgument(6,attr);} }

// Function implementations for IfcRelAssociatesDocument
::Ifc2x3::IfcDocumentSelect* Ifc2x3::IfcRelAssociatesDocument::RelatingDocument() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDocumentSelect>(true); }
void Ifc2x3::IfcRelAssociatesDocument::setRelatingDocument(::Ifc2x3::IfcDocumentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesDocument::declaration() const { return *IFC2X3_IfcRelAssociatesDocument_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesDocument::Class() { return *IFC2X3_IfcRelAssociatesDocument_type; }
Ifc2x3::IfcRelAssociatesDocument::IfcRelAssociatesDocument(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesDocument_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesDocument::IfcRelAssociatesDocument(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcDocumentSelect* v6_RelatingDocument) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesDocument_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingDocument));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesLibrary
::Ifc2x3::IfcLibrarySelect* Ifc2x3::IfcRelAssociatesLibrary::RelatingLibrary() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcLibrarySelect>(true); }
void Ifc2x3::IfcRelAssociatesLibrary::setRelatingLibrary(::Ifc2x3::IfcLibrarySelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesLibrary::declaration() const { return *IFC2X3_IfcRelAssociatesLibrary_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesLibrary::Class() { return *IFC2X3_IfcRelAssociatesLibrary_type; }
Ifc2x3::IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesLibrary_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcLibrarySelect* v6_RelatingLibrary) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesLibrary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingLibrary));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesMaterial
::Ifc2x3::IfcMaterialSelect* Ifc2x3::IfcRelAssociatesMaterial::RelatingMaterial() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcMaterialSelect>(true); }
void Ifc2x3::IfcRelAssociatesMaterial::setRelatingMaterial(::Ifc2x3::IfcMaterialSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesMaterial::declaration() const { return *IFC2X3_IfcRelAssociatesMaterial_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesMaterial::Class() { return *IFC2X3_IfcRelAssociatesMaterial_type; }
Ifc2x3::IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesMaterial_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcMaterialSelect* v6_RelatingMaterial) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesMaterial_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingMaterial));data_->setArgument(5,attr);} }

// Function implementations for IfcRelAssociatesProfileProperties
::Ifc2x3::IfcProfileProperties* Ifc2x3::IfcRelAssociatesProfileProperties::RelatingProfileProperties() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcProfileProperties>(true); }
void Ifc2x3::IfcRelAssociatesProfileProperties::setRelatingProfileProperties(::Ifc2x3::IfcProfileProperties* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcRelAssociatesProfileProperties::ProfileSectionLocation() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcRelAssociatesProfileProperties::setProfileSectionLocation(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcOrientationSelect* Ifc2x3::IfcRelAssociatesProfileProperties::ProfileOrientation() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcOrientationSelect>(true); }
void Ifc2x3::IfcRelAssociatesProfileProperties::setProfileOrientation(::Ifc2x3::IfcOrientationSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelAssociatesProfileProperties::declaration() const { return *IFC2X3_IfcRelAssociatesProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcRelAssociatesProfileProperties::Class() { return *IFC2X3_IfcRelAssociatesProfileProperties_type; }
Ifc2x3::IfcRelAssociatesProfileProperties::IfcRelAssociatesProfileProperties(IfcEntityInstanceData* e) : IfcRelAssociates((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelAssociatesProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelAssociatesProfileProperties::IfcRelAssociatesProfileProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcRoot >::ptr v5_RelatedObjects, ::Ifc2x3::IfcProfileProperties* v6_RelatingProfileProperties, ::Ifc2x3::IfcShapeAspect* v7_ProfileSectionLocation, ::Ifc2x3::IfcOrientationSelect* v8_ProfileOrientation) : IfcRelAssociates((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelAssociatesProfileProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingProfileProperties));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ProfileSectionLocation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ProfileOrientation));data_->setArgument(7,attr);} }

// Function implementations for IfcRelConnects


const IfcParse::entity& Ifc2x3::IfcRelConnects::declaration() const { return *IFC2X3_IfcRelConnects_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnects::Class() { return *IFC2X3_IfcRelConnects_type; }
Ifc2x3::IfcRelConnects::IfcRelConnects(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnects_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnects::IfcRelConnects(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnects_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRelConnectsElements
::Ifc2x3::IfcConnectionGeometry* Ifc2x3::IfcRelConnectsElements::ConnectionGeometry() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcConnectionGeometry>(true); }
void Ifc2x3::IfcRelConnectsElements::setConnectionGeometry(::Ifc2x3::IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelConnectsElements::RelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelConnectsElements::setRelatingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelConnectsElements::RelatedElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelConnectsElements::setRelatedElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsElements::declaration() const { return *IFC2X3_IfcRelConnectsElements_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsElements::Class() { return *IFC2X3_IfcRelConnectsElements_type; }
Ifc2x3::IfcRelConnectsElements::IfcRelConnectsElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsElements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsElements::IfcRelConnectsElements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcConnectionGeometry* v5_ConnectionGeometry, ::Ifc2x3::IfcElement* v6_RelatingElement, ::Ifc2x3::IfcElement* v7_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsPathElements
std::vector< int > /*[0:?]*/ Ifc2x3::IfcRelConnectsPathElements::RelatingPriorities() const {  std::vector< int > /*[0:?]*/ v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcRelConnectsPathElements::setRelatingPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
std::vector< int > /*[0:?]*/ Ifc2x3::IfcRelConnectsPathElements::RelatedPriorities() const {  std::vector< int > /*[0:?]*/ v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcRelConnectsPathElements::setRelatedPriorities(std::vector< int > /*[0:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcConnectionTypeEnum::Value Ifc2x3::IfcRelConnectsPathElements::RelatedConnectionType() const {  return ::Ifc2x3::IfcConnectionTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcRelConnectsPathElements::setRelatedConnectionType(::Ifc2x3::IfcConnectionTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcConnectionTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
::Ifc2x3::IfcConnectionTypeEnum::Value Ifc2x3::IfcRelConnectsPathElements::RelatingConnectionType() const {  return ::Ifc2x3::IfcConnectionTypeEnum::FromString(*data_->getArgument(10)); }
void Ifc2x3::IfcRelConnectsPathElements::setRelatingConnectionType(::Ifc2x3::IfcConnectionTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcConnectionTypeEnum::ToString(v)));data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsPathElements::declaration() const { return *IFC2X3_IfcRelConnectsPathElements_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsPathElements::Class() { return *IFC2X3_IfcRelConnectsPathElements_type; }
Ifc2x3::IfcRelConnectsPathElements::IfcRelConnectsPathElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsPathElements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsPathElements::IfcRelConnectsPathElements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcConnectionGeometry* v5_ConnectionGeometry, ::Ifc2x3::IfcElement* v6_RelatingElement, ::Ifc2x3::IfcElement* v7_RelatedElement, std::vector< int > /*[0:?]*/ v8_RelatingPriorities, std::vector< int > /*[0:?]*/ v9_RelatedPriorities, ::Ifc2x3::IfcConnectionTypeEnum::Value v10_RelatedConnectionType, ::Ifc2x3::IfcConnectionTypeEnum::Value v11_RelatingConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsPathElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RelatingPriorities));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RelatedPriorities));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_RelatedConnectionType,::Ifc2x3::IfcConnectionTypeEnum::ToString(v10_RelatedConnectionType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v11_RelatingConnectionType,::Ifc2x3::IfcConnectionTypeEnum::ToString(v11_RelatingConnectionType))));data_->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsPortToElement
::Ifc2x3::IfcPort* Ifc2x3::IfcRelConnectsPortToElement::RelatingPort() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcPort>(true); }
void Ifc2x3::IfcRelConnectsPortToElement::setRelatingPort(::Ifc2x3::IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelConnectsPortToElement::RelatedElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelConnectsPortToElement::setRelatedElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsPortToElement::declaration() const { return *IFC2X3_IfcRelConnectsPortToElement_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsPortToElement::Class() { return *IFC2X3_IfcRelConnectsPortToElement_type; }
Ifc2x3::IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsPortToElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcPort* v5_RelatingPort, ::Ifc2x3::IfcElement* v6_RelatedElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsPortToElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsPorts
::Ifc2x3::IfcPort* Ifc2x3::IfcRelConnectsPorts::RelatingPort() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcPort>(true); }
void Ifc2x3::IfcRelConnectsPorts::setRelatingPort(::Ifc2x3::IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcPort* Ifc2x3::IfcRelConnectsPorts::RelatedPort() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcPort>(true); }
void Ifc2x3::IfcRelConnectsPorts::setRelatedPort(::Ifc2x3::IfcPort* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelConnectsPorts::RealizingElement() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelConnectsPorts::setRealizingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsPorts::declaration() const { return *IFC2X3_IfcRelConnectsPorts_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsPorts::Class() { return *IFC2X3_IfcRelConnectsPorts_type; }
Ifc2x3::IfcRelConnectsPorts::IfcRelConnectsPorts(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsPorts_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsPorts::IfcRelConnectsPorts(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcPort* v5_RelatingPort, ::Ifc2x3::IfcPort* v6_RelatedPort, ::Ifc2x3::IfcElement* v7_RealizingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsPorts_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingPort));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedPort));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RealizingElement));data_->setArgument(6,attr);} }

// Function implementations for IfcRelConnectsStructuralActivity
::Ifc2x3::IfcStructuralActivityAssignmentSelect* Ifc2x3::IfcRelConnectsStructuralActivity::RelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcStructuralActivityAssignmentSelect>(true); }
void Ifc2x3::IfcRelConnectsStructuralActivity::setRelatingElement(::Ifc2x3::IfcStructuralActivityAssignmentSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcStructuralActivity* Ifc2x3::IfcRelConnectsStructuralActivity::RelatedStructuralActivity() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcStructuralActivity>(true); }
void Ifc2x3::IfcRelConnectsStructuralActivity::setRelatedStructuralActivity(::Ifc2x3::IfcStructuralActivity* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralActivity::declaration() const { return *IFC2X3_IfcRelConnectsStructuralActivity_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralActivity::Class() { return *IFC2X3_IfcRelConnectsStructuralActivity_type; }
Ifc2x3::IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsStructuralActivity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcStructuralActivityAssignmentSelect* v5_RelatingElement, ::Ifc2x3::IfcStructuralActivity* v6_RelatedStructuralActivity) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsStructuralActivity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralActivity));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsStructuralElement
::Ifc2x3::IfcElement* Ifc2x3::IfcRelConnectsStructuralElement::RelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelConnectsStructuralElement::setRelatingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcStructuralMember* Ifc2x3::IfcRelConnectsStructuralElement::RelatedStructuralMember() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcStructuralMember>(true); }
void Ifc2x3::IfcRelConnectsStructuralElement::setRelatedStructuralMember(::Ifc2x3::IfcStructuralMember* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralElement::declaration() const { return *IFC2X3_IfcRelConnectsStructuralElement_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralElement::Class() { return *IFC2X3_IfcRelConnectsStructuralElement_type; }
Ifc2x3::IfcRelConnectsStructuralElement::IfcRelConnectsStructuralElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsStructuralElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsStructuralElement::IfcRelConnectsStructuralElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcElement* v5_RelatingElement, ::Ifc2x3::IfcStructuralMember* v6_RelatedStructuralMember) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsStructuralElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralMember));data_->setArgument(5,attr);} }

// Function implementations for IfcRelConnectsStructuralMember
::Ifc2x3::IfcStructuralMember* Ifc2x3::IfcRelConnectsStructuralMember::RelatingStructuralMember() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcStructuralMember>(true); }
void Ifc2x3::IfcRelConnectsStructuralMember::setRelatingStructuralMember(::Ifc2x3::IfcStructuralMember* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcStructuralConnection* Ifc2x3::IfcRelConnectsStructuralMember::RelatedStructuralConnection() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcStructuralConnection>(true); }
void Ifc2x3::IfcRelConnectsStructuralMember::setRelatedStructuralConnection(::Ifc2x3::IfcStructuralConnection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcBoundaryCondition* Ifc2x3::IfcRelConnectsStructuralMember::AppliedCondition() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcBoundaryCondition>(true); }
void Ifc2x3::IfcRelConnectsStructuralMember::setAppliedCondition(::Ifc2x3::IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcStructuralConnectionCondition* Ifc2x3::IfcRelConnectsStructuralMember::AdditionalConditions() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcStructuralConnectionCondition>(true); }
void Ifc2x3::IfcRelConnectsStructuralMember::setAdditionalConditions(::Ifc2x3::IfcStructuralConnectionCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcRelConnectsStructuralMember::SupportedLength() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcRelConnectsStructuralMember::setSupportedLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcRelConnectsStructuralMember::ConditionCoordinateSystem() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcRelConnectsStructuralMember::setConditionCoordinateSystem(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralMember::declaration() const { return *IFC2X3_IfcRelConnectsStructuralMember_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsStructuralMember::Class() { return *IFC2X3_IfcRelConnectsStructuralMember_type; }
Ifc2x3::IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsStructuralMember_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcStructuralMember* v5_RelatingStructuralMember, ::Ifc2x3::IfcStructuralConnection* v6_RelatedStructuralConnection, ::Ifc2x3::IfcBoundaryCondition* v7_AppliedCondition, ::Ifc2x3::IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, ::Ifc2x3::IfcAxis2Placement3D* v10_ConditionCoordinateSystem) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsStructuralMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));data_->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));data_->setArgument(9,attr);} }

// Function implementations for IfcRelConnectsWithEccentricity
::Ifc2x3::IfcConnectionGeometry* Ifc2x3::IfcRelConnectsWithEccentricity::ConnectionConstraint() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcConnectionGeometry>(true); }
void Ifc2x3::IfcRelConnectsWithEccentricity::setConnectionConstraint(::Ifc2x3::IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsWithEccentricity::declaration() const { return *IFC2X3_IfcRelConnectsWithEccentricity_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsWithEccentricity::Class() { return *IFC2X3_IfcRelConnectsWithEccentricity_type; }
Ifc2x3::IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(IfcEntityInstanceData* e) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsWithEccentricity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcStructuralMember* v5_RelatingStructuralMember, ::Ifc2x3::IfcStructuralConnection* v6_RelatedStructuralConnection, ::Ifc2x3::IfcBoundaryCondition* v7_AppliedCondition, ::Ifc2x3::IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, ::Ifc2x3::IfcAxis2Placement3D* v10_ConditionCoordinateSystem, ::Ifc2x3::IfcConnectionGeometry* v11_ConnectionConstraint) : IfcRelConnectsStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsWithEccentricity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingStructuralMember));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedStructuralConnection));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_AppliedCondition));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AdditionalConditions));data_->setArgument(7,attr);} if (v9_SupportedLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SupportedLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ConditionCoordinateSystem));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ConnectionConstraint));data_->setArgument(10,attr);} }

// Function implementations for IfcRelConnectsWithRealizingElements
aggregate_of< ::Ifc2x3::IfcElement >::ptr Ifc2x3::IfcRelConnectsWithRealizingElements::RealizingElements() const {  aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcElement >(); }
void Ifc2x3::IfcRelConnectsWithRealizingElements::setRealizingElements(aggregate_of< ::Ifc2x3::IfcElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcRelConnectsWithRealizingElements::ConnectionType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcRelConnectsWithRealizingElements::setConnectionType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelConnectsWithRealizingElements::declaration() const { return *IFC2X3_IfcRelConnectsWithRealizingElements_type; }
const IfcParse::entity& Ifc2x3::IfcRelConnectsWithRealizingElements::Class() { return *IFC2X3_IfcRelConnectsWithRealizingElements_type; }
Ifc2x3::IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(IfcEntityInstanceData* e) : IfcRelConnectsElements((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelConnectsWithRealizingElements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcConnectionGeometry* v5_ConnectionGeometry, ::Ifc2x3::IfcElement* v6_RelatingElement, ::Ifc2x3::IfcElement* v7_RelatedElement, aggregate_of< ::Ifc2x3::IfcElement >::ptr v8_RealizingElements, boost::optional< std::string > v9_ConnectionType) : IfcRelConnectsElements((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelConnectsWithRealizingElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_ConnectionGeometry));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatedElement));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RealizingElements)->generalize());data_->setArgument(7,attr);} if (v9_ConnectionType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ConnectionType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcRelContainedInSpatialStructure
aggregate_of< ::Ifc2x3::IfcProduct >::ptr Ifc2x3::IfcRelContainedInSpatialStructure::RelatedElements() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcProduct >(); }
void Ifc2x3::IfcRelContainedInSpatialStructure::setRelatedElements(aggregate_of< ::Ifc2x3::IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcRelContainedInSpatialStructure::RelatingStructure() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcRelContainedInSpatialStructure::setRelatingStructure(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelContainedInSpatialStructure::declaration() const { return *IFC2X3_IfcRelContainedInSpatialStructure_type; }
const IfcParse::entity& Ifc2x3::IfcRelContainedInSpatialStructure::Class() { return *IFC2X3_IfcRelContainedInSpatialStructure_type; }
Ifc2x3::IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelContainedInSpatialStructure_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcProduct >::ptr v5_RelatedElements, ::Ifc2x3::IfcSpatialStructureElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelContainedInSpatialStructure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));data_->setArgument(5,attr);} }

// Function implementations for IfcRelCoversBldgElements
::Ifc2x3::IfcElement* Ifc2x3::IfcRelCoversBldgElements::RelatingBuildingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelCoversBldgElements::setRelatingBuildingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcCovering >::ptr Ifc2x3::IfcRelCoversBldgElements::RelatedCoverings() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcCovering >(); }
void Ifc2x3::IfcRelCoversBldgElements::setRelatedCoverings(aggregate_of< ::Ifc2x3::IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelCoversBldgElements::declaration() const { return *IFC2X3_IfcRelCoversBldgElements_type; }
const IfcParse::entity& Ifc2x3::IfcRelCoversBldgElements::Class() { return *IFC2X3_IfcRelCoversBldgElements_type; }
Ifc2x3::IfcRelCoversBldgElements::IfcRelCoversBldgElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelCoversBldgElements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelCoversBldgElements::IfcRelCoversBldgElements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcElement* v5_RelatingBuildingElement, aggregate_of< ::Ifc2x3::IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelCoversBldgElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelCoversSpaces
::Ifc2x3::IfcSpace* Ifc2x3::IfcRelCoversSpaces::RelatedSpace() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSpace>(true); }
void Ifc2x3::IfcRelCoversSpaces::setRelatedSpace(::Ifc2x3::IfcSpace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcCovering >::ptr Ifc2x3::IfcRelCoversSpaces::RelatedCoverings() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcCovering >(); }
void Ifc2x3::IfcRelCoversSpaces::setRelatedCoverings(aggregate_of< ::Ifc2x3::IfcCovering >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelCoversSpaces::declaration() const { return *IFC2X3_IfcRelCoversSpaces_type; }
const IfcParse::entity& Ifc2x3::IfcRelCoversSpaces::Class() { return *IFC2X3_IfcRelCoversSpaces_type; }
Ifc2x3::IfcRelCoversSpaces::IfcRelCoversSpaces(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelCoversSpaces_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelCoversSpaces::IfcRelCoversSpaces(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcSpace* v5_RelatedSpace, aggregate_of< ::Ifc2x3::IfcCovering >::ptr v6_RelatedCoverings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelCoversSpaces_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedCoverings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelDecomposes
::Ifc2x3::IfcObjectDefinition* Ifc2x3::IfcRelDecomposes::RelatingObject() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcObjectDefinition>(true); }
void Ifc2x3::IfcRelDecomposes::setRelatingObject(::Ifc2x3::IfcObjectDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr Ifc2x3::IfcRelDecomposes::RelatedObjects() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcObjectDefinition >(); }
void Ifc2x3::IfcRelDecomposes::setRelatedObjects(aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelDecomposes::declaration() const { return *IFC2X3_IfcRelDecomposes_type; }
const IfcParse::entity& Ifc2x3::IfcRelDecomposes::Class() { return *IFC2X3_IfcRelDecomposes_type; }
Ifc2x3::IfcRelDecomposes::IfcRelDecomposes(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelDecomposes_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelDecomposes::IfcRelDecomposes(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcObjectDefinition* v5_RelatingObject, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelDecomposes_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelDefines
aggregate_of< ::Ifc2x3::IfcObject >::ptr Ifc2x3::IfcRelDefines::RelatedObjects() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcObject >(); }
void Ifc2x3::IfcRelDefines::setRelatedObjects(aggregate_of< ::Ifc2x3::IfcObject >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelDefines::declaration() const { return *IFC2X3_IfcRelDefines_type; }
const IfcParse::entity& Ifc2x3::IfcRelDefines::Class() { return *IFC2X3_IfcRelDefines_type; }
Ifc2x3::IfcRelDefines::IfcRelDefines(IfcEntityInstanceData* e) : IfcRelationship((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelDefines_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelDefines::IfcRelDefines(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObject >::ptr v5_RelatedObjects) : IfcRelationship((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelDefines_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} }

// Function implementations for IfcRelDefinesByProperties
::Ifc2x3::IfcPropertySetDefinition* Ifc2x3::IfcRelDefinesByProperties::RelatingPropertyDefinition() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcPropertySetDefinition>(true); }
void Ifc2x3::IfcRelDefinesByProperties::setRelatingPropertyDefinition(::Ifc2x3::IfcPropertySetDefinition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelDefinesByProperties::declaration() const { return *IFC2X3_IfcRelDefinesByProperties_type; }
const IfcParse::entity& Ifc2x3::IfcRelDefinesByProperties::Class() { return *IFC2X3_IfcRelDefinesByProperties_type; }
Ifc2x3::IfcRelDefinesByProperties::IfcRelDefinesByProperties(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelDefinesByProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelDefinesByProperties::IfcRelDefinesByProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObject >::ptr v5_RelatedObjects, ::Ifc2x3::IfcPropertySetDefinition* v6_RelatingPropertyDefinition) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelDefinesByProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingPropertyDefinition));data_->setArgument(5,attr);} }

// Function implementations for IfcRelDefinesByType
::Ifc2x3::IfcTypeObject* Ifc2x3::IfcRelDefinesByType::RelatingType() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcTypeObject>(true); }
void Ifc2x3::IfcRelDefinesByType::setRelatingType(::Ifc2x3::IfcTypeObject* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelDefinesByType::declaration() const { return *IFC2X3_IfcRelDefinesByType_type; }
const IfcParse::entity& Ifc2x3::IfcRelDefinesByType::Class() { return *IFC2X3_IfcRelDefinesByType_type; }
Ifc2x3::IfcRelDefinesByType::IfcRelDefinesByType(IfcEntityInstanceData* e) : IfcRelDefines((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelDefinesByType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelDefinesByType::IfcRelDefinesByType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObject >::ptr v5_RelatedObjects, ::Ifc2x3::IfcTypeObject* v6_RelatingType) : IfcRelDefines((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelDefinesByType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingType));data_->setArgument(5,attr);} }

// Function implementations for IfcRelFillsElement
::Ifc2x3::IfcOpeningElement* Ifc2x3::IfcRelFillsElement::RelatingOpeningElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcOpeningElement>(true); }
void Ifc2x3::IfcRelFillsElement::setRelatingOpeningElement(::Ifc2x3::IfcOpeningElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelFillsElement::RelatedBuildingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelFillsElement::setRelatedBuildingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelFillsElement::declaration() const { return *IFC2X3_IfcRelFillsElement_type; }
const IfcParse::entity& Ifc2x3::IfcRelFillsElement::Class() { return *IFC2X3_IfcRelFillsElement_type; }
Ifc2x3::IfcRelFillsElement::IfcRelFillsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelFillsElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelFillsElement::IfcRelFillsElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcOpeningElement* v5_RelatingOpeningElement, ::Ifc2x3::IfcElement* v6_RelatedBuildingElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelFillsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingOpeningElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelFlowControlElements
aggregate_of< ::Ifc2x3::IfcDistributionControlElement >::ptr Ifc2x3::IfcRelFlowControlElements::RelatedControlElements() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcDistributionControlElement >(); }
void Ifc2x3::IfcRelFlowControlElements::setRelatedControlElements(aggregate_of< ::Ifc2x3::IfcDistributionControlElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }
::Ifc2x3::IfcDistributionFlowElement* Ifc2x3::IfcRelFlowControlElements::RelatingFlowElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDistributionFlowElement>(true); }
void Ifc2x3::IfcRelFlowControlElements::setRelatingFlowElement(::Ifc2x3::IfcDistributionFlowElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelFlowControlElements::declaration() const { return *IFC2X3_IfcRelFlowControlElements_type; }
const IfcParse::entity& Ifc2x3::IfcRelFlowControlElements::Class() { return *IFC2X3_IfcRelFlowControlElements_type; }
Ifc2x3::IfcRelFlowControlElements::IfcRelFlowControlElements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelFlowControlElements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelFlowControlElements::IfcRelFlowControlElements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcDistributionControlElement >::ptr v5_RelatedControlElements, ::Ifc2x3::IfcDistributionFlowElement* v6_RelatingFlowElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelFlowControlElements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedControlElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingFlowElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelInteractionRequirements
boost::optional< double > Ifc2x3::IfcRelInteractionRequirements::DailyInteraction() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcRelInteractionRequirements::setDailyInteraction(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcRelInteractionRequirements::ImportanceRating() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRelInteractionRequirements::setImportanceRating(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcRelInteractionRequirements::LocationOfInteraction() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcRelInteractionRequirements::setLocationOfInteraction(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcSpaceProgram* Ifc2x3::IfcRelInteractionRequirements::RelatedSpaceProgram() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcSpaceProgram>(true); }
void Ifc2x3::IfcRelInteractionRequirements::setRelatedSpaceProgram(::Ifc2x3::IfcSpaceProgram* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcSpaceProgram* Ifc2x3::IfcRelInteractionRequirements::RelatingSpaceProgram() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcSpaceProgram>(true); }
void Ifc2x3::IfcRelInteractionRequirements::setRelatingSpaceProgram(::Ifc2x3::IfcSpaceProgram* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelInteractionRequirements::declaration() const { return *IFC2X3_IfcRelInteractionRequirements_type; }
const IfcParse::entity& Ifc2x3::IfcRelInteractionRequirements::Class() { return *IFC2X3_IfcRelInteractionRequirements_type; }
Ifc2x3::IfcRelInteractionRequirements::IfcRelInteractionRequirements(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelInteractionRequirements_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelInteractionRequirements::IfcRelInteractionRequirements(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_DailyInteraction, boost::optional< double > v6_ImportanceRating, ::Ifc2x3::IfcSpatialStructureElement* v7_LocationOfInteraction, ::Ifc2x3::IfcSpaceProgram* v8_RelatedSpaceProgram, ::Ifc2x3::IfcSpaceProgram* v9_RelatingSpaceProgram) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelInteractionRequirements_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_DailyInteraction) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_DailyInteraction));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ImportanceRating) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ImportanceRating));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LocationOfInteraction));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_RelatedSpaceProgram));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RelatingSpaceProgram));data_->setArgument(8,attr);} }

// Function implementations for IfcRelNests


const IfcParse::entity& Ifc2x3::IfcRelNests::declaration() const { return *IFC2X3_IfcRelNests_type; }
const IfcParse::entity& Ifc2x3::IfcRelNests::Class() { return *IFC2X3_IfcRelNests_type; }
Ifc2x3::IfcRelNests::IfcRelNests(IfcEntityInstanceData* e) : IfcRelDecomposes((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelNests_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelNests::IfcRelNests(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcObjectDefinition* v5_RelatingObject, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v6_RelatedObjects) : IfcRelDecomposes((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelNests_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingObject));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedObjects)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelOccupiesSpaces


const IfcParse::entity& Ifc2x3::IfcRelOccupiesSpaces::declaration() const { return *IFC2X3_IfcRelOccupiesSpaces_type; }
const IfcParse::entity& Ifc2x3::IfcRelOccupiesSpaces::Class() { return *IFC2X3_IfcRelOccupiesSpaces_type; }
Ifc2x3::IfcRelOccupiesSpaces::IfcRelOccupiesSpaces(IfcEntityInstanceData* e) : IfcRelAssignsToActor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelOccupiesSpaces_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelOccupiesSpaces::IfcRelOccupiesSpaces(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcActor* v7_RelatingActor, ::Ifc2x3::IfcActorRole* v8_ActingRole) : IfcRelAssignsToActor((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelOccupiesSpaces_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingActor));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_ActingRole));data_->setArgument(7,attr);} }

// Function implementations for IfcRelOverridesProperties
aggregate_of< ::Ifc2x3::IfcProperty >::ptr Ifc2x3::IfcRelOverridesProperties::OverridingProperties() const {  aggregate_of_instance::ptr es = *data_->getArgument(6); return es->as< ::Ifc2x3::IfcProperty >(); }
void Ifc2x3::IfcRelOverridesProperties::setOverridingProperties(aggregate_of< ::Ifc2x3::IfcProperty >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelOverridesProperties::declaration() const { return *IFC2X3_IfcRelOverridesProperties_type; }
const IfcParse::entity& Ifc2x3::IfcRelOverridesProperties::Class() { return *IFC2X3_IfcRelOverridesProperties_type; }
Ifc2x3::IfcRelOverridesProperties::IfcRelOverridesProperties(IfcEntityInstanceData* e) : IfcRelDefinesByProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelOverridesProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelOverridesProperties::IfcRelOverridesProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObject >::ptr v5_RelatedObjects, ::Ifc2x3::IfcPropertySetDefinition* v6_RelatingPropertyDefinition, aggregate_of< ::Ifc2x3::IfcProperty >::ptr v7_OverridingProperties) : IfcRelDefinesByProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelOverridesProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingPropertyDefinition));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OverridingProperties)->generalize());data_->setArgument(6,attr);} }

// Function implementations for IfcRelProjectsElement
::Ifc2x3::IfcElement* Ifc2x3::IfcRelProjectsElement::RelatingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelProjectsElement::setRelatingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcFeatureElementAddition* Ifc2x3::IfcRelProjectsElement::RelatedFeatureElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcFeatureElementAddition>(true); }
void Ifc2x3::IfcRelProjectsElement::setRelatedFeatureElement(::Ifc2x3::IfcFeatureElementAddition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelProjectsElement::declaration() const { return *IFC2X3_IfcRelProjectsElement_type; }
const IfcParse::entity& Ifc2x3::IfcRelProjectsElement::Class() { return *IFC2X3_IfcRelProjectsElement_type; }
Ifc2x3::IfcRelProjectsElement::IfcRelProjectsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelProjectsElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelProjectsElement::IfcRelProjectsElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcElement* v5_RelatingElement, ::Ifc2x3::IfcFeatureElementAddition* v6_RelatedFeatureElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelProjectsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedFeatureElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelReferencedInSpatialStructure
aggregate_of< ::Ifc2x3::IfcProduct >::ptr Ifc2x3::IfcRelReferencedInSpatialStructure::RelatedElements() const {  aggregate_of_instance::ptr es = *data_->getArgument(4); return es->as< ::Ifc2x3::IfcProduct >(); }
void Ifc2x3::IfcRelReferencedInSpatialStructure::setRelatedElements(aggregate_of< ::Ifc2x3::IfcProduct >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(4,attr);} }
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcRelReferencedInSpatialStructure::RelatingStructure() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcRelReferencedInSpatialStructure::setRelatingStructure(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelReferencedInSpatialStructure::declaration() const { return *IFC2X3_IfcRelReferencedInSpatialStructure_type; }
const IfcParse::entity& Ifc2x3::IfcRelReferencedInSpatialStructure::Class() { return *IFC2X3_IfcRelReferencedInSpatialStructure_type; }
Ifc2x3::IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelReferencedInSpatialStructure_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcProduct >::ptr v5_RelatedElements, ::Ifc2x3::IfcSpatialStructureElement* v6_RelatingStructure) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelReferencedInSpatialStructure_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedElements)->generalize());data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatingStructure));data_->setArgument(5,attr);} }

// Function implementations for IfcRelSchedulesCostItems


const IfcParse::entity& Ifc2x3::IfcRelSchedulesCostItems::declaration() const { return *IFC2X3_IfcRelSchedulesCostItems_type; }
const IfcParse::entity& Ifc2x3::IfcRelSchedulesCostItems::Class() { return *IFC2X3_IfcRelSchedulesCostItems_type; }
Ifc2x3::IfcRelSchedulesCostItems::IfcRelSchedulesCostItems(IfcEntityInstanceData* e) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelSchedulesCostItems_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelSchedulesCostItems::IfcRelSchedulesCostItems(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, aggregate_of< ::Ifc2x3::IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< ::Ifc2x3::IfcObjectTypeEnum::Value > v6_RelatedObjectsType, ::Ifc2x3::IfcControl* v7_RelatingControl) : IfcRelAssignsToControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelSchedulesCostItems_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatedObjects)->generalize());data_->setArgument(4,attr);} if (v6_RelatedObjectsType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_RelatedObjectsType,::Ifc2x3::IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_RelatingControl));data_->setArgument(6,attr);} }

// Function implementations for IfcRelSequence
::Ifc2x3::IfcProcess* Ifc2x3::IfcRelSequence::RelatingProcess() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcProcess>(true); }
void Ifc2x3::IfcRelSequence::setRelatingProcess(::Ifc2x3::IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcProcess* Ifc2x3::IfcRelSequence::RelatedProcess() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcProcess>(true); }
void Ifc2x3::IfcRelSequence::setRelatedProcess(::Ifc2x3::IfcProcess* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcRelSequence::TimeLag() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcRelSequence::setTimeLag(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcSequenceEnum::Value Ifc2x3::IfcRelSequence::SequenceType() const {  return ::Ifc2x3::IfcSequenceEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcRelSequence::setSequenceType(::Ifc2x3::IfcSequenceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSequenceEnum::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelSequence::declaration() const { return *IFC2X3_IfcRelSequence_type; }
const IfcParse::entity& Ifc2x3::IfcRelSequence::Class() { return *IFC2X3_IfcRelSequence_type; }
Ifc2x3::IfcRelSequence::IfcRelSequence(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelSequence_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelSequence::IfcRelSequence(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcProcess* v5_RelatingProcess, ::Ifc2x3::IfcProcess* v6_RelatedProcess, double v7_TimeLag, ::Ifc2x3::IfcSequenceEnum::Value v8_SequenceType) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelSequence_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingProcess));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedProcess));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TimeLag));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_SequenceType,::Ifc2x3::IfcSequenceEnum::ToString(v8_SequenceType))));data_->setArgument(7,attr);} }

// Function implementations for IfcRelServicesBuildings
::Ifc2x3::IfcSystem* Ifc2x3::IfcRelServicesBuildings::RelatingSystem() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSystem>(true); }
void Ifc2x3::IfcRelServicesBuildings::setRelatingSystem(::Ifc2x3::IfcSystem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcSpatialStructureElement >::ptr Ifc2x3::IfcRelServicesBuildings::RelatedBuildings() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcSpatialStructureElement >(); }
void Ifc2x3::IfcRelServicesBuildings::setRelatedBuildings(aggregate_of< ::Ifc2x3::IfcSpatialStructureElement >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelServicesBuildings::declaration() const { return *IFC2X3_IfcRelServicesBuildings_type; }
const IfcParse::entity& Ifc2x3::IfcRelServicesBuildings::Class() { return *IFC2X3_IfcRelServicesBuildings_type; }
Ifc2x3::IfcRelServicesBuildings::IfcRelServicesBuildings(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelServicesBuildings_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelServicesBuildings::IfcRelServicesBuildings(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcSystem* v5_RelatingSystem, aggregate_of< ::Ifc2x3::IfcSpatialStructureElement >::ptr v6_RelatedBuildings) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelServicesBuildings_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSystem));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildings)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcRelSpaceBoundary
::Ifc2x3::IfcSpace* Ifc2x3::IfcRelSpaceBoundary::RelatingSpace() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSpace>(true); }
void Ifc2x3::IfcRelSpaceBoundary::setRelatingSpace(::Ifc2x3::IfcSpace* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcElement* Ifc2x3::IfcRelSpaceBoundary::RelatedBuildingElement() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelSpaceBoundary::setRelatedBuildingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcConnectionGeometry* Ifc2x3::IfcRelSpaceBoundary::ConnectionGeometry() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcConnectionGeometry>(true); }
void Ifc2x3::IfcRelSpaceBoundary::setConnectionGeometry(::Ifc2x3::IfcConnectionGeometry* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcPhysicalOrVirtualEnum::Value Ifc2x3::IfcRelSpaceBoundary::PhysicalOrVirtualBoundary() const {  return ::Ifc2x3::IfcPhysicalOrVirtualEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcRelSpaceBoundary::setPhysicalOrVirtualBoundary(::Ifc2x3::IfcPhysicalOrVirtualEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPhysicalOrVirtualEnum::ToString(v)));data_->setArgument(7,attr);} }
::Ifc2x3::IfcInternalOrExternalEnum::Value Ifc2x3::IfcRelSpaceBoundary::InternalOrExternalBoundary() const {  return ::Ifc2x3::IfcInternalOrExternalEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcRelSpaceBoundary::setInternalOrExternalBoundary(::Ifc2x3::IfcInternalOrExternalEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcInternalOrExternalEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelSpaceBoundary::declaration() const { return *IFC2X3_IfcRelSpaceBoundary_type; }
const IfcParse::entity& Ifc2x3::IfcRelSpaceBoundary::Class() { return *IFC2X3_IfcRelSpaceBoundary_type; }
Ifc2x3::IfcRelSpaceBoundary::IfcRelSpaceBoundary(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelSpaceBoundary_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelSpaceBoundary::IfcRelSpaceBoundary(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcSpace* v5_RelatingSpace, ::Ifc2x3::IfcElement* v6_RelatedBuildingElement, ::Ifc2x3::IfcConnectionGeometry* v7_ConnectionGeometry, ::Ifc2x3::IfcPhysicalOrVirtualEnum::Value v8_PhysicalOrVirtualBoundary, ::Ifc2x3::IfcInternalOrExternalEnum::Value v9_InternalOrExternalBoundary) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelSpaceBoundary_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingSpace));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedBuildingElement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ConnectionGeometry));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PhysicalOrVirtualBoundary,::Ifc2x3::IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary))));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_InternalOrExternalBoundary,::Ifc2x3::IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary))));data_->setArgument(8,attr);} }

// Function implementations for IfcRelVoidsElement
::Ifc2x3::IfcElement* Ifc2x3::IfcRelVoidsElement::RelatingBuildingElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcElement>(true); }
void Ifc2x3::IfcRelVoidsElement::setRelatingBuildingElement(::Ifc2x3::IfcElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcFeatureElementSubtraction* Ifc2x3::IfcRelVoidsElement::RelatedOpeningElement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcFeatureElementSubtraction>(true); }
void Ifc2x3::IfcRelVoidsElement::setRelatedOpeningElement(::Ifc2x3::IfcFeatureElementSubtraction* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelVoidsElement::declaration() const { return *IFC2X3_IfcRelVoidsElement_type; }
const IfcParse::entity& Ifc2x3::IfcRelVoidsElement::Class() { return *IFC2X3_IfcRelVoidsElement_type; }
Ifc2x3::IfcRelVoidsElement::IfcRelVoidsElement(IfcEntityInstanceData* e) : IfcRelConnects((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelVoidsElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelVoidsElement::IfcRelVoidsElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcElement* v5_RelatingBuildingElement, ::Ifc2x3::IfcFeatureElementSubtraction* v6_RelatedOpeningElement) : IfcRelConnects((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelVoidsElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_RelatingBuildingElement));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RelatedOpeningElement));data_->setArgument(5,attr);} }

// Function implementations for IfcRelationship


const IfcParse::entity& Ifc2x3::IfcRelationship::declaration() const { return *IFC2X3_IfcRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcRelationship::Class() { return *IFC2X3_IfcRelationship_type; }
Ifc2x3::IfcRelationship::IfcRelationship(IfcEntityInstanceData* e) : IfcRoot((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelationship::IfcRelationship(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcRoot((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRelaxation
double Ifc2x3::IfcRelaxation::RelaxationValue() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcRelaxation::setRelaxationValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcRelaxation::InitialStress() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRelaxation::setInitialStress(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcRelaxation::declaration() const { return *IFC2X3_IfcRelaxation_type; }
const IfcParse::entity& Ifc2x3::IfcRelaxation::Class() { return *IFC2X3_IfcRelaxation_type; }
Ifc2x3::IfcRelaxation::IfcRelaxation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRelaxation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRelaxation::IfcRelaxation(double v1_RelaxationValue, double v2_InitialStress) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRelaxation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RelaxationValue));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_InitialStress));data_->setArgument(1,attr);} }

// Function implementations for IfcRepresentation
::Ifc2x3::IfcRepresentationContext* Ifc2x3::IfcRepresentation::ContextOfItems() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcRepresentationContext>(true); }
void Ifc2x3::IfcRepresentation::setContextOfItems(::Ifc2x3::IfcRepresentationContext* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcRepresentation::RepresentationIdentifier() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRepresentation::setRepresentationIdentifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcRepresentation::RepresentationType() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRepresentation::setRepresentationType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr Ifc2x3::IfcRepresentation::Items() const {  aggregate_of_instance::ptr es = *data_->getArgument(3); return es->as< ::Ifc2x3::IfcRepresentationItem >(); }
void Ifc2x3::IfcRepresentation::setItems(aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(3,attr);} }

::Ifc2x3::IfcRepresentationMap::list::ptr Ifc2x3::IfcRepresentation::RepresentationMap() const { return data_->getInverse(IFC2X3_IfcRepresentationMap_type, 1)->as<IfcRepresentationMap>(); }
::Ifc2x3::IfcPresentationLayerAssignment::list::ptr Ifc2x3::IfcRepresentation::LayerAssignments() const { return data_->getInverse(IFC2X3_IfcPresentationLayerAssignment_type, 2)->as<IfcPresentationLayerAssignment>(); }
::Ifc2x3::IfcProductRepresentation::list::ptr Ifc2x3::IfcRepresentation::OfProductRepresentation() const { return data_->getInverse(IFC2X3_IfcProductRepresentation_type, 2)->as<IfcProductRepresentation>(); }

const IfcParse::entity& Ifc2x3::IfcRepresentation::declaration() const { return *IFC2X3_IfcRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcRepresentation::Class() { return *IFC2X3_IfcRepresentation_type; }
Ifc2x3::IfcRepresentation::IfcRepresentation(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRepresentation::IfcRepresentation(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcRepresentationContext
boost::optional< std::string > Ifc2x3::IfcRepresentationContext::ContextIdentifier() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcRepresentationContext::setContextIdentifier(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcRepresentationContext::ContextType() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRepresentationContext::setContextType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }

::Ifc2x3::IfcRepresentation::list::ptr Ifc2x3::IfcRepresentationContext::RepresentationsInContext() const { return data_->getInverse(IFC2X3_IfcRepresentation_type, 0)->as<IfcRepresentation>(); }

const IfcParse::entity& Ifc2x3::IfcRepresentationContext::declaration() const { return *IFC2X3_IfcRepresentationContext_type; }
const IfcParse::entity& Ifc2x3::IfcRepresentationContext::Class() { return *IFC2X3_IfcRepresentationContext_type; }
Ifc2x3::IfcRepresentationContext::IfcRepresentationContext(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRepresentationContext_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRepresentationContext::IfcRepresentationContext(boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRepresentationContext_type);  if (v1_ContextIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ContextIdentifier));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ContextType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ContextType));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcRepresentationItem

::Ifc2x3::IfcPresentationLayerAssignment::list::ptr Ifc2x3::IfcRepresentationItem::LayerAssignments() const { return data_->getInverse(IFC2X3_IfcPresentationLayerAssignment_type, 2)->as<IfcPresentationLayerAssignment>(); }
::Ifc2x3::IfcStyledItem::list::ptr Ifc2x3::IfcRepresentationItem::StyledByItem() const { return data_->getInverse(IFC2X3_IfcStyledItem_type, 0)->as<IfcStyledItem>(); }

const IfcParse::entity& Ifc2x3::IfcRepresentationItem::declaration() const { return *IFC2X3_IfcRepresentationItem_type; }
const IfcParse::entity& Ifc2x3::IfcRepresentationItem::Class() { return *IFC2X3_IfcRepresentationItem_type; }
Ifc2x3::IfcRepresentationItem::IfcRepresentationItem(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRepresentationItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRepresentationItem::IfcRepresentationItem() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRepresentationItem_type);  }

// Function implementations for IfcRepresentationMap
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcRepresentationMap::MappingOrigin() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcRepresentationMap::setMappingOrigin(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcRepresentation* Ifc2x3::IfcRepresentationMap::MappedRepresentation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcRepresentation>(true); }
void Ifc2x3::IfcRepresentationMap::setMappedRepresentation(::Ifc2x3::IfcRepresentation* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

::Ifc2x3::IfcMappedItem::list::ptr Ifc2x3::IfcRepresentationMap::MapUsage() const { return data_->getInverse(IFC2X3_IfcMappedItem_type, 0)->as<IfcMappedItem>(); }

const IfcParse::entity& Ifc2x3::IfcRepresentationMap::declaration() const { return *IFC2X3_IfcRepresentationMap_type; }
const IfcParse::entity& Ifc2x3::IfcRepresentationMap::Class() { return *IFC2X3_IfcRepresentationMap_type; }
Ifc2x3::IfcRepresentationMap::IfcRepresentationMap(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRepresentationMap_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRepresentationMap::IfcRepresentationMap(::Ifc2x3::IfcAxis2Placement* v1_MappingOrigin, ::Ifc2x3::IfcRepresentation* v2_MappedRepresentation) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRepresentationMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_MappingOrigin));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_MappedRepresentation));data_->setArgument(1,attr);} }

// Function implementations for IfcResource

::Ifc2x3::IfcRelAssignsToResource::list::ptr Ifc2x3::IfcResource::ResourceOf() const { return data_->getInverse(IFC2X3_IfcRelAssignsToResource_type, 6)->as<IfcRelAssignsToResource>(); }

const IfcParse::entity& Ifc2x3::IfcResource::declaration() const { return *IFC2X3_IfcResource_type; }
const IfcParse::entity& Ifc2x3::IfcResource::Class() { return *IFC2X3_IfcResource_type; }
Ifc2x3::IfcResource::IfcResource(IfcEntityInstanceData* e) : IfcObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcResource::IfcResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcRevolvedAreaSolid
::Ifc2x3::IfcAxis1Placement* Ifc2x3::IfcRevolvedAreaSolid::Axis() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAxis1Placement>(true); }
void Ifc2x3::IfcRevolvedAreaSolid::setAxis(::Ifc2x3::IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcRevolvedAreaSolid::Angle() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRevolvedAreaSolid::setAngle(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcRevolvedAreaSolid::declaration() const { return *IFC2X3_IfcRevolvedAreaSolid_type; }
const IfcParse::entity& Ifc2x3::IfcRevolvedAreaSolid::Class() { return *IFC2X3_IfcRevolvedAreaSolid_type; }
Ifc2x3::IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRevolvedAreaSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(::Ifc2x3::IfcProfileDef* v1_SweptArea, ::Ifc2x3::IfcAxis2Placement3D* v2_Position, ::Ifc2x3::IfcAxis1Placement* v3_Axis, double v4_Angle) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRevolvedAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Axis));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Angle));data_->setArgument(3,attr);} }

// Function implementations for IfcRibPlateProfileProperties
boost::optional< double > Ifc2x3::IfcRibPlateProfileProperties::Thickness() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRibPlateProfileProperties::setThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcRibPlateProfileProperties::RibHeight() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRibPlateProfileProperties::setRibHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcRibPlateProfileProperties::RibWidth() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcRibPlateProfileProperties::setRibWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcRibPlateProfileProperties::RibSpacing() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRibPlateProfileProperties::setRibSpacing(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
::Ifc2x3::IfcRibPlateDirectionEnum::Value Ifc2x3::IfcRibPlateProfileProperties::Direction() const {  return ::Ifc2x3::IfcRibPlateDirectionEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcRibPlateProfileProperties::setDirection(::Ifc2x3::IfcRibPlateDirectionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRibPlateDirectionEnum::ToString(v)));data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcRibPlateProfileProperties::declaration() const { return *IFC2X3_IfcRibPlateProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcRibPlateProfileProperties::Class() { return *IFC2X3_IfcRibPlateProfileProperties_type; }
Ifc2x3::IfcRibPlateProfileProperties::IfcRibPlateProfileProperties(IfcEntityInstanceData* e) : IfcProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRibPlateProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRibPlateProfileProperties::IfcRibPlateProfileProperties(boost::optional< std::string > v1_ProfileName, ::Ifc2x3::IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_Thickness, boost::optional< double > v4_RibHeight, boost::optional< double > v5_RibWidth, boost::optional< double > v6_RibSpacing, ::Ifc2x3::IfcRibPlateDirectionEnum::Value v7_Direction) : IfcProfileProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRibPlateProfileProperties_type);  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));data_->setArgument(1,attr);} if (v3_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Thickness));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_RibHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_RibHeight));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RibWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RibWidth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RibSpacing) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RibSpacing));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_Direction,::Ifc2x3::IfcRibPlateDirectionEnum::ToString(v7_Direction))));data_->setArgument(6,attr);} }

// Function implementations for IfcRightCircularCone
double Ifc2x3::IfcRightCircularCone::Height() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRightCircularCone::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcRightCircularCone::BottomRadius() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRightCircularCone::setBottomRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcRightCircularCone::declaration() const { return *IFC2X3_IfcRightCircularCone_type; }
const IfcParse::entity& Ifc2x3::IfcRightCircularCone::Class() { return *IFC2X3_IfcRightCircularCone_type; }
Ifc2x3::IfcRightCircularCone::IfcRightCircularCone(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRightCircularCone_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRightCircularCone::IfcRightCircularCone(::Ifc2x3::IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_BottomRadius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRightCircularCone_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_BottomRadius));data_->setArgument(2,attr);} }

// Function implementations for IfcRightCircularCylinder
double Ifc2x3::IfcRightCircularCylinder::Height() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcRightCircularCylinder::setHeight(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
double Ifc2x3::IfcRightCircularCylinder::Radius() const {  double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRightCircularCylinder::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcRightCircularCylinder::declaration() const { return *IFC2X3_IfcRightCircularCylinder_type; }
const IfcParse::entity& Ifc2x3::IfcRightCircularCylinder::Class() { return *IFC2X3_IfcRightCircularCylinder_type; }
Ifc2x3::IfcRightCircularCylinder::IfcRightCircularCylinder(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRightCircularCylinder_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRightCircularCylinder::IfcRightCircularCylinder(::Ifc2x3::IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRightCircularCylinder_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Height));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Radius));data_->setArgument(2,attr);} }

// Function implementations for IfcRoof
::Ifc2x3::IfcRoofTypeEnum::Value Ifc2x3::IfcRoof::ShapeType() const {  return ::Ifc2x3::IfcRoofTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcRoof::setShapeType(::Ifc2x3::IfcRoofTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcRoofTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcRoof::declaration() const { return *IFC2X3_IfcRoof_type; }
const IfcParse::entity& Ifc2x3::IfcRoof::Class() { return *IFC2X3_IfcRoof_type; }
Ifc2x3::IfcRoof::IfcRoof(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRoof_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRoof::IfcRoof(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcRoofTypeEnum::Value v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRoof_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,::Ifc2x3::IfcRoofTypeEnum::ToString(v9_ShapeType))));data_->setArgument(8,attr);} }

// Function implementations for IfcRoot
std::string Ifc2x3::IfcRoot::GlobalId() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcRoot::setGlobalId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcOwnerHistory* Ifc2x3::IfcRoot::OwnerHistory() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcOwnerHistory>(true); }
void Ifc2x3::IfcRoot::setOwnerHistory(::Ifc2x3::IfcOwnerHistory* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcRoot::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcRoot::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcRoot::Description() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcRoot::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcRoot::declaration() const { return *IFC2X3_IfcRoot_type; }
const IfcParse::entity& Ifc2x3::IfcRoot::Class() { return *IFC2X3_IfcRoot_type; }
Ifc2x3::IfcRoot::IfcRoot(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcRoot_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRoot::IfcRoot(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcRoot_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcRoundedEdgeFeature
boost::optional< double > Ifc2x3::IfcRoundedEdgeFeature::Radius() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcRoundedEdgeFeature::setRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcRoundedEdgeFeature::declaration() const { return *IFC2X3_IfcRoundedEdgeFeature_type; }
const IfcParse::entity& Ifc2x3::IfcRoundedEdgeFeature::Class() { return *IFC2X3_IfcRoundedEdgeFeature_type; }
Ifc2x3::IfcRoundedEdgeFeature::IfcRoundedEdgeFeature(IfcEntityInstanceData* e) : IfcEdgeFeature((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRoundedEdgeFeature_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRoundedEdgeFeature::IfcRoundedEdgeFeature(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Radius) : IfcEdgeFeature((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRoundedEdgeFeature_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FeatureLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FeatureLength));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Radius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Radius));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcRoundedRectangleProfileDef
double Ifc2x3::IfcRoundedRectangleProfileDef::RoundingRadius() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcRoundedRectangleProfileDef::setRoundingRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcRoundedRectangleProfileDef::declaration() const { return *IFC2X3_IfcRoundedRectangleProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcRoundedRectangleProfileDef::Class() { return *IFC2X3_IfcRoundedRectangleProfileDef_type; }
Ifc2x3::IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcEntityInstanceData* e) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcRoundedRectangleProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_RoundingRadius) : IfcRectangleProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcRoundedRectangleProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_XDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_YDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_RoundingRadius));data_->setArgument(5,attr);} }

// Function implementations for IfcSIUnit
boost::optional< ::Ifc2x3::IfcSIPrefix::Value > Ifc2x3::IfcSIUnit::Prefix() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } return ::Ifc2x3::IfcSIPrefix::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcSIUnit::setPrefix(boost::optional< ::Ifc2x3::IfcSIPrefix::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcSIPrefix::ToString(*v)));}data_->setArgument(2,attr);} }
::Ifc2x3::IfcSIUnitName::Value Ifc2x3::IfcSIUnit::Name() const {  return ::Ifc2x3::IfcSIUnitName::FromString(*data_->getArgument(3)); }
void Ifc2x3::IfcSIUnit::setName(::Ifc2x3::IfcSIUnitName::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSIUnitName::ToString(v)));data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcSIUnit::declaration() const { return *IFC2X3_IfcSIUnit_type; }
const IfcParse::entity& Ifc2x3::IfcSIUnit::Class() { return *IFC2X3_IfcSIUnit_type; }
Ifc2x3::IfcSIUnit::IfcSIUnit(IfcEntityInstanceData* e) : IfcNamedUnit((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSIUnit_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSIUnit::IfcSIUnit(::Ifc2x3::IfcUnitEnum::Value v2_UnitType, boost::optional< ::Ifc2x3::IfcSIPrefix::Value > v3_Prefix, ::Ifc2x3::IfcSIUnitName::Value v4_Name) : IfcNamedUnit((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSIUnit_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::Derived());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_UnitType,::Ifc2x3::IfcUnitEnum::ToString(v2_UnitType))));data_->setArgument(1,attr);} if (v3_Prefix) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v3_Prefix,::Ifc2x3::IfcSIPrefix::ToString(*v3_Prefix))));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_Name,::Ifc2x3::IfcSIUnitName::ToString(v4_Name))));data_->setArgument(3,attr);} }

// Function implementations for IfcSanitaryTerminalType
::Ifc2x3::IfcSanitaryTerminalTypeEnum::Value Ifc2x3::IfcSanitaryTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcSanitaryTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSanitaryTerminalType::setPredefinedType(::Ifc2x3::IfcSanitaryTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSanitaryTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSanitaryTerminalType::declaration() const { return *IFC2X3_IfcSanitaryTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcSanitaryTerminalType::Class() { return *IFC2X3_IfcSanitaryTerminalType_type; }
Ifc2x3::IfcSanitaryTerminalType::IfcSanitaryTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSanitaryTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSanitaryTerminalType::IfcSanitaryTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSanitaryTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSanitaryTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSanitaryTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcScheduleTimeControl
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::ActualStart() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setActualStart(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::EarlyStart() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setEarlyStart(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::LateStart() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setLateStart(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::ScheduleStart() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setScheduleStart(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::ActualFinish() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setActualFinish(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::EarlyFinish() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setEarlyFinish(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::LateFinish() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setLateFinish(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::ScheduleFinish() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setScheduleFinish(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::ScheduleDuration() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcScheduleTimeControl::setScheduleDuration(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(13,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::ActualDuration() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return boost::none; } double v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcScheduleTimeControl::setActualDuration(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(14,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::RemainingTime() const { if(!data_->getArgument(15) || data_->getArgument(15)->isNull()) { return boost::none; } double v = *data_->getArgument(15); return v; }
void Ifc2x3::IfcScheduleTimeControl::setRemainingTime(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(15,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::FreeFloat() const { if(!data_->getArgument(16) || data_->getArgument(16)->isNull()) { return boost::none; } double v = *data_->getArgument(16); return v; }
void Ifc2x3::IfcScheduleTimeControl::setFreeFloat(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(16,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::TotalFloat() const { if(!data_->getArgument(17) || data_->getArgument(17)->isNull()) { return boost::none; } double v = *data_->getArgument(17); return v; }
void Ifc2x3::IfcScheduleTimeControl::setTotalFloat(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(17,attr);} }
boost::optional< bool > Ifc2x3::IfcScheduleTimeControl::IsCritical() const { if(!data_->getArgument(18) || data_->getArgument(18)->isNull()) { return boost::none; } bool v = *data_->getArgument(18); return v; }
void Ifc2x3::IfcScheduleTimeControl::setIsCritical(boost::optional< bool > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(18,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcScheduleTimeControl::StatusTime() const { if(!data_->getArgument(19) || data_->getArgument(19)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(19)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcScheduleTimeControl::setStatusTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(19,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::StartFloat() const { if(!data_->getArgument(20) || data_->getArgument(20)->isNull()) { return boost::none; } double v = *data_->getArgument(20); return v; }
void Ifc2x3::IfcScheduleTimeControl::setStartFloat(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(20,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::FinishFloat() const { if(!data_->getArgument(21) || data_->getArgument(21)->isNull()) { return boost::none; } double v = *data_->getArgument(21); return v; }
void Ifc2x3::IfcScheduleTimeControl::setFinishFloat(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(21,attr);} }
boost::optional< double > Ifc2x3::IfcScheduleTimeControl::Completion() const { if(!data_->getArgument(22) || data_->getArgument(22)->isNull()) { return boost::none; } double v = *data_->getArgument(22); return v; }
void Ifc2x3::IfcScheduleTimeControl::setCompletion(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(22,attr);} }

::Ifc2x3::IfcRelAssignsTasks::list::ptr Ifc2x3::IfcScheduleTimeControl::ScheduleTimeControlAssigned() const { return data_->getInverse(IFC2X3_IfcRelAssignsTasks_type, 7)->as<IfcRelAssignsTasks>(); }

const IfcParse::entity& Ifc2x3::IfcScheduleTimeControl::declaration() const { return *IFC2X3_IfcScheduleTimeControl_type; }
const IfcParse::entity& Ifc2x3::IfcScheduleTimeControl::Class() { return *IFC2X3_IfcScheduleTimeControl_type; }
Ifc2x3::IfcScheduleTimeControl::IfcScheduleTimeControl(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcScheduleTimeControl_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcScheduleTimeControl::IfcScheduleTimeControl(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcDateTimeSelect* v6_ActualStart, ::Ifc2x3::IfcDateTimeSelect* v7_EarlyStart, ::Ifc2x3::IfcDateTimeSelect* v8_LateStart, ::Ifc2x3::IfcDateTimeSelect* v9_ScheduleStart, ::Ifc2x3::IfcDateTimeSelect* v10_ActualFinish, ::Ifc2x3::IfcDateTimeSelect* v11_EarlyFinish, ::Ifc2x3::IfcDateTimeSelect* v12_LateFinish, ::Ifc2x3::IfcDateTimeSelect* v13_ScheduleFinish, boost::optional< double > v14_ScheduleDuration, boost::optional< double > v15_ActualDuration, boost::optional< double > v16_RemainingTime, boost::optional< double > v17_FreeFloat, boost::optional< double > v18_TotalFloat, boost::optional< bool > v19_IsCritical, ::Ifc2x3::IfcDateTimeSelect* v20_StatusTime, boost::optional< double > v21_StartFloat, boost::optional< double > v22_FinishFloat, boost::optional< double > v23_Completion) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcScheduleTimeControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ActualStart));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_EarlyStart));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LateStart));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ScheduleStart));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_ActualFinish));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_EarlyFinish));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_LateFinish));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ScheduleFinish));data_->setArgument(12,attr);} if (v14_ScheduleDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ScheduleDuration));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_ActualDuration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ActualDuration));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_RemainingTime) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_RemainingTime));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_FreeFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_FreeFloat));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_TotalFloat));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_IsCritical) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_IsCritical));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v20_StatusTime));data_->setArgument(19,attr);} if (v21_StartFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_StartFloat));data_->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(20, attr); } if (v22_FinishFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_FinishFloat));data_->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(21, attr); } if (v23_Completion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_Completion));data_->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(22, attr); } }

// Function implementations for IfcSectionProperties
::Ifc2x3::IfcSectionTypeEnum::Value Ifc2x3::IfcSectionProperties::SectionType() const {  return ::Ifc2x3::IfcSectionTypeEnum::FromString(*data_->getArgument(0)); }
void Ifc2x3::IfcSectionProperties::setSectionType(::Ifc2x3::IfcSectionTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSectionTypeEnum::ToString(v)));data_->setArgument(0,attr);} }
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcSectionProperties::StartProfile() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcSectionProperties::setStartProfile(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcSectionProperties::EndProfile() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcSectionProperties::setEndProfile(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcSectionProperties::declaration() const { return *IFC2X3_IfcSectionProperties_type; }
const IfcParse::entity& Ifc2x3::IfcSectionProperties::Class() { return *IFC2X3_IfcSectionProperties_type; }
Ifc2x3::IfcSectionProperties::IfcSectionProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSectionProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSectionProperties::IfcSectionProperties(::Ifc2x3::IfcSectionTypeEnum::Value v1_SectionType, ::Ifc2x3::IfcProfileDef* v2_StartProfile, ::Ifc2x3::IfcProfileDef* v3_EndProfile) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_SectionType,::Ifc2x3::IfcSectionTypeEnum::ToString(v1_SectionType))));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StartProfile));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_EndProfile));data_->setArgument(2,attr);} }

// Function implementations for IfcSectionReinforcementProperties
double Ifc2x3::IfcSectionReinforcementProperties::LongitudinalStartPosition() const {  double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcSectionReinforcementProperties::setLongitudinalStartPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcSectionReinforcementProperties::LongitudinalEndPosition() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSectionReinforcementProperties::setLongitudinalEndPosition(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcSectionReinforcementProperties::TransversePosition() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcSectionReinforcementProperties::setTransversePosition(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
::Ifc2x3::IfcReinforcingBarRoleEnum::Value Ifc2x3::IfcSectionReinforcementProperties::ReinforcementRole() const {  return ::Ifc2x3::IfcReinforcingBarRoleEnum::FromString(*data_->getArgument(3)); }
void Ifc2x3::IfcSectionReinforcementProperties::setReinforcementRole(::Ifc2x3::IfcReinforcingBarRoleEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcReinforcingBarRoleEnum::ToString(v)));data_->setArgument(3,attr);} }
::Ifc2x3::IfcSectionProperties* Ifc2x3::IfcSectionReinforcementProperties::SectionDefinition() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSectionProperties>(true); }
void Ifc2x3::IfcSectionReinforcementProperties::setSectionDefinition(::Ifc2x3::IfcSectionProperties* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
aggregate_of< ::Ifc2x3::IfcReinforcementBarProperties >::ptr Ifc2x3::IfcSectionReinforcementProperties::CrossSectionReinforcementDefinitions() const {  aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcReinforcementBarProperties >(); }
void Ifc2x3::IfcSectionReinforcementProperties::setCrossSectionReinforcementDefinitions(aggregate_of< ::Ifc2x3::IfcReinforcementBarProperties >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcSectionReinforcementProperties::declaration() const { return *IFC2X3_IfcSectionReinforcementProperties_type; }
const IfcParse::entity& Ifc2x3::IfcSectionReinforcementProperties::Class() { return *IFC2X3_IfcSectionReinforcementProperties_type; }
Ifc2x3::IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSectionReinforcementProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(double v1_LongitudinalStartPosition, double v2_LongitudinalEndPosition, boost::optional< double > v3_TransversePosition, ::Ifc2x3::IfcReinforcingBarRoleEnum::Value v4_ReinforcementRole, ::Ifc2x3::IfcSectionProperties* v5_SectionDefinition, aggregate_of< ::Ifc2x3::IfcReinforcementBarProperties >::ptr v6_CrossSectionReinforcementDefinitions) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionReinforcementProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LongitudinalStartPosition));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_LongitudinalEndPosition));data_->setArgument(1,attr);} if (v3_TransversePosition) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TransversePosition));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v4_ReinforcementRole,::Ifc2x3::IfcReinforcingBarRoleEnum::ToString(v4_ReinforcementRole))));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SectionDefinition));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_CrossSectionReinforcementDefinitions)->generalize());data_->setArgument(5,attr);} }

// Function implementations for IfcSectionedSpine
::Ifc2x3::IfcCompositeCurve* Ifc2x3::IfcSectionedSpine::SpineCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCompositeCurve>(true); }
void Ifc2x3::IfcSectionedSpine::setSpineCurve(::Ifc2x3::IfcCompositeCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr Ifc2x3::IfcSectionedSpine::CrossSections() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcProfileDef >(); }
void Ifc2x3::IfcSectionedSpine::setCrossSections(aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
aggregate_of< ::Ifc2x3::IfcAxis2Placement3D >::ptr Ifc2x3::IfcSectionedSpine::CrossSectionPositions() const {  aggregate_of_instance::ptr es = *data_->getArgument(2); return es->as< ::Ifc2x3::IfcAxis2Placement3D >(); }
void Ifc2x3::IfcSectionedSpine::setCrossSectionPositions(aggregate_of< ::Ifc2x3::IfcAxis2Placement3D >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcSectionedSpine::declaration() const { return *IFC2X3_IfcSectionedSpine_type; }
const IfcParse::entity& Ifc2x3::IfcSectionedSpine::Class() { return *IFC2X3_IfcSectionedSpine_type; }
Ifc2x3::IfcSectionedSpine::IfcSectionedSpine(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSectionedSpine_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSectionedSpine::IfcSectionedSpine(::Ifc2x3::IfcCompositeCurve* v1_SpineCurve, aggregate_of< ::Ifc2x3::IfcProfileDef >::ptr v2_CrossSections, aggregate_of< ::Ifc2x3::IfcAxis2Placement3D >::ptr v3_CrossSectionPositions) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSectionedSpine_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SpineCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_CrossSections)->generalize());data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_CrossSectionPositions)->generalize());data_->setArgument(2,attr);} }

// Function implementations for IfcSensorType
::Ifc2x3::IfcSensorTypeEnum::Value Ifc2x3::IfcSensorType::PredefinedType() const {  return ::Ifc2x3::IfcSensorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSensorType::setPredefinedType(::Ifc2x3::IfcSensorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSensorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSensorType::declaration() const { return *IFC2X3_IfcSensorType_type; }
const IfcParse::entity& Ifc2x3::IfcSensorType::Class() { return *IFC2X3_IfcSensorType_type; }
Ifc2x3::IfcSensorType::IfcSensorType(IfcEntityInstanceData* e) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSensorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSensorType::IfcSensorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSensorTypeEnum::Value v10_PredefinedType) : IfcDistributionControlElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSensorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSensorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcServiceLife
::Ifc2x3::IfcServiceLifeTypeEnum::Value Ifc2x3::IfcServiceLife::ServiceLifeType() const {  return ::Ifc2x3::IfcServiceLifeTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcServiceLife::setServiceLifeType(::Ifc2x3::IfcServiceLifeTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcServiceLifeTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
double Ifc2x3::IfcServiceLife::ServiceLifeDuration() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcServiceLife::setServiceLifeDuration(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcServiceLife::declaration() const { return *IFC2X3_IfcServiceLife_type; }
const IfcParse::entity& Ifc2x3::IfcServiceLife::Class() { return *IFC2X3_IfcServiceLife_type; }
Ifc2x3::IfcServiceLife::IfcServiceLife(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcServiceLife_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcServiceLife::IfcServiceLife(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcServiceLifeTypeEnum::Value v6_ServiceLifeType, double v7_ServiceLifeDuration) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLife_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_ServiceLifeType,::Ifc2x3::IfcServiceLifeTypeEnum::ToString(v6_ServiceLifeType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ServiceLifeDuration));data_->setArgument(6,attr);} }

// Function implementations for IfcServiceLifeFactor
::Ifc2x3::IfcServiceLifeFactorTypeEnum::Value Ifc2x3::IfcServiceLifeFactor::PredefinedType() const {  return ::Ifc2x3::IfcServiceLifeFactorTypeEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcServiceLifeFactor::setPredefinedType(::Ifc2x3::IfcServiceLifeFactorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcServiceLifeFactorTypeEnum::ToString(v)));data_->setArgument(4,attr);} }
::Ifc2x3::IfcMeasureValue* Ifc2x3::IfcServiceLifeFactor::UpperValue() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcMeasureValue>(true); }
void Ifc2x3::IfcServiceLifeFactor::setUpperValue(::Ifc2x3::IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcMeasureValue* Ifc2x3::IfcServiceLifeFactor::MostUsedValue() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcMeasureValue>(true); }
void Ifc2x3::IfcServiceLifeFactor::setMostUsedValue(::Ifc2x3::IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcMeasureValue* Ifc2x3::IfcServiceLifeFactor::LowerValue() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcMeasureValue>(true); }
void Ifc2x3::IfcServiceLifeFactor::setLowerValue(::Ifc2x3::IfcMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcServiceLifeFactor::declaration() const { return *IFC2X3_IfcServiceLifeFactor_type; }
const IfcParse::entity& Ifc2x3::IfcServiceLifeFactor::Class() { return *IFC2X3_IfcServiceLifeFactor_type; }
Ifc2x3::IfcServiceLifeFactor::IfcServiceLifeFactor(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcServiceLifeFactor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcServiceLifeFactor::IfcServiceLifeFactor(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcServiceLifeFactorTypeEnum::Value v5_PredefinedType, ::Ifc2x3::IfcMeasureValue* v6_UpperValue, ::Ifc2x3::IfcMeasureValue* v7_MostUsedValue, ::Ifc2x3::IfcMeasureValue* v8_LowerValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcServiceLifeFactor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_PredefinedType,::Ifc2x3::IfcServiceLifeFactorTypeEnum::ToString(v5_PredefinedType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_UpperValue));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_MostUsedValue));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_LowerValue));data_->setArgument(7,attr);} }

// Function implementations for IfcShapeAspect
aggregate_of< ::Ifc2x3::IfcShapeModel >::ptr Ifc2x3::IfcShapeAspect::ShapeRepresentations() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcShapeModel >(); }
void Ifc2x3::IfcShapeAspect::setShapeRepresentations(aggregate_of< ::Ifc2x3::IfcShapeModel >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcShapeAspect::Name() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcShapeAspect::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcShapeAspect::Description() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcShapeAspect::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::logic::tribool Ifc2x3::IfcShapeAspect::ProductDefinitional() const {  boost::logic::tribool v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcShapeAspect::setProductDefinitional(boost::logic::tribool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcProductDefinitionShape* Ifc2x3::IfcShapeAspect::PartOfProductDefinitionShape() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcProductDefinitionShape>(true); }
void Ifc2x3::IfcShapeAspect::setPartOfProductDefinitionShape(::Ifc2x3::IfcProductDefinitionShape* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcShapeAspect::declaration() const { return *IFC2X3_IfcShapeAspect_type; }
const IfcParse::entity& Ifc2x3::IfcShapeAspect::Class() { return *IFC2X3_IfcShapeAspect_type; }
Ifc2x3::IfcShapeAspect::IfcShapeAspect(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcShapeAspect_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcShapeAspect::IfcShapeAspect(aggregate_of< ::Ifc2x3::IfcShapeModel >::ptr v1_ShapeRepresentations, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, boost::logic::tribool v4_ProductDefinitional, ::Ifc2x3::IfcProductDefinitionShape* v5_PartOfProductDefinitionShape) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcShapeAspect_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ShapeRepresentations)->generalize());data_->setArgument(0,attr);} if (v2_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Name));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Description));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ProductDefinitional));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_PartOfProductDefinitionShape));data_->setArgument(4,attr);} }

// Function implementations for IfcShapeModel

::Ifc2x3::IfcShapeAspect::list::ptr Ifc2x3::IfcShapeModel::OfShapeAspect() const { return data_->getInverse(IFC2X3_IfcShapeAspect_type, 0)->as<IfcShapeAspect>(); }

const IfcParse::entity& Ifc2x3::IfcShapeModel::declaration() const { return *IFC2X3_IfcShapeModel_type; }
const IfcParse::entity& Ifc2x3::IfcShapeModel::Class() { return *IFC2X3_IfcShapeModel_type; }
Ifc2x3::IfcShapeModel::IfcShapeModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcShapeModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcShapeModel::IfcShapeModel(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcShapeModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcShapeRepresentation


const IfcParse::entity& Ifc2x3::IfcShapeRepresentation::declaration() const { return *IFC2X3_IfcShapeRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcShapeRepresentation::Class() { return *IFC2X3_IfcShapeRepresentation_type; }
Ifc2x3::IfcShapeRepresentation::IfcShapeRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcShapeRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcShapeRepresentation::IfcShapeRepresentation(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcShapeRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcShellBasedSurfaceModel
aggregate_of_instance::ptr Ifc2x3::IfcShellBasedSurfaceModel::SbsmBoundary() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcShellBasedSurfaceModel::setSbsmBoundary(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcShellBasedSurfaceModel::declaration() const { return *IFC2X3_IfcShellBasedSurfaceModel_type; }
const IfcParse::entity& Ifc2x3::IfcShellBasedSurfaceModel::Class() { return *IFC2X3_IfcShellBasedSurfaceModel_type; }
Ifc2x3::IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcShellBasedSurfaceModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(aggregate_of_instance::ptr v1_SbsmBoundary) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcShellBasedSurfaceModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SbsmBoundary));data_->setArgument(0,attr);} }

// Function implementations for IfcSimpleProperty


const IfcParse::entity& Ifc2x3::IfcSimpleProperty::declaration() const { return *IFC2X3_IfcSimpleProperty_type; }
const IfcParse::entity& Ifc2x3::IfcSimpleProperty::Class() { return *IFC2X3_IfcSimpleProperty_type; }
Ifc2x3::IfcSimpleProperty::IfcSimpleProperty(IfcEntityInstanceData* e) : IfcProperty((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSimpleProperty_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSimpleProperty::IfcSimpleProperty(std::string v1_Name, boost::optional< std::string > v2_Description) : IfcProperty((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSimpleProperty_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcSite
boost::optional< std::vector< int > /*[3:4]*/ > Ifc2x3::IfcSite::RefLatitude() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::vector< int > /*[3:4]*/ v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcSite::setRefLatitude(boost::optional< std::vector< int > /*[3:4]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< std::vector< int > /*[3:4]*/ > Ifc2x3::IfcSite::RefLongitude() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } std::vector< int > /*[3:4]*/ v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcSite::setRefLongitude(boost::optional< std::vector< int > /*[3:4]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcSite::RefElevation() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcSite::setRefElevation(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< std::string > Ifc2x3::IfcSite::LandTitleNumber() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } std::string v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcSite::setLandTitleNumber(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
::Ifc2x3::IfcPostalAddress* Ifc2x3::IfcSite::SiteAddress() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(13)))->as<::Ifc2x3::IfcPostalAddress>(true); }
void Ifc2x3::IfcSite::setSiteAddress(::Ifc2x3::IfcPostalAddress* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcSite::declaration() const { return *IFC2X3_IfcSite_type; }
const IfcParse::entity& Ifc2x3::IfcSite::Class() { return *IFC2X3_IfcSite_type; }
Ifc2x3::IfcSite::IfcSite(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSite_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSite::IfcSite(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, ::Ifc2x3::IfcElementCompositionEnum::Value v9_CompositionType, boost::optional< std::vector< int > /*[3:4]*/ > v10_RefLatitude, boost::optional< std::vector< int > /*[3:4]*/ > v11_RefLongitude, boost::optional< double > v12_RefElevation, boost::optional< std::string > v13_LandTitleNumber, ::Ifc2x3::IfcPostalAddress* v14_SiteAddress) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSite_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(v9_CompositionType))));data_->setArgument(8,attr);} if (v10_RefLatitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_RefLatitude));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_RefLongitude) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RefLongitude));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_RefElevation) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_RefElevation));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_LandTitleNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_LandTitleNumber));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SiteAddress));data_->setArgument(13,attr);} }

// Function implementations for IfcSlab
boost::optional< ::Ifc2x3::IfcSlabTypeEnum::Value > Ifc2x3::IfcSlab::PredefinedType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcSlabTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcSlab::setPredefinedType(boost::optional< ::Ifc2x3::IfcSlabTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcSlabTypeEnum::ToString(*v)));}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcSlab::declaration() const { return *IFC2X3_IfcSlab_type; }
const IfcParse::entity& Ifc2x3::IfcSlab::Class() { return *IFC2X3_IfcSlab_type; }
Ifc2x3::IfcSlab::IfcSlab(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSlab_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSlab::IfcSlab(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcSlabTypeEnum::Value > v9_PredefinedType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSlab_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_PredefinedType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_PredefinedType,::Ifc2x3::IfcSlabTypeEnum::ToString(*v9_PredefinedType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSlabType
::Ifc2x3::IfcSlabTypeEnum::Value Ifc2x3::IfcSlabType::PredefinedType() const {  return ::Ifc2x3::IfcSlabTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSlabType::setPredefinedType(::Ifc2x3::IfcSlabTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSlabTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSlabType::declaration() const { return *IFC2X3_IfcSlabType_type; }
const IfcParse::entity& Ifc2x3::IfcSlabType::Class() { return *IFC2X3_IfcSlabType_type; }
Ifc2x3::IfcSlabType::IfcSlabType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSlabType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSlabType::IfcSlabType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSlabTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSlabType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSlabTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSlippageConnectionCondition
boost::optional< double > Ifc2x3::IfcSlippageConnectionCondition::SlippageX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSlippageConnectionCondition::setSlippageX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcSlippageConnectionCondition::SlippageY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcSlippageConnectionCondition::setSlippageY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcSlippageConnectionCondition::SlippageZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcSlippageConnectionCondition::setSlippageZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcSlippageConnectionCondition::declaration() const { return *IFC2X3_IfcSlippageConnectionCondition_type; }
const IfcParse::entity& Ifc2x3::IfcSlippageConnectionCondition::Class() { return *IFC2X3_IfcSlippageConnectionCondition_type; }
Ifc2x3::IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(IfcEntityInstanceData* e) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSlippageConnectionCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(boost::optional< std::string > v1_Name, boost::optional< double > v2_SlippageX, boost::optional< double > v3_SlippageY, boost::optional< double > v4_SlippageZ) : IfcStructuralConnectionCondition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSlippageConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_SlippageX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SlippageX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_SlippageY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_SlippageY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_SlippageZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_SlippageZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcSolidModel


const IfcParse::entity& Ifc2x3::IfcSolidModel::declaration() const { return *IFC2X3_IfcSolidModel_type; }
const IfcParse::entity& Ifc2x3::IfcSolidModel::Class() { return *IFC2X3_IfcSolidModel_type; }
Ifc2x3::IfcSolidModel::IfcSolidModel(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSolidModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSolidModel::IfcSolidModel() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSolidModel_type);  }

// Function implementations for IfcSoundProperties
bool Ifc2x3::IfcSoundProperties::IsAttenuating() const {  bool v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcSoundProperties::setIsAttenuating(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
boost::optional< ::Ifc2x3::IfcSoundScaleEnum::Value > Ifc2x3::IfcSoundProperties::SoundScale() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } return ::Ifc2x3::IfcSoundScaleEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcSoundProperties::setSoundScale(boost::optional< ::Ifc2x3::IfcSoundScaleEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcSoundScaleEnum::ToString(*v)));}data_->setArgument(5,attr);} }
aggregate_of< ::Ifc2x3::IfcSoundValue >::ptr Ifc2x3::IfcSoundProperties::SoundValues() const {  aggregate_of_instance::ptr es = *data_->getArgument(6); return es->as< ::Ifc2x3::IfcSoundValue >(); }
void Ifc2x3::IfcSoundProperties::setSoundValues(aggregate_of< ::Ifc2x3::IfcSoundValue >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcSoundProperties::declaration() const { return *IFC2X3_IfcSoundProperties_type; }
const IfcParse::entity& Ifc2x3::IfcSoundProperties::Class() { return *IFC2X3_IfcSoundProperties_type; }
Ifc2x3::IfcSoundProperties::IfcSoundProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSoundProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSoundProperties::IfcSoundProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, bool v5_IsAttenuating, boost::optional< ::Ifc2x3::IfcSoundScaleEnum::Value > v6_SoundScale, aggregate_of< ::Ifc2x3::IfcSoundValue >::ptr v7_SoundValues) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_IsAttenuating));data_->setArgument(4,attr);} if (v6_SoundScale) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v6_SoundScale,::Ifc2x3::IfcSoundScaleEnum::ToString(*v6_SoundScale))));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SoundValues)->generalize());data_->setArgument(6,attr);} }

// Function implementations for IfcSoundValue
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcSoundValue::SoundLevelTimeSeries() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcSoundValue::setSoundLevelTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcSoundValue::Frequency() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcSoundValue::setFrequency(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcDerivedMeasureValue* Ifc2x3::IfcSoundValue::SoundLevelSingleValue() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcDerivedMeasureValue>(true); }
void Ifc2x3::IfcSoundValue::setSoundLevelSingleValue(::Ifc2x3::IfcDerivedMeasureValue* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcSoundValue::declaration() const { return *IFC2X3_IfcSoundValue_type; }
const IfcParse::entity& Ifc2x3::IfcSoundValue::Class() { return *IFC2X3_IfcSoundValue_type; }
Ifc2x3::IfcSoundValue::IfcSoundValue(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSoundValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSoundValue::IfcSoundValue(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcTimeSeries* v5_SoundLevelTimeSeries, double v6_Frequency, ::Ifc2x3::IfcDerivedMeasureValue* v7_SoundLevelSingleValue) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSoundValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_SoundLevelTimeSeries));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Frequency));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SoundLevelSingleValue));data_->setArgument(6,attr);} }

// Function implementations for IfcSpace
::Ifc2x3::IfcInternalOrExternalEnum::Value Ifc2x3::IfcSpace::InteriorOrExteriorSpace() const {  return ::Ifc2x3::IfcInternalOrExternalEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSpace::setInteriorOrExteriorSpace(::Ifc2x3::IfcInternalOrExternalEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcInternalOrExternalEnum::ToString(v)));data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcSpace::ElevationWithFlooring() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcSpace::setElevationWithFlooring(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }

::Ifc2x3::IfcRelCoversSpaces::list::ptr Ifc2x3::IfcSpace::HasCoverings() const { return data_->getInverse(IFC2X3_IfcRelCoversSpaces_type, 4)->as<IfcRelCoversSpaces>(); }
::Ifc2x3::IfcRelSpaceBoundary::list::ptr Ifc2x3::IfcSpace::BoundedBy() const { return data_->getInverse(IFC2X3_IfcRelSpaceBoundary_type, 4)->as<IfcRelSpaceBoundary>(); }

const IfcParse::entity& Ifc2x3::IfcSpace::declaration() const { return *IFC2X3_IfcSpace_type; }
const IfcParse::entity& Ifc2x3::IfcSpace::Class() { return *IFC2X3_IfcSpace_type; }
Ifc2x3::IfcSpace::IfcSpace(IfcEntityInstanceData* e) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpace_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpace::IfcSpace(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, ::Ifc2x3::IfcElementCompositionEnum::Value v9_CompositionType, ::Ifc2x3::IfcInternalOrExternalEnum::Value v10_InteriorOrExteriorSpace, boost::optional< double > v11_ElevationWithFlooring) : IfcSpatialStructureElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpace_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(v9_CompositionType))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_InteriorOrExteriorSpace,::Ifc2x3::IfcInternalOrExternalEnum::ToString(v10_InteriorOrExteriorSpace))));data_->setArgument(9,attr);} if (v11_ElevationWithFlooring) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_ElevationWithFlooring));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSpaceHeaterType
::Ifc2x3::IfcSpaceHeaterTypeEnum::Value Ifc2x3::IfcSpaceHeaterType::PredefinedType() const {  return ::Ifc2x3::IfcSpaceHeaterTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSpaceHeaterType::setPredefinedType(::Ifc2x3::IfcSpaceHeaterTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSpaceHeaterTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSpaceHeaterType::declaration() const { return *IFC2X3_IfcSpaceHeaterType_type; }
const IfcParse::entity& Ifc2x3::IfcSpaceHeaterType::Class() { return *IFC2X3_IfcSpaceHeaterType_type; }
Ifc2x3::IfcSpaceHeaterType::IfcSpaceHeaterType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpaceHeaterType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpaceHeaterType::IfcSpaceHeaterType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSpaceHeaterTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceHeaterType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSpaceHeaterTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSpaceProgram
std::string Ifc2x3::IfcSpaceProgram::SpaceProgramIdentifier() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcSpaceProgram::setSpaceProgramIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcSpaceProgram::MaxRequiredArea() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcSpaceProgram::setMaxRequiredArea(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcSpaceProgram::MinRequiredArea() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcSpaceProgram::setMinRequiredArea(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcSpatialStructureElement* Ifc2x3::IfcSpaceProgram::RequestedLocation() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcSpatialStructureElement>(true); }
void Ifc2x3::IfcSpaceProgram::setRequestedLocation(::Ifc2x3::IfcSpatialStructureElement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
double Ifc2x3::IfcSpaceProgram::StandardRequiredArea() const {  double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcSpaceProgram::setStandardRequiredArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }

::Ifc2x3::IfcRelInteractionRequirements::list::ptr Ifc2x3::IfcSpaceProgram::HasInteractionReqsFrom() const { return data_->getInverse(IFC2X3_IfcRelInteractionRequirements_type, 7)->as<IfcRelInteractionRequirements>(); }
::Ifc2x3::IfcRelInteractionRequirements::list::ptr Ifc2x3::IfcSpaceProgram::HasInteractionReqsTo() const { return data_->getInverse(IFC2X3_IfcRelInteractionRequirements_type, 8)->as<IfcRelInteractionRequirements>(); }

const IfcParse::entity& Ifc2x3::IfcSpaceProgram::declaration() const { return *IFC2X3_IfcSpaceProgram_type; }
const IfcParse::entity& Ifc2x3::IfcSpaceProgram::Class() { return *IFC2X3_IfcSpaceProgram_type; }
Ifc2x3::IfcSpaceProgram::IfcSpaceProgram(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpaceProgram_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpaceProgram::IfcSpaceProgram(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_SpaceProgramIdentifier, boost::optional< double > v7_MaxRequiredArea, boost::optional< double > v8_MinRequiredArea, ::Ifc2x3::IfcSpatialStructureElement* v9_RequestedLocation, double v10_StandardRequiredArea) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceProgram_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_SpaceProgramIdentifier));data_->setArgument(5,attr);} if (v7_MaxRequiredArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MaxRequiredArea));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_MinRequiredArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MinRequiredArea));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_RequestedLocation));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_StandardRequiredArea));data_->setArgument(9,attr);} }

// Function implementations for IfcSpaceThermalLoadProperties
boost::optional< double > Ifc2x3::IfcSpaceThermalLoadProperties::ApplicableValueRatio() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setApplicableValueRatio(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
::Ifc2x3::IfcThermalLoadSourceEnum::Value Ifc2x3::IfcSpaceThermalLoadProperties::ThermalLoadSource() const {  return ::Ifc2x3::IfcThermalLoadSourceEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcSpaceThermalLoadProperties::setThermalLoadSource(::Ifc2x3::IfcThermalLoadSourceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcThermalLoadSourceEnum::ToString(v)));data_->setArgument(5,attr);} }
::Ifc2x3::IfcPropertySourceEnum::Value Ifc2x3::IfcSpaceThermalLoadProperties::PropertySource() const {  return ::Ifc2x3::IfcPropertySourceEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcSpaceThermalLoadProperties::setPropertySource(::Ifc2x3::IfcPropertySourceEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcPropertySourceEnum::ToString(v)));data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcSpaceThermalLoadProperties::SourceDescription() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setSourceDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
double Ifc2x3::IfcSpaceThermalLoadProperties::MaximumValue() const {  double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setMaximumValue(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcSpaceThermalLoadProperties::MinimumValue() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setMinimumValue(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcSpaceThermalLoadProperties::ThermalLoadTimeSeriesValues() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcSpaceThermalLoadProperties::setThermalLoadTimeSeriesValues(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
boost::optional< std::string > Ifc2x3::IfcSpaceThermalLoadProperties::UserDefinedThermalLoadSource() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } std::string v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setUserDefinedThermalLoadSource(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< std::string > Ifc2x3::IfcSpaceThermalLoadProperties::UserDefinedPropertySource() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } std::string v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcSpaceThermalLoadProperties::setUserDefinedPropertySource(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
::Ifc2x3::IfcThermalLoadTypeEnum::Value Ifc2x3::IfcSpaceThermalLoadProperties::ThermalLoadType() const {  return ::Ifc2x3::IfcThermalLoadTypeEnum::FromString(*data_->getArgument(13)); }
void Ifc2x3::IfcSpaceThermalLoadProperties::setThermalLoadType(::Ifc2x3::IfcThermalLoadTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcThermalLoadTypeEnum::ToString(v)));data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcSpaceThermalLoadProperties::declaration() const { return *IFC2X3_IfcSpaceThermalLoadProperties_type; }
const IfcParse::entity& Ifc2x3::IfcSpaceThermalLoadProperties::Class() { return *IFC2X3_IfcSpaceThermalLoadProperties_type; }
Ifc2x3::IfcSpaceThermalLoadProperties::IfcSpaceThermalLoadProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpaceThermalLoadProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpaceThermalLoadProperties::IfcSpaceThermalLoadProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_ApplicableValueRatio, ::Ifc2x3::IfcThermalLoadSourceEnum::Value v6_ThermalLoadSource, ::Ifc2x3::IfcPropertySourceEnum::Value v7_PropertySource, boost::optional< std::string > v8_SourceDescription, double v9_MaximumValue, boost::optional< double > v10_MinimumValue, ::Ifc2x3::IfcTimeSeries* v11_ThermalLoadTimeSeriesValues, boost::optional< std::string > v12_UserDefinedThermalLoadSource, boost::optional< std::string > v13_UserDefinedPropertySource, ::Ifc2x3::IfcThermalLoadTypeEnum::Value v14_ThermalLoadType) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceThermalLoadProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableValueRatio) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableValueRatio));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_ThermalLoadSource,::Ifc2x3::IfcThermalLoadSourceEnum::ToString(v6_ThermalLoadSource))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_PropertySource,::Ifc2x3::IfcPropertySourceEnum::ToString(v7_PropertySource))));data_->setArgument(6,attr);} if (v8_SourceDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_SourceDescription));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_MaximumValue));data_->setArgument(8,attr);} if (v10_MinimumValue) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MinimumValue));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ThermalLoadTimeSeriesValues));data_->setArgument(10,attr);} if (v12_UserDefinedThermalLoadSource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_UserDefinedThermalLoadSource));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_UserDefinedPropertySource) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_UserDefinedPropertySource));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v14_ThermalLoadType,::Ifc2x3::IfcThermalLoadTypeEnum::ToString(v14_ThermalLoadType))));data_->setArgument(13,attr);} }

// Function implementations for IfcSpaceType
::Ifc2x3::IfcSpaceTypeEnum::Value Ifc2x3::IfcSpaceType::PredefinedType() const {  return ::Ifc2x3::IfcSpaceTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSpaceType::setPredefinedType(::Ifc2x3::IfcSpaceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSpaceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSpaceType::declaration() const { return *IFC2X3_IfcSpaceType_type; }
const IfcParse::entity& Ifc2x3::IfcSpaceType::Class() { return *IFC2X3_IfcSpaceType_type; }
Ifc2x3::IfcSpaceType::IfcSpaceType(IfcEntityInstanceData* e) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpaceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpaceType::IfcSpaceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSpaceTypeEnum::Value v10_PredefinedType) : IfcSpatialStructureElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpaceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSpaceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSpatialStructureElement
boost::optional< std::string > Ifc2x3::IfcSpatialStructureElement::LongName() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcSpatialStructureElement::setLongName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcElementCompositionEnum::Value Ifc2x3::IfcSpatialStructureElement::CompositionType() const {  return ::Ifc2x3::IfcElementCompositionEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcSpatialStructureElement::setCompositionType(::Ifc2x3::IfcElementCompositionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcElementCompositionEnum::ToString(v)));data_->setArgument(8,attr);} }

::Ifc2x3::IfcRelReferencedInSpatialStructure::list::ptr Ifc2x3::IfcSpatialStructureElement::ReferencesElements() const { return data_->getInverse(IFC2X3_IfcRelReferencedInSpatialStructure_type, 5)->as<IfcRelReferencedInSpatialStructure>(); }
::Ifc2x3::IfcRelServicesBuildings::list::ptr Ifc2x3::IfcSpatialStructureElement::ServicedBySystems() const { return data_->getInverse(IFC2X3_IfcRelServicesBuildings_type, 5)->as<IfcRelServicesBuildings>(); }
::Ifc2x3::IfcRelContainedInSpatialStructure::list::ptr Ifc2x3::IfcSpatialStructureElement::ContainsElements() const { return data_->getInverse(IFC2X3_IfcRelContainedInSpatialStructure_type, 5)->as<IfcRelContainedInSpatialStructure>(); }

const IfcParse::entity& Ifc2x3::IfcSpatialStructureElement::declaration() const { return *IFC2X3_IfcSpatialStructureElement_type; }
const IfcParse::entity& Ifc2x3::IfcSpatialStructureElement::Class() { return *IFC2X3_IfcSpatialStructureElement_type; }
Ifc2x3::IfcSpatialStructureElement::IfcSpatialStructureElement(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpatialStructureElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpatialStructureElement::IfcSpatialStructureElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, ::Ifc2x3::IfcElementCompositionEnum::Value v9_CompositionType) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpatialStructureElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_LongName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LongName));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_CompositionType,::Ifc2x3::IfcElementCompositionEnum::ToString(v9_CompositionType))));data_->setArgument(8,attr);} }

// Function implementations for IfcSpatialStructureElementType


const IfcParse::entity& Ifc2x3::IfcSpatialStructureElementType::declaration() const { return *IFC2X3_IfcSpatialStructureElementType_type; }
const IfcParse::entity& Ifc2x3::IfcSpatialStructureElementType::Class() { return *IFC2X3_IfcSpatialStructureElementType_type; }
Ifc2x3::IfcSpatialStructureElementType::IfcSpatialStructureElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSpatialStructureElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSpatialStructureElementType::IfcSpatialStructureElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSpatialStructureElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcSphere
double Ifc2x3::IfcSphere::Radius() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSphere::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcSphere::declaration() const { return *IFC2X3_IfcSphere_type; }
const IfcParse::entity& Ifc2x3::IfcSphere::Class() { return *IFC2X3_IfcSphere_type; }
Ifc2x3::IfcSphere::IfcSphere(IfcEntityInstanceData* e) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSphere_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSphere::IfcSphere(::Ifc2x3::IfcAxis2Placement3D* v1_Position, double v2_Radius) : IfcCsgPrimitive3D((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSphere_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Position));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} }

// Function implementations for IfcStackTerminalType
::Ifc2x3::IfcStackTerminalTypeEnum::Value Ifc2x3::IfcStackTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcStackTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcStackTerminalType::setPredefinedType(::Ifc2x3::IfcStackTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcStackTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcStackTerminalType::declaration() const { return *IFC2X3_IfcStackTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcStackTerminalType::Class() { return *IFC2X3_IfcStackTerminalType_type; }
Ifc2x3::IfcStackTerminalType::IfcStackTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStackTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStackTerminalType::IfcStackTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcStackTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStackTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcStackTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStair
::Ifc2x3::IfcStairTypeEnum::Value Ifc2x3::IfcStair::ShapeType() const {  return ::Ifc2x3::IfcStairTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcStair::setShapeType(::Ifc2x3::IfcStairTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcStairTypeEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcStair::declaration() const { return *IFC2X3_IfcStair_type; }
const IfcParse::entity& Ifc2x3::IfcStair::Class() { return *IFC2X3_IfcStair_type; }
Ifc2x3::IfcStair::IfcStair(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStair_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStair::IfcStair(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcStairTypeEnum::Value v9_ShapeType) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStair_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ShapeType,::Ifc2x3::IfcStairTypeEnum::ToString(v9_ShapeType))));data_->setArgument(8,attr);} }

// Function implementations for IfcStairFlight
boost::optional< int > Ifc2x3::IfcStairFlight::NumberOfRiser() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } int v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcStairFlight::setNumberOfRiser(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< int > Ifc2x3::IfcStairFlight::NumberOfTreads() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } int v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcStairFlight::setNumberOfTreads(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcStairFlight::RiserHeight() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcStairFlight::setRiserHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcStairFlight::TreadLength() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcStairFlight::setTreadLength(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcStairFlight::declaration() const { return *IFC2X3_IfcStairFlight_type; }
const IfcParse::entity& Ifc2x3::IfcStairFlight::Class() { return *IFC2X3_IfcStairFlight_type; }
Ifc2x3::IfcStairFlight::IfcStairFlight(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStairFlight_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStairFlight::IfcStairFlight(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< int > v9_NumberOfRiser, boost::optional< int > v10_NumberOfTreads, boost::optional< double > v11_RiserHeight, boost::optional< double > v12_TreadLength) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStairFlight_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_NumberOfRiser) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_NumberOfRiser));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_NumberOfTreads) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_NumberOfTreads));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_RiserHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_RiserHeight));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_TreadLength) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_TreadLength));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } }

// Function implementations for IfcStairFlightType
::Ifc2x3::IfcStairFlightTypeEnum::Value Ifc2x3::IfcStairFlightType::PredefinedType() const {  return ::Ifc2x3::IfcStairFlightTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcStairFlightType::setPredefinedType(::Ifc2x3::IfcStairFlightTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcStairFlightTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcStairFlightType::declaration() const { return *IFC2X3_IfcStairFlightType_type; }
const IfcParse::entity& Ifc2x3::IfcStairFlightType::Class() { return *IFC2X3_IfcStairFlightType_type; }
Ifc2x3::IfcStairFlightType::IfcStairFlightType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStairFlightType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStairFlightType::IfcStairFlightType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcStairFlightTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStairFlightType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcStairFlightTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcStructuralAction
bool Ifc2x3::IfcStructuralAction::DestabilizingLoad() const {  bool v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcStructuralAction::setDestabilizingLoad(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
::Ifc2x3::IfcStructuralReaction* Ifc2x3::IfcStructuralAction::CausedBy() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcStructuralReaction>(true); }
void Ifc2x3::IfcStructuralAction::setCausedBy(::Ifc2x3::IfcStructuralReaction* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralAction::declaration() const { return *IFC2X3_IfcStructuralAction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralAction::Class() { return *IFC2X3_IfcStructuralAction_type; }
Ifc2x3::IfcStructuralAction::IfcStructuralAction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralAction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralAction::IfcStructuralAction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy) : IfcStructuralActivity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);} }

// Function implementations for IfcStructuralActivity
::Ifc2x3::IfcStructuralLoad* Ifc2x3::IfcStructuralActivity::AppliedLoad() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcStructuralLoad>(true); }
void Ifc2x3::IfcStructuralActivity::setAppliedLoad(::Ifc2x3::IfcStructuralLoad* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcGlobalOrLocalEnum::Value Ifc2x3::IfcStructuralActivity::GlobalOrLocal() const {  return ::Ifc2x3::IfcGlobalOrLocalEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcStructuralActivity::setGlobalOrLocal(::Ifc2x3::IfcGlobalOrLocalEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v)));data_->setArgument(8,attr);} }

::Ifc2x3::IfcRelConnectsStructuralActivity::list::ptr Ifc2x3::IfcStructuralActivity::AssignedToStructuralItem() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralActivity_type, 5)->as<IfcRelConnectsStructuralActivity>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralActivity::declaration() const { return *IFC2X3_IfcStructuralActivity_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralActivity::Class() { return *IFC2X3_IfcStructuralActivity_type; }
Ifc2x3::IfcStructuralActivity::IfcStructuralActivity(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralActivity_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralActivity::IfcStructuralActivity(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralActivity_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralAnalysisModel
::Ifc2x3::IfcAnalysisModelTypeEnum::Value Ifc2x3::IfcStructuralAnalysisModel::PredefinedType() const {  return ::Ifc2x3::IfcAnalysisModelTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcStructuralAnalysisModel::setPredefinedType(::Ifc2x3::IfcAnalysisModelTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAnalysisModelTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcStructuralAnalysisModel::OrientationOf2DPlane() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcStructuralAnalysisModel::setOrientationOf2DPlane(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralLoadGroup >::ptr > Ifc2x3::IfcStructuralAnalysisModel::LoadedBy() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcStructuralLoadGroup >(); }
void Ifc2x3::IfcStructuralAnalysisModel::setLoadedBy(boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralLoadGroup >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(7,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralResultGroup >::ptr > Ifc2x3::IfcStructuralAnalysisModel::HasResults() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(8); return es->as< ::Ifc2x3::IfcStructuralResultGroup >(); }
void Ifc2x3::IfcStructuralAnalysisModel::setHasResults(boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralResultGroup >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralAnalysisModel::declaration() const { return *IFC2X3_IfcStructuralAnalysisModel_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralAnalysisModel::Class() { return *IFC2X3_IfcStructuralAnalysisModel_type; }
Ifc2x3::IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(IfcEntityInstanceData* e) : IfcSystem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralAnalysisModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcAnalysisModelTypeEnum::Value v6_PredefinedType, ::Ifc2x3::IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralLoadGroup >::ptr > v8_LoadedBy, boost::optional< aggregate_of< ::Ifc2x3::IfcStructuralResultGroup >::ptr > v9_HasResults) : IfcSystem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralAnalysisModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,::Ifc2x3::IfcAnalysisModelTypeEnum::ToString(v6_PredefinedType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_OrientationOf2DPlane));data_->setArgument(6,attr);} if (v8_LoadedBy) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_LoadedBy)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_HasResults) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_HasResults)->generalize());data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStructuralConnection
::Ifc2x3::IfcBoundaryCondition* Ifc2x3::IfcStructuralConnection::AppliedCondition() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcBoundaryCondition>(true); }
void Ifc2x3::IfcStructuralConnection::setAppliedCondition(::Ifc2x3::IfcBoundaryCondition* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

::Ifc2x3::IfcRelConnectsStructuralMember::list::ptr Ifc2x3::IfcStructuralConnection::ConnectsStructuralMembers() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralMember_type, 5)->as<IfcRelConnectsStructuralMember>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralConnection::declaration() const { return *IFC2X3_IfcStructuralConnection_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralConnection::Class() { return *IFC2X3_IfcStructuralConnection_type; }
Ifc2x3::IfcStructuralConnection::IfcStructuralConnection(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralConnection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralConnection::IfcStructuralConnection(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralConnectionCondition
boost::optional< std::string > Ifc2x3::IfcStructuralConnectionCondition::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcStructuralConnectionCondition::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralConnectionCondition::declaration() const { return *IFC2X3_IfcStructuralConnectionCondition_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralConnectionCondition::Class() { return *IFC2X3_IfcStructuralConnectionCondition_type; }
Ifc2x3::IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcStructuralConnectionCondition_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralConnectionCondition_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralCurveConnection


const IfcParse::entity& Ifc2x3::IfcStructuralCurveConnection::declaration() const { return *IFC2X3_IfcStructuralCurveConnection_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralCurveConnection::Class() { return *IFC2X3_IfcStructuralCurveConnection_type; }
Ifc2x3::IfcStructuralCurveConnection::IfcStructuralCurveConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralCurveConnection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralCurveConnection::IfcStructuralCurveConnection(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralCurveConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralCurveMember
::Ifc2x3::IfcStructuralCurveTypeEnum::Value Ifc2x3::IfcStructuralCurveMember::PredefinedType() const {  return ::Ifc2x3::IfcStructuralCurveTypeEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcStructuralCurveMember::setPredefinedType(::Ifc2x3::IfcStructuralCurveTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcStructuralCurveTypeEnum::ToString(v)));data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralCurveMember::declaration() const { return *IFC2X3_IfcStructuralCurveMember_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralCurveMember::Class() { return *IFC2X3_IfcStructuralCurveMember_type; }
Ifc2x3::IfcStructuralCurveMember::IfcStructuralCurveMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralCurveMember_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralCurveMember::IfcStructuralCurveMember(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralCurveTypeEnum::Value v8_PredefinedType) : IfcStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralCurveMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,::Ifc2x3::IfcStructuralCurveTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralCurveMemberVarying


const IfcParse::entity& Ifc2x3::IfcStructuralCurveMemberVarying::declaration() const { return *IFC2X3_IfcStructuralCurveMemberVarying_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralCurveMemberVarying::Class() { return *IFC2X3_IfcStructuralCurveMemberVarying_type; }
Ifc2x3::IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(IfcEntityInstanceData* e) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralCurveMemberVarying_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralCurveTypeEnum::Value v8_PredefinedType) : IfcStructuralCurveMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralCurveMemberVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,::Ifc2x3::IfcStructuralCurveTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralItem

::Ifc2x3::IfcRelConnectsStructuralActivity::list::ptr Ifc2x3::IfcStructuralItem::AssignedStructuralActivity() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralActivity_type, 4)->as<IfcRelConnectsStructuralActivity>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralItem::declaration() const { return *IFC2X3_IfcStructuralItem_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralItem::Class() { return *IFC2X3_IfcStructuralItem_type; }
Ifc2x3::IfcStructuralItem::IfcStructuralItem(IfcEntityInstanceData* e) : IfcProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralItem::IfcStructuralItem(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation) : IfcProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcStructuralLinearAction
::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value Ifc2x3::IfcStructuralLinearAction::ProjectedOrTrue() const {  return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::FromString(*data_->getArgument(11)); }
void Ifc2x3::IfcStructuralLinearAction::setProjectedOrTrue(::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLinearAction::declaration() const { return *IFC2X3_IfcStructuralLinearAction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLinearAction::Class() { return *IFC2X3_IfcStructuralLinearAction_type; }
Ifc2x3::IfcStructuralLinearAction::IfcStructuralLinearAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLinearAction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLinearAction::IfcStructuralLinearAction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy, ::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v12_ProjectedOrTrue) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLinearAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralLinearActionVarying
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcStructuralLinearActionVarying::VaryingAppliedLoadLocation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcStructuralLinearActionVarying::setVaryingAppliedLoadLocation(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr Ifc2x3::IfcStructuralLinearActionVarying::SubsequentAppliedLoads() const {  aggregate_of_instance::ptr es = *data_->getArgument(13); return es->as< ::Ifc2x3::IfcStructuralLoad >(); }
void Ifc2x3::IfcStructuralLinearActionVarying::setSubsequentAppliedLoads(aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLinearActionVarying::declaration() const { return *IFC2X3_IfcStructuralLinearActionVarying_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLinearActionVarying::Class() { return *IFC2X3_IfcStructuralLinearActionVarying_type; }
Ifc2x3::IfcStructuralLinearActionVarying::IfcStructuralLinearActionVarying(IfcEntityInstanceData* e) : IfcStructuralLinearAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLinearActionVarying_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLinearActionVarying::IfcStructuralLinearActionVarying(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy, ::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v12_ProjectedOrTrue, ::Ifc2x3::IfcShapeAspect* v13_VaryingAppliedLoadLocation, aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads) : IfcStructuralLinearAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLinearActionVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_VaryingAppliedLoadLocation));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SubsequentAppliedLoads)->generalize());data_->setArgument(13,attr);} }

// Function implementations for IfcStructuralLoad
boost::optional< std::string > Ifc2x3::IfcStructuralLoad::Name() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcStructuralLoad::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoad::declaration() const { return *IFC2X3_IfcStructuralLoad_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoad::Class() { return *IFC2X3_IfcStructuralLoad_type; }
Ifc2x3::IfcStructuralLoad::IfcStructuralLoad(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoad_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoad::IfcStructuralLoad(boost::optional< std::string > v1_Name) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoad_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadGroup
::Ifc2x3::IfcLoadGroupTypeEnum::Value Ifc2x3::IfcStructuralLoadGroup::PredefinedType() const {  return ::Ifc2x3::IfcLoadGroupTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcStructuralLoadGroup::setPredefinedType(::Ifc2x3::IfcLoadGroupTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcLoadGroupTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
::Ifc2x3::IfcActionTypeEnum::Value Ifc2x3::IfcStructuralLoadGroup::ActionType() const {  return ::Ifc2x3::IfcActionTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcStructuralLoadGroup::setActionType(::Ifc2x3::IfcActionTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcActionTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
::Ifc2x3::IfcActionSourceTypeEnum::Value Ifc2x3::IfcStructuralLoadGroup::ActionSource() const {  return ::Ifc2x3::IfcActionSourceTypeEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcStructuralLoadGroup::setActionSource(::Ifc2x3::IfcActionSourceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcActionSourceTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadGroup::Coefficient() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcStructuralLoadGroup::setCoefficient(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< std::string > Ifc2x3::IfcStructuralLoadGroup::Purpose() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } std::string v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcStructuralLoadGroup::setPurpose(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }

::Ifc2x3::IfcStructuralResultGroup::list::ptr Ifc2x3::IfcStructuralLoadGroup::SourceOfResultGroup() const { return data_->getInverse(IFC2X3_IfcStructuralResultGroup_type, 6)->as<IfcStructuralResultGroup>(); }
::Ifc2x3::IfcStructuralAnalysisModel::list::ptr Ifc2x3::IfcStructuralLoadGroup::LoadGroupFor() const { return data_->getInverse(IFC2X3_IfcStructuralAnalysisModel_type, 7)->as<IfcStructuralAnalysisModel>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralLoadGroup::declaration() const { return *IFC2X3_IfcStructuralLoadGroup_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadGroup::Class() { return *IFC2X3_IfcStructuralLoadGroup_type; }
Ifc2x3::IfcStructuralLoadGroup::IfcStructuralLoadGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadGroup_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadGroup::IfcStructuralLoadGroup(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcLoadGroupTypeEnum::Value v6_PredefinedType, ::Ifc2x3::IfcActionTypeEnum::Value v7_ActionType, ::Ifc2x3::IfcActionSourceTypeEnum::Value v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PredefinedType,::Ifc2x3::IfcLoadGroupTypeEnum::ToString(v6_PredefinedType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_ActionType,::Ifc2x3::IfcActionTypeEnum::ToString(v7_ActionType))));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_ActionSource,::Ifc2x3::IfcActionSourceTypeEnum::ToString(v8_ActionSource))));data_->setArgument(7,attr);} if (v9_Coefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Coefficient));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Purpose));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcStructuralLoadLinearForce
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearForceX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearForceX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearForceY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearForceY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearForceZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearForceZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearMomentX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearMomentX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearMomentY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearMomentY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadLinearForce::LinearMomentZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcStructuralLoadLinearForce::setLinearMomentZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadLinearForce::declaration() const { return *IFC2X3_IfcStructuralLoadLinearForce_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadLinearForce::Class() { return *IFC2X3_IfcStructuralLoadLinearForce_type; }
Ifc2x3::IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadLinearForce_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearForceX, boost::optional< double > v3_LinearForceY, boost::optional< double > v4_LinearForceZ, boost::optional< double > v5_LinearMomentX, boost::optional< double > v6_LinearMomentY, boost::optional< double > v7_LinearMomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadLinearForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_LinearForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_LinearForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_LinearForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_LinearForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_LinearForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_LinearForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LinearMomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LinearMomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LinearMomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LinearMomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_LinearMomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_LinearMomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadPlanarForce
boost::optional< double > Ifc2x3::IfcStructuralLoadPlanarForce::PlanarForceX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcStructuralLoadPlanarForce::setPlanarForceX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadPlanarForce::PlanarForceY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStructuralLoadPlanarForce::setPlanarForceY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadPlanarForce::PlanarForceZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcStructuralLoadPlanarForce::setPlanarForceZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadPlanarForce::declaration() const { return *IFC2X3_IfcStructuralLoadPlanarForce_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadPlanarForce::Class() { return *IFC2X3_IfcStructuralLoadPlanarForce_type; }
Ifc2x3::IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadPlanarForce_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_PlanarForceX, boost::optional< double > v3_PlanarForceY, boost::optional< double > v4_PlanarForceZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadPlanarForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_PlanarForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_PlanarForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_PlanarForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PlanarForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_PlanarForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_PlanarForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacement
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::DisplacementX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setDisplacementX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::DisplacementY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setDisplacementY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::DisplacementZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setDisplacementZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::RotationalDisplacementRX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::RotationalDisplacementRY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacement::RotationalDisplacementRZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleDisplacement::declaration() const { return *IFC2X3_IfcStructuralLoadSingleDisplacement_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleDisplacement::Class() { return *IFC2X3_IfcStructuralLoadSingleDisplacement_type; }
Ifc2x3::IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadSingleDisplacement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadSingleDisplacement_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleDisplacementDistortion
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::Distortion() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::setDistortion(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::declaration() const { return *IFC2X3_IfcStructuralLoadSingleDisplacementDistortion_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::Class() { return *IFC2X3_IfcStructuralLoadSingleDisplacementDistortion_type; }
Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(IfcEntityInstanceData* e) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadSingleDisplacementDistortion_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ, boost::optional< double > v8_Distortion) : IfcStructuralLoadSingleDisplacement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadSingleDisplacementDistortion_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DisplacementX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DisplacementX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DisplacementY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DisplacementY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DisplacementZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DisplacementZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_RotationalDisplacementRX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_RotationalDisplacementRX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_RotationalDisplacementRY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_RotationalDisplacementRY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RotationalDisplacementRZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RotationalDisplacementRZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Distortion) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Distortion));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadSingleForce
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::ForceX() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setForceX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::ForceY() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setForceY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::ForceZ() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setForceZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::MomentX() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setMomentX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::MomentY() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setMomentY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForce::MomentZ() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcStructuralLoadSingleForce::setMomentZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleForce::declaration() const { return *IFC2X3_IfcStructuralLoadSingleForce_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleForce::Class() { return *IFC2X3_IfcStructuralLoadSingleForce_type; }
Ifc2x3::IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadSingleForce_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadSingleForce_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } }

// Function implementations for IfcStructuralLoadSingleForceWarping
boost::optional< double > Ifc2x3::IfcStructuralLoadSingleForceWarping::WarpingMoment() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcStructuralLoadSingleForceWarping::setWarpingMoment(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleForceWarping::declaration() const { return *IFC2X3_IfcStructuralLoadSingleForceWarping_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadSingleForceWarping::Class() { return *IFC2X3_IfcStructuralLoadSingleForceWarping_type; }
Ifc2x3::IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(IfcEntityInstanceData* e) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadSingleForceWarping_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ, boost::optional< double > v8_WarpingMoment) : IfcStructuralLoadSingleForce((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadSingleForceWarping_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_ForceX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ForceX));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_ForceY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_ForceY));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_ForceZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_ForceZ));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MomentX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MomentX));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MomentY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MomentY));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_MomentZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_MomentZ));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WarpingMoment) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WarpingMoment));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcStructuralLoadStatic


const IfcParse::entity& Ifc2x3::IfcStructuralLoadStatic::declaration() const { return *IFC2X3_IfcStructuralLoadStatic_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadStatic::Class() { return *IFC2X3_IfcStructuralLoadStatic_type; }
Ifc2x3::IfcStructuralLoadStatic::IfcStructuralLoadStatic(IfcEntityInstanceData* e) : IfcStructuralLoad((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadStatic_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadStatic::IfcStructuralLoadStatic(boost::optional< std::string > v1_Name) : IfcStructuralLoad((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadStatic_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } }

// Function implementations for IfcStructuralLoadTemperature
boost::optional< double > Ifc2x3::IfcStructuralLoadTemperature::DeltaT_Constant() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcStructuralLoadTemperature::setDeltaT_Constant(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadTemperature::DeltaT_Y() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStructuralLoadTemperature::setDeltaT_Y(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralLoadTemperature::DeltaT_Z() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcStructuralLoadTemperature::setDeltaT_Z(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralLoadTemperature::declaration() const { return *IFC2X3_IfcStructuralLoadTemperature_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralLoadTemperature::Class() { return *IFC2X3_IfcStructuralLoadTemperature_type; }
Ifc2x3::IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(IfcEntityInstanceData* e) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralLoadTemperature_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(boost::optional< std::string > v1_Name, boost::optional< double > v2_DeltaT_Constant, boost::optional< double > v3_DeltaT_Y, boost::optional< double > v4_DeltaT_Z) : IfcStructuralLoadStatic((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralLoadTemperature_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DeltaT_Constant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DeltaT_Constant));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_DeltaT_Y) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_DeltaT_Y));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_DeltaT_Z) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_DeltaT_Z));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } }

// Function implementations for IfcStructuralMember

::Ifc2x3::IfcRelConnectsStructuralElement::list::ptr Ifc2x3::IfcStructuralMember::ReferencesElement() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralElement_type, 5)->as<IfcRelConnectsStructuralElement>(); }
::Ifc2x3::IfcRelConnectsStructuralMember::list::ptr Ifc2x3::IfcStructuralMember::ConnectedBy() const { return data_->getInverse(IFC2X3_IfcRelConnectsStructuralMember_type, 4)->as<IfcRelConnectsStructuralMember>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralMember::declaration() const { return *IFC2X3_IfcStructuralMember_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralMember::Class() { return *IFC2X3_IfcStructuralMember_type; }
Ifc2x3::IfcStructuralMember::IfcStructuralMember(IfcEntityInstanceData* e) : IfcStructuralItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralMember_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralMember::IfcStructuralMember(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation) : IfcStructuralItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} }

// Function implementations for IfcStructuralPlanarAction
::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value Ifc2x3::IfcStructuralPlanarAction::ProjectedOrTrue() const {  return ::Ifc2x3::IfcProjectedOrTrueLengthEnum::FromString(*data_->getArgument(11)); }
void Ifc2x3::IfcStructuralPlanarAction::setProjectedOrTrue(::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v)));data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralPlanarAction::declaration() const { return *IFC2X3_IfcStructuralPlanarAction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralPlanarAction::Class() { return *IFC2X3_IfcStructuralPlanarAction_type; }
Ifc2x3::IfcStructuralPlanarAction::IfcStructuralPlanarAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralPlanarAction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralPlanarAction::IfcStructuralPlanarAction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy, ::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v12_ProjectedOrTrue) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralPlanarAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));data_->setArgument(11,attr);} }

// Function implementations for IfcStructuralPlanarActionVarying
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcStructuralPlanarActionVarying::VaryingAppliedLoadLocation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcStructuralPlanarActionVarying::setVaryingAppliedLoadLocation(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr Ifc2x3::IfcStructuralPlanarActionVarying::SubsequentAppliedLoads() const {  aggregate_of_instance::ptr es = *data_->getArgument(13); return es->as< ::Ifc2x3::IfcStructuralLoad >(); }
void Ifc2x3::IfcStructuralPlanarActionVarying::setSubsequentAppliedLoads(aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(13,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralPlanarActionVarying::declaration() const { return *IFC2X3_IfcStructuralPlanarActionVarying_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralPlanarActionVarying::Class() { return *IFC2X3_IfcStructuralPlanarActionVarying_type; }
Ifc2x3::IfcStructuralPlanarActionVarying::IfcStructuralPlanarActionVarying(IfcEntityInstanceData* e) : IfcStructuralPlanarAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralPlanarActionVarying_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralPlanarActionVarying::IfcStructuralPlanarActionVarying(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy, ::Ifc2x3::IfcProjectedOrTrueLengthEnum::Value v12_ProjectedOrTrue, ::Ifc2x3::IfcShapeAspect* v13_VaryingAppliedLoadLocation, aggregate_of< ::Ifc2x3::IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads) : IfcStructuralPlanarAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralPlanarActionVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v12_ProjectedOrTrue,::Ifc2x3::IfcProjectedOrTrueLengthEnum::ToString(v12_ProjectedOrTrue))));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_VaryingAppliedLoadLocation));data_->setArgument(12,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v14_SubsequentAppliedLoads)->generalize());data_->setArgument(13,attr);} }

// Function implementations for IfcStructuralPointAction


const IfcParse::entity& Ifc2x3::IfcStructuralPointAction::declaration() const { return *IFC2X3_IfcStructuralPointAction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralPointAction::Class() { return *IFC2X3_IfcStructuralPointAction_type; }
Ifc2x3::IfcStructuralPointAction::IfcStructuralPointAction(IfcEntityInstanceData* e) : IfcStructuralAction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralPointAction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralPointAction::IfcStructuralPointAction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal, bool v10_DestabilizingLoad, ::Ifc2x3::IfcStructuralReaction* v11_CausedBy) : IfcStructuralAction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralPointAction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_DestabilizingLoad));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_CausedBy));data_->setArgument(10,attr);} }

// Function implementations for IfcStructuralPointConnection


const IfcParse::entity& Ifc2x3::IfcStructuralPointConnection::declaration() const { return *IFC2X3_IfcStructuralPointConnection_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralPointConnection::Class() { return *IFC2X3_IfcStructuralPointConnection_type; }
Ifc2x3::IfcStructuralPointConnection::IfcStructuralPointConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralPointConnection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralPointConnection::IfcStructuralPointConnection(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralPointConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralPointReaction


const IfcParse::entity& Ifc2x3::IfcStructuralPointReaction::declaration() const { return *IFC2X3_IfcStructuralPointReaction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralPointReaction::Class() { return *IFC2X3_IfcStructuralPointReaction_type; }
Ifc2x3::IfcStructuralPointReaction::IfcStructuralPointReaction(IfcEntityInstanceData* e) : IfcStructuralReaction((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralPointReaction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralPointReaction::IfcStructuralPointReaction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal) : IfcStructuralReaction((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralPointReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralProfileProperties
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::TorsionalConstantX() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setTorsionalConstantX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MomentOfInertiaYZ() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMomentOfInertiaYZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MomentOfInertiaY() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMomentOfInertiaY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MomentOfInertiaZ() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMomentOfInertiaZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::WarpingConstant() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setWarpingConstant(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::ShearCentreZ() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setShearCentreZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::ShearCentreY() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setShearCentreY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(13,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::ShearDeformationAreaZ() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return boost::none; } double v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setShearDeformationAreaZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(14,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::ShearDeformationAreaY() const { if(!data_->getArgument(15) || data_->getArgument(15)->isNull()) { return boost::none; } double v = *data_->getArgument(15); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setShearDeformationAreaY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(15,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MaximumSectionModulusY() const { if(!data_->getArgument(16) || data_->getArgument(16)->isNull()) { return boost::none; } double v = *data_->getArgument(16); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMaximumSectionModulusY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(16,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MinimumSectionModulusY() const { if(!data_->getArgument(17) || data_->getArgument(17)->isNull()) { return boost::none; } double v = *data_->getArgument(17); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMinimumSectionModulusY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(17,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MaximumSectionModulusZ() const { if(!data_->getArgument(18) || data_->getArgument(18)->isNull()) { return boost::none; } double v = *data_->getArgument(18); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMaximumSectionModulusZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(18,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::MinimumSectionModulusZ() const { if(!data_->getArgument(19) || data_->getArgument(19)->isNull()) { return boost::none; } double v = *data_->getArgument(19); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setMinimumSectionModulusZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(19,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::TorsionalSectionModulus() const { if(!data_->getArgument(20) || data_->getArgument(20)->isNull()) { return boost::none; } double v = *data_->getArgument(20); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setTorsionalSectionModulus(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(20,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::CentreOfGravityInX() const { if(!data_->getArgument(21) || data_->getArgument(21)->isNull()) { return boost::none; } double v = *data_->getArgument(21); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setCentreOfGravityInX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(21,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralProfileProperties::CentreOfGravityInY() const { if(!data_->getArgument(22) || data_->getArgument(22)->isNull()) { return boost::none; } double v = *data_->getArgument(22); return v; }
void Ifc2x3::IfcStructuralProfileProperties::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(22,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralProfileProperties::declaration() const { return *IFC2X3_IfcStructuralProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralProfileProperties::Class() { return *IFC2X3_IfcStructuralProfileProperties_type; }
Ifc2x3::IfcStructuralProfileProperties::IfcStructuralProfileProperties(IfcEntityInstanceData* e) : IfcGeneralProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralProfileProperties::IfcStructuralProfileProperties(boost::optional< std::string > v1_ProfileName, ::Ifc2x3::IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY) : IfcGeneralProfileProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralProfileProperties_type);  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));data_->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_TorsionalConstantX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TorsionalConstantX));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_MomentOfInertiaYZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_MomentOfInertiaYZ));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_MomentOfInertiaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MomentOfInertiaY));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_MomentOfInertiaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MomentOfInertiaZ));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_WarpingConstant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WarpingConstant));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_ShearCentreZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ShearCentreZ));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_ShearCentreY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ShearCentreY));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_ShearDeformationAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ShearDeformationAreaZ));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_ShearDeformationAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ShearDeformationAreaY));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_MaximumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MaximumSectionModulusY));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_MinimumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_MinimumSectionModulusY));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_MaximumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_MaximumSectionModulusZ));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } if (v20_MinimumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_MinimumSectionModulusZ));data_->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(19, attr); } if (v21_TorsionalSectionModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_TorsionalSectionModulus));data_->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(20, attr); } if (v22_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_CentreOfGravityInX));data_->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(21, attr); } if (v23_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_CentreOfGravityInY));data_->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(22, attr); } }

// Function implementations for IfcStructuralReaction

::Ifc2x3::IfcStructuralAction::list::ptr Ifc2x3::IfcStructuralReaction::Causes() const { return data_->getInverse(IFC2X3_IfcStructuralAction_type, 10)->as<IfcStructuralAction>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralReaction::declaration() const { return *IFC2X3_IfcStructuralReaction_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralReaction::Class() { return *IFC2X3_IfcStructuralReaction_type; }
Ifc2x3::IfcStructuralReaction::IfcStructuralReaction(IfcEntityInstanceData* e) : IfcStructuralActivity((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralReaction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralReaction::IfcStructuralReaction(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralLoad* v8_AppliedLoad, ::Ifc2x3::IfcGlobalOrLocalEnum::Value v9_GlobalOrLocal) : IfcStructuralActivity((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralReaction_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedLoad));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_GlobalOrLocal,::Ifc2x3::IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal))));data_->setArgument(8,attr);} }

// Function implementations for IfcStructuralResultGroup
::Ifc2x3::IfcAnalysisTheoryTypeEnum::Value Ifc2x3::IfcStructuralResultGroup::TheoryType() const {  return ::Ifc2x3::IfcAnalysisTheoryTypeEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcStructuralResultGroup::setTheoryType(::Ifc2x3::IfcAnalysisTheoryTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcAnalysisTheoryTypeEnum::ToString(v)));data_->setArgument(5,attr);} }
::Ifc2x3::IfcStructuralLoadGroup* Ifc2x3::IfcStructuralResultGroup::ResultForLoadGroup() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcStructuralLoadGroup>(true); }
void Ifc2x3::IfcStructuralResultGroup::setResultForLoadGroup(::Ifc2x3::IfcStructuralLoadGroup* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
bool Ifc2x3::IfcStructuralResultGroup::IsLinear() const {  bool v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcStructuralResultGroup::setIsLinear(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

::Ifc2x3::IfcStructuralAnalysisModel::list::ptr Ifc2x3::IfcStructuralResultGroup::ResultGroupFor() const { return data_->getInverse(IFC2X3_IfcStructuralAnalysisModel_type, 8)->as<IfcStructuralAnalysisModel>(); }

const IfcParse::entity& Ifc2x3::IfcStructuralResultGroup::declaration() const { return *IFC2X3_IfcStructuralResultGroup_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralResultGroup::Class() { return *IFC2X3_IfcStructuralResultGroup_type; }
Ifc2x3::IfcStructuralResultGroup::IfcStructuralResultGroup(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralResultGroup_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralResultGroup::IfcStructuralResultGroup(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcAnalysisTheoryTypeEnum::Value v6_TheoryType, ::Ifc2x3::IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralResultGroup_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_TheoryType,::Ifc2x3::IfcAnalysisTheoryTypeEnum::ToString(v6_TheoryType))));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_ResultForLoadGroup));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_IsLinear));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralSteelProfileProperties
boost::optional< double > Ifc2x3::IfcStructuralSteelProfileProperties::ShearAreaZ() const { if(!data_->getArgument(23) || data_->getArgument(23)->isNull()) { return boost::none; } double v = *data_->getArgument(23); return v; }
void Ifc2x3::IfcStructuralSteelProfileProperties::setShearAreaZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(23,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralSteelProfileProperties::ShearAreaY() const { if(!data_->getArgument(24) || data_->getArgument(24)->isNull()) { return boost::none; } double v = *data_->getArgument(24); return v; }
void Ifc2x3::IfcStructuralSteelProfileProperties::setShearAreaY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(24,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralSteelProfileProperties::PlasticShapeFactorY() const { if(!data_->getArgument(25) || data_->getArgument(25)->isNull()) { return boost::none; } double v = *data_->getArgument(25); return v; }
void Ifc2x3::IfcStructuralSteelProfileProperties::setPlasticShapeFactorY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(25,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralSteelProfileProperties::PlasticShapeFactorZ() const { if(!data_->getArgument(26) || data_->getArgument(26)->isNull()) { return boost::none; } double v = *data_->getArgument(26); return v; }
void Ifc2x3::IfcStructuralSteelProfileProperties::setPlasticShapeFactorZ(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(26,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralSteelProfileProperties::declaration() const { return *IFC2X3_IfcStructuralSteelProfileProperties_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralSteelProfileProperties::Class() { return *IFC2X3_IfcStructuralSteelProfileProperties_type; }
Ifc2x3::IfcStructuralSteelProfileProperties::IfcStructuralSteelProfileProperties(IfcEntityInstanceData* e) : IfcStructuralProfileProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralSteelProfileProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralSteelProfileProperties::IfcStructuralSteelProfileProperties(boost::optional< std::string > v1_ProfileName, ::Ifc2x3::IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY, boost::optional< double > v24_ShearAreaZ, boost::optional< double > v25_ShearAreaY, boost::optional< double > v26_PlasticShapeFactorY, boost::optional< double > v27_PlasticShapeFactorZ) : IfcStructuralProfileProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSteelProfileProperties_type);  if (v1_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_ProfileName));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_ProfileDefinition));data_->setArgument(1,attr);} if (v3_PhysicalWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_PhysicalWeight));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Perimeter) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Perimeter));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_MinimumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_MinimumPlateThickness));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_MaximumPlateThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_MaximumPlateThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_CrossSectionArea) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_CrossSectionArea));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_TorsionalConstantX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_TorsionalConstantX));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_MomentOfInertiaYZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_MomentOfInertiaYZ));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_MomentOfInertiaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_MomentOfInertiaY));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_MomentOfInertiaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_MomentOfInertiaZ));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_WarpingConstant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_WarpingConstant));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_ShearCentreZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_ShearCentreZ));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_ShearCentreY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_ShearCentreY));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_ShearDeformationAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_ShearDeformationAreaZ));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_ShearDeformationAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_ShearDeformationAreaY));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_MaximumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MaximumSectionModulusY));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } if (v18_MinimumSectionModulusY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v18_MinimumSectionModulusY));data_->setArgument(17,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(17, attr); } if (v19_MaximumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v19_MaximumSectionModulusZ));data_->setArgument(18,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(18, attr); } if (v20_MinimumSectionModulusZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v20_MinimumSectionModulusZ));data_->setArgument(19,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(19, attr); } if (v21_TorsionalSectionModulus) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v21_TorsionalSectionModulus));data_->setArgument(20,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(20, attr); } if (v22_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v22_CentreOfGravityInX));data_->setArgument(21,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(21, attr); } if (v23_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v23_CentreOfGravityInY));data_->setArgument(22,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(22, attr); } if (v24_ShearAreaZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v24_ShearAreaZ));data_->setArgument(23,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(23, attr); } if (v25_ShearAreaY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v25_ShearAreaY));data_->setArgument(24,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(24, attr); } if (v26_PlasticShapeFactorY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v26_PlasticShapeFactorY));data_->setArgument(25,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(25, attr); } if (v27_PlasticShapeFactorZ) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v27_PlasticShapeFactorZ));data_->setArgument(26,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(26, attr); } }

// Function implementations for IfcStructuralSurfaceConnection


const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceConnection::declaration() const { return *IFC2X3_IfcStructuralSurfaceConnection_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceConnection::Class() { return *IFC2X3_IfcStructuralSurfaceConnection_type; }
Ifc2x3::IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(IfcEntityInstanceData* e) : IfcStructuralConnection((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralSurfaceConnection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSurfaceConnection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_AppliedCondition));data_->setArgument(7,attr);} }

// Function implementations for IfcStructuralSurfaceMember
::Ifc2x3::IfcStructuralSurfaceTypeEnum::Value Ifc2x3::IfcStructuralSurfaceMember::PredefinedType() const {  return ::Ifc2x3::IfcStructuralSurfaceTypeEnum::FromString(*data_->getArgument(7)); }
void Ifc2x3::IfcStructuralSurfaceMember::setPredefinedType(::Ifc2x3::IfcStructuralSurfaceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcStructuralSurfaceTypeEnum::ToString(v)));data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcStructuralSurfaceMember::Thickness() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcStructuralSurfaceMember::setThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceMember::declaration() const { return *IFC2X3_IfcStructuralSurfaceMember_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceMember::Class() { return *IFC2X3_IfcStructuralSurfaceMember_type; }
Ifc2x3::IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(IfcEntityInstanceData* e) : IfcStructuralMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralSurfaceMember_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralSurfaceTypeEnum::Value v8_PredefinedType, boost::optional< double > v9_Thickness) : IfcStructuralMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSurfaceMember_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,::Ifc2x3::IfcStructuralSurfaceTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcStructuralSurfaceMemberVarying
std::vector< double > /*[2:?]*/ Ifc2x3::IfcStructuralSurfaceMemberVarying::SubsequentThickness() const {  std::vector< double > /*[2:?]*/ v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcStructuralSurfaceMemberVarying::setSubsequentThickness(std::vector< double > /*[2:?]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcStructuralSurfaceMemberVarying::VaryingThicknessLocation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(10)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcStructuralSurfaceMemberVarying::setVaryingThicknessLocation(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceMemberVarying::declaration() const { return *IFC2X3_IfcStructuralSurfaceMemberVarying_type; }
const IfcParse::entity& Ifc2x3::IfcStructuralSurfaceMemberVarying::Class() { return *IFC2X3_IfcStructuralSurfaceMemberVarying_type; }
Ifc2x3::IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(IfcEntityInstanceData* e) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuralSurfaceMemberVarying_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, ::Ifc2x3::IfcStructuralSurfaceTypeEnum::Value v8_PredefinedType, boost::optional< double > v9_Thickness, std::vector< double > /*[2:?]*/ v10_SubsequentThickness, ::Ifc2x3::IfcShapeAspect* v11_VaryingThicknessLocation) : IfcStructuralSurfaceMember((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuralSurfaceMemberVarying_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v8_PredefinedType,::Ifc2x3::IfcStructuralSurfaceTypeEnum::ToString(v8_PredefinedType))));data_->setArgument(7,attr);} if (v9_Thickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Thickness));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SubsequentThickness));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_VaryingThicknessLocation));data_->setArgument(10,attr);} }

// Function implementations for IfcStructuredDimensionCallout


const IfcParse::entity& Ifc2x3::IfcStructuredDimensionCallout::declaration() const { return *IFC2X3_IfcStructuredDimensionCallout_type; }
const IfcParse::entity& Ifc2x3::IfcStructuredDimensionCallout::Class() { return *IFC2X3_IfcStructuredDimensionCallout_type; }
Ifc2x3::IfcStructuredDimensionCallout::IfcStructuredDimensionCallout(IfcEntityInstanceData* e) : IfcDraughtingCallout((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStructuredDimensionCallout_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStructuredDimensionCallout::IfcStructuredDimensionCallout(aggregate_of_instance::ptr v1_Contents) : IfcDraughtingCallout((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStructuredDimensionCallout_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Contents));data_->setArgument(0,attr);} }

// Function implementations for IfcStyleModel


const IfcParse::entity& Ifc2x3::IfcStyleModel::declaration() const { return *IFC2X3_IfcStyleModel_type; }
const IfcParse::entity& Ifc2x3::IfcStyleModel::Class() { return *IFC2X3_IfcStyleModel_type; }
Ifc2x3::IfcStyleModel::IfcStyleModel(IfcEntityInstanceData* e) : IfcRepresentation((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStyleModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStyleModel::IfcStyleModel(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcRepresentation((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStyleModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcStyledItem
::Ifc2x3::IfcRepresentationItem* Ifc2x3::IfcStyledItem::Item() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcRepresentationItem>(true); }
void Ifc2x3::IfcStyledItem::setItem(::Ifc2x3::IfcRepresentationItem* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr Ifc2x3::IfcStyledItem::Styles() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcPresentationStyleAssignment >(); }
void Ifc2x3::IfcStyledItem::setStyles(aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcStyledItem::Name() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcStyledItem::setName(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcStyledItem::declaration() const { return *IFC2X3_IfcStyledItem_type; }
const IfcParse::entity& Ifc2x3::IfcStyledItem::Class() { return *IFC2X3_IfcStyledItem_type; }
Ifc2x3::IfcStyledItem::IfcStyledItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStyledItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStyledItem::IfcStyledItem(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name) : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStyledItem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } }

// Function implementations for IfcStyledRepresentation


const IfcParse::entity& Ifc2x3::IfcStyledRepresentation::declaration() const { return *IFC2X3_IfcStyledRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcStyledRepresentation::Class() { return *IFC2X3_IfcStyledRepresentation_type; }
Ifc2x3::IfcStyledRepresentation::IfcStyledRepresentation(IfcEntityInstanceData* e) : IfcStyleModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcStyledRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcStyledRepresentation::IfcStyledRepresentation(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcStyleModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcStyledRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcSubContractResource
::Ifc2x3::IfcActorSelect* Ifc2x3::IfcSubContractResource::SubContractor() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(9)))->as<::Ifc2x3::IfcActorSelect>(true); }
void Ifc2x3::IfcSubContractResource::setSubContractor(::Ifc2x3::IfcActorSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(9,attr);} }
boost::optional< std::string > Ifc2x3::IfcSubContractResource::JobDescription() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } std::string v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcSubContractResource::setJobDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcSubContractResource::declaration() const { return *IFC2X3_IfcSubContractResource_type; }
const IfcParse::entity& Ifc2x3::IfcSubContractResource::Class() { return *IFC2X3_IfcSubContractResource_type; }
Ifc2x3::IfcSubContractResource::IfcSubContractResource(IfcEntityInstanceData* e) : IfcConstructionResource((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSubContractResource_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSubContractResource::IfcSubContractResource(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< ::Ifc2x3::IfcResourceConsumptionEnum::Value > v8_ResourceConsumption, ::Ifc2x3::IfcMeasureWithUnit* v9_BaseQuantity, ::Ifc2x3::IfcActorSelect* v10_SubContractor, boost::optional< std::string > v11_JobDescription) : IfcConstructionResource((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSubContractResource_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ResourceIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ResourceIdentifier));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ResourceGroup) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ResourceGroup));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_ResourceConsumption) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v8_ResourceConsumption,::Ifc2x3::IfcResourceConsumptionEnum::ToString(*v8_ResourceConsumption))));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_BaseQuantity));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v10_SubContractor));data_->setArgument(9,attr);} if (v11_JobDescription) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_JobDescription));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcSubedge
::Ifc2x3::IfcEdge* Ifc2x3::IfcSubedge::ParentEdge() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcEdge>(true); }
void Ifc2x3::IfcSubedge::setParentEdge(::Ifc2x3::IfcEdge* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcSubedge::declaration() const { return *IFC2X3_IfcSubedge_type; }
const IfcParse::entity& Ifc2x3::IfcSubedge::Class() { return *IFC2X3_IfcSubedge_type; }
Ifc2x3::IfcSubedge::IfcSubedge(IfcEntityInstanceData* e) : IfcEdge((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSubedge_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSubedge::IfcSubedge(::Ifc2x3::IfcVertex* v1_EdgeStart, ::Ifc2x3::IfcVertex* v2_EdgeEnd, ::Ifc2x3::IfcEdge* v3_ParentEdge) : IfcEdge((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSubedge_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_EdgeStart));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_EdgeEnd));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ParentEdge));data_->setArgument(2,attr);} }

// Function implementations for IfcSurface


const IfcParse::entity& Ifc2x3::IfcSurface::declaration() const { return *IFC2X3_IfcSurface_type; }
const IfcParse::entity& Ifc2x3::IfcSurface::Class() { return *IFC2X3_IfcSurface_type; }
Ifc2x3::IfcSurface::IfcSurface(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurface::IfcSurface() : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurface_type);  }

// Function implementations for IfcSurfaceCurveSweptAreaSolid
::Ifc2x3::IfcCurve* Ifc2x3::IfcSurfaceCurveSweptAreaSolid::Directrix() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcSurfaceCurveSweptAreaSolid::setDirectrix(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcSurfaceCurveSweptAreaSolid::StartParam() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcSurfaceCurveSweptAreaSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcSurfaceCurveSweptAreaSolid::EndParam() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcSurfaceCurveSweptAreaSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcSurface* Ifc2x3::IfcSurfaceCurveSweptAreaSolid::ReferenceSurface() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcSurface>(true); }
void Ifc2x3::IfcSurfaceCurveSweptAreaSolid::setReferenceSurface(::Ifc2x3::IfcSurface* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceCurveSweptAreaSolid::declaration() const { return *IFC2X3_IfcSurfaceCurveSweptAreaSolid_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceCurveSweptAreaSolid::Class() { return *IFC2X3_IfcSurfaceCurveSweptAreaSolid_type; }
Ifc2x3::IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcEntityInstanceData* e) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceCurveSweptAreaSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(::Ifc2x3::IfcProfileDef* v1_SweptArea, ::Ifc2x3::IfcAxis2Placement3D* v2_Position, ::Ifc2x3::IfcCurve* v3_Directrix, double v4_StartParam, double v5_EndParam, ::Ifc2x3::IfcSurface* v6_ReferenceSurface) : IfcSweptAreaSolid((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceCurveSweptAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Directrix));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_StartParam));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndParam));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReferenceSurface));data_->setArgument(5,attr);} }

// Function implementations for IfcSurfaceOfLinearExtrusion
::Ifc2x3::IfcDirection* Ifc2x3::IfcSurfaceOfLinearExtrusion::ExtrudedDirection() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcSurfaceOfLinearExtrusion::setExtrudedDirection(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
double Ifc2x3::IfcSurfaceOfLinearExtrusion::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcSurfaceOfLinearExtrusion::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceOfLinearExtrusion::declaration() const { return *IFC2X3_IfcSurfaceOfLinearExtrusion_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceOfLinearExtrusion::Class() { return *IFC2X3_IfcSurfaceOfLinearExtrusion_type; }
Ifc2x3::IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceOfLinearExtrusion_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(::Ifc2x3::IfcProfileDef* v1_SweptCurve, ::Ifc2x3::IfcAxis2Placement3D* v2_Position, ::Ifc2x3::IfcDirection* v3_ExtrudedDirection, double v4_Depth) : IfcSweptSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceOfLinearExtrusion_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_ExtrudedDirection));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);} }

// Function implementations for IfcSurfaceOfRevolution
::Ifc2x3::IfcAxis1Placement* Ifc2x3::IfcSurfaceOfRevolution::AxisPosition() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcAxis1Placement>(true); }
void Ifc2x3::IfcSurfaceOfRevolution::setAxisPosition(::Ifc2x3::IfcAxis1Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceOfRevolution::declaration() const { return *IFC2X3_IfcSurfaceOfRevolution_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceOfRevolution::Class() { return *IFC2X3_IfcSurfaceOfRevolution_type; }
Ifc2x3::IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcEntityInstanceData* e) : IfcSweptSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceOfRevolution_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(::Ifc2x3::IfcProfileDef* v1_SweptCurve, ::Ifc2x3::IfcAxis2Placement3D* v2_Position, ::Ifc2x3::IfcAxis1Placement* v3_AxisPosition) : IfcSweptSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceOfRevolution_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_AxisPosition));data_->setArgument(2,attr);} }

// Function implementations for IfcSurfaceStyle
::Ifc2x3::IfcSurfaceSide::Value Ifc2x3::IfcSurfaceStyle::Side() const {  return ::Ifc2x3::IfcSurfaceSide::FromString(*data_->getArgument(1)); }
void Ifc2x3::IfcSurfaceStyle::setSide(::Ifc2x3::IfcSurfaceSide::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSurfaceSide::ToString(v)));data_->setArgument(1,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcSurfaceStyle::Styles() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcSurfaceStyle::setStyles(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyle::declaration() const { return *IFC2X3_IfcSurfaceStyle_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyle::Class() { return *IFC2X3_IfcSurfaceStyle_type; }
Ifc2x3::IfcSurfaceStyle::IfcSurfaceStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyle::IfcSurfaceStyle(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcSurfaceSide::Value v2_Side, aggregate_of_instance::ptr v3_Styles) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v2_Side,::Ifc2x3::IfcSurfaceSide::ToString(v2_Side))));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Styles));data_->setArgument(2,attr);} }

// Function implementations for IfcSurfaceStyleLighting
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcSurfaceStyleLighting::DiffuseTransmissionColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcSurfaceStyleLighting::setDiffuseTransmissionColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcSurfaceStyleLighting::DiffuseReflectionColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcSurfaceStyleLighting::setDiffuseReflectionColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcSurfaceStyleLighting::TransmissionColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcSurfaceStyleLighting::setTransmissionColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcSurfaceStyleLighting::ReflectanceColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcSurfaceStyleLighting::setReflectanceColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyleLighting::declaration() const { return *IFC2X3_IfcSurfaceStyleLighting_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyleLighting::Class() { return *IFC2X3_IfcSurfaceStyleLighting_type; }
Ifc2x3::IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyleLighting_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(::Ifc2x3::IfcColourRgb* v1_DiffuseTransmissionColour, ::Ifc2x3::IfcColourRgb* v2_DiffuseReflectionColour, ::Ifc2x3::IfcColourRgb* v3_TransmissionColour, ::Ifc2x3::IfcColourRgb* v4_ReflectanceColour) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyleLighting_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_DiffuseTransmissionColour));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_DiffuseReflectionColour));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TransmissionColour));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_ReflectanceColour));data_->setArgument(3,attr);} }

// Function implementations for IfcSurfaceStyleRefraction
boost::optional< double > Ifc2x3::IfcSurfaceStyleRefraction::RefractionIndex() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcSurfaceStyleRefraction::setRefractionIndex(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< double > Ifc2x3::IfcSurfaceStyleRefraction::DispersionFactor() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSurfaceStyleRefraction::setDispersionFactor(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyleRefraction::declaration() const { return *IFC2X3_IfcSurfaceStyleRefraction_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyleRefraction::Class() { return *IFC2X3_IfcSurfaceStyleRefraction_type; }
Ifc2x3::IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyleRefraction_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(boost::optional< double > v1_RefractionIndex, boost::optional< double > v2_DispersionFactor) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyleRefraction_type);  if (v1_RefractionIndex) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_RefractionIndex));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_DispersionFactor) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_DispersionFactor));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } }

// Function implementations for IfcSurfaceStyleRendering
boost::optional< double > Ifc2x3::IfcSurfaceStyleRendering::Transparency() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSurfaceStyleRendering::setTransparency(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcColourOrFactor* Ifc2x3::IfcSurfaceStyleRendering::DiffuseColour() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcColourOrFactor>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setDiffuseColour(::Ifc2x3::IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcColourOrFactor* Ifc2x3::IfcSurfaceStyleRendering::TransmissionColour() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcColourOrFactor>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setTransmissionColour(::Ifc2x3::IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcColourOrFactor* Ifc2x3::IfcSurfaceStyleRendering::DiffuseTransmissionColour() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcColourOrFactor>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setDiffuseTransmissionColour(::Ifc2x3::IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
::Ifc2x3::IfcColourOrFactor* Ifc2x3::IfcSurfaceStyleRendering::ReflectionColour() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcColourOrFactor>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setReflectionColour(::Ifc2x3::IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcColourOrFactor* Ifc2x3::IfcSurfaceStyleRendering::SpecularColour() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcColourOrFactor>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setSpecularColour(::Ifc2x3::IfcColourOrFactor* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
::Ifc2x3::IfcSpecularHighlightSelect* Ifc2x3::IfcSurfaceStyleRendering::SpecularHighlight() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcSpecularHighlightSelect>(true); }
void Ifc2x3::IfcSurfaceStyleRendering::setSpecularHighlight(::Ifc2x3::IfcSpecularHighlightSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }
::Ifc2x3::IfcReflectanceMethodEnum::Value Ifc2x3::IfcSurfaceStyleRendering::ReflectanceMethod() const {  return ::Ifc2x3::IfcReflectanceMethodEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcSurfaceStyleRendering::setReflectanceMethod(::Ifc2x3::IfcReflectanceMethodEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcReflectanceMethodEnum::ToString(v)));data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyleRendering::declaration() const { return *IFC2X3_IfcSurfaceStyleRendering_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyleRendering::Class() { return *IFC2X3_IfcSurfaceStyleRendering_type; }
Ifc2x3::IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcEntityInstanceData* e) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyleRendering_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(::Ifc2x3::IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency, ::Ifc2x3::IfcColourOrFactor* v3_DiffuseColour, ::Ifc2x3::IfcColourOrFactor* v4_TransmissionColour, ::Ifc2x3::IfcColourOrFactor* v5_DiffuseTransmissionColour, ::Ifc2x3::IfcColourOrFactor* v6_ReflectionColour, ::Ifc2x3::IfcColourOrFactor* v7_SpecularColour, ::Ifc2x3::IfcSpecularHighlightSelect* v8_SpecularHighlight, ::Ifc2x3::IfcReflectanceMethodEnum::Value v9_ReflectanceMethod) : IfcSurfaceStyleShading((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyleRendering_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));data_->setArgument(0,attr);} if (v2_Transparency) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Transparency));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_DiffuseColour));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TransmissionColour));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_DiffuseTransmissionColour));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ReflectionColour));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_SpecularColour));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_SpecularHighlight));data_->setArgument(7,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ReflectanceMethod,::Ifc2x3::IfcReflectanceMethodEnum::ToString(v9_ReflectanceMethod))));data_->setArgument(8,attr);} }

// Function implementations for IfcSurfaceStyleShading
::Ifc2x3::IfcColourRgb* Ifc2x3::IfcSurfaceStyleShading::SurfaceColour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcColourRgb>(true); }
void Ifc2x3::IfcSurfaceStyleShading::setSurfaceColour(::Ifc2x3::IfcColourRgb* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyleShading::declaration() const { return *IFC2X3_IfcSurfaceStyleShading_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyleShading::Class() { return *IFC2X3_IfcSurfaceStyleShading_type; }
Ifc2x3::IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyleShading_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyleShading::IfcSurfaceStyleShading(::Ifc2x3::IfcColourRgb* v1_SurfaceColour) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyleShading_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SurfaceColour));data_->setArgument(0,attr);} }

// Function implementations for IfcSurfaceStyleWithTextures
aggregate_of< ::Ifc2x3::IfcSurfaceTexture >::ptr Ifc2x3::IfcSurfaceStyleWithTextures::Textures() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcSurfaceTexture >(); }
void Ifc2x3::IfcSurfaceStyleWithTextures::setTextures(aggregate_of< ::Ifc2x3::IfcSurfaceTexture >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceStyleWithTextures::declaration() const { return *IFC2X3_IfcSurfaceStyleWithTextures_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceStyleWithTextures::Class() { return *IFC2X3_IfcSurfaceStyleWithTextures_type; }
Ifc2x3::IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceStyleWithTextures_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(aggregate_of< ::Ifc2x3::IfcSurfaceTexture >::ptr v1_Textures) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceStyleWithTextures_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Textures)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcSurfaceTexture
bool Ifc2x3::IfcSurfaceTexture::RepeatS() const {  bool v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcSurfaceTexture::setRepeatS(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool Ifc2x3::IfcSurfaceTexture::RepeatT() const {  bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSurfaceTexture::setRepeatT(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcSurfaceTextureEnum::Value Ifc2x3::IfcSurfaceTexture::TextureType() const {  return ::Ifc2x3::IfcSurfaceTextureEnum::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcSurfaceTexture::setTextureType(::Ifc2x3::IfcSurfaceTextureEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSurfaceTextureEnum::ToString(v)));data_->setArgument(2,attr);} }
::Ifc2x3::IfcCartesianTransformationOperator2D* Ifc2x3::IfcSurfaceTexture::TextureTransform() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcCartesianTransformationOperator2D>(true); }
void Ifc2x3::IfcSurfaceTexture::setTextureTransform(::Ifc2x3::IfcCartesianTransformationOperator2D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcSurfaceTexture::declaration() const { return *IFC2X3_IfcSurfaceTexture_type; }
const IfcParse::entity& Ifc2x3::IfcSurfaceTexture::Class() { return *IFC2X3_IfcSurfaceTexture_type; }
Ifc2x3::IfcSurfaceTexture::IfcSurfaceTexture(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcSurfaceTexture_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSurfaceTexture::IfcSurfaceTexture(bool v1_RepeatS, bool v2_RepeatT, ::Ifc2x3::IfcSurfaceTextureEnum::Value v3_TextureType, ::Ifc2x3::IfcCartesianTransformationOperator2D* v4_TextureTransform) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcSurfaceTexture_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatS));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_RepeatT));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_TextureType,::Ifc2x3::IfcSurfaceTextureEnum::ToString(v3_TextureType))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextureTransform));data_->setArgument(3,attr);} }

// Function implementations for IfcSweptAreaSolid
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcSweptAreaSolid::SweptArea() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcSweptAreaSolid::setSweptArea(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcSweptAreaSolid::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcSweptAreaSolid::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcSweptAreaSolid::declaration() const { return *IFC2X3_IfcSweptAreaSolid_type; }
const IfcParse::entity& Ifc2x3::IfcSweptAreaSolid::Class() { return *IFC2X3_IfcSweptAreaSolid_type; }
Ifc2x3::IfcSweptAreaSolid::IfcSweptAreaSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSweptAreaSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSweptAreaSolid::IfcSweptAreaSolid(::Ifc2x3::IfcProfileDef* v1_SweptArea, ::Ifc2x3::IfcAxis2Placement3D* v2_Position) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSweptAreaSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptArea));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);} }

// Function implementations for IfcSweptDiskSolid
::Ifc2x3::IfcCurve* Ifc2x3::IfcSweptDiskSolid::Directrix() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcSweptDiskSolid::setDirectrix(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcSweptDiskSolid::Radius() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcSweptDiskSolid::setRadius(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcSweptDiskSolid::InnerRadius() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcSweptDiskSolid::setInnerRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
double Ifc2x3::IfcSweptDiskSolid::StartParam() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcSweptDiskSolid::setStartParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcSweptDiskSolid::EndParam() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcSweptDiskSolid::setEndParam(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcSweptDiskSolid::declaration() const { return *IFC2X3_IfcSweptDiskSolid_type; }
const IfcParse::entity& Ifc2x3::IfcSweptDiskSolid::Class() { return *IFC2X3_IfcSweptDiskSolid_type; }
Ifc2x3::IfcSweptDiskSolid::IfcSweptDiskSolid(IfcEntityInstanceData* e) : IfcSolidModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSweptDiskSolid_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSweptDiskSolid::IfcSweptDiskSolid(::Ifc2x3::IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, double v4_StartParam, double v5_EndParam) : IfcSolidModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSweptDiskSolid_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Directrix));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Radius));data_->setArgument(1,attr);} if (v3_InnerRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_InnerRadius));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_StartParam));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_EndParam));data_->setArgument(4,attr);} }

// Function implementations for IfcSweptSurface
::Ifc2x3::IfcProfileDef* Ifc2x3::IfcSweptSurface::SweptCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcProfileDef>(true); }
void Ifc2x3::IfcSweptSurface::setSweptCurve(::Ifc2x3::IfcProfileDef* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcAxis2Placement3D* Ifc2x3::IfcSweptSurface::Position() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcAxis2Placement3D>(true); }
void Ifc2x3::IfcSweptSurface::setPosition(::Ifc2x3::IfcAxis2Placement3D* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcSweptSurface::declaration() const { return *IFC2X3_IfcSweptSurface_type; }
const IfcParse::entity& Ifc2x3::IfcSweptSurface::Class() { return *IFC2X3_IfcSweptSurface_type; }
Ifc2x3::IfcSweptSurface::IfcSweptSurface(IfcEntityInstanceData* e) : IfcSurface((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSweptSurface_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSweptSurface::IfcSweptSurface(::Ifc2x3::IfcProfileDef* v1_SweptCurve, ::Ifc2x3::IfcAxis2Placement3D* v2_Position) : IfcSurface((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSweptSurface_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_SweptCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Position));data_->setArgument(1,attr);} }

// Function implementations for IfcSwitchingDeviceType
::Ifc2x3::IfcSwitchingDeviceTypeEnum::Value Ifc2x3::IfcSwitchingDeviceType::PredefinedType() const {  return ::Ifc2x3::IfcSwitchingDeviceTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcSwitchingDeviceType::setPredefinedType(::Ifc2x3::IfcSwitchingDeviceTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcSwitchingDeviceTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcSwitchingDeviceType::declaration() const { return *IFC2X3_IfcSwitchingDeviceType_type; }
const IfcParse::entity& Ifc2x3::IfcSwitchingDeviceType::Class() { return *IFC2X3_IfcSwitchingDeviceType_type; }
Ifc2x3::IfcSwitchingDeviceType::IfcSwitchingDeviceType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSwitchingDeviceType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSwitchingDeviceType::IfcSwitchingDeviceType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcSwitchingDeviceTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSwitchingDeviceType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcSwitchingDeviceTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcSymbolStyle
::Ifc2x3::IfcSymbolStyleSelect* Ifc2x3::IfcSymbolStyle::StyleOfSymbol() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcSymbolStyleSelect>(true); }
void Ifc2x3::IfcSymbolStyle::setStyleOfSymbol(::Ifc2x3::IfcSymbolStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcSymbolStyle::declaration() const { return *IFC2X3_IfcSymbolStyle_type; }
const IfcParse::entity& Ifc2x3::IfcSymbolStyle::Class() { return *IFC2X3_IfcSymbolStyle_type; }
Ifc2x3::IfcSymbolStyle::IfcSymbolStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSymbolStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSymbolStyle::IfcSymbolStyle(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcSymbolStyleSelect* v2_StyleOfSymbol) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSymbolStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_StyleOfSymbol));data_->setArgument(1,attr);} }

// Function implementations for IfcSystem

::Ifc2x3::IfcRelServicesBuildings::list::ptr Ifc2x3::IfcSystem::ServicesBuildings() const { return data_->getInverse(IFC2X3_IfcRelServicesBuildings_type, 4)->as<IfcRelServicesBuildings>(); }

const IfcParse::entity& Ifc2x3::IfcSystem::declaration() const { return *IFC2X3_IfcSystem_type; }
const IfcParse::entity& Ifc2x3::IfcSystem::Class() { return *IFC2X3_IfcSystem_type; }
Ifc2x3::IfcSystem::IfcSystem(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSystem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSystem::IfcSystem(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSystem_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcSystemFurnitureElementType


const IfcParse::entity& Ifc2x3::IfcSystemFurnitureElementType::declaration() const { return *IFC2X3_IfcSystemFurnitureElementType_type; }
const IfcParse::entity& Ifc2x3::IfcSystemFurnitureElementType::Class() { return *IFC2X3_IfcSystemFurnitureElementType_type; }
Ifc2x3::IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(IfcEntityInstanceData* e) : IfcFurnishingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcSystemFurnitureElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType) : IfcFurnishingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcSystemFurnitureElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTShapeProfileDef
double Ifc2x3::IfcTShapeProfileDef::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcTShapeProfileDef::FlangeWidth() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcTShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcTShapeProfileDef::FlangeThickness() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcTShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::FilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcTShapeProfileDef::setFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::FlangeEdgeRadius() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcTShapeProfileDef::setFlangeEdgeRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::WebEdgeRadius() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcTShapeProfileDef::setWebEdgeRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::WebSlope() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcTShapeProfileDef::setWebSlope(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::FlangeSlope() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcTShapeProfileDef::setFlangeSlope(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcTShapeProfileDef::CentreOfGravityInY() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcTShapeProfileDef::setCentreOfGravityInY(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcTShapeProfileDef::declaration() const { return *IFC2X3_IfcTShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcTShapeProfileDef::Class() { return *IFC2X3_IfcTShapeProfileDef_type; }
Ifc2x3::IfcTShapeProfileDef::IfcTShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTShapeProfileDef::IfcTShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_WebEdgeRadius, boost::optional< double > v11_WebSlope, boost::optional< double > v12_FlangeSlope, boost::optional< double > v13_CentreOfGravityInY) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FlangeEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FlangeEdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_WebEdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_WebEdgeRadius));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_WebSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_WebSlope));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_FlangeSlope));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); } if (v13_CentreOfGravityInY) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_CentreOfGravityInY));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } }

// Function implementations for IfcTable
std::string Ifc2x3::IfcTable::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTable::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcTableRow >::ptr Ifc2x3::IfcTable::Rows() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcTableRow >(); }
void Ifc2x3::IfcTable::setRows(aggregate_of< ::Ifc2x3::IfcTableRow >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcTable::declaration() const { return *IFC2X3_IfcTable_type; }
const IfcParse::entity& Ifc2x3::IfcTable::Class() { return *IFC2X3_IfcTable_type; }
Ifc2x3::IfcTable::IfcTable(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTable_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTable::IfcTable(std::string v1_Name, aggregate_of< ::Ifc2x3::IfcTableRow >::ptr v2_Rows) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTable_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Rows)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcTableRow
aggregate_of_instance::ptr Ifc2x3::IfcTableRow::RowCells() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTableRow::setRowCells(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
bool Ifc2x3::IfcTableRow::IsHeading() const {  bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTableRow::setIsHeading(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }

::Ifc2x3::IfcTable::list::ptr Ifc2x3::IfcTableRow::OfTable() const { return data_->getInverse(IFC2X3_IfcTable_type, 1)->as<IfcTable>(); }

const IfcParse::entity& Ifc2x3::IfcTableRow::declaration() const { return *IFC2X3_IfcTableRow_type; }
const IfcParse::entity& Ifc2x3::IfcTableRow::Class() { return *IFC2X3_IfcTableRow_type; }
Ifc2x3::IfcTableRow::IfcTableRow(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTableRow_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTableRow::IfcTableRow(aggregate_of_instance::ptr v1_RowCells, bool v2_IsHeading) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTableRow_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RowCells));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_IsHeading));data_->setArgument(1,attr);} }

// Function implementations for IfcTankType
::Ifc2x3::IfcTankTypeEnum::Value Ifc2x3::IfcTankType::PredefinedType() const {  return ::Ifc2x3::IfcTankTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcTankType::setPredefinedType(::Ifc2x3::IfcTankTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTankTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcTankType::declaration() const { return *IFC2X3_IfcTankType_type; }
const IfcParse::entity& Ifc2x3::IfcTankType::Class() { return *IFC2X3_IfcTankType_type; }
Ifc2x3::IfcTankType::IfcTankType(IfcEntityInstanceData* e) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTankType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTankType::IfcTankType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcTankTypeEnum::Value v10_PredefinedType) : IfcFlowStorageDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTankType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcTankTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTask
std::string Ifc2x3::IfcTask::TaskId() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTask::setTaskId(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcTask::Status() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcTask::setStatus(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcTask::WorkMethod() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcTask::setWorkMethod(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
bool Ifc2x3::IfcTask::IsMilestone() const {  bool v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcTask::setIsMilestone(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }
boost::optional< int > Ifc2x3::IfcTask::Priority() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } int v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcTask::setPriority(boost::optional< int > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcTask::declaration() const { return *IFC2X3_IfcTask_type; }
const IfcParse::entity& Ifc2x3::IfcTask::Class() { return *IFC2X3_IfcTask_type; }
Ifc2x3::IfcTask::IfcTask(IfcEntityInstanceData* e) : IfcProcess((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTask_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTask::IfcTask(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority) : IfcProcess((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTask_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_TaskId));data_->setArgument(5,attr);} if (v7_Status) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_Status));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WorkMethod) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WorkMethod));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_IsMilestone));data_->setArgument(8,attr);} if (v10_Priority) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Priority));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcTelecomAddress
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcTelecomAddress::TelephoneNumbers() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTelecomAddress::setTelephoneNumbers(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcTelecomAddress::FacsimileNumbers() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTelecomAddress::setFacsimileNumbers(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcTelecomAddress::PagerNumber() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTelecomAddress::setPagerNumber(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcTelecomAddress::ElectronicMailAddresses() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcTelecomAddress::setElectronicMailAddresses(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcTelecomAddress::WWWHomePageURL() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcTelecomAddress::setWWWHomePageURL(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcTelecomAddress::declaration() const { return *IFC2X3_IfcTelecomAddress_type; }
const IfcParse::entity& Ifc2x3::IfcTelecomAddress::Class() { return *IFC2X3_IfcTelecomAddress_type; }
Ifc2x3::IfcTelecomAddress::IfcTelecomAddress(IfcEntityInstanceData* e) : IfcAddress((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTelecomAddress_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTelecomAddress::IfcTelecomAddress(boost::optional< ::Ifc2x3::IfcAddressTypeEnum::Value > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< std::string > v6_PagerNumber, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< std::string > v8_WWWHomePageURL) : IfcAddress((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTelecomAddress_type);  if (v1_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v1_Purpose,::Ifc2x3::IfcAddressTypeEnum::ToString(*v1_Purpose))));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_UserDefinedPurpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_UserDefinedPurpose));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_TelephoneNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_TelephoneNumbers));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_FacsimileNumbers) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FacsimileNumbers));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_PagerNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_PagerNumber));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_ElectronicMailAddresses) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_ElectronicMailAddresses));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_WWWHomePageURL) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_WWWHomePageURL));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcTendon
::Ifc2x3::IfcTendonTypeEnum::Value Ifc2x3::IfcTendon::PredefinedType() const {  return ::Ifc2x3::IfcTendonTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcTendon::setPredefinedType(::Ifc2x3::IfcTendonTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTendonTypeEnum::ToString(v)));data_->setArgument(9,attr);} }
double Ifc2x3::IfcTendon::NominalDiameter() const {  double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcTendon::setNominalDiameter(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
double Ifc2x3::IfcTendon::CrossSectionArea() const {  double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcTendon::setCrossSectionArea(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
boost::optional< double > Ifc2x3::IfcTendon::TensionForce() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return boost::none; } double v = *data_->getArgument(12); return v; }
void Ifc2x3::IfcTendon::setTensionForce(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(12,attr);} }
boost::optional< double > Ifc2x3::IfcTendon::PreStress() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } double v = *data_->getArgument(13); return v; }
void Ifc2x3::IfcTendon::setPreStress(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(13,attr);} }
boost::optional< double > Ifc2x3::IfcTendon::FrictionCoefficient() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return boost::none; } double v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcTendon::setFrictionCoefficient(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(14,attr);} }
boost::optional< double > Ifc2x3::IfcTendon::AnchorageSlip() const { if(!data_->getArgument(15) || data_->getArgument(15)->isNull()) { return boost::none; } double v = *data_->getArgument(15); return v; }
void Ifc2x3::IfcTendon::setAnchorageSlip(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(15,attr);} }
boost::optional< double > Ifc2x3::IfcTendon::MinCurvatureRadius() const { if(!data_->getArgument(16) || data_->getArgument(16)->isNull()) { return boost::none; } double v = *data_->getArgument(16); return v; }
void Ifc2x3::IfcTendon::setMinCurvatureRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(16,attr);} }


const IfcParse::entity& Ifc2x3::IfcTendon::declaration() const { return *IFC2X3_IfcTendon_type; }
const IfcParse::entity& Ifc2x3::IfcTendon::Class() { return *IFC2X3_IfcTendon_type; }
Ifc2x3::IfcTendon::IfcTendon(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTendon_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTendon::IfcTendon(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, ::Ifc2x3::IfcTendonTypeEnum::Value v10_PredefinedType, double v11_NominalDiameter, double v12_CrossSectionArea, boost::optional< double > v13_TensionForce, boost::optional< double > v14_PreStress, boost::optional< double > v15_FrictionCoefficient, boost::optional< double > v16_AnchorageSlip, boost::optional< double > v17_MinCurvatureRadius) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTendon_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcTendonTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_NominalDiameter));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_CrossSectionArea));data_->setArgument(11,attr);} if (v13_TensionForce) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v13_TensionForce));data_->setArgument(12,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(12, attr); } if (v14_PreStress) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v14_PreStress));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_FrictionCoefficient) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_FrictionCoefficient));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } if (v16_AnchorageSlip) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v16_AnchorageSlip));data_->setArgument(15,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(15, attr); } if (v17_MinCurvatureRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v17_MinCurvatureRadius));data_->setArgument(16,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(16, attr); } }

// Function implementations for IfcTendonAnchor


const IfcParse::entity& Ifc2x3::IfcTendonAnchor::declaration() const { return *IFC2X3_IfcTendonAnchor_type; }
const IfcParse::entity& Ifc2x3::IfcTendonAnchor::Class() { return *IFC2X3_IfcTendonAnchor_type; }
Ifc2x3::IfcTendonAnchor::IfcTendonAnchor(IfcEntityInstanceData* e) : IfcReinforcingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTendonAnchor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTendonAnchor::IfcTendonAnchor(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade) : IfcReinforcingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTendonAnchor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_SteelGrade) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_SteelGrade));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcTerminatorSymbol
::Ifc2x3::IfcAnnotationCurveOccurrence* Ifc2x3::IfcTerminatorSymbol::AnnotatedCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcAnnotationCurveOccurrence>(true); }
void Ifc2x3::IfcTerminatorSymbol::setAnnotatedCurve(::Ifc2x3::IfcAnnotationCurveOccurrence* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcTerminatorSymbol::declaration() const { return *IFC2X3_IfcTerminatorSymbol_type; }
const IfcParse::entity& Ifc2x3::IfcTerminatorSymbol::Class() { return *IFC2X3_IfcTerminatorSymbol_type; }
Ifc2x3::IfcTerminatorSymbol::IfcTerminatorSymbol(IfcEntityInstanceData* e) : IfcAnnotationSymbolOccurrence((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTerminatorSymbol_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTerminatorSymbol::IfcTerminatorSymbol(::Ifc2x3::IfcRepresentationItem* v1_Item, aggregate_of< ::Ifc2x3::IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, ::Ifc2x3::IfcAnnotationCurveOccurrence* v4_AnnotatedCurve) : IfcAnnotationSymbolOccurrence((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTerminatorSymbol_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Item));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Styles)->generalize());data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_AnnotatedCurve));data_->setArgument(3,attr);} }

// Function implementations for IfcTextLiteral
std::string Ifc2x3::IfcTextLiteral::Literal() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTextLiteral::setLiteral(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcAxis2Placement* Ifc2x3::IfcTextLiteral::Placement() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcAxis2Placement>(true); }
void Ifc2x3::IfcTextLiteral::setPlacement(::Ifc2x3::IfcAxis2Placement* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcTextPath::Value Ifc2x3::IfcTextLiteral::Path() const {  return ::Ifc2x3::IfcTextPath::FromString(*data_->getArgument(2)); }
void Ifc2x3::IfcTextLiteral::setPath(::Ifc2x3::IfcTextPath::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTextPath::ToString(v)));data_->setArgument(2,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextLiteral::declaration() const { return *IFC2X3_IfcTextLiteral_type; }
const IfcParse::entity& Ifc2x3::IfcTextLiteral::Class() { return *IFC2X3_IfcTextLiteral_type; }
Ifc2x3::IfcTextLiteral::IfcTextLiteral(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextLiteral_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextLiteral::IfcTextLiteral(std::string v1_Literal, ::Ifc2x3::IfcAxis2Placement* v2_Placement, ::Ifc2x3::IfcTextPath::Value v3_Path) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextLiteral_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,::Ifc2x3::IfcTextPath::ToString(v3_Path))));data_->setArgument(2,attr);} }

// Function implementations for IfcTextLiteralWithExtent
::Ifc2x3::IfcPlanarExtent* Ifc2x3::IfcTextLiteralWithExtent::Extent() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcPlanarExtent>(true); }
void Ifc2x3::IfcTextLiteralWithExtent::setExtent(::Ifc2x3::IfcPlanarExtent* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
std::string Ifc2x3::IfcTextLiteralWithExtent::BoxAlignment() const {  std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTextLiteralWithExtent::setBoxAlignment(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextLiteralWithExtent::declaration() const { return *IFC2X3_IfcTextLiteralWithExtent_type; }
const IfcParse::entity& Ifc2x3::IfcTextLiteralWithExtent::Class() { return *IFC2X3_IfcTextLiteralWithExtent_type; }
Ifc2x3::IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(IfcEntityInstanceData* e) : IfcTextLiteral((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextLiteralWithExtent_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(std::string v1_Literal, ::Ifc2x3::IfcAxis2Placement* v2_Placement, ::Ifc2x3::IfcTextPath::Value v3_Path, ::Ifc2x3::IfcPlanarExtent* v4_Extent, std::string v5_BoxAlignment) : IfcTextLiteral((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextLiteralWithExtent_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Literal));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Placement));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v3_Path,::Ifc2x3::IfcTextPath::ToString(v3_Path))));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Extent));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_BoxAlignment));data_->setArgument(4,attr);} }

// Function implementations for IfcTextStyle
::Ifc2x3::IfcCharacterStyleSelect* Ifc2x3::IfcTextStyle::TextCharacterAppearance() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcCharacterStyleSelect>(true); }
void Ifc2x3::IfcTextStyle::setTextCharacterAppearance(::Ifc2x3::IfcCharacterStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
::Ifc2x3::IfcTextStyleSelect* Ifc2x3::IfcTextStyle::TextStyle() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcTextStyleSelect>(true); }
void Ifc2x3::IfcTextStyle::setTextStyle(::Ifc2x3::IfcTextStyleSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcTextFontSelect* Ifc2x3::IfcTextStyle::TextFontStyle() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcTextFontSelect>(true); }
void Ifc2x3::IfcTextStyle::setTextFontStyle(::Ifc2x3::IfcTextFontSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextStyle::declaration() const { return *IFC2X3_IfcTextStyle_type; }
const IfcParse::entity& Ifc2x3::IfcTextStyle::Class() { return *IFC2X3_IfcTextStyle_type; }
Ifc2x3::IfcTextStyle::IfcTextStyle(IfcEntityInstanceData* e) : IfcPresentationStyle((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextStyle::IfcTextStyle(boost::optional< std::string > v1_Name, ::Ifc2x3::IfcCharacterStyleSelect* v2_TextCharacterAppearance, ::Ifc2x3::IfcTextStyleSelect* v3_TextStyle, ::Ifc2x3::IfcTextFontSelect* v4_TextFontStyle) : IfcPresentationStyle((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextStyle_type);  if (v1_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_Name));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TextCharacterAppearance));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_TextStyle));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_TextFontStyle));data_->setArgument(3,attr);} }

// Function implementations for IfcTextStyleFontModel
boost::optional< std::vector< std::string > /*[1:?]*/ > Ifc2x3::IfcTextStyleFontModel::FontFamily() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::vector< std::string > /*[1:?]*/ v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTextStyleFontModel::setFontFamily(boost::optional< std::vector< std::string > /*[1:?]*/ > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleFontModel::FontStyle() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcTextStyleFontModel::setFontStyle(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleFontModel::FontVariant() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } std::string v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTextStyleFontModel::setFontVariant(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleFontModel::FontWeight() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTextStyleFontModel::setFontWeight(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleFontModel::FontSize() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(5)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleFontModel::setFontSize(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextStyleFontModel::declaration() const { return *IFC2X3_IfcTextStyleFontModel_type; }
const IfcParse::entity& Ifc2x3::IfcTextStyleFontModel::Class() { return *IFC2X3_IfcTextStyleFontModel_type; }
Ifc2x3::IfcTextStyleFontModel::IfcTextStyleFontModel(IfcEntityInstanceData* e) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextStyleFontModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextStyleFontModel::IfcTextStyleFontModel(std::string v1_Name, boost::optional< std::vector< std::string > /*[1:?]*/ > v2_FontFamily, boost::optional< std::string > v3_FontStyle, boost::optional< std::string > v4_FontVariant, boost::optional< std::string > v5_FontWeight, ::Ifc2x3::IfcSizeSelect* v6_FontSize) : IfcPreDefinedTextFont((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextStyleFontModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_FontFamily) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_FontFamily));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_FontStyle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_FontStyle));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_FontVariant) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_FontVariant));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_FontWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_FontWeight));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_FontSize));data_->setArgument(5,attr);} }

// Function implementations for IfcTextStyleForDefinedFont
::Ifc2x3::IfcColour* Ifc2x3::IfcTextStyleForDefinedFont::Colour() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcColour>(true); }
void Ifc2x3::IfcTextStyleForDefinedFont::setColour(::Ifc2x3::IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
::Ifc2x3::IfcColour* Ifc2x3::IfcTextStyleForDefinedFont::BackgroundColour() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcColour>(true); }
void Ifc2x3::IfcTextStyleForDefinedFont::setBackgroundColour(::Ifc2x3::IfcColour* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextStyleForDefinedFont::declaration() const { return *IFC2X3_IfcTextStyleForDefinedFont_type; }
const IfcParse::entity& Ifc2x3::IfcTextStyleForDefinedFont::Class() { return *IFC2X3_IfcTextStyleForDefinedFont_type; }
Ifc2x3::IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTextStyleForDefinedFont_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(::Ifc2x3::IfcColour* v1_Colour, ::Ifc2x3::IfcColour* v2_BackgroundColour) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextStyleForDefinedFont_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Colour));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_BackgroundColour));data_->setArgument(1,attr);} }

// Function implementations for IfcTextStyleTextModel
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleTextModel::TextIndent() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleTextModel::setTextIndent(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleTextModel::TextAlign() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTextStyleTextModel::setTextAlign(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleTextModel::TextDecoration() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } std::string v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcTextStyleTextModel::setTextDecoration(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleTextModel::LetterSpacing() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleTextModel::setLetterSpacing(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleTextModel::WordSpacing() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleTextModel::setWordSpacing(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
boost::optional< std::string > Ifc2x3::IfcTextStyleTextModel::TextTransform() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTextStyleTextModel::setTextTransform(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleTextModel::LineHeight() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleTextModel::setLineHeight(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextStyleTextModel::declaration() const { return *IFC2X3_IfcTextStyleTextModel_type; }
const IfcParse::entity& Ifc2x3::IfcTextStyleTextModel::Class() { return *IFC2X3_IfcTextStyleTextModel_type; }
Ifc2x3::IfcTextStyleTextModel::IfcTextStyleTextModel(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTextStyleTextModel_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextStyleTextModel::IfcTextStyleTextModel(::Ifc2x3::IfcSizeSelect* v1_TextIndent, boost::optional< std::string > v2_TextAlign, boost::optional< std::string > v3_TextDecoration, ::Ifc2x3::IfcSizeSelect* v4_LetterSpacing, ::Ifc2x3::IfcSizeSelect* v5_WordSpacing, boost::optional< std::string > v6_TextTransform, ::Ifc2x3::IfcSizeSelect* v7_LineHeight) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextStyleTextModel_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextIndent));data_->setArgument(0,attr);} if (v2_TextAlign) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_TextAlign));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_TextDecoration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_TextDecoration));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_LetterSpacing));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_WordSpacing));data_->setArgument(4,attr);} if (v6_TextTransform) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_TextTransform));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_LineHeight));data_->setArgument(6,attr);} }

// Function implementations for IfcTextStyleWithBoxCharacteristics
boost::optional< double > Ifc2x3::IfcTextStyleWithBoxCharacteristics::BoxHeight() const { if(!data_->getArgument(0) || data_->getArgument(0)->isNull()) { return boost::none; } double v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTextStyleWithBoxCharacteristics::setBoxHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(0,attr);} }
boost::optional< double > Ifc2x3::IfcTextStyleWithBoxCharacteristics::BoxWidth() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTextStyleWithBoxCharacteristics::setBoxWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcTextStyleWithBoxCharacteristics::BoxSlantAngle() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcTextStyleWithBoxCharacteristics::setBoxSlantAngle(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcTextStyleWithBoxCharacteristics::BoxRotateAngle() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTextStyleWithBoxCharacteristics::setBoxRotateAngle(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
::Ifc2x3::IfcSizeSelect* Ifc2x3::IfcTextStyleWithBoxCharacteristics::CharacterSpacing() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(4)))->as<::Ifc2x3::IfcSizeSelect>(true); }
void Ifc2x3::IfcTextStyleWithBoxCharacteristics::setCharacterSpacing(::Ifc2x3::IfcSizeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextStyleWithBoxCharacteristics::declaration() const { return *IFC2X3_IfcTextStyleWithBoxCharacteristics_type; }
const IfcParse::entity& Ifc2x3::IfcTextStyleWithBoxCharacteristics::Class() { return *IFC2X3_IfcTextStyleWithBoxCharacteristics_type; }
Ifc2x3::IfcTextStyleWithBoxCharacteristics::IfcTextStyleWithBoxCharacteristics(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTextStyleWithBoxCharacteristics_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextStyleWithBoxCharacteristics::IfcTextStyleWithBoxCharacteristics(boost::optional< double > v1_BoxHeight, boost::optional< double > v2_BoxWidth, boost::optional< double > v3_BoxSlantAngle, boost::optional< double > v4_BoxRotateAngle, ::Ifc2x3::IfcSizeSelect* v5_CharacterSpacing) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextStyleWithBoxCharacteristics_type);  if (v1_BoxHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v1_BoxHeight));data_->setArgument(0,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(0, attr); } if (v2_BoxWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_BoxWidth));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_BoxSlantAngle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_BoxSlantAngle));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_BoxRotateAngle) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_BoxRotateAngle));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_CharacterSpacing));data_->setArgument(4,attr);} }

// Function implementations for IfcTextureCoordinate

::Ifc2x3::IfcAnnotationSurface::list::ptr Ifc2x3::IfcTextureCoordinate::AnnotatedSurface() const { return data_->getInverse(IFC2X3_IfcAnnotationSurface_type, 1)->as<IfcAnnotationSurface>(); }

const IfcParse::entity& Ifc2x3::IfcTextureCoordinate::declaration() const { return *IFC2X3_IfcTextureCoordinate_type; }
const IfcParse::entity& Ifc2x3::IfcTextureCoordinate::Class() { return *IFC2X3_IfcTextureCoordinate_type; }
Ifc2x3::IfcTextureCoordinate::IfcTextureCoordinate(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTextureCoordinate_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextureCoordinate::IfcTextureCoordinate() : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextureCoordinate_type);  }

// Function implementations for IfcTextureCoordinateGenerator
std::string Ifc2x3::IfcTextureCoordinateGenerator::Mode() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTextureCoordinateGenerator::setMode(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcTextureCoordinateGenerator::Parameter() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTextureCoordinateGenerator::setParameter(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextureCoordinateGenerator::declaration() const { return *IFC2X3_IfcTextureCoordinateGenerator_type; }
const IfcParse::entity& Ifc2x3::IfcTextureCoordinateGenerator::Class() { return *IFC2X3_IfcTextureCoordinateGenerator_type; }
Ifc2x3::IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextureCoordinateGenerator_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(std::string v1_Mode, aggregate_of_instance::ptr v2_Parameter) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextureCoordinateGenerator_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Mode));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Parameter));data_->setArgument(1,attr);} }

// Function implementations for IfcTextureMap
aggregate_of< ::Ifc2x3::IfcVertexBasedTextureMap >::ptr Ifc2x3::IfcTextureMap::TextureMaps() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcVertexBasedTextureMap >(); }
void Ifc2x3::IfcTextureMap::setTextureMaps(aggregate_of< ::Ifc2x3::IfcVertexBasedTextureMap >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextureMap::declaration() const { return *IFC2X3_IfcTextureMap_type; }
const IfcParse::entity& Ifc2x3::IfcTextureMap::Class() { return *IFC2X3_IfcTextureMap_type; }
Ifc2x3::IfcTextureMap::IfcTextureMap(IfcEntityInstanceData* e) : IfcTextureCoordinate((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTextureMap_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextureMap::IfcTextureMap(aggregate_of< ::Ifc2x3::IfcVertexBasedTextureMap >::ptr v1_TextureMaps) : IfcTextureCoordinate((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextureMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextureMaps)->generalize());data_->setArgument(0,attr);} }

// Function implementations for IfcTextureVertex
std::vector< double > /*[2:2]*/ Ifc2x3::IfcTextureVertex::Coordinates() const {  std::vector< double > /*[2:2]*/ v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTextureVertex::setCoordinates(std::vector< double > /*[2:2]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcTextureVertex::declaration() const { return *IFC2X3_IfcTextureVertex_type; }
const IfcParse::entity& Ifc2x3::IfcTextureVertex::Class() { return *IFC2X3_IfcTextureVertex_type; }
Ifc2x3::IfcTextureVertex::IfcTextureVertex(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTextureVertex_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTextureVertex::IfcTextureVertex(std::vector< double > /*[2:2]*/ v1_Coordinates) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTextureVertex_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Coordinates));data_->setArgument(0,attr);} }

// Function implementations for IfcThermalMaterialProperties
boost::optional< double > Ifc2x3::IfcThermalMaterialProperties::SpecificHeatCapacity() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcThermalMaterialProperties::setSpecificHeatCapacity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcThermalMaterialProperties::BoilingPoint() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcThermalMaterialProperties::setBoilingPoint(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcThermalMaterialProperties::FreezingPoint() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcThermalMaterialProperties::setFreezingPoint(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcThermalMaterialProperties::ThermalConductivity() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcThermalMaterialProperties::setThermalConductivity(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcThermalMaterialProperties::declaration() const { return *IFC2X3_IfcThermalMaterialProperties_type; }
const IfcParse::entity& Ifc2x3::IfcThermalMaterialProperties::Class() { return *IFC2X3_IfcThermalMaterialProperties_type; }
Ifc2x3::IfcThermalMaterialProperties::IfcThermalMaterialProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcThermalMaterialProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcThermalMaterialProperties::IfcThermalMaterialProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_BoilingPoint, boost::optional< double > v4_FreezingPoint, boost::optional< double > v5_ThermalConductivity) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcThermalMaterialProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_SpecificHeatCapacity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_SpecificHeatCapacity));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_BoilingPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_BoilingPoint));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_FreezingPoint) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_FreezingPoint));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ThermalConductivity) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ThermalConductivity));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

// Function implementations for IfcTimeSeries
std::string Ifc2x3::IfcTimeSeries::Name() const {  std::string v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTimeSeries::setName(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
boost::optional< std::string > Ifc2x3::IfcTimeSeries::Description() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } std::string v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTimeSeries::setDescription(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcTimeSeries::StartTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(2)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcTimeSeries::setStartTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcTimeSeries::EndTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(3)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcTimeSeries::setEndTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcTimeSeriesDataTypeEnum::Value Ifc2x3::IfcTimeSeries::TimeSeriesDataType() const {  return ::Ifc2x3::IfcTimeSeriesDataTypeEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcTimeSeries::setTimeSeriesDataType(::Ifc2x3::IfcTimeSeriesDataTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTimeSeriesDataTypeEnum::ToString(v)));data_->setArgument(4,attr);} }
::Ifc2x3::IfcDataOriginEnum::Value Ifc2x3::IfcTimeSeries::DataOrigin() const {  return ::Ifc2x3::IfcDataOriginEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcTimeSeries::setDataOrigin(::Ifc2x3::IfcDataOriginEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcDataOriginEnum::ToString(v)));data_->setArgument(5,attr);} }
boost::optional< std::string > Ifc2x3::IfcTimeSeries::UserDefinedDataOrigin() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } std::string v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcTimeSeries::setUserDefinedDataOrigin(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
::Ifc2x3::IfcUnit* Ifc2x3::IfcTimeSeries::Unit() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcUnit>(true); }
void Ifc2x3::IfcTimeSeries::setUnit(::Ifc2x3::IfcUnit* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }

::Ifc2x3::IfcTimeSeriesReferenceRelationship::list::ptr Ifc2x3::IfcTimeSeries::DocumentedBy() const { return data_->getInverse(IFC2X3_IfcTimeSeriesReferenceRelationship_type, 0)->as<IfcTimeSeriesReferenceRelationship>(); }

const IfcParse::entity& Ifc2x3::IfcTimeSeries::declaration() const { return *IFC2X3_IfcTimeSeries_type; }
const IfcParse::entity& Ifc2x3::IfcTimeSeries::Class() { return *IFC2X3_IfcTimeSeries_type; }
Ifc2x3::IfcTimeSeries::IfcTimeSeries(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTimeSeries_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTimeSeries::IfcTimeSeries(std::string v1_Name, boost::optional< std::string > v2_Description, ::Ifc2x3::IfcDateTimeSelect* v3_StartTime, ::Ifc2x3::IfcDateTimeSelect* v4_EndTime, ::Ifc2x3::IfcTimeSeriesDataTypeEnum::Value v5_TimeSeriesDataType, ::Ifc2x3::IfcDataOriginEnum::Value v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, ::Ifc2x3::IfcUnit* v8_Unit) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeries_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Name));data_->setArgument(0,attr);} if (v2_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_Description));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_StartTime));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_EndTime));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_TimeSeriesDataType,::Ifc2x3::IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_DataOrigin,::Ifc2x3::IfcDataOriginEnum::ToString(v6_DataOrigin))));data_->setArgument(5,attr);} if (v7_UserDefinedDataOrigin) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_UserDefinedDataOrigin));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_Unit));data_->setArgument(7,attr);} }

// Function implementations for IfcTimeSeriesReferenceRelationship
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcTimeSeriesReferenceRelationship::ReferencedTimeSeries() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcTimeSeriesReferenceRelationship::setReferencedTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcTimeSeriesReferenceRelationship::TimeSeriesReferences() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTimeSeriesReferenceRelationship::setTimeSeriesReferences(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcTimeSeriesReferenceRelationship::declaration() const { return *IFC2X3_IfcTimeSeriesReferenceRelationship_type; }
const IfcParse::entity& Ifc2x3::IfcTimeSeriesReferenceRelationship::Class() { return *IFC2X3_IfcTimeSeriesReferenceRelationship_type; }
Ifc2x3::IfcTimeSeriesReferenceRelationship::IfcTimeSeriesReferenceRelationship(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTimeSeriesReferenceRelationship_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTimeSeriesReferenceRelationship::IfcTimeSeriesReferenceRelationship(::Ifc2x3::IfcTimeSeries* v1_ReferencedTimeSeries, aggregate_of_instance::ptr v2_TimeSeriesReferences) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesReferenceRelationship_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ReferencedTimeSeries));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TimeSeriesReferences));data_->setArgument(1,attr);} }

// Function implementations for IfcTimeSeriesSchedule
boost::optional< aggregate_of_instance::ptr > Ifc2x3::IfcTimeSeriesSchedule::ApplicableDates() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } aggregate_of_instance::ptr v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTimeSeriesSchedule::setApplicableDates(boost::optional< aggregate_of_instance::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Value Ifc2x3::IfcTimeSeriesSchedule::TimeSeriesScheduleType() const {  return ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::FromString(*data_->getArgument(6)); }
void Ifc2x3::IfcTimeSeriesSchedule::setTimeSeriesScheduleType(::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::ToString(v)));data_->setArgument(6,attr);} }
::Ifc2x3::IfcTimeSeries* Ifc2x3::IfcTimeSeriesSchedule::TimeSeries() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(7)))->as<::Ifc2x3::IfcTimeSeries>(true); }
void Ifc2x3::IfcTimeSeriesSchedule::setTimeSeries(::Ifc2x3::IfcTimeSeries* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcTimeSeriesSchedule::declaration() const { return *IFC2X3_IfcTimeSeriesSchedule_type; }
const IfcParse::entity& Ifc2x3::IfcTimeSeriesSchedule::Class() { return *IFC2X3_IfcTimeSeriesSchedule_type; }
Ifc2x3::IfcTimeSeriesSchedule::IfcTimeSeriesSchedule(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTimeSeriesSchedule_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTimeSeriesSchedule::IfcTimeSeriesSchedule(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< aggregate_of_instance::ptr > v6_ApplicableDates, ::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::Value v7_TimeSeriesScheduleType, ::Ifc2x3::IfcTimeSeries* v8_TimeSeries) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesSchedule_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ApplicableDates) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ApplicableDates));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v7_TimeSeriesScheduleType,::Ifc2x3::IfcTimeSeriesScheduleTypeEnum::ToString(v7_TimeSeriesScheduleType))));data_->setArgument(6,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v8_TimeSeries));data_->setArgument(7,attr);} }

// Function implementations for IfcTimeSeriesValue
aggregate_of_instance::ptr Ifc2x3::IfcTimeSeriesValue::ListValues() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcTimeSeriesValue::setListValues(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcTimeSeriesValue::declaration() const { return *IFC2X3_IfcTimeSeriesValue_type; }
const IfcParse::entity& Ifc2x3::IfcTimeSeriesValue::Class() { return *IFC2X3_IfcTimeSeriesValue_type; }
Ifc2x3::IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcTimeSeriesValue_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTimeSeriesValue::IfcTimeSeriesValue(aggregate_of_instance::ptr v1_ListValues) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcTimeSeriesValue_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ListValues));data_->setArgument(0,attr);} }

// Function implementations for IfcTopologicalRepresentationItem


const IfcParse::entity& Ifc2x3::IfcTopologicalRepresentationItem::declaration() const { return *IFC2X3_IfcTopologicalRepresentationItem_type; }
const IfcParse::entity& Ifc2x3::IfcTopologicalRepresentationItem::Class() { return *IFC2X3_IfcTopologicalRepresentationItem_type; }
Ifc2x3::IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem(IfcEntityInstanceData* e) : IfcRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTopologicalRepresentationItem_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem() : IfcRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTopologicalRepresentationItem_type);  }

// Function implementations for IfcTopologyRepresentation


const IfcParse::entity& Ifc2x3::IfcTopologyRepresentation::declaration() const { return *IFC2X3_IfcTopologyRepresentation_type; }
const IfcParse::entity& Ifc2x3::IfcTopologyRepresentation::Class() { return *IFC2X3_IfcTopologyRepresentation_type; }
Ifc2x3::IfcTopologyRepresentation::IfcTopologyRepresentation(IfcEntityInstanceData* e) : IfcShapeModel((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTopologyRepresentation_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTopologyRepresentation::IfcTopologyRepresentation(::Ifc2x3::IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, aggregate_of< ::Ifc2x3::IfcRepresentationItem >::ptr v4_Items) : IfcShapeModel((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTopologyRepresentation_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_ContextOfItems));data_->setArgument(0,attr);} if (v2_RepresentationIdentifier) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_RepresentationIdentifier));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_RepresentationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_RepresentationType));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Items)->generalize());data_->setArgument(3,attr);} }

// Function implementations for IfcTransformerType
::Ifc2x3::IfcTransformerTypeEnum::Value Ifc2x3::IfcTransformerType::PredefinedType() const {  return ::Ifc2x3::IfcTransformerTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcTransformerType::setPredefinedType(::Ifc2x3::IfcTransformerTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTransformerTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcTransformerType::declaration() const { return *IFC2X3_IfcTransformerType_type; }
const IfcParse::entity& Ifc2x3::IfcTransformerType::Class() { return *IFC2X3_IfcTransformerType_type; }
Ifc2x3::IfcTransformerType::IfcTransformerType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTransformerType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTransformerType::IfcTransformerType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcTransformerTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTransformerType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcTransformerTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTransportElement
boost::optional< ::Ifc2x3::IfcTransportElementTypeEnum::Value > Ifc2x3::IfcTransportElement::OperationType() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } return ::Ifc2x3::IfcTransportElementTypeEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcTransportElement::setOperationType(boost::optional< ::Ifc2x3::IfcTransportElementTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcTransportElementTypeEnum::ToString(*v)));}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcTransportElement::CapacityByWeight() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcTransportElement::setCapacityByWeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcTransportElement::CapacityByNumber() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcTransportElement::setCapacityByNumber(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcTransportElement::declaration() const { return *IFC2X3_IfcTransportElement_type; }
const IfcParse::entity& Ifc2x3::IfcTransportElement::Class() { return *IFC2X3_IfcTransportElement_type; }
Ifc2x3::IfcTransportElement::IfcTransportElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTransportElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTransportElement::IfcTransportElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< ::Ifc2x3::IfcTransportElementTypeEnum::Value > v9_OperationType, boost::optional< double > v10_CapacityByWeight, boost::optional< double > v11_CapacityByNumber) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTransportElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OperationType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v9_OperationType,::Ifc2x3::IfcTransportElementTypeEnum::ToString(*v9_OperationType))));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_CapacityByWeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_CapacityByWeight));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_CapacityByNumber) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CapacityByNumber));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcTransportElementType
::Ifc2x3::IfcTransportElementTypeEnum::Value Ifc2x3::IfcTransportElementType::PredefinedType() const {  return ::Ifc2x3::IfcTransportElementTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcTransportElementType::setPredefinedType(::Ifc2x3::IfcTransportElementTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTransportElementTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcTransportElementType::declaration() const { return *IFC2X3_IfcTransportElementType_type; }
const IfcParse::entity& Ifc2x3::IfcTransportElementType::Class() { return *IFC2X3_IfcTransportElementType_type; }
Ifc2x3::IfcTransportElementType::IfcTransportElementType(IfcEntityInstanceData* e) : IfcElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTransportElementType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTransportElementType::IfcTransportElementType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcTransportElementTypeEnum::Value v10_PredefinedType) : IfcElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTransportElementType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcTransportElementTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTrapeziumProfileDef
double Ifc2x3::IfcTrapeziumProfileDef::BottomXDim() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTrapeziumProfileDef::setBottomXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcTrapeziumProfileDef::TopXDim() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTrapeziumProfileDef::setTopXDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcTrapeziumProfileDef::YDim() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcTrapeziumProfileDef::setYDim(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcTrapeziumProfileDef::TopXOffset() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcTrapeziumProfileDef::setTopXOffset(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }


const IfcParse::entity& Ifc2x3::IfcTrapeziumProfileDef::declaration() const { return *IFC2X3_IfcTrapeziumProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcTrapeziumProfileDef::Class() { return *IFC2X3_IfcTrapeziumProfileDef_type; }
Ifc2x3::IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTrapeziumProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_BottomXDim, double v5_TopXDim, double v6_YDim, double v7_TopXOffset) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTrapeziumProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_BottomXDim));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_TopXDim));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_YDim));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_TopXOffset));data_->setArgument(6,attr);} }

// Function implementations for IfcTrimmedCurve
::Ifc2x3::IfcCurve* Ifc2x3::IfcTrimmedCurve::BasisCurve() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcCurve>(true); }
void Ifc2x3::IfcTrimmedCurve::setBasisCurve(::Ifc2x3::IfcCurve* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcTrimmedCurve::Trim1() const {  aggregate_of_instance::ptr v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcTrimmedCurve::setTrim1(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }
aggregate_of_instance::ptr Ifc2x3::IfcTrimmedCurve::Trim2() const {  aggregate_of_instance::ptr v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcTrimmedCurve::setTrim2(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(2,attr);} }
bool Ifc2x3::IfcTrimmedCurve::SenseAgreement() const {  bool v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcTrimmedCurve::setSenseAgreement(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
::Ifc2x3::IfcTrimmingPreference::Value Ifc2x3::IfcTrimmedCurve::MasterRepresentation() const {  return ::Ifc2x3::IfcTrimmingPreference::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcTrimmedCurve::setMasterRepresentation(::Ifc2x3::IfcTrimmingPreference::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTrimmingPreference::ToString(v)));data_->setArgument(4,attr);} }


const IfcParse::entity& Ifc2x3::IfcTrimmedCurve::declaration() const { return *IFC2X3_IfcTrimmedCurve_type; }
const IfcParse::entity& Ifc2x3::IfcTrimmedCurve::Class() { return *IFC2X3_IfcTrimmedCurve_type; }
Ifc2x3::IfcTrimmedCurve::IfcTrimmedCurve(IfcEntityInstanceData* e) : IfcBoundedCurve((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTrimmedCurve_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTrimmedCurve::IfcTrimmedCurve(::Ifc2x3::IfcCurve* v1_BasisCurve, aggregate_of_instance::ptr v2_Trim1, aggregate_of_instance::ptr v3_Trim2, bool v4_SenseAgreement, ::Ifc2x3::IfcTrimmingPreference::Value v5_MasterRepresentation) : IfcBoundedCurve((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTrimmedCurve_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_BasisCurve));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Trim1));data_->setArgument(1,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Trim2));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_SenseAgreement));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_MasterRepresentation,::Ifc2x3::IfcTrimmingPreference::ToString(v5_MasterRepresentation))));data_->setArgument(4,attr);} }

// Function implementations for IfcTubeBundleType
::Ifc2x3::IfcTubeBundleTypeEnum::Value Ifc2x3::IfcTubeBundleType::PredefinedType() const {  return ::Ifc2x3::IfcTubeBundleTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcTubeBundleType::setPredefinedType(::Ifc2x3::IfcTubeBundleTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcTubeBundleTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcTubeBundleType::declaration() const { return *IFC2X3_IfcTubeBundleType_type; }
const IfcParse::entity& Ifc2x3::IfcTubeBundleType::Class() { return *IFC2X3_IfcTubeBundleType_type; }
Ifc2x3::IfcTubeBundleType::IfcTubeBundleType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTubeBundleType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTubeBundleType::IfcTubeBundleType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcTubeBundleTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTubeBundleType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcTubeBundleTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcTwoDirectionRepeatFactor
::Ifc2x3::IfcVector* Ifc2x3::IfcTwoDirectionRepeatFactor::SecondRepeatFactor() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(1)))->as<::Ifc2x3::IfcVector>(true); }
void Ifc2x3::IfcTwoDirectionRepeatFactor::setSecondRepeatFactor(::Ifc2x3::IfcVector* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcTwoDirectionRepeatFactor::declaration() const { return *IFC2X3_IfcTwoDirectionRepeatFactor_type; }
const IfcParse::entity& Ifc2x3::IfcTwoDirectionRepeatFactor::Class() { return *IFC2X3_IfcTwoDirectionRepeatFactor_type; }
Ifc2x3::IfcTwoDirectionRepeatFactor::IfcTwoDirectionRepeatFactor(IfcEntityInstanceData* e) : IfcOneDirectionRepeatFactor((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTwoDirectionRepeatFactor_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTwoDirectionRepeatFactor::IfcTwoDirectionRepeatFactor(::Ifc2x3::IfcVector* v1_RepeatFactor, ::Ifc2x3::IfcVector* v2_SecondRepeatFactor) : IfcOneDirectionRepeatFactor((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTwoDirectionRepeatFactor_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_RepeatFactor));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_SecondRepeatFactor));data_->setArgument(1,attr);} }

// Function implementations for IfcTypeObject
boost::optional< std::string > Ifc2x3::IfcTypeObject::ApplicableOccurrence() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } std::string v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcTypeObject::setApplicableOccurrence(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > Ifc2x3::IfcTypeObject::HasPropertySets() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(5); return es->as< ::Ifc2x3::IfcPropertySetDefinition >(); }
void Ifc2x3::IfcTypeObject::setHasPropertySets(boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(5,attr);} }

::Ifc2x3::IfcRelDefinesByType::list::ptr Ifc2x3::IfcTypeObject::ObjectTypeOf() const { return data_->getInverse(IFC2X3_IfcRelDefinesByType_type, 5)->as<IfcRelDefinesByType>(); }

const IfcParse::entity& Ifc2x3::IfcTypeObject::declaration() const { return *IFC2X3_IfcTypeObject_type; }
const IfcParse::entity& Ifc2x3::IfcTypeObject::Class() { return *IFC2X3_IfcTypeObject_type; }
Ifc2x3::IfcTypeObject::IfcTypeObject(IfcEntityInstanceData* e) : IfcObjectDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTypeObject_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTypeObject::IfcTypeObject(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets) : IfcObjectDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTypeObject_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } }

// Function implementations for IfcTypeProduct
boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > Ifc2x3::IfcTypeProduct::RepresentationMaps() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(6); return es->as< ::Ifc2x3::IfcRepresentationMap >(); }
void Ifc2x3::IfcTypeProduct::setRepresentationMaps(boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(6,attr);} }
boost::optional< std::string > Ifc2x3::IfcTypeProduct::Tag() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } std::string v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcTypeProduct::setTag(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcTypeProduct::declaration() const { return *IFC2X3_IfcTypeProduct_type; }
const IfcParse::entity& Ifc2x3::IfcTypeProduct::Class() { return *IFC2X3_IfcTypeProduct_type; }
Ifc2x3::IfcTypeProduct::IfcTypeProduct(IfcEntityInstanceData* e) : IfcTypeObject((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcTypeProduct_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcTypeProduct::IfcTypeProduct(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag) : IfcTypeObject((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcTypeProduct_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcUShapeProfileDef
double Ifc2x3::IfcUShapeProfileDef::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcUShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcUShapeProfileDef::FlangeWidth() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcUShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcUShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcUShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcUShapeProfileDef::FlangeThickness() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcUShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcUShapeProfileDef::FilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcUShapeProfileDef::setFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcUShapeProfileDef::EdgeRadius() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcUShapeProfileDef::setEdgeRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcUShapeProfileDef::FlangeSlope() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcUShapeProfileDef::setFlangeSlope(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcUShapeProfileDef::CentreOfGravityInX() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcUShapeProfileDef::setCentreOfGravityInX(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }


const IfcParse::entity& Ifc2x3::IfcUShapeProfileDef::declaration() const { return *IFC2X3_IfcUShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcUShapeProfileDef::Class() { return *IFC2X3_IfcUShapeProfileDef_type; }
Ifc2x3::IfcUShapeProfileDef::IfcUShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcUShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcUShapeProfileDef::IfcUShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius, boost::optional< double > v10_FlangeSlope, boost::optional< double > v11_CentreOfGravityInX) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcUShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_FlangeSlope) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_FlangeSlope));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_CentreOfGravityInX) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_CentreOfGravityInX));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } }

// Function implementations for IfcUnitAssignment
aggregate_of_instance::ptr Ifc2x3::IfcUnitAssignment::Units() const {  aggregate_of_instance::ptr v = *data_->getArgument(0); return v; }
void Ifc2x3::IfcUnitAssignment::setUnits(aggregate_of_instance::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcUnitAssignment::declaration() const { return *IFC2X3_IfcUnitAssignment_type; }
const IfcParse::entity& Ifc2x3::IfcUnitAssignment::Class() { return *IFC2X3_IfcUnitAssignment_type; }
Ifc2x3::IfcUnitAssignment::IfcUnitAssignment(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcUnitAssignment_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcUnitAssignment::IfcUnitAssignment(aggregate_of_instance::ptr v1_Units) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitAssignment_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Units));data_->setArgument(0,attr);} }

// Function implementations for IfcUnitaryEquipmentType
::Ifc2x3::IfcUnitaryEquipmentTypeEnum::Value Ifc2x3::IfcUnitaryEquipmentType::PredefinedType() const {  return ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcUnitaryEquipmentType::setPredefinedType(::Ifc2x3::IfcUnitaryEquipmentTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcUnitaryEquipmentTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcUnitaryEquipmentType::declaration() const { return *IFC2X3_IfcUnitaryEquipmentType_type; }
const IfcParse::entity& Ifc2x3::IfcUnitaryEquipmentType::Class() { return *IFC2X3_IfcUnitaryEquipmentType_type; }
Ifc2x3::IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(IfcEntityInstanceData* e) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcUnitaryEquipmentType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcUnitaryEquipmentTypeEnum::Value v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcUnitaryEquipmentType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcUnitaryEquipmentTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcValveType
::Ifc2x3::IfcValveTypeEnum::Value Ifc2x3::IfcValveType::PredefinedType() const {  return ::Ifc2x3::IfcValveTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcValveType::setPredefinedType(::Ifc2x3::IfcValveTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcValveTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcValveType::declaration() const { return *IFC2X3_IfcValveType_type; }
const IfcParse::entity& Ifc2x3::IfcValveType::Class() { return *IFC2X3_IfcValveType_type; }
Ifc2x3::IfcValveType::IfcValveType(IfcEntityInstanceData* e) : IfcFlowControllerType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcValveType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcValveType::IfcValveType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcValveTypeEnum::Value v10_PredefinedType) : IfcFlowControllerType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcValveType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcValveTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcVector
::Ifc2x3::IfcDirection* Ifc2x3::IfcVector::Orientation() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcDirection>(true); }
void Ifc2x3::IfcVector::setOrientation(::Ifc2x3::IfcDirection* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }
double Ifc2x3::IfcVector::Magnitude() const {  double v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcVector::setMagnitude(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcVector::declaration() const { return *IFC2X3_IfcVector_type; }
const IfcParse::entity& Ifc2x3::IfcVector::Class() { return *IFC2X3_IfcVector_type; }
Ifc2x3::IfcVector::IfcVector(IfcEntityInstanceData* e) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVector_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVector::IfcVector(::Ifc2x3::IfcDirection* v1_Orientation, double v2_Magnitude) : IfcGeometricRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVector_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Orientation));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_Magnitude));data_->setArgument(1,attr);} }

// Function implementations for IfcVertex


const IfcParse::entity& Ifc2x3::IfcVertex::declaration() const { return *IFC2X3_IfcVertex_type; }
const IfcParse::entity& Ifc2x3::IfcVertex::Class() { return *IFC2X3_IfcVertex_type; }
Ifc2x3::IfcVertex::IfcVertex(IfcEntityInstanceData* e) : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVertex_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVertex::IfcVertex() : IfcTopologicalRepresentationItem((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVertex_type);  }

// Function implementations for IfcVertexBasedTextureMap
aggregate_of< ::Ifc2x3::IfcTextureVertex >::ptr Ifc2x3::IfcVertexBasedTextureMap::TextureVertices() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcTextureVertex >(); }
void Ifc2x3::IfcVertexBasedTextureMap::setTextureVertices(aggregate_of< ::Ifc2x3::IfcTextureVertex >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr Ifc2x3::IfcVertexBasedTextureMap::TexturePoints() const {  aggregate_of_instance::ptr es = *data_->getArgument(1); return es->as< ::Ifc2x3::IfcCartesianPoint >(); }
void Ifc2x3::IfcVertexBasedTextureMap::setTexturePoints(aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcVertexBasedTextureMap::declaration() const { return *IFC2X3_IfcVertexBasedTextureMap_type; }
const IfcParse::entity& Ifc2x3::IfcVertexBasedTextureMap::Class() { return *IFC2X3_IfcVertexBasedTextureMap_type; }
Ifc2x3::IfcVertexBasedTextureMap::IfcVertexBasedTextureMap(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcVertexBasedTextureMap_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVertexBasedTextureMap::IfcVertexBasedTextureMap(aggregate_of< ::Ifc2x3::IfcTextureVertex >::ptr v1_TextureVertices, aggregate_of< ::Ifc2x3::IfcCartesianPoint >::ptr v2_TexturePoints) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcVertexBasedTextureMap_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_TextureVertices)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_TexturePoints)->generalize());data_->setArgument(1,attr);} }

// Function implementations for IfcVertexLoop
::Ifc2x3::IfcVertex* Ifc2x3::IfcVertexLoop::LoopVertex() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcVertex>(true); }
void Ifc2x3::IfcVertexLoop::setLoopVertex(::Ifc2x3::IfcVertex* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcVertexLoop::declaration() const { return *IFC2X3_IfcVertexLoop_type; }
const IfcParse::entity& Ifc2x3::IfcVertexLoop::Class() { return *IFC2X3_IfcVertexLoop_type; }
Ifc2x3::IfcVertexLoop::IfcVertexLoop(IfcEntityInstanceData* e) : IfcLoop((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVertexLoop_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVertexLoop::IfcVertexLoop(::Ifc2x3::IfcVertex* v1_LoopVertex) : IfcLoop((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVertexLoop_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_LoopVertex));data_->setArgument(0,attr);} }

// Function implementations for IfcVertexPoint
::Ifc2x3::IfcPoint* Ifc2x3::IfcVertexPoint::VertexGeometry() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(0)))->as<::Ifc2x3::IfcPoint>(true); }
void Ifc2x3::IfcVertexPoint::setVertexGeometry(::Ifc2x3::IfcPoint* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(0,attr);} }


const IfcParse::entity& Ifc2x3::IfcVertexPoint::declaration() const { return *IFC2X3_IfcVertexPoint_type; }
const IfcParse::entity& Ifc2x3::IfcVertexPoint::Class() { return *IFC2X3_IfcVertexPoint_type; }
Ifc2x3::IfcVertexPoint::IfcVertexPoint(IfcEntityInstanceData* e) : IfcVertex((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVertexPoint_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVertexPoint::IfcVertexPoint(::Ifc2x3::IfcPoint* v1_VertexGeometry) : IfcVertex((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVertexPoint_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_VertexGeometry));data_->setArgument(0,attr);} }

// Function implementations for IfcVibrationIsolatorType
::Ifc2x3::IfcVibrationIsolatorTypeEnum::Value Ifc2x3::IfcVibrationIsolatorType::PredefinedType() const {  return ::Ifc2x3::IfcVibrationIsolatorTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcVibrationIsolatorType::setPredefinedType(::Ifc2x3::IfcVibrationIsolatorTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcVibrationIsolatorTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcVibrationIsolatorType::declaration() const { return *IFC2X3_IfcVibrationIsolatorType_type; }
const IfcParse::entity& Ifc2x3::IfcVibrationIsolatorType::Class() { return *IFC2X3_IfcVibrationIsolatorType_type; }
Ifc2x3::IfcVibrationIsolatorType::IfcVibrationIsolatorType(IfcEntityInstanceData* e) : IfcDiscreteAccessoryType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVibrationIsolatorType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVibrationIsolatorType::IfcVibrationIsolatorType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcVibrationIsolatorTypeEnum::Value v10_PredefinedType) : IfcDiscreteAccessoryType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVibrationIsolatorType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcVibrationIsolatorTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcVirtualElement


const IfcParse::entity& Ifc2x3::IfcVirtualElement::declaration() const { return *IFC2X3_IfcVirtualElement_type; }
const IfcParse::entity& Ifc2x3::IfcVirtualElement::Class() { return *IFC2X3_IfcVirtualElement_type; }
Ifc2x3::IfcVirtualElement::IfcVirtualElement(IfcEntityInstanceData* e) : IfcElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcVirtualElement_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVirtualElement::IfcVirtualElement(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcVirtualElement_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcVirtualGridIntersection
aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr Ifc2x3::IfcVirtualGridIntersection::IntersectingAxes() const {  aggregate_of_instance::ptr es = *data_->getArgument(0); return es->as< ::Ifc2x3::IfcGridAxis >(); }
void Ifc2x3::IfcVirtualGridIntersection::setIntersectingAxes(aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v)->generalize());data_->setArgument(0,attr);} }
std::vector< double > /*[2:3]*/ Ifc2x3::IfcVirtualGridIntersection::OffsetDistances() const {  std::vector< double > /*[2:3]*/ v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcVirtualGridIntersection::setOffsetDistances(std::vector< double > /*[2:3]*/ v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(1,attr);} }


const IfcParse::entity& Ifc2x3::IfcVirtualGridIntersection::declaration() const { return *IFC2X3_IfcVirtualGridIntersection_type; }
const IfcParse::entity& Ifc2x3::IfcVirtualGridIntersection::Class() { return *IFC2X3_IfcVirtualGridIntersection_type; }
Ifc2x3::IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcEntityInstanceData* e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (e->type() != IFC2X3_IfcVirtualGridIntersection_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcVirtualGridIntersection::IfcVirtualGridIntersection(aggregate_of< ::Ifc2x3::IfcGridAxis >::ptr v1_IntersectingAxes, std::vector< double > /*[2:3]*/ v2_OffsetDistances) : IfcUtil::IfcBaseEntity() {data_ = new IfcEntityInstanceData(IFC2X3_IfcVirtualGridIntersection_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_IntersectingAxes)->generalize());data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OffsetDistances));data_->setArgument(1,attr);} }

// Function implementations for IfcWall


const IfcParse::entity& Ifc2x3::IfcWall::declaration() const { return *IFC2X3_IfcWall_type; }
const IfcParse::entity& Ifc2x3::IfcWall::Class() { return *IFC2X3_IfcWall_type; }
Ifc2x3::IfcWall::IfcWall(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWall_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWall::IfcWall(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWall_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcWallStandardCase


const IfcParse::entity& Ifc2x3::IfcWallStandardCase::declaration() const { return *IFC2X3_IfcWallStandardCase_type; }
const IfcParse::entity& Ifc2x3::IfcWallStandardCase::Class() { return *IFC2X3_IfcWallStandardCase_type; }
Ifc2x3::IfcWallStandardCase::IfcWallStandardCase(IfcEntityInstanceData* e) : IfcWall((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWallStandardCase_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWallStandardCase::IfcWallStandardCase(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag) : IfcWall((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWallStandardCase_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcWallType
::Ifc2x3::IfcWallTypeEnum::Value Ifc2x3::IfcWallType::PredefinedType() const {  return ::Ifc2x3::IfcWallTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcWallType::setPredefinedType(::Ifc2x3::IfcWallTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWallTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcWallType::declaration() const { return *IFC2X3_IfcWallType_type; }
const IfcParse::entity& Ifc2x3::IfcWallType::Class() { return *IFC2X3_IfcWallType_type; }
Ifc2x3::IfcWallType::IfcWallType(IfcEntityInstanceData* e) : IfcBuildingElementType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWallType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWallType::IfcWallType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcWallTypeEnum::Value v10_PredefinedType) : IfcBuildingElementType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWallType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcWallTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcWasteTerminalType
::Ifc2x3::IfcWasteTerminalTypeEnum::Value Ifc2x3::IfcWasteTerminalType::PredefinedType() const {  return ::Ifc2x3::IfcWasteTerminalTypeEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcWasteTerminalType::setPredefinedType(::Ifc2x3::IfcWasteTerminalTypeEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWasteTerminalTypeEnum::ToString(v)));data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcWasteTerminalType::declaration() const { return *IFC2X3_IfcWasteTerminalType_type; }
const IfcParse::entity& Ifc2x3::IfcWasteTerminalType::Class() { return *IFC2X3_IfcWasteTerminalType_type; }
Ifc2x3::IfcWasteTerminalType::IfcWasteTerminalType(IfcEntityInstanceData* e) : IfcFlowTerminalType((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWasteTerminalType_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWasteTerminalType::IfcWasteTerminalType(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, ::Ifc2x3::IfcWasteTerminalTypeEnum::Value v10_PredefinedType) : IfcFlowTerminalType((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWasteTerminalType_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_ElementType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_ElementType));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_PredefinedType,::Ifc2x3::IfcWasteTerminalTypeEnum::ToString(v10_PredefinedType))));data_->setArgument(9,attr);} }

// Function implementations for IfcWaterProperties
boost::optional< bool > Ifc2x3::IfcWaterProperties::IsPotable() const { if(!data_->getArgument(1) || data_->getArgument(1)->isNull()) { return boost::none; } bool v = *data_->getArgument(1); return v; }
void Ifc2x3::IfcWaterProperties::setIsPotable(boost::optional< bool > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(1,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::Hardness() const { if(!data_->getArgument(2) || data_->getArgument(2)->isNull()) { return boost::none; } double v = *data_->getArgument(2); return v; }
void Ifc2x3::IfcWaterProperties::setHardness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(2,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::AlkalinityConcentration() const { if(!data_->getArgument(3) || data_->getArgument(3)->isNull()) { return boost::none; } double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcWaterProperties::setAlkalinityConcentration(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(3,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::AcidityConcentration() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcWaterProperties::setAcidityConcentration(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::ImpuritiesContent() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcWaterProperties::setImpuritiesContent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::PHLevel() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcWaterProperties::setPHLevel(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcWaterProperties::DissolvedSolidsContent() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcWaterProperties::setDissolvedSolidsContent(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }


const IfcParse::entity& Ifc2x3::IfcWaterProperties::declaration() const { return *IFC2X3_IfcWaterProperties_type; }
const IfcParse::entity& Ifc2x3::IfcWaterProperties::Class() { return *IFC2X3_IfcWaterProperties_type; }
Ifc2x3::IfcWaterProperties::IfcWaterProperties(IfcEntityInstanceData* e) : IfcMaterialProperties((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWaterProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWaterProperties::IfcWaterProperties(::Ifc2x3::IfcMaterial* v1_Material, boost::optional< bool > v2_IsPotable, boost::optional< double > v3_Hardness, boost::optional< double > v4_AlkalinityConcentration, boost::optional< double > v5_AcidityConcentration, boost::optional< double > v6_ImpuritiesContent, boost::optional< double > v7_PHLevel, boost::optional< double > v8_DissolvedSolidsContent) : IfcMaterialProperties((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWaterProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_Material));data_->setArgument(0,attr);} if (v2_IsPotable) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_IsPotable));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); } if (v3_Hardness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Hardness));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_AlkalinityConcentration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_AlkalinityConcentration));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_AcidityConcentration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_AcidityConcentration));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_ImpuritiesContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_ImpuritiesContent));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_PHLevel) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_PHLevel));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_DissolvedSolidsContent) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_DissolvedSolidsContent));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } }

// Function implementations for IfcWindow
boost::optional< double > Ifc2x3::IfcWindow::OverallHeight() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcWindow::setOverallHeight(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcWindow::OverallWidth() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcWindow::setOverallWidth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }


const IfcParse::entity& Ifc2x3::IfcWindow::declaration() const { return *IFC2X3_IfcWindow_type; }
const IfcParse::entity& Ifc2x3::IfcWindow::Class() { return *IFC2X3_IfcWindow_type; }
Ifc2x3::IfcWindow::IfcWindow(IfcEntityInstanceData* e) : IfcBuildingElement((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWindow_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWindow::IfcWindow(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, ::Ifc2x3::IfcObjectPlacement* v6_ObjectPlacement, ::Ifc2x3::IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth) : IfcBuildingElement((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWindow_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_ObjectPlacement));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_Representation));data_->setArgument(6,attr);} if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_OverallHeight) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_OverallHeight));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_OverallWidth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_OverallWidth));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } }

// Function implementations for IfcWindowLiningProperties
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::LiningDepth() const { if(!data_->getArgument(4) || data_->getArgument(4)->isNull()) { return boost::none; } double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcWindowLiningProperties::setLiningDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(4,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::LiningThickness() const { if(!data_->getArgument(5) || data_->getArgument(5)->isNull()) { return boost::none; } double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcWindowLiningProperties::setLiningThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::TransomThickness() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcWindowLiningProperties::setTransomThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::MullionThickness() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcWindowLiningProperties::setMullionThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::FirstTransomOffset() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcWindowLiningProperties::setFirstTransomOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::SecondTransomOffset() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcWindowLiningProperties::setSecondTransomOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::FirstMullionOffset() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcWindowLiningProperties::setFirstMullionOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
boost::optional< double > Ifc2x3::IfcWindowLiningProperties::SecondMullionOffset() const { if(!data_->getArgument(11) || data_->getArgument(11)->isNull()) { return boost::none; } double v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcWindowLiningProperties::setSecondMullionOffset(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(11,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcWindowLiningProperties::ShapeAspectStyle() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcWindowLiningProperties::setShapeAspectStyle(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }


const IfcParse::entity& Ifc2x3::IfcWindowLiningProperties::declaration() const { return *IFC2X3_IfcWindowLiningProperties_type; }
const IfcParse::entity& Ifc2x3::IfcWindowLiningProperties::Class() { return *IFC2X3_IfcWindowLiningProperties_type; }
Ifc2x3::IfcWindowLiningProperties::IfcWindowLiningProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWindowLiningProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWindowLiningProperties::IfcWindowLiningProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_TransomThickness, boost::optional< double > v8_MullionThickness, boost::optional< double > v9_FirstTransomOffset, boost::optional< double > v10_SecondTransomOffset, boost::optional< double > v11_FirstMullionOffset, boost::optional< double > v12_SecondMullionOffset, ::Ifc2x3::IfcShapeAspect* v13_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowLiningProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_LiningDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_LiningDepth));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_LiningThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_LiningThickness));data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_TransomThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_TransomThickness));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_MullionThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_MullionThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_FirstTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_FirstTransomOffset));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_SecondTransomOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_SecondTransomOffset));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_FirstMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_FirstMullionOffset));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); } if (v12_SecondMullionOffset) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v12_SecondMullionOffset));data_->setArgument(11,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(11, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_ShapeAspectStyle));data_->setArgument(12,attr);} }

// Function implementations for IfcWindowPanelProperties
::Ifc2x3::IfcWindowPanelOperationEnum::Value Ifc2x3::IfcWindowPanelProperties::OperationType() const {  return ::Ifc2x3::IfcWindowPanelOperationEnum::FromString(*data_->getArgument(4)); }
void Ifc2x3::IfcWindowPanelProperties::setOperationType(::Ifc2x3::IfcWindowPanelOperationEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWindowPanelOperationEnum::ToString(v)));data_->setArgument(4,attr);} }
::Ifc2x3::IfcWindowPanelPositionEnum::Value Ifc2x3::IfcWindowPanelProperties::PanelPosition() const {  return ::Ifc2x3::IfcWindowPanelPositionEnum::FromString(*data_->getArgument(5)); }
void Ifc2x3::IfcWindowPanelProperties::setPanelPosition(::Ifc2x3::IfcWindowPanelPositionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWindowPanelPositionEnum::ToString(v)));data_->setArgument(5,attr);} }
boost::optional< double > Ifc2x3::IfcWindowPanelProperties::FrameDepth() const { if(!data_->getArgument(6) || data_->getArgument(6)->isNull()) { return boost::none; } double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcWindowPanelProperties::setFrameDepth(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcWindowPanelProperties::FrameThickness() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcWindowPanelProperties::setFrameThickness(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
::Ifc2x3::IfcShapeAspect* Ifc2x3::IfcWindowPanelProperties::ShapeAspectStyle() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(8)))->as<::Ifc2x3::IfcShapeAspect>(true); }
void Ifc2x3::IfcWindowPanelProperties::setShapeAspectStyle(::Ifc2x3::IfcShapeAspect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcWindowPanelProperties::declaration() const { return *IFC2X3_IfcWindowPanelProperties_type; }
const IfcParse::entity& Ifc2x3::IfcWindowPanelProperties::Class() { return *IFC2X3_IfcWindowPanelProperties_type; }
Ifc2x3::IfcWindowPanelProperties::IfcWindowPanelProperties(IfcEntityInstanceData* e) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWindowPanelProperties_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWindowPanelProperties::IfcWindowPanelProperties(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, ::Ifc2x3::IfcWindowPanelOperationEnum::Value v5_OperationType, ::Ifc2x3::IfcWindowPanelPositionEnum::Value v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, ::Ifc2x3::IfcShapeAspect* v9_ShapeAspectStyle) : IfcPropertySetDefinition((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowPanelProperties_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v5_OperationType,::Ifc2x3::IfcWindowPanelOperationEnum::ToString(v5_OperationType))));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v6_PanelPosition,::Ifc2x3::IfcWindowPanelPositionEnum::ToString(v6_PanelPosition))));data_->setArgument(5,attr);} if (v7_FrameDepth) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_FrameDepth));data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_FrameThickness) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FrameThickness));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v9_ShapeAspectStyle));data_->setArgument(8,attr);} }

// Function implementations for IfcWindowStyle
::Ifc2x3::IfcWindowStyleConstructionEnum::Value Ifc2x3::IfcWindowStyle::ConstructionType() const {  return ::Ifc2x3::IfcWindowStyleConstructionEnum::FromString(*data_->getArgument(8)); }
void Ifc2x3::IfcWindowStyle::setConstructionType(::Ifc2x3::IfcWindowStyleConstructionEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWindowStyleConstructionEnum::ToString(v)));data_->setArgument(8,attr);} }
::Ifc2x3::IfcWindowStyleOperationEnum::Value Ifc2x3::IfcWindowStyle::OperationType() const {  return ::Ifc2x3::IfcWindowStyleOperationEnum::FromString(*data_->getArgument(9)); }
void Ifc2x3::IfcWindowStyle::setOperationType(::Ifc2x3::IfcWindowStyleOperationEnum::Value v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(v,::Ifc2x3::IfcWindowStyleOperationEnum::ToString(v)));data_->setArgument(9,attr);} }
bool Ifc2x3::IfcWindowStyle::ParameterTakesPrecedence() const {  bool v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcWindowStyle::setParameterTakesPrecedence(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(10,attr);} }
bool Ifc2x3::IfcWindowStyle::Sizeable() const {  bool v = *data_->getArgument(11); return v; }
void Ifc2x3::IfcWindowStyle::setSizeable(bool v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }


const IfcParse::entity& Ifc2x3::IfcWindowStyle::declaration() const { return *IFC2X3_IfcWindowStyle_type; }
const IfcParse::entity& Ifc2x3::IfcWindowStyle::Class() { return *IFC2X3_IfcWindowStyle_type; }
Ifc2x3::IfcWindowStyle::IfcWindowStyle(IfcEntityInstanceData* e) : IfcTypeProduct((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWindowStyle_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWindowStyle::IfcWindowStyle(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< aggregate_of< ::Ifc2x3::IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< aggregate_of< ::Ifc2x3::IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, ::Ifc2x3::IfcWindowStyleConstructionEnum::Value v9_ConstructionType, ::Ifc2x3::IfcWindowStyleOperationEnum::Value v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWindowStyle_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ApplicableOccurrence) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ApplicableOccurrence));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } if (v6_HasPropertySets) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v6_HasPropertySets)->generalize());data_->setArgument(5,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(5, attr); } if (v7_RepresentationMaps) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v7_RepresentationMaps)->generalize());data_->setArgument(6,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(6, attr); } if (v8_Tag) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Tag));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v9_ConstructionType,::Ifc2x3::IfcWindowStyleConstructionEnum::ToString(v9_ConstructionType))));data_->setArgument(8,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v10_OperationType,::Ifc2x3::IfcWindowStyleOperationEnum::ToString(v10_OperationType))));data_->setArgument(9,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v11_ParameterTakesPrecedence));data_->setArgument(10,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_Sizeable));data_->setArgument(11,attr);} }

// Function implementations for IfcWorkControl
std::string Ifc2x3::IfcWorkControl::Identifier() const {  std::string v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcWorkControl::setIdentifier(std::string v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcWorkControl::CreationDate() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(6)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcWorkControl::setCreationDate(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< aggregate_of< ::Ifc2x3::IfcPerson >::ptr > Ifc2x3::IfcWorkControl::Creators() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } aggregate_of_instance::ptr es = *data_->getArgument(7); return es->as< ::Ifc2x3::IfcPerson >(); }
void Ifc2x3::IfcWorkControl::setCreators(boost::optional< aggregate_of< ::Ifc2x3::IfcPerson >::ptr > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set((*v)->generalize());}data_->setArgument(7,attr);} }
boost::optional< std::string > Ifc2x3::IfcWorkControl::Purpose() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } std::string v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcWorkControl::setPurpose(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }
boost::optional< double > Ifc2x3::IfcWorkControl::Duration() const { if(!data_->getArgument(9) || data_->getArgument(9)->isNull()) { return boost::none; } double v = *data_->getArgument(9); return v; }
void Ifc2x3::IfcWorkControl::setDuration(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(9,attr);} }
boost::optional< double > Ifc2x3::IfcWorkControl::TotalFloat() const { if(!data_->getArgument(10) || data_->getArgument(10)->isNull()) { return boost::none; } double v = *data_->getArgument(10); return v; }
void Ifc2x3::IfcWorkControl::setTotalFloat(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(10,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcWorkControl::StartTime() const {  return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(11)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcWorkControl::setStartTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(11,attr);} }
::Ifc2x3::IfcDateTimeSelect* Ifc2x3::IfcWorkControl::FinishTime() const { if(!data_->getArgument(12) || data_->getArgument(12)->isNull()) { return nullptr; } return ((IfcUtil::IfcBaseClass*)(*data_->getArgument(12)))->as<::Ifc2x3::IfcDateTimeSelect>(true); }
void Ifc2x3::IfcWorkControl::setFinishTime(::Ifc2x3::IfcDateTimeSelect* v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(12,attr);} }
boost::optional< ::Ifc2x3::IfcWorkControlTypeEnum::Value > Ifc2x3::IfcWorkControl::WorkControlType() const { if(!data_->getArgument(13) || data_->getArgument(13)->isNull()) { return boost::none; } return ::Ifc2x3::IfcWorkControlTypeEnum::FromString(*data_->getArgument(13)); }
void Ifc2x3::IfcWorkControl::setWorkControlType(boost::optional< ::Ifc2x3::IfcWorkControlTypeEnum::Value > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(IfcWrite::IfcWriteArgument::EnumerationReference(*v,::Ifc2x3::IfcWorkControlTypeEnum::ToString(*v)));}data_->setArgument(13,attr);} }
boost::optional< std::string > Ifc2x3::IfcWorkControl::UserDefinedControlType() const { if(!data_->getArgument(14) || data_->getArgument(14)->isNull()) { return boost::none; } std::string v = *data_->getArgument(14); return v; }
void Ifc2x3::IfcWorkControl::setUserDefinedControlType(boost::optional< std::string > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(14,attr);} }


const IfcParse::entity& Ifc2x3::IfcWorkControl::declaration() const { return *IFC2X3_IfcWorkControl_type; }
const IfcParse::entity& Ifc2x3::IfcWorkControl::Class() { return *IFC2X3_IfcWorkControl_type; }
Ifc2x3::IfcWorkControl::IfcWorkControl(IfcEntityInstanceData* e) : IfcControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWorkControl_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWorkControl::IfcWorkControl(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, ::Ifc2x3::IfcDateTimeSelect* v7_CreationDate, boost::optional< aggregate_of< ::Ifc2x3::IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, ::Ifc2x3::IfcDateTimeSelect* v12_StartTime, ::Ifc2x3::IfcDateTimeSelect* v13_FinishTime, boost::optional< ::Ifc2x3::IfcWorkControlTypeEnum::Value > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWorkControl_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));data_->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,::Ifc2x3::IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } }

// Function implementations for IfcWorkPlan


const IfcParse::entity& Ifc2x3::IfcWorkPlan::declaration() const { return *IFC2X3_IfcWorkPlan_type; }
const IfcParse::entity& Ifc2x3::IfcWorkPlan::Class() { return *IFC2X3_IfcWorkPlan_type; }
Ifc2x3::IfcWorkPlan::IfcWorkPlan(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWorkPlan_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWorkPlan::IfcWorkPlan(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, ::Ifc2x3::IfcDateTimeSelect* v7_CreationDate, boost::optional< aggregate_of< ::Ifc2x3::IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, ::Ifc2x3::IfcDateTimeSelect* v12_StartTime, ::Ifc2x3::IfcDateTimeSelect* v13_FinishTime, boost::optional< ::Ifc2x3::IfcWorkControlTypeEnum::Value > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcWorkControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWorkPlan_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));data_->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,::Ifc2x3::IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } }

// Function implementations for IfcWorkSchedule


const IfcParse::entity& Ifc2x3::IfcWorkSchedule::declaration() const { return *IFC2X3_IfcWorkSchedule_type; }
const IfcParse::entity& Ifc2x3::IfcWorkSchedule::Class() { return *IFC2X3_IfcWorkSchedule_type; }
Ifc2x3::IfcWorkSchedule::IfcWorkSchedule(IfcEntityInstanceData* e) : IfcWorkControl((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcWorkSchedule_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcWorkSchedule::IfcWorkSchedule(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, ::Ifc2x3::IfcDateTimeSelect* v7_CreationDate, boost::optional< aggregate_of< ::Ifc2x3::IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, ::Ifc2x3::IfcDateTimeSelect* v12_StartTime, ::Ifc2x3::IfcDateTimeSelect* v13_FinishTime, boost::optional< ::Ifc2x3::IfcWorkControlTypeEnum::Value > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType) : IfcWorkControl((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcWorkSchedule_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_Identifier));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_CreationDate));data_->setArgument(6,attr);} if (v8_Creators) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_Creators)->generalize());data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_Purpose) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_Purpose));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } if (v10_Duration) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v10_Duration));data_->setArgument(9,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(9, attr); } if (v11_TotalFloat) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v11_TotalFloat));data_->setArgument(10,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(10, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v12_StartTime));data_->setArgument(11,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v13_FinishTime));data_->setArgument(12,attr);} if (v14_WorkControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(*v14_WorkControlType,::Ifc2x3::IfcWorkControlTypeEnum::ToString(*v14_WorkControlType))));data_->setArgument(13,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(13, attr); } if (v15_UserDefinedControlType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v15_UserDefinedControlType));data_->setArgument(14,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(14, attr); } }

// Function implementations for IfcZShapeProfileDef
double Ifc2x3::IfcZShapeProfileDef::Depth() const {  double v = *data_->getArgument(3); return v; }
void Ifc2x3::IfcZShapeProfileDef::setDepth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(3,attr);} }
double Ifc2x3::IfcZShapeProfileDef::FlangeWidth() const {  double v = *data_->getArgument(4); return v; }
void Ifc2x3::IfcZShapeProfileDef::setFlangeWidth(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(4,attr);} }
double Ifc2x3::IfcZShapeProfileDef::WebThickness() const {  double v = *data_->getArgument(5); return v; }
void Ifc2x3::IfcZShapeProfileDef::setWebThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(5,attr);} }
double Ifc2x3::IfcZShapeProfileDef::FlangeThickness() const {  double v = *data_->getArgument(6); return v; }
void Ifc2x3::IfcZShapeProfileDef::setFlangeThickness(double v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set(v);data_->setArgument(6,attr);} }
boost::optional< double > Ifc2x3::IfcZShapeProfileDef::FilletRadius() const { if(!data_->getArgument(7) || data_->getArgument(7)->isNull()) { return boost::none; } double v = *data_->getArgument(7); return v; }
void Ifc2x3::IfcZShapeProfileDef::setFilletRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(7,attr);} }
boost::optional< double > Ifc2x3::IfcZShapeProfileDef::EdgeRadius() const { if(!data_->getArgument(8) || data_->getArgument(8)->isNull()) { return boost::none; } double v = *data_->getArgument(8); return v; }
void Ifc2x3::IfcZShapeProfileDef::setEdgeRadius(boost::optional< double > v) { {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();if (v) {attr->set(*v);}data_->setArgument(8,attr);} }


const IfcParse::entity& Ifc2x3::IfcZShapeProfileDef::declaration() const { return *IFC2X3_IfcZShapeProfileDef_type; }
const IfcParse::entity& Ifc2x3::IfcZShapeProfileDef::Class() { return *IFC2X3_IfcZShapeProfileDef_type; }
Ifc2x3::IfcZShapeProfileDef::IfcZShapeProfileDef(IfcEntityInstanceData* e) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcZShapeProfileDef_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcZShapeProfileDef::IfcZShapeProfileDef(::Ifc2x3::IfcProfileTypeEnum::Value v1_ProfileType, boost::optional< std::string > v2_ProfileName, ::Ifc2x3::IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius) : IfcParameterizedProfileDef((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcZShapeProfileDef_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((IfcWrite::IfcWriteArgument::EnumerationReference(v1_ProfileType,::Ifc2x3::IfcProfileTypeEnum::ToString(v1_ProfileType))));data_->setArgument(0,attr);} if (v2_ProfileName) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v2_ProfileName));data_->setArgument(1,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(1, attr); }{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v3_Position));data_->setArgument(2,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v4_Depth));data_->setArgument(3,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v5_FlangeWidth));data_->setArgument(4,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v6_WebThickness));data_->setArgument(5,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v7_FlangeThickness));data_->setArgument(6,attr);} if (v8_FilletRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v8_FilletRadius));data_->setArgument(7,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(7, attr); } if (v9_EdgeRadius) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v9_EdgeRadius));data_->setArgument(8,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(8, attr); } }

// Function implementations for IfcZone


const IfcParse::entity& Ifc2x3::IfcZone::declaration() const { return *IFC2X3_IfcZone_type; }
const IfcParse::entity& Ifc2x3::IfcZone::Class() { return *IFC2X3_IfcZone_type; }
Ifc2x3::IfcZone::IfcZone(IfcEntityInstanceData* e) : IfcGroup((IfcEntityInstanceData*)0) { if (!e) return; if (e->type() != IFC2X3_IfcZone_type) throw IfcException("Unable to find keyword in schema"); data_ = e; }
Ifc2x3::IfcZone::IfcZone(std::string v1_GlobalId, ::Ifc2x3::IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType) : IfcGroup((IfcEntityInstanceData*)0) {data_ = new IfcEntityInstanceData(IFC2X3_IfcZone_type); {IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v1_GlobalId));data_->setArgument(0,attr);}{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((v2_OwnerHistory));data_->setArgument(1,attr);} if (v3_Name) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v3_Name));data_->setArgument(2,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(2, attr); } if (v4_Description) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v4_Description));data_->setArgument(3,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(3, attr); } if (v5_ObjectType) {{IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();attr->set((*v5_ObjectType));data_->setArgument(4,attr);} } else { IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument(); attr->set(boost::blank()); data_->setArgument(4, attr); } }

