/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC4.exp. Do not make modifications        *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/
 
#ifdef USE_IFC4

#include "../ifcparse/Ifc4.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"
#include "../ifcparse/IfcWritableEntity.h"

using namespace Ifc4;
using namespace IfcParse;
using namespace IfcWrite;

IfcUtil::IfcSchemaEntity Ifc4::SchemaEntity(IfcAbstractEntityPtr e) {
    switch(e->type()) {
        case Type::IfcAbsorbedDoseMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcAccelerationMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcAmountOfSubstanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcAngularVelocityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcAreaDensityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcAreaMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcBoolean: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcColour: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcComplexNumber: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcCompoundPlaneAngleMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcContextDependentMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcCountMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcCurvatureMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcCurveStyleFontSelect: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDate: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDateTime: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDerivedMeasureValue: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDescriptiveMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDoseEquivalentMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDuration: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcDynamicViscosityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricCapacitanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricChargeMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricConductanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricCurrentMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricResistanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcElectricVoltageMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcEnergyMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcForceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcFrequencyMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcHeatFluxDensityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcHeatingValueMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcIdentifier: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcIlluminanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcInductanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcInteger: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcIntegerCountRateMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcIonConcentrationMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcIsothermalMoistureCapacityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcKinematicViscosityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLabel: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLengthMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLinearForceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLinearMomentMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLinearStiffnessMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLinearVelocityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLogical: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLuminousFluxMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLuminousIntensityDistributionMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcLuminousIntensityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMagneticFluxDensityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMagneticFluxMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMassDensityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMassFlowRateMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMassMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMassPerLengthMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMeasureValue: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcModulusOfElasticityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcModulusOfLinearSubgradeReactionMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcModulusOfRotationalSubgradeReactionMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcModulusOfSubgradeReactionMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMoistureDiffusivityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMolecularWeightMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMomentOfInertiaMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcMonetaryMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcNonNegativeLengthMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcNormalisedRatioMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcNullStyle: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcNumericMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPHMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcParameterValue: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPlanarForceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPlaneAngleMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPositiveLengthMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPositivePlaneAngleMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPositiveRatioMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPowerMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPressureMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcPropertySetDefinitionSet: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcRadioActivityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcRatioMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcReal: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcRotationalFrequencyMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcRotationalMassMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcRotationalStiffnessMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSectionModulusMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSectionalAreaIntegralMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcShearModulusMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSimpleValue: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSolidAngleMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSoundPowerLevelMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSoundPowerMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSoundPressureLevelMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSoundPressureMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSpecificHeatCapacityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSpecularExponent: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcSpecularRoughness: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTemperatureGradientMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTemperatureRateOfChangeMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcText: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermalAdmittanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermalConductivityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermalExpansionCoefficientMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermalResistanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermalTransmittanceMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcThermodynamicTemperatureMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTime: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTimeMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTimeStamp: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcTorqueMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcValue: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcVaporPermeabilityMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcVolumeMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcVolumetricFlowRateMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcWarpingConstantMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcWarpingMomentMeasure: return new IfcUtil::IfcEntitySelect(e); break;
        case Type::IfcActionRequest: return new IfcActionRequest(e); break;
        case Type::IfcActor: return new IfcActor(e); break;
        case Type::IfcActorRole: return new IfcActorRole(e); break;
        case Type::IfcActuator: return new IfcActuator(e); break;
        case Type::IfcActuatorType: return new IfcActuatorType(e); break;
        case Type::IfcAddress: return new IfcAddress(e); break;
        case Type::IfcAdvancedBrep: return new IfcAdvancedBrep(e); break;
        case Type::IfcAdvancedBrepWithVoids: return new IfcAdvancedBrepWithVoids(e); break;
        case Type::IfcAdvancedFace: return new IfcAdvancedFace(e); break;
        case Type::IfcAirTerminal: return new IfcAirTerminal(e); break;
        case Type::IfcAirTerminalBox: return new IfcAirTerminalBox(e); break;
        case Type::IfcAirTerminalBoxType: return new IfcAirTerminalBoxType(e); break;
        case Type::IfcAirTerminalType: return new IfcAirTerminalType(e); break;
        case Type::IfcAirToAirHeatRecovery: return new IfcAirToAirHeatRecovery(e); break;
        case Type::IfcAirToAirHeatRecoveryType: return new IfcAirToAirHeatRecoveryType(e); break;
        case Type::IfcAlarm: return new IfcAlarm(e); break;
        case Type::IfcAlarmType: return new IfcAlarmType(e); break;
        case Type::IfcAnnotation: return new IfcAnnotation(e); break;
        case Type::IfcAnnotationFillArea: return new IfcAnnotationFillArea(e); break;
        case Type::IfcApplication: return new IfcApplication(e); break;
        case Type::IfcAppliedValue: return new IfcAppliedValue(e); break;
        case Type::IfcApproval: return new IfcApproval(e); break;
        case Type::IfcApprovalRelationship: return new IfcApprovalRelationship(e); break;
        case Type::IfcArbitraryClosedProfileDef: return new IfcArbitraryClosedProfileDef(e); break;
        case Type::IfcArbitraryOpenProfileDef: return new IfcArbitraryOpenProfileDef(e); break;
        case Type::IfcArbitraryProfileDefWithVoids: return new IfcArbitraryProfileDefWithVoids(e); break;
        case Type::IfcAsset: return new IfcAsset(e); break;
        case Type::IfcAsymmetricIShapeProfileDef: return new IfcAsymmetricIShapeProfileDef(e); break;
        case Type::IfcAudioVisualAppliance: return new IfcAudioVisualAppliance(e); break;
        case Type::IfcAudioVisualApplianceType: return new IfcAudioVisualApplianceType(e); break;
        case Type::IfcAxis1Placement: return new IfcAxis1Placement(e); break;
        case Type::IfcAxis2Placement2D: return new IfcAxis2Placement2D(e); break;
        case Type::IfcAxis2Placement3D: return new IfcAxis2Placement3D(e); break;
        case Type::IfcBSplineCurve: return new IfcBSplineCurve(e); break;
        case Type::IfcBSplineCurveWithKnots: return new IfcBSplineCurveWithKnots(e); break;
        case Type::IfcBSplineSurface: return new IfcBSplineSurface(e); break;
        case Type::IfcBSplineSurfaceWithKnots: return new IfcBSplineSurfaceWithKnots(e); break;
        case Type::IfcBeam: return new IfcBeam(e); break;
        case Type::IfcBeamStandardCase: return new IfcBeamStandardCase(e); break;
        case Type::IfcBeamType: return new IfcBeamType(e); break;
        case Type::IfcBlobTexture: return new IfcBlobTexture(e); break;
        case Type::IfcBlock: return new IfcBlock(e); break;
        case Type::IfcBoiler: return new IfcBoiler(e); break;
        case Type::IfcBoilerType: return new IfcBoilerType(e); break;
        case Type::IfcBooleanClippingResult: return new IfcBooleanClippingResult(e); break;
        case Type::IfcBooleanResult: return new IfcBooleanResult(e); break;
        case Type::IfcBoundaryCondition: return new IfcBoundaryCondition(e); break;
        case Type::IfcBoundaryCurve: return new IfcBoundaryCurve(e); break;
        case Type::IfcBoundaryEdgeCondition: return new IfcBoundaryEdgeCondition(e); break;
        case Type::IfcBoundaryFaceCondition: return new IfcBoundaryFaceCondition(e); break;
        case Type::IfcBoundaryNodeCondition: return new IfcBoundaryNodeCondition(e); break;
        case Type::IfcBoundaryNodeConditionWarping: return new IfcBoundaryNodeConditionWarping(e); break;
        case Type::IfcBoundedCurve: return new IfcBoundedCurve(e); break;
        case Type::IfcBoundedSurface: return new IfcBoundedSurface(e); break;
        case Type::IfcBoundingBox: return new IfcBoundingBox(e); break;
        case Type::IfcBoxedHalfSpace: return new IfcBoxedHalfSpace(e); break;
        case Type::IfcBuilding: return new IfcBuilding(e); break;
        case Type::IfcBuildingElement: return new IfcBuildingElement(e); break;
        case Type::IfcBuildingElementPart: return new IfcBuildingElementPart(e); break;
        case Type::IfcBuildingElementPartType: return new IfcBuildingElementPartType(e); break;
        case Type::IfcBuildingElementProxy: return new IfcBuildingElementProxy(e); break;
        case Type::IfcBuildingElementProxyType: return new IfcBuildingElementProxyType(e); break;
        case Type::IfcBuildingElementType: return new IfcBuildingElementType(e); break;
        case Type::IfcBuildingStorey: return new IfcBuildingStorey(e); break;
        case Type::IfcBuildingSystem: return new IfcBuildingSystem(e); break;
        case Type::IfcBurner: return new IfcBurner(e); break;
        case Type::IfcBurnerType: return new IfcBurnerType(e); break;
        case Type::IfcCShapeProfileDef: return new IfcCShapeProfileDef(e); break;
        case Type::IfcCableCarrierFitting: return new IfcCableCarrierFitting(e); break;
        case Type::IfcCableCarrierFittingType: return new IfcCableCarrierFittingType(e); break;
        case Type::IfcCableCarrierSegment: return new IfcCableCarrierSegment(e); break;
        case Type::IfcCableCarrierSegmentType: return new IfcCableCarrierSegmentType(e); break;
        case Type::IfcCableFitting: return new IfcCableFitting(e); break;
        case Type::IfcCableFittingType: return new IfcCableFittingType(e); break;
        case Type::IfcCableSegment: return new IfcCableSegment(e); break;
        case Type::IfcCableSegmentType: return new IfcCableSegmentType(e); break;
        case Type::IfcCartesianPoint: return new IfcCartesianPoint(e); break;
        case Type::IfcCartesianPointList: return new IfcCartesianPointList(e); break;
        case Type::IfcCartesianPointList3D: return new IfcCartesianPointList3D(e); break;
        case Type::IfcCartesianTransformationOperator: return new IfcCartesianTransformationOperator(e); break;
        case Type::IfcCartesianTransformationOperator2D: return new IfcCartesianTransformationOperator2D(e); break;
        case Type::IfcCartesianTransformationOperator2DnonUniform: return new IfcCartesianTransformationOperator2DnonUniform(e); break;
        case Type::IfcCartesianTransformationOperator3D: return new IfcCartesianTransformationOperator3D(e); break;
        case Type::IfcCartesianTransformationOperator3DnonUniform: return new IfcCartesianTransformationOperator3DnonUniform(e); break;
        case Type::IfcCenterLineProfileDef: return new IfcCenterLineProfileDef(e); break;
        case Type::IfcChiller: return new IfcChiller(e); break;
        case Type::IfcChillerType: return new IfcChillerType(e); break;
        case Type::IfcChimney: return new IfcChimney(e); break;
        case Type::IfcChimneyType: return new IfcChimneyType(e); break;
        case Type::IfcCircle: return new IfcCircle(e); break;
        case Type::IfcCircleHollowProfileDef: return new IfcCircleHollowProfileDef(e); break;
        case Type::IfcCircleProfileDef: return new IfcCircleProfileDef(e); break;
        case Type::IfcCivilElement: return new IfcCivilElement(e); break;
        case Type::IfcCivilElementType: return new IfcCivilElementType(e); break;
        case Type::IfcClassification: return new IfcClassification(e); break;
        case Type::IfcClassificationReference: return new IfcClassificationReference(e); break;
        case Type::IfcClosedShell: return new IfcClosedShell(e); break;
        case Type::IfcCoil: return new IfcCoil(e); break;
        case Type::IfcCoilType: return new IfcCoilType(e); break;
        case Type::IfcColourRgb: return new IfcColourRgb(e); break;
        case Type::IfcColourRgbList: return new IfcColourRgbList(e); break;
        case Type::IfcColourSpecification: return new IfcColourSpecification(e); break;
        case Type::IfcColumn: return new IfcColumn(e); break;
        case Type::IfcColumnStandardCase: return new IfcColumnStandardCase(e); break;
        case Type::IfcColumnType: return new IfcColumnType(e); break;
        case Type::IfcCommunicationsAppliance: return new IfcCommunicationsAppliance(e); break;
        case Type::IfcCommunicationsApplianceType: return new IfcCommunicationsApplianceType(e); break;
        case Type::IfcComplexProperty: return new IfcComplexProperty(e); break;
        case Type::IfcComplexPropertyTemplate: return new IfcComplexPropertyTemplate(e); break;
        case Type::IfcCompositeCurve: return new IfcCompositeCurve(e); break;
        case Type::IfcCompositeCurveOnSurface: return new IfcCompositeCurveOnSurface(e); break;
        case Type::IfcCompositeCurveSegment: return new IfcCompositeCurveSegment(e); break;
        case Type::IfcCompositeProfileDef: return new IfcCompositeProfileDef(e); break;
        case Type::IfcCompressor: return new IfcCompressor(e); break;
        case Type::IfcCompressorType: return new IfcCompressorType(e); break;
        case Type::IfcCondenser: return new IfcCondenser(e); break;
        case Type::IfcCondenserType: return new IfcCondenserType(e); break;
        case Type::IfcConic: return new IfcConic(e); break;
        case Type::IfcConnectedFaceSet: return new IfcConnectedFaceSet(e); break;
        case Type::IfcConnectionCurveGeometry: return new IfcConnectionCurveGeometry(e); break;
        case Type::IfcConnectionGeometry: return new IfcConnectionGeometry(e); break;
        case Type::IfcConnectionPointEccentricity: return new IfcConnectionPointEccentricity(e); break;
        case Type::IfcConnectionPointGeometry: return new IfcConnectionPointGeometry(e); break;
        case Type::IfcConnectionSurfaceGeometry: return new IfcConnectionSurfaceGeometry(e); break;
        case Type::IfcConnectionVolumeGeometry: return new IfcConnectionVolumeGeometry(e); break;
        case Type::IfcConstraint: return new IfcConstraint(e); break;
        case Type::IfcConstructionEquipmentResource: return new IfcConstructionEquipmentResource(e); break;
        case Type::IfcConstructionEquipmentResourceType: return new IfcConstructionEquipmentResourceType(e); break;
        case Type::IfcConstructionMaterialResource: return new IfcConstructionMaterialResource(e); break;
        case Type::IfcConstructionMaterialResourceType: return new IfcConstructionMaterialResourceType(e); break;
        case Type::IfcConstructionProductResource: return new IfcConstructionProductResource(e); break;
        case Type::IfcConstructionProductResourceType: return new IfcConstructionProductResourceType(e); break;
        case Type::IfcConstructionResource: return new IfcConstructionResource(e); break;
        case Type::IfcConstructionResourceType: return new IfcConstructionResourceType(e); break;
        case Type::IfcContext: return new IfcContext(e); break;
        case Type::IfcContextDependentUnit: return new IfcContextDependentUnit(e); break;
        case Type::IfcControl: return new IfcControl(e); break;
        case Type::IfcController: return new IfcController(e); break;
        case Type::IfcControllerType: return new IfcControllerType(e); break;
        case Type::IfcConversionBasedUnit: return new IfcConversionBasedUnit(e); break;
        case Type::IfcConversionBasedUnitWithOffset: return new IfcConversionBasedUnitWithOffset(e); break;
        case Type::IfcCooledBeam: return new IfcCooledBeam(e); break;
        case Type::IfcCooledBeamType: return new IfcCooledBeamType(e); break;
        case Type::IfcCoolingTower: return new IfcCoolingTower(e); break;
        case Type::IfcCoolingTowerType: return new IfcCoolingTowerType(e); break;
        case Type::IfcCoordinateOperation: return new IfcCoordinateOperation(e); break;
        case Type::IfcCoordinateReferenceSystem: return new IfcCoordinateReferenceSystem(e); break;
        case Type::IfcCostItem: return new IfcCostItem(e); break;
        case Type::IfcCostSchedule: return new IfcCostSchedule(e); break;
        case Type::IfcCostValue: return new IfcCostValue(e); break;
        case Type::IfcCovering: return new IfcCovering(e); break;
        case Type::IfcCoveringType: return new IfcCoveringType(e); break;
        case Type::IfcCrewResource: return new IfcCrewResource(e); break;
        case Type::IfcCrewResourceType: return new IfcCrewResourceType(e); break;
        case Type::IfcCsgPrimitive3D: return new IfcCsgPrimitive3D(e); break;
        case Type::IfcCsgSolid: return new IfcCsgSolid(e); break;
        case Type::IfcCurrencyRelationship: return new IfcCurrencyRelationship(e); break;
        case Type::IfcCurtainWall: return new IfcCurtainWall(e); break;
        case Type::IfcCurtainWallType: return new IfcCurtainWallType(e); break;
        case Type::IfcCurve: return new IfcCurve(e); break;
        case Type::IfcCurveBoundedPlane: return new IfcCurveBoundedPlane(e); break;
        case Type::IfcCurveBoundedSurface: return new IfcCurveBoundedSurface(e); break;
        case Type::IfcCurveStyle: return new IfcCurveStyle(e); break;
        case Type::IfcCurveStyleFont: return new IfcCurveStyleFont(e); break;
        case Type::IfcCurveStyleFontAndScaling: return new IfcCurveStyleFontAndScaling(e); break;
        case Type::IfcCurveStyleFontPattern: return new IfcCurveStyleFontPattern(e); break;
        case Type::IfcCylindricalSurface: return new IfcCylindricalSurface(e); break;
        case Type::IfcDamper: return new IfcDamper(e); break;
        case Type::IfcDamperType: return new IfcDamperType(e); break;
        case Type::IfcDerivedProfileDef: return new IfcDerivedProfileDef(e); break;
        case Type::IfcDerivedUnit: return new IfcDerivedUnit(e); break;
        case Type::IfcDerivedUnitElement: return new IfcDerivedUnitElement(e); break;
        case Type::IfcDimensionalExponents: return new IfcDimensionalExponents(e); break;
        case Type::IfcDirection: return new IfcDirection(e); break;
        case Type::IfcDiscreteAccessory: return new IfcDiscreteAccessory(e); break;
        case Type::IfcDiscreteAccessoryType: return new IfcDiscreteAccessoryType(e); break;
        case Type::IfcDistributionChamberElement: return new IfcDistributionChamberElement(e); break;
        case Type::IfcDistributionChamberElementType: return new IfcDistributionChamberElementType(e); break;
        case Type::IfcDistributionCircuit: return new IfcDistributionCircuit(e); break;
        case Type::IfcDistributionControlElement: return new IfcDistributionControlElement(e); break;
        case Type::IfcDistributionControlElementType: return new IfcDistributionControlElementType(e); break;
        case Type::IfcDistributionElement: return new IfcDistributionElement(e); break;
        case Type::IfcDistributionElementType: return new IfcDistributionElementType(e); break;
        case Type::IfcDistributionFlowElement: return new IfcDistributionFlowElement(e); break;
        case Type::IfcDistributionFlowElementType: return new IfcDistributionFlowElementType(e); break;
        case Type::IfcDistributionPort: return new IfcDistributionPort(e); break;
        case Type::IfcDistributionSystem: return new IfcDistributionSystem(e); break;
        case Type::IfcDocumentInformation: return new IfcDocumentInformation(e); break;
        case Type::IfcDocumentInformationRelationship: return new IfcDocumentInformationRelationship(e); break;
        case Type::IfcDocumentReference: return new IfcDocumentReference(e); break;
        case Type::IfcDoor: return new IfcDoor(e); break;
        case Type::IfcDoorLiningProperties: return new IfcDoorLiningProperties(e); break;
        case Type::IfcDoorPanelProperties: return new IfcDoorPanelProperties(e); break;
        case Type::IfcDoorStandardCase: return new IfcDoorStandardCase(e); break;
        case Type::IfcDoorStyle: return new IfcDoorStyle(e); break;
        case Type::IfcDoorType: return new IfcDoorType(e); break;
        case Type::IfcDraughtingPreDefinedColour: return new IfcDraughtingPreDefinedColour(e); break;
        case Type::IfcDraughtingPreDefinedCurveFont: return new IfcDraughtingPreDefinedCurveFont(e); break;
        case Type::IfcDuctFitting: return new IfcDuctFitting(e); break;
        case Type::IfcDuctFittingType: return new IfcDuctFittingType(e); break;
        case Type::IfcDuctSegment: return new IfcDuctSegment(e); break;
        case Type::IfcDuctSegmentType: return new IfcDuctSegmentType(e); break;
        case Type::IfcDuctSilencer: return new IfcDuctSilencer(e); break;
        case Type::IfcDuctSilencerType: return new IfcDuctSilencerType(e); break;
        case Type::IfcEdge: return new IfcEdge(e); break;
        case Type::IfcEdgeCurve: return new IfcEdgeCurve(e); break;
        case Type::IfcEdgeLoop: return new IfcEdgeLoop(e); break;
        case Type::IfcElectricAppliance: return new IfcElectricAppliance(e); break;
        case Type::IfcElectricApplianceType: return new IfcElectricApplianceType(e); break;
        case Type::IfcElectricDistributionBoard: return new IfcElectricDistributionBoard(e); break;
        case Type::IfcElectricDistributionBoardType: return new IfcElectricDistributionBoardType(e); break;
        case Type::IfcElectricFlowStorageDevice: return new IfcElectricFlowStorageDevice(e); break;
        case Type::IfcElectricFlowStorageDeviceType: return new IfcElectricFlowStorageDeviceType(e); break;
        case Type::IfcElectricGenerator: return new IfcElectricGenerator(e); break;
        case Type::IfcElectricGeneratorType: return new IfcElectricGeneratorType(e); break;
        case Type::IfcElectricMotor: return new IfcElectricMotor(e); break;
        case Type::IfcElectricMotorType: return new IfcElectricMotorType(e); break;
        case Type::IfcElectricTimeControl: return new IfcElectricTimeControl(e); break;
        case Type::IfcElectricTimeControlType: return new IfcElectricTimeControlType(e); break;
        case Type::IfcElement: return new IfcElement(e); break;
        case Type::IfcElementAssembly: return new IfcElementAssembly(e); break;
        case Type::IfcElementAssemblyType: return new IfcElementAssemblyType(e); break;
        case Type::IfcElementComponent: return new IfcElementComponent(e); break;
        case Type::IfcElementComponentType: return new IfcElementComponentType(e); break;
        case Type::IfcElementQuantity: return new IfcElementQuantity(e); break;
        case Type::IfcElementType: return new IfcElementType(e); break;
        case Type::IfcElementarySurface: return new IfcElementarySurface(e); break;
        case Type::IfcEllipse: return new IfcEllipse(e); break;
        case Type::IfcEllipseProfileDef: return new IfcEllipseProfileDef(e); break;
        case Type::IfcEnergyConversionDevice: return new IfcEnergyConversionDevice(e); break;
        case Type::IfcEnergyConversionDeviceType: return new IfcEnergyConversionDeviceType(e); break;
        case Type::IfcEngine: return new IfcEngine(e); break;
        case Type::IfcEngineType: return new IfcEngineType(e); break;
        case Type::IfcEvaporativeCooler: return new IfcEvaporativeCooler(e); break;
        case Type::IfcEvaporativeCoolerType: return new IfcEvaporativeCoolerType(e); break;
        case Type::IfcEvaporator: return new IfcEvaporator(e); break;
        case Type::IfcEvaporatorType: return new IfcEvaporatorType(e); break;
        case Type::IfcEvent: return new IfcEvent(e); break;
        case Type::IfcEventTime: return new IfcEventTime(e); break;
        case Type::IfcEventType: return new IfcEventType(e); break;
        case Type::IfcExtendedProperties: return new IfcExtendedProperties(e); break;
        case Type::IfcExternalInformation: return new IfcExternalInformation(e); break;
        case Type::IfcExternalReference: return new IfcExternalReference(e); break;
        case Type::IfcExternalReferenceRelationship: return new IfcExternalReferenceRelationship(e); break;
        case Type::IfcExternalSpatialElement: return new IfcExternalSpatialElement(e); break;
        case Type::IfcExternalSpatialStructureElement: return new IfcExternalSpatialStructureElement(e); break;
        case Type::IfcExternallyDefinedHatchStyle: return new IfcExternallyDefinedHatchStyle(e); break;
        case Type::IfcExternallyDefinedSurfaceStyle: return new IfcExternallyDefinedSurfaceStyle(e); break;
        case Type::IfcExternallyDefinedTextFont: return new IfcExternallyDefinedTextFont(e); break;
        case Type::IfcExtrudedAreaSolid: return new IfcExtrudedAreaSolid(e); break;
        case Type::IfcExtrudedAreaSolidTapered: return new IfcExtrudedAreaSolidTapered(e); break;
        case Type::IfcFace: return new IfcFace(e); break;
        case Type::IfcFaceBasedSurfaceModel: return new IfcFaceBasedSurfaceModel(e); break;
        case Type::IfcFaceBound: return new IfcFaceBound(e); break;
        case Type::IfcFaceOuterBound: return new IfcFaceOuterBound(e); break;
        case Type::IfcFaceSurface: return new IfcFaceSurface(e); break;
        case Type::IfcFacetedBrep: return new IfcFacetedBrep(e); break;
        case Type::IfcFacetedBrepWithVoids: return new IfcFacetedBrepWithVoids(e); break;
        case Type::IfcFailureConnectionCondition: return new IfcFailureConnectionCondition(e); break;
        case Type::IfcFan: return new IfcFan(e); break;
        case Type::IfcFanType: return new IfcFanType(e); break;
        case Type::IfcFastener: return new IfcFastener(e); break;
        case Type::IfcFastenerType: return new IfcFastenerType(e); break;
        case Type::IfcFeatureElement: return new IfcFeatureElement(e); break;
        case Type::IfcFeatureElementAddition: return new IfcFeatureElementAddition(e); break;
        case Type::IfcFeatureElementSubtraction: return new IfcFeatureElementSubtraction(e); break;
        case Type::IfcFillAreaStyle: return new IfcFillAreaStyle(e); break;
        case Type::IfcFillAreaStyleHatching: return new IfcFillAreaStyleHatching(e); break;
        case Type::IfcFillAreaStyleTiles: return new IfcFillAreaStyleTiles(e); break;
        case Type::IfcFilter: return new IfcFilter(e); break;
        case Type::IfcFilterType: return new IfcFilterType(e); break;
        case Type::IfcFireSuppressionTerminal: return new IfcFireSuppressionTerminal(e); break;
        case Type::IfcFireSuppressionTerminalType: return new IfcFireSuppressionTerminalType(e); break;
        case Type::IfcFixedReferenceSweptAreaSolid: return new IfcFixedReferenceSweptAreaSolid(e); break;
        case Type::IfcFlowController: return new IfcFlowController(e); break;
        case Type::IfcFlowControllerType: return new IfcFlowControllerType(e); break;
        case Type::IfcFlowFitting: return new IfcFlowFitting(e); break;
        case Type::IfcFlowFittingType: return new IfcFlowFittingType(e); break;
        case Type::IfcFlowInstrument: return new IfcFlowInstrument(e); break;
        case Type::IfcFlowInstrumentType: return new IfcFlowInstrumentType(e); break;
        case Type::IfcFlowMeter: return new IfcFlowMeter(e); break;
        case Type::IfcFlowMeterType: return new IfcFlowMeterType(e); break;
        case Type::IfcFlowMovingDevice: return new IfcFlowMovingDevice(e); break;
        case Type::IfcFlowMovingDeviceType: return new IfcFlowMovingDeviceType(e); break;
        case Type::IfcFlowSegment: return new IfcFlowSegment(e); break;
        case Type::IfcFlowSegmentType: return new IfcFlowSegmentType(e); break;
        case Type::IfcFlowStorageDevice: return new IfcFlowStorageDevice(e); break;
        case Type::IfcFlowStorageDeviceType: return new IfcFlowStorageDeviceType(e); break;
        case Type::IfcFlowTerminal: return new IfcFlowTerminal(e); break;
        case Type::IfcFlowTerminalType: return new IfcFlowTerminalType(e); break;
        case Type::IfcFlowTreatmentDevice: return new IfcFlowTreatmentDevice(e); break;
        case Type::IfcFlowTreatmentDeviceType: return new IfcFlowTreatmentDeviceType(e); break;
        case Type::IfcFooting: return new IfcFooting(e); break;
        case Type::IfcFootingType: return new IfcFootingType(e); break;
        case Type::IfcFurnishingElement: return new IfcFurnishingElement(e); break;
        case Type::IfcFurnishingElementType: return new IfcFurnishingElementType(e); break;
        case Type::IfcFurniture: return new IfcFurniture(e); break;
        case Type::IfcFurnitureType: return new IfcFurnitureType(e); break;
        case Type::IfcGeographicElement: return new IfcGeographicElement(e); break;
        case Type::IfcGeographicElementType: return new IfcGeographicElementType(e); break;
        case Type::IfcGeometricCurveSet: return new IfcGeometricCurveSet(e); break;
        case Type::IfcGeometricRepresentationContext: return new IfcGeometricRepresentationContext(e); break;
        case Type::IfcGeometricRepresentationItem: return new IfcGeometricRepresentationItem(e); break;
        case Type::IfcGeometricRepresentationSubContext: return new IfcGeometricRepresentationSubContext(e); break;
        case Type::IfcGeometricSet: return new IfcGeometricSet(e); break;
        case Type::IfcGrid: return new IfcGrid(e); break;
        case Type::IfcGridAxis: return new IfcGridAxis(e); break;
        case Type::IfcGridPlacement: return new IfcGridPlacement(e); break;
        case Type::IfcGroup: return new IfcGroup(e); break;
        case Type::IfcHalfSpaceSolid: return new IfcHalfSpaceSolid(e); break;
        case Type::IfcHeatExchanger: return new IfcHeatExchanger(e); break;
        case Type::IfcHeatExchangerType: return new IfcHeatExchangerType(e); break;
        case Type::IfcHumidifier: return new IfcHumidifier(e); break;
        case Type::IfcHumidifierType: return new IfcHumidifierType(e); break;
        case Type::IfcIShapeProfileDef: return new IfcIShapeProfileDef(e); break;
        case Type::IfcImageTexture: return new IfcImageTexture(e); break;
        case Type::IfcIndexedColourMap: return new IfcIndexedColourMap(e); break;
        case Type::IfcIndexedTextureMap: return new IfcIndexedTextureMap(e); break;
        case Type::IfcIndexedTriangleTextureMap: return new IfcIndexedTriangleTextureMap(e); break;
        case Type::IfcInterceptor: return new IfcInterceptor(e); break;
        case Type::IfcInterceptorType: return new IfcInterceptorType(e); break;
        case Type::IfcInventory: return new IfcInventory(e); break;
        case Type::IfcIrregularTimeSeries: return new IfcIrregularTimeSeries(e); break;
        case Type::IfcIrregularTimeSeriesValue: return new IfcIrregularTimeSeriesValue(e); break;
        case Type::IfcJunctionBox: return new IfcJunctionBox(e); break;
        case Type::IfcJunctionBoxType: return new IfcJunctionBoxType(e); break;
        case Type::IfcLShapeProfileDef: return new IfcLShapeProfileDef(e); break;
        case Type::IfcLaborResource: return new IfcLaborResource(e); break;
        case Type::IfcLaborResourceType: return new IfcLaborResourceType(e); break;
        case Type::IfcLagTime: return new IfcLagTime(e); break;
        case Type::IfcLamp: return new IfcLamp(e); break;
        case Type::IfcLampType: return new IfcLampType(e); break;
        case Type::IfcLibraryInformation: return new IfcLibraryInformation(e); break;
        case Type::IfcLibraryReference: return new IfcLibraryReference(e); break;
        case Type::IfcLightDistributionData: return new IfcLightDistributionData(e); break;
        case Type::IfcLightFixture: return new IfcLightFixture(e); break;
        case Type::IfcLightFixtureType: return new IfcLightFixtureType(e); break;
        case Type::IfcLightIntensityDistribution: return new IfcLightIntensityDistribution(e); break;
        case Type::IfcLightSource: return new IfcLightSource(e); break;
        case Type::IfcLightSourceAmbient: return new IfcLightSourceAmbient(e); break;
        case Type::IfcLightSourceDirectional: return new IfcLightSourceDirectional(e); break;
        case Type::IfcLightSourceGoniometric: return new IfcLightSourceGoniometric(e); break;
        case Type::IfcLightSourcePositional: return new IfcLightSourcePositional(e); break;
        case Type::IfcLightSourceSpot: return new IfcLightSourceSpot(e); break;
        case Type::IfcLine: return new IfcLine(e); break;
        case Type::IfcLocalPlacement: return new IfcLocalPlacement(e); break;
        case Type::IfcLoop: return new IfcLoop(e); break;
        case Type::IfcManifoldSolidBrep: return new IfcManifoldSolidBrep(e); break;
        case Type::IfcMapConversion: return new IfcMapConversion(e); break;
        case Type::IfcMappedItem: return new IfcMappedItem(e); break;
        case Type::IfcMaterial: return new IfcMaterial(e); break;
        case Type::IfcMaterialClassificationRelationship: return new IfcMaterialClassificationRelationship(e); break;
        case Type::IfcMaterialConstituent: return new IfcMaterialConstituent(e); break;
        case Type::IfcMaterialConstituentSet: return new IfcMaterialConstituentSet(e); break;
        case Type::IfcMaterialDefinition: return new IfcMaterialDefinition(e); break;
        case Type::IfcMaterialDefinitionRepresentation: return new IfcMaterialDefinitionRepresentation(e); break;
        case Type::IfcMaterialLayer: return new IfcMaterialLayer(e); break;
        case Type::IfcMaterialLayerSet: return new IfcMaterialLayerSet(e); break;
        case Type::IfcMaterialLayerSetUsage: return new IfcMaterialLayerSetUsage(e); break;
        case Type::IfcMaterialLayerWithOffsets: return new IfcMaterialLayerWithOffsets(e); break;
        case Type::IfcMaterialList: return new IfcMaterialList(e); break;
        case Type::IfcMaterialProfile: return new IfcMaterialProfile(e); break;
        case Type::IfcMaterialProfileSet: return new IfcMaterialProfileSet(e); break;
        case Type::IfcMaterialProfileSetUsage: return new IfcMaterialProfileSetUsage(e); break;
        case Type::IfcMaterialProfileSetUsageTapering: return new IfcMaterialProfileSetUsageTapering(e); break;
        case Type::IfcMaterialProfileWithOffsets: return new IfcMaterialProfileWithOffsets(e); break;
        case Type::IfcMaterialProperties: return new IfcMaterialProperties(e); break;
        case Type::IfcMaterialRelationship: return new IfcMaterialRelationship(e); break;
        case Type::IfcMaterialUsageDefinition: return new IfcMaterialUsageDefinition(e); break;
        case Type::IfcMeasureWithUnit: return new IfcMeasureWithUnit(e); break;
        case Type::IfcMechanicalFastener: return new IfcMechanicalFastener(e); break;
        case Type::IfcMechanicalFastenerType: return new IfcMechanicalFastenerType(e); break;
        case Type::IfcMedicalDevice: return new IfcMedicalDevice(e); break;
        case Type::IfcMedicalDeviceType: return new IfcMedicalDeviceType(e); break;
        case Type::IfcMember: return new IfcMember(e); break;
        case Type::IfcMemberStandardCase: return new IfcMemberStandardCase(e); break;
        case Type::IfcMemberType: return new IfcMemberType(e); break;
        case Type::IfcMetric: return new IfcMetric(e); break;
        case Type::IfcMirroredProfileDef: return new IfcMirroredProfileDef(e); break;
        case Type::IfcMonetaryUnit: return new IfcMonetaryUnit(e); break;
        case Type::IfcMotorConnection: return new IfcMotorConnection(e); break;
        case Type::IfcMotorConnectionType: return new IfcMotorConnectionType(e); break;
        case Type::IfcNamedUnit: return new IfcNamedUnit(e); break;
        case Type::IfcObject: return new IfcObject(e); break;
        case Type::IfcObjectDefinition: return new IfcObjectDefinition(e); break;
        case Type::IfcObjectPlacement: return new IfcObjectPlacement(e); break;
        case Type::IfcObjective: return new IfcObjective(e); break;
        case Type::IfcOccupant: return new IfcOccupant(e); break;
        case Type::IfcOffsetCurve2D: return new IfcOffsetCurve2D(e); break;
        case Type::IfcOffsetCurve3D: return new IfcOffsetCurve3D(e); break;
        case Type::IfcOpenShell: return new IfcOpenShell(e); break;
        case Type::IfcOpeningElement: return new IfcOpeningElement(e); break;
        case Type::IfcOpeningStandardCase: return new IfcOpeningStandardCase(e); break;
        case Type::IfcOrganization: return new IfcOrganization(e); break;
        case Type::IfcOrganizationRelationship: return new IfcOrganizationRelationship(e); break;
        case Type::IfcOrientedEdge: return new IfcOrientedEdge(e); break;
        case Type::IfcOuterBoundaryCurve: return new IfcOuterBoundaryCurve(e); break;
        case Type::IfcOutlet: return new IfcOutlet(e); break;
        case Type::IfcOutletType: return new IfcOutletType(e); break;
        case Type::IfcOwnerHistory: return new IfcOwnerHistory(e); break;
        case Type::IfcParameterizedProfileDef: return new IfcParameterizedProfileDef(e); break;
        case Type::IfcPath: return new IfcPath(e); break;
        case Type::IfcPcurve: return new IfcPcurve(e); break;
        case Type::IfcPerformanceHistory: return new IfcPerformanceHistory(e); break;
        case Type::IfcPermeableCoveringProperties: return new IfcPermeableCoveringProperties(e); break;
        case Type::IfcPermit: return new IfcPermit(e); break;
        case Type::IfcPerson: return new IfcPerson(e); break;
        case Type::IfcPersonAndOrganization: return new IfcPersonAndOrganization(e); break;
        case Type::IfcPhysicalComplexQuantity: return new IfcPhysicalComplexQuantity(e); break;
        case Type::IfcPhysicalQuantity: return new IfcPhysicalQuantity(e); break;
        case Type::IfcPhysicalSimpleQuantity: return new IfcPhysicalSimpleQuantity(e); break;
        case Type::IfcPile: return new IfcPile(e); break;
        case Type::IfcPileType: return new IfcPileType(e); break;
        case Type::IfcPipeFitting: return new IfcPipeFitting(e); break;
        case Type::IfcPipeFittingType: return new IfcPipeFittingType(e); break;
        case Type::IfcPipeSegment: return new IfcPipeSegment(e); break;
        case Type::IfcPipeSegmentType: return new IfcPipeSegmentType(e); break;
        case Type::IfcPixelTexture: return new IfcPixelTexture(e); break;
        case Type::IfcPlacement: return new IfcPlacement(e); break;
        case Type::IfcPlanarBox: return new IfcPlanarBox(e); break;
        case Type::IfcPlanarExtent: return new IfcPlanarExtent(e); break;
        case Type::IfcPlane: return new IfcPlane(e); break;
        case Type::IfcPlate: return new IfcPlate(e); break;
        case Type::IfcPlateStandardCase: return new IfcPlateStandardCase(e); break;
        case Type::IfcPlateType: return new IfcPlateType(e); break;
        case Type::IfcPoint: return new IfcPoint(e); break;
        case Type::IfcPointOnCurve: return new IfcPointOnCurve(e); break;
        case Type::IfcPointOnSurface: return new IfcPointOnSurface(e); break;
        case Type::IfcPolyLoop: return new IfcPolyLoop(e); break;
        case Type::IfcPolygonalBoundedHalfSpace: return new IfcPolygonalBoundedHalfSpace(e); break;
        case Type::IfcPolyline: return new IfcPolyline(e); break;
        case Type::IfcPort: return new IfcPort(e); break;
        case Type::IfcPostalAddress: return new IfcPostalAddress(e); break;
        case Type::IfcPreDefinedColour: return new IfcPreDefinedColour(e); break;
        case Type::IfcPreDefinedCurveFont: return new IfcPreDefinedCurveFont(e); break;
        case Type::IfcPreDefinedItem: return new IfcPreDefinedItem(e); break;
        case Type::IfcPreDefinedProperties: return new IfcPreDefinedProperties(e); break;
        case Type::IfcPreDefinedPropertySet: return new IfcPreDefinedPropertySet(e); break;
        case Type::IfcPreDefinedTextFont: return new IfcPreDefinedTextFont(e); break;
        case Type::IfcPresentationItem: return new IfcPresentationItem(e); break;
        case Type::IfcPresentationLayerAssignment: return new IfcPresentationLayerAssignment(e); break;
        case Type::IfcPresentationLayerWithStyle: return new IfcPresentationLayerWithStyle(e); break;
        case Type::IfcPresentationStyle: return new IfcPresentationStyle(e); break;
        case Type::IfcPresentationStyleAssignment: return new IfcPresentationStyleAssignment(e); break;
        case Type::IfcProcedure: return new IfcProcedure(e); break;
        case Type::IfcProcedureType: return new IfcProcedureType(e); break;
        case Type::IfcProcess: return new IfcProcess(e); break;
        case Type::IfcProduct: return new IfcProduct(e); break;
        case Type::IfcProductDefinitionShape: return new IfcProductDefinitionShape(e); break;
        case Type::IfcProductRepresentation: return new IfcProductRepresentation(e); break;
        case Type::IfcProfileDef: return new IfcProfileDef(e); break;
        case Type::IfcProfileProperties: return new IfcProfileProperties(e); break;
        case Type::IfcProject: return new IfcProject(e); break;
        case Type::IfcProjectLibrary: return new IfcProjectLibrary(e); break;
        case Type::IfcProjectOrder: return new IfcProjectOrder(e); break;
        case Type::IfcProjectedCRS: return new IfcProjectedCRS(e); break;
        case Type::IfcProjectionElement: return new IfcProjectionElement(e); break;
        case Type::IfcProperty: return new IfcProperty(e); break;
        case Type::IfcPropertyAbstraction: return new IfcPropertyAbstraction(e); break;
        case Type::IfcPropertyBoundedValue: return new IfcPropertyBoundedValue(e); break;
        case Type::IfcPropertyDefinition: return new IfcPropertyDefinition(e); break;
        case Type::IfcPropertyDependencyRelationship: return new IfcPropertyDependencyRelationship(e); break;
        case Type::IfcPropertyEnumeratedValue: return new IfcPropertyEnumeratedValue(e); break;
        case Type::IfcPropertyEnumeration: return new IfcPropertyEnumeration(e); break;
        case Type::IfcPropertyListValue: return new IfcPropertyListValue(e); break;
        case Type::IfcPropertyReferenceValue: return new IfcPropertyReferenceValue(e); break;
        case Type::IfcPropertySet: return new IfcPropertySet(e); break;
        case Type::IfcPropertySetDefinition: return new IfcPropertySetDefinition(e); break;
        case Type::IfcPropertySetTemplate: return new IfcPropertySetTemplate(e); break;
        case Type::IfcPropertySingleValue: return new IfcPropertySingleValue(e); break;
        case Type::IfcPropertyTableValue: return new IfcPropertyTableValue(e); break;
        case Type::IfcPropertyTemplate: return new IfcPropertyTemplate(e); break;
        case Type::IfcPropertyTemplateDefinition: return new IfcPropertyTemplateDefinition(e); break;
        case Type::IfcProtectiveDevice: return new IfcProtectiveDevice(e); break;
        case Type::IfcProtectiveDeviceTrippingUnit: return new IfcProtectiveDeviceTrippingUnit(e); break;
        case Type::IfcProtectiveDeviceTrippingUnitType: return new IfcProtectiveDeviceTrippingUnitType(e); break;
        case Type::IfcProtectiveDeviceType: return new IfcProtectiveDeviceType(e); break;
        case Type::IfcProxy: return new IfcProxy(e); break;
        case Type::IfcPump: return new IfcPump(e); break;
        case Type::IfcPumpType: return new IfcPumpType(e); break;
        case Type::IfcQuantityArea: return new IfcQuantityArea(e); break;
        case Type::IfcQuantityCount: return new IfcQuantityCount(e); break;
        case Type::IfcQuantityLength: return new IfcQuantityLength(e); break;
        case Type::IfcQuantitySet: return new IfcQuantitySet(e); break;
        case Type::IfcQuantityTime: return new IfcQuantityTime(e); break;
        case Type::IfcQuantityVolume: return new IfcQuantityVolume(e); break;
        case Type::IfcQuantityWeight: return new IfcQuantityWeight(e); break;
        case Type::IfcRailing: return new IfcRailing(e); break;
        case Type::IfcRailingType: return new IfcRailingType(e); break;
        case Type::IfcRamp: return new IfcRamp(e); break;
        case Type::IfcRampFlight: return new IfcRampFlight(e); break;
        case Type::IfcRampFlightType: return new IfcRampFlightType(e); break;
        case Type::IfcRampType: return new IfcRampType(e); break;
        case Type::IfcRationalBSplineCurveWithKnots: return new IfcRationalBSplineCurveWithKnots(e); break;
        case Type::IfcRationalBSplineSurfaceWithKnots: return new IfcRationalBSplineSurfaceWithKnots(e); break;
        case Type::IfcRectangleHollowProfileDef: return new IfcRectangleHollowProfileDef(e); break;
        case Type::IfcRectangleProfileDef: return new IfcRectangleProfileDef(e); break;
        case Type::IfcRectangularPyramid: return new IfcRectangularPyramid(e); break;
        case Type::IfcRectangularTrimmedSurface: return new IfcRectangularTrimmedSurface(e); break;
        case Type::IfcRecurrencePattern: return new IfcRecurrencePattern(e); break;
        case Type::IfcReference: return new IfcReference(e); break;
        case Type::IfcRegularTimeSeries: return new IfcRegularTimeSeries(e); break;
        case Type::IfcReinforcementBarProperties: return new IfcReinforcementBarProperties(e); break;
        case Type::IfcReinforcementDefinitionProperties: return new IfcReinforcementDefinitionProperties(e); break;
        case Type::IfcReinforcingBar: return new IfcReinforcingBar(e); break;
        case Type::IfcReinforcingBarType: return new IfcReinforcingBarType(e); break;
        case Type::IfcReinforcingElement: return new IfcReinforcingElement(e); break;
        case Type::IfcReinforcingElementType: return new IfcReinforcingElementType(e); break;
        case Type::IfcReinforcingMesh: return new IfcReinforcingMesh(e); break;
        case Type::IfcReinforcingMeshType: return new IfcReinforcingMeshType(e); break;
        case Type::IfcRelAggregates: return new IfcRelAggregates(e); break;
        case Type::IfcRelAssigns: return new IfcRelAssigns(e); break;
        case Type::IfcRelAssignsToActor: return new IfcRelAssignsToActor(e); break;
        case Type::IfcRelAssignsToControl: return new IfcRelAssignsToControl(e); break;
        case Type::IfcRelAssignsToGroup: return new IfcRelAssignsToGroup(e); break;
        case Type::IfcRelAssignsToGroupByFactor: return new IfcRelAssignsToGroupByFactor(e); break;
        case Type::IfcRelAssignsToProcess: return new IfcRelAssignsToProcess(e); break;
        case Type::IfcRelAssignsToProduct: return new IfcRelAssignsToProduct(e); break;
        case Type::IfcRelAssignsToResource: return new IfcRelAssignsToResource(e); break;
        case Type::IfcRelAssociates: return new IfcRelAssociates(e); break;
        case Type::IfcRelAssociatesApproval: return new IfcRelAssociatesApproval(e); break;
        case Type::IfcRelAssociatesClassification: return new IfcRelAssociatesClassification(e); break;
        case Type::IfcRelAssociatesConstraint: return new IfcRelAssociatesConstraint(e); break;
        case Type::IfcRelAssociatesDocument: return new IfcRelAssociatesDocument(e); break;
        case Type::IfcRelAssociatesLibrary: return new IfcRelAssociatesLibrary(e); break;
        case Type::IfcRelAssociatesMaterial: return new IfcRelAssociatesMaterial(e); break;
        case Type::IfcRelConnects: return new IfcRelConnects(e); break;
        case Type::IfcRelConnectsElements: return new IfcRelConnectsElements(e); break;
        case Type::IfcRelConnectsPathElements: return new IfcRelConnectsPathElements(e); break;
        case Type::IfcRelConnectsPortToElement: return new IfcRelConnectsPortToElement(e); break;
        case Type::IfcRelConnectsPorts: return new IfcRelConnectsPorts(e); break;
        case Type::IfcRelConnectsStructuralActivity: return new IfcRelConnectsStructuralActivity(e); break;
        case Type::IfcRelConnectsStructuralMember: return new IfcRelConnectsStructuralMember(e); break;
        case Type::IfcRelConnectsWithEccentricity: return new IfcRelConnectsWithEccentricity(e); break;
        case Type::IfcRelConnectsWithRealizingElements: return new IfcRelConnectsWithRealizingElements(e); break;
        case Type::IfcRelContainedInSpatialStructure: return new IfcRelContainedInSpatialStructure(e); break;
        case Type::IfcRelCoversBldgElements: return new IfcRelCoversBldgElements(e); break;
        case Type::IfcRelCoversSpaces: return new IfcRelCoversSpaces(e); break;
        case Type::IfcRelDeclares: return new IfcRelDeclares(e); break;
        case Type::IfcRelDecomposes: return new IfcRelDecomposes(e); break;
        case Type::IfcRelDefines: return new IfcRelDefines(e); break;
        case Type::IfcRelDefinesByObject: return new IfcRelDefinesByObject(e); break;
        case Type::IfcRelDefinesByProperties: return new IfcRelDefinesByProperties(e); break;
        case Type::IfcRelDefinesByTemplate: return new IfcRelDefinesByTemplate(e); break;
        case Type::IfcRelDefinesByType: return new IfcRelDefinesByType(e); break;
        case Type::IfcRelFillsElement: return new IfcRelFillsElement(e); break;
        case Type::IfcRelFlowControlElements: return new IfcRelFlowControlElements(e); break;
        case Type::IfcRelInterferesElements: return new IfcRelInterferesElements(e); break;
        case Type::IfcRelNests: return new IfcRelNests(e); break;
        case Type::IfcRelProjectsElement: return new IfcRelProjectsElement(e); break;
        case Type::IfcRelReferencedInSpatialStructure: return new IfcRelReferencedInSpatialStructure(e); break;
        case Type::IfcRelSequence: return new IfcRelSequence(e); break;
        case Type::IfcRelServicesBuildings: return new IfcRelServicesBuildings(e); break;
        case Type::IfcRelSpaceBoundary: return new IfcRelSpaceBoundary(e); break;
        case Type::IfcRelSpaceBoundary1stLevel: return new IfcRelSpaceBoundary1stLevel(e); break;
        case Type::IfcRelSpaceBoundary2ndLevel: return new IfcRelSpaceBoundary2ndLevel(e); break;
        case Type::IfcRelVoidsElement: return new IfcRelVoidsElement(e); break;
        case Type::IfcRelationship: return new IfcRelationship(e); break;
        case Type::IfcReparametrisedCompositeCurveSegment: return new IfcReparametrisedCompositeCurveSegment(e); break;
        case Type::IfcRepresentation: return new IfcRepresentation(e); break;
        case Type::IfcRepresentationContext: return new IfcRepresentationContext(e); break;
        case Type::IfcRepresentationItem: return new IfcRepresentationItem(e); break;
        case Type::IfcRepresentationMap: return new IfcRepresentationMap(e); break;
        case Type::IfcResource: return new IfcResource(e); break;
        case Type::IfcResourceApprovalRelationship: return new IfcResourceApprovalRelationship(e); break;
        case Type::IfcResourceConstraintRelationship: return new IfcResourceConstraintRelationship(e); break;
        case Type::IfcResourceLevelRelationship: return new IfcResourceLevelRelationship(e); break;
        case Type::IfcResourceTime: return new IfcResourceTime(e); break;
        case Type::IfcRevolvedAreaSolid: return new IfcRevolvedAreaSolid(e); break;
        case Type::IfcRevolvedAreaSolidTapered: return new IfcRevolvedAreaSolidTapered(e); break;
        case Type::IfcRightCircularCone: return new IfcRightCircularCone(e); break;
        case Type::IfcRightCircularCylinder: return new IfcRightCircularCylinder(e); break;
        case Type::IfcRoof: return new IfcRoof(e); break;
        case Type::IfcRoofType: return new IfcRoofType(e); break;
        case Type::IfcRoot: return new IfcRoot(e); break;
        case Type::IfcRoundedRectangleProfileDef: return new IfcRoundedRectangleProfileDef(e); break;
        case Type::IfcSIUnit: return new IfcSIUnit(e); break;
        case Type::IfcSanitaryTerminal: return new IfcSanitaryTerminal(e); break;
        case Type::IfcSanitaryTerminalType: return new IfcSanitaryTerminalType(e); break;
        case Type::IfcSchedulingTime: return new IfcSchedulingTime(e); break;
        case Type::IfcSectionProperties: return new IfcSectionProperties(e); break;
        case Type::IfcSectionReinforcementProperties: return new IfcSectionReinforcementProperties(e); break;
        case Type::IfcSectionedSpine: return new IfcSectionedSpine(e); break;
        case Type::IfcSensor: return new IfcSensor(e); break;
        case Type::IfcSensorType: return new IfcSensorType(e); break;
        case Type::IfcShadingDevice: return new IfcShadingDevice(e); break;
        case Type::IfcShadingDeviceType: return new IfcShadingDeviceType(e); break;
        case Type::IfcShapeAspect: return new IfcShapeAspect(e); break;
        case Type::IfcShapeModel: return new IfcShapeModel(e); break;
        case Type::IfcShapeRepresentation: return new IfcShapeRepresentation(e); break;
        case Type::IfcShellBasedSurfaceModel: return new IfcShellBasedSurfaceModel(e); break;
        case Type::IfcSimpleProperty: return new IfcSimpleProperty(e); break;
        case Type::IfcSimplePropertyTemplate: return new IfcSimplePropertyTemplate(e); break;
        case Type::IfcSite: return new IfcSite(e); break;
        case Type::IfcSlab: return new IfcSlab(e); break;
        case Type::IfcSlabElementedCase: return new IfcSlabElementedCase(e); break;
        case Type::IfcSlabStandardCase: return new IfcSlabStandardCase(e); break;
        case Type::IfcSlabType: return new IfcSlabType(e); break;
        case Type::IfcSlippageConnectionCondition: return new IfcSlippageConnectionCondition(e); break;
        case Type::IfcSolarDevice: return new IfcSolarDevice(e); break;
        case Type::IfcSolarDeviceType: return new IfcSolarDeviceType(e); break;
        case Type::IfcSolidModel: return new IfcSolidModel(e); break;
        case Type::IfcSpace: return new IfcSpace(e); break;
        case Type::IfcSpaceHeater: return new IfcSpaceHeater(e); break;
        case Type::IfcSpaceHeaterType: return new IfcSpaceHeaterType(e); break;
        case Type::IfcSpaceType: return new IfcSpaceType(e); break;
        case Type::IfcSpatialElement: return new IfcSpatialElement(e); break;
        case Type::IfcSpatialElementType: return new IfcSpatialElementType(e); break;
        case Type::IfcSpatialStructureElement: return new IfcSpatialStructureElement(e); break;
        case Type::IfcSpatialStructureElementType: return new IfcSpatialStructureElementType(e); break;
        case Type::IfcSpatialZone: return new IfcSpatialZone(e); break;
        case Type::IfcSpatialZoneType: return new IfcSpatialZoneType(e); break;
        case Type::IfcSphere: return new IfcSphere(e); break;
        case Type::IfcStackTerminal: return new IfcStackTerminal(e); break;
        case Type::IfcStackTerminalType: return new IfcStackTerminalType(e); break;
        case Type::IfcStair: return new IfcStair(e); break;
        case Type::IfcStairFlight: return new IfcStairFlight(e); break;
        case Type::IfcStairFlightType: return new IfcStairFlightType(e); break;
        case Type::IfcStairType: return new IfcStairType(e); break;
        case Type::IfcStructuralAction: return new IfcStructuralAction(e); break;
        case Type::IfcStructuralActivity: return new IfcStructuralActivity(e); break;
        case Type::IfcStructuralAnalysisModel: return new IfcStructuralAnalysisModel(e); break;
        case Type::IfcStructuralConnection: return new IfcStructuralConnection(e); break;
        case Type::IfcStructuralConnectionCondition: return new IfcStructuralConnectionCondition(e); break;
        case Type::IfcStructuralCurveAction: return new IfcStructuralCurveAction(e); break;
        case Type::IfcStructuralCurveConnection: return new IfcStructuralCurveConnection(e); break;
        case Type::IfcStructuralCurveMember: return new IfcStructuralCurveMember(e); break;
        case Type::IfcStructuralCurveMemberVarying: return new IfcStructuralCurveMemberVarying(e); break;
        case Type::IfcStructuralCurveReaction: return new IfcStructuralCurveReaction(e); break;
        case Type::IfcStructuralItem: return new IfcStructuralItem(e); break;
        case Type::IfcStructuralLinearAction: return new IfcStructuralLinearAction(e); break;
        case Type::IfcStructuralLoad: return new IfcStructuralLoad(e); break;
        case Type::IfcStructuralLoadCase: return new IfcStructuralLoadCase(e); break;
        case Type::IfcStructuralLoadConfiguration: return new IfcStructuralLoadConfiguration(e); break;
        case Type::IfcStructuralLoadGroup: return new IfcStructuralLoadGroup(e); break;
        case Type::IfcStructuralLoadLinearForce: return new IfcStructuralLoadLinearForce(e); break;
        case Type::IfcStructuralLoadOrResult: return new IfcStructuralLoadOrResult(e); break;
        case Type::IfcStructuralLoadPlanarForce: return new IfcStructuralLoadPlanarForce(e); break;
        case Type::IfcStructuralLoadSingleDisplacement: return new IfcStructuralLoadSingleDisplacement(e); break;
        case Type::IfcStructuralLoadSingleDisplacementDistortion: return new IfcStructuralLoadSingleDisplacementDistortion(e); break;
        case Type::IfcStructuralLoadSingleForce: return new IfcStructuralLoadSingleForce(e); break;
        case Type::IfcStructuralLoadSingleForceWarping: return new IfcStructuralLoadSingleForceWarping(e); break;
        case Type::IfcStructuralLoadStatic: return new IfcStructuralLoadStatic(e); break;
        case Type::IfcStructuralLoadTemperature: return new IfcStructuralLoadTemperature(e); break;
        case Type::IfcStructuralMember: return new IfcStructuralMember(e); break;
        case Type::IfcStructuralPlanarAction: return new IfcStructuralPlanarAction(e); break;
        case Type::IfcStructuralPointAction: return new IfcStructuralPointAction(e); break;
        case Type::IfcStructuralPointConnection: return new IfcStructuralPointConnection(e); break;
        case Type::IfcStructuralPointReaction: return new IfcStructuralPointReaction(e); break;
        case Type::IfcStructuralReaction: return new IfcStructuralReaction(e); break;
        case Type::IfcStructuralResultGroup: return new IfcStructuralResultGroup(e); break;
        case Type::IfcStructuralSurfaceAction: return new IfcStructuralSurfaceAction(e); break;
        case Type::IfcStructuralSurfaceConnection: return new IfcStructuralSurfaceConnection(e); break;
        case Type::IfcStructuralSurfaceMember: return new IfcStructuralSurfaceMember(e); break;
        case Type::IfcStructuralSurfaceMemberVarying: return new IfcStructuralSurfaceMemberVarying(e); break;
        case Type::IfcStructuralSurfaceReaction: return new IfcStructuralSurfaceReaction(e); break;
        case Type::IfcStyleModel: return new IfcStyleModel(e); break;
        case Type::IfcStyledItem: return new IfcStyledItem(e); break;
        case Type::IfcStyledRepresentation: return new IfcStyledRepresentation(e); break;
        case Type::IfcSubContractResource: return new IfcSubContractResource(e); break;
        case Type::IfcSubContractResourceType: return new IfcSubContractResourceType(e); break;
        case Type::IfcSubedge: return new IfcSubedge(e); break;
        case Type::IfcSurface: return new IfcSurface(e); break;
        case Type::IfcSurfaceCurveSweptAreaSolid: return new IfcSurfaceCurveSweptAreaSolid(e); break;
        case Type::IfcSurfaceFeature: return new IfcSurfaceFeature(e); break;
        case Type::IfcSurfaceOfLinearExtrusion: return new IfcSurfaceOfLinearExtrusion(e); break;
        case Type::IfcSurfaceOfRevolution: return new IfcSurfaceOfRevolution(e); break;
        case Type::IfcSurfaceReinforcementArea: return new IfcSurfaceReinforcementArea(e); break;
        case Type::IfcSurfaceStyle: return new IfcSurfaceStyle(e); break;
        case Type::IfcSurfaceStyleLighting: return new IfcSurfaceStyleLighting(e); break;
        case Type::IfcSurfaceStyleRefraction: return new IfcSurfaceStyleRefraction(e); break;
        case Type::IfcSurfaceStyleRendering: return new IfcSurfaceStyleRendering(e); break;
        case Type::IfcSurfaceStyleShading: return new IfcSurfaceStyleShading(e); break;
        case Type::IfcSurfaceStyleWithTextures: return new IfcSurfaceStyleWithTextures(e); break;
        case Type::IfcSurfaceTexture: return new IfcSurfaceTexture(e); break;
        case Type::IfcSweptAreaSolid: return new IfcSweptAreaSolid(e); break;
        case Type::IfcSweptDiskSolid: return new IfcSweptDiskSolid(e); break;
        case Type::IfcSweptDiskSolidPolygonal: return new IfcSweptDiskSolidPolygonal(e); break;
        case Type::IfcSweptSurface: return new IfcSweptSurface(e); break;
        case Type::IfcSwitchingDevice: return new IfcSwitchingDevice(e); break;
        case Type::IfcSwitchingDeviceType: return new IfcSwitchingDeviceType(e); break;
        case Type::IfcSystem: return new IfcSystem(e); break;
        case Type::IfcSystemFurnitureElement: return new IfcSystemFurnitureElement(e); break;
        case Type::IfcSystemFurnitureElementType: return new IfcSystemFurnitureElementType(e); break;
        case Type::IfcTShapeProfileDef: return new IfcTShapeProfileDef(e); break;
        case Type::IfcTable: return new IfcTable(e); break;
        case Type::IfcTableColumn: return new IfcTableColumn(e); break;
        case Type::IfcTableRow: return new IfcTableRow(e); break;
        case Type::IfcTank: return new IfcTank(e); break;
        case Type::IfcTankType: return new IfcTankType(e); break;
        case Type::IfcTask: return new IfcTask(e); break;
        case Type::IfcTaskTime: return new IfcTaskTime(e); break;
        case Type::IfcTaskTimeRecurring: return new IfcTaskTimeRecurring(e); break;
        case Type::IfcTaskType: return new IfcTaskType(e); break;
        case Type::IfcTelecomAddress: return new IfcTelecomAddress(e); break;
        case Type::IfcTendon: return new IfcTendon(e); break;
        case Type::IfcTendonAnchor: return new IfcTendonAnchor(e); break;
        case Type::IfcTendonAnchorType: return new IfcTendonAnchorType(e); break;
        case Type::IfcTendonType: return new IfcTendonType(e); break;
        case Type::IfcTessellatedFaceSet: return new IfcTessellatedFaceSet(e); break;
        case Type::IfcTessellatedItem: return new IfcTessellatedItem(e); break;
        case Type::IfcTextLiteral: return new IfcTextLiteral(e); break;
        case Type::IfcTextLiteralWithExtent: return new IfcTextLiteralWithExtent(e); break;
        case Type::IfcTextStyle: return new IfcTextStyle(e); break;
        case Type::IfcTextStyleFontModel: return new IfcTextStyleFontModel(e); break;
        case Type::IfcTextStyleForDefinedFont: return new IfcTextStyleForDefinedFont(e); break;
        case Type::IfcTextStyleTextModel: return new IfcTextStyleTextModel(e); break;
        case Type::IfcTextureCoordinate: return new IfcTextureCoordinate(e); break;
        case Type::IfcTextureCoordinateGenerator: return new IfcTextureCoordinateGenerator(e); break;
        case Type::IfcTextureMap: return new IfcTextureMap(e); break;
        case Type::IfcTextureVertex: return new IfcTextureVertex(e); break;
        case Type::IfcTextureVertexList: return new IfcTextureVertexList(e); break;
        case Type::IfcTimePeriod: return new IfcTimePeriod(e); break;
        case Type::IfcTimeSeries: return new IfcTimeSeries(e); break;
        case Type::IfcTimeSeriesValue: return new IfcTimeSeriesValue(e); break;
        case Type::IfcTopologicalRepresentationItem: return new IfcTopologicalRepresentationItem(e); break;
        case Type::IfcTopologyRepresentation: return new IfcTopologyRepresentation(e); break;
        case Type::IfcTransformer: return new IfcTransformer(e); break;
        case Type::IfcTransformerType: return new IfcTransformerType(e); break;
        case Type::IfcTransportElement: return new IfcTransportElement(e); break;
        case Type::IfcTransportElementType: return new IfcTransportElementType(e); break;
        case Type::IfcTrapeziumProfileDef: return new IfcTrapeziumProfileDef(e); break;
        case Type::IfcTriangulatedFaceSet: return new IfcTriangulatedFaceSet(e); break;
        case Type::IfcTrimmedCurve: return new IfcTrimmedCurve(e); break;
        case Type::IfcTubeBundle: return new IfcTubeBundle(e); break;
        case Type::IfcTubeBundleType: return new IfcTubeBundleType(e); break;
        case Type::IfcTypeObject: return new IfcTypeObject(e); break;
        case Type::IfcTypeProcess: return new IfcTypeProcess(e); break;
        case Type::IfcTypeProduct: return new IfcTypeProduct(e); break;
        case Type::IfcTypeResource: return new IfcTypeResource(e); break;
        case Type::IfcUShapeProfileDef: return new IfcUShapeProfileDef(e); break;
        case Type::IfcUnitAssignment: return new IfcUnitAssignment(e); break;
        case Type::IfcUnitaryControlElement: return new IfcUnitaryControlElement(e); break;
        case Type::IfcUnitaryControlElementType: return new IfcUnitaryControlElementType(e); break;
        case Type::IfcUnitaryEquipment: return new IfcUnitaryEquipment(e); break;
        case Type::IfcUnitaryEquipmentType: return new IfcUnitaryEquipmentType(e); break;
        case Type::IfcValve: return new IfcValve(e); break;
        case Type::IfcValveType: return new IfcValveType(e); break;
        case Type::IfcVector: return new IfcVector(e); break;
        case Type::IfcVertex: return new IfcVertex(e); break;
        case Type::IfcVertexLoop: return new IfcVertexLoop(e); break;
        case Type::IfcVertexPoint: return new IfcVertexPoint(e); break;
        case Type::IfcVibrationIsolator: return new IfcVibrationIsolator(e); break;
        case Type::IfcVibrationIsolatorType: return new IfcVibrationIsolatorType(e); break;
        case Type::IfcVirtualElement: return new IfcVirtualElement(e); break;
        case Type::IfcVirtualGridIntersection: return new IfcVirtualGridIntersection(e); break;
        case Type::IfcVoidingFeature: return new IfcVoidingFeature(e); break;
        case Type::IfcWall: return new IfcWall(e); break;
        case Type::IfcWallElementedCase: return new IfcWallElementedCase(e); break;
        case Type::IfcWallStandardCase: return new IfcWallStandardCase(e); break;
        case Type::IfcWallType: return new IfcWallType(e); break;
        case Type::IfcWasteTerminal: return new IfcWasteTerminal(e); break;
        case Type::IfcWasteTerminalType: return new IfcWasteTerminalType(e); break;
        case Type::IfcWindow: return new IfcWindow(e); break;
        case Type::IfcWindowLiningProperties: return new IfcWindowLiningProperties(e); break;
        case Type::IfcWindowPanelProperties: return new IfcWindowPanelProperties(e); break;
        case Type::IfcWindowStandardCase: return new IfcWindowStandardCase(e); break;
        case Type::IfcWindowStyle: return new IfcWindowStyle(e); break;
        case Type::IfcWindowType: return new IfcWindowType(e); break;
        case Type::IfcWorkCalendar: return new IfcWorkCalendar(e); break;
        case Type::IfcWorkControl: return new IfcWorkControl(e); break;
        case Type::IfcWorkPlan: return new IfcWorkPlan(e); break;
        case Type::IfcWorkSchedule: return new IfcWorkSchedule(e); break;
        case Type::IfcWorkTime: return new IfcWorkTime(e); break;
        case Type::IfcZShapeProfileDef: return new IfcZShapeProfileDef(e); break;
        case Type::IfcZone: return new IfcZone(e); break;
        default: throw IfcException("Unable to find find keyword in schema"); break; 
    }
}

std::string Type::ToString(Enum v) {
    if (v < 0 || v >= 882) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "IfcAbsorbedDoseMeasure", "IfcAccelerationMeasure", "IfcAmountOfSubstanceMeasure", "IfcAngularVelocityMeasure", "IfcAreaDensityMeasure", "IfcAreaMeasure", "IfcBoolean", "IfcColour", "IfcComplexNumber", "IfcCompoundPlaneAngleMeasure", "IfcContextDependentMeasure", "IfcCountMeasure", "IfcCurvatureMeasure", "IfcCurveStyleFontSelect", "IfcDate", "IfcDateTime", "IfcDerivedMeasureValue", "IfcDescriptiveMeasure", "IfcDoseEquivalentMeasure", "IfcDuration", "IfcDynamicViscosityMeasure", "IfcElectricCapacitanceMeasure", "IfcElectricChargeMeasure", "IfcElectricConductanceMeasure", "IfcElectricCurrentMeasure", "IfcElectricResistanceMeasure", "IfcElectricVoltageMeasure", "IfcEnergyMeasure", "IfcForceMeasure", "IfcFrequencyMeasure", "IfcHeatFluxDensityMeasure", "IfcHeatingValueMeasure", "IfcIdentifier", "IfcIlluminanceMeasure", "IfcInductanceMeasure", "IfcInteger", "IfcIntegerCountRateMeasure", "IfcIonConcentrationMeasure", "IfcIsothermalMoistureCapacityMeasure", "IfcKinematicViscosityMeasure", "IfcLabel", "IfcLengthMeasure", "IfcLinearForceMeasure", "IfcLinearMomentMeasure", "IfcLinearStiffnessMeasure", "IfcLinearVelocityMeasure", "IfcLogical", "IfcLuminousFluxMeasure", "IfcLuminousIntensityDistributionMeasure", "IfcLuminousIntensityMeasure", "IfcMagneticFluxDensityMeasure", "IfcMagneticFluxMeasure", "IfcMassDensityMeasure", "IfcMassFlowRateMeasure", "IfcMassMeasure", "IfcMassPerLengthMeasure", "IfcMeasureValue", "IfcModulusOfElasticityMeasure", "IfcModulusOfLinearSubgradeReactionMeasure", "IfcModulusOfRotationalSubgradeReactionMeasure", "IfcModulusOfSubgradeReactionMeasure", "IfcMoistureDiffusivityMeasure", "IfcMolecularWeightMeasure", "IfcMomentOfInertiaMeasure", "IfcMonetaryMeasure", "IfcNonNegativeLengthMeasure", "IfcNormalisedRatioMeasure", "IfcNullStyle", "IfcNumericMeasure", "IfcPHMeasure", "IfcParameterValue", "IfcPlanarForceMeasure", "IfcPlaneAngleMeasure", "IfcPositiveLengthMeasure", "IfcPositivePlaneAngleMeasure", "IfcPositiveRatioMeasure", "IfcPowerMeasure", "IfcPressureMeasure", "IfcPropertySetDefinitionSet", "IfcRadioActivityMeasure", "IfcRatioMeasure", "IfcReal", "IfcRotationalFrequencyMeasure", "IfcRotationalMassMeasure", "IfcRotationalStiffnessMeasure", "IfcSectionModulusMeasure", "IfcSectionalAreaIntegralMeasure", "IfcShearModulusMeasure", "IfcSimpleValue", "IfcSolidAngleMeasure", "IfcSoundPowerLevelMeasure", "IfcSoundPowerMeasure", "IfcSoundPressureLevelMeasure", "IfcSoundPressureMeasure", "IfcSpecificHeatCapacityMeasure", "IfcSpecularExponent", "IfcSpecularRoughness", "IfcTemperatureGradientMeasure", "IfcTemperatureRateOfChangeMeasure", "IfcText", "IfcThermalAdmittanceMeasure", "IfcThermalConductivityMeasure", "IfcThermalExpansionCoefficientMeasure", "IfcThermalResistanceMeasure", "IfcThermalTransmittanceMeasure", "IfcThermodynamicTemperatureMeasure", "IfcTime", "IfcTimeMeasure", "IfcTimeStamp", "IfcTorqueMeasure", "IfcValue", "IfcVaporPermeabilityMeasure", "IfcVolumeMeasure", "IfcVolumetricFlowRateMeasure", "IfcWarpingConstantMeasure", "IfcWarpingMomentMeasure", "IfcActionRequest", "IfcActor", "IfcActorRole", "IfcActuator", "IfcActuatorType", "IfcAddress", "IfcAdvancedBrep", "IfcAdvancedBrepWithVoids", "IfcAdvancedFace", "IfcAirTerminal", "IfcAirTerminalBox", "IfcAirTerminalBoxType", "IfcAirTerminalType", "IfcAirToAirHeatRecovery", "IfcAirToAirHeatRecoveryType", "IfcAlarm", "IfcAlarmType", "IfcAnnotation", "IfcAnnotationFillArea", "IfcApplication", "IfcAppliedValue", "IfcApproval", "IfcApprovalRelationship", "IfcArbitraryClosedProfileDef", "IfcArbitraryOpenProfileDef", "IfcArbitraryProfileDefWithVoids", "IfcAsset", "IfcAsymmetricIShapeProfileDef", "IfcAudioVisualAppliance", "IfcAudioVisualApplianceType", "IfcAxis1Placement", "IfcAxis2Placement2D", "IfcAxis2Placement3D", "IfcBSplineCurve", "IfcBSplineCurveWithKnots", "IfcBSplineSurface", "IfcBSplineSurfaceWithKnots", "IfcBeam", "IfcBeamStandardCase", "IfcBeamType", "IfcBlobTexture", "IfcBlock", "IfcBoiler", "IfcBoilerType", "IfcBooleanClippingResult", "IfcBooleanResult", "IfcBoundaryCondition", "IfcBoundaryCurve", "IfcBoundaryEdgeCondition", "IfcBoundaryFaceCondition", "IfcBoundaryNodeCondition", "IfcBoundaryNodeConditionWarping", "IfcBoundedCurve", "IfcBoundedSurface", "IfcBoundingBox", "IfcBoxedHalfSpace", "IfcBuilding", "IfcBuildingElement", "IfcBuildingElementPart", "IfcBuildingElementPartType", "IfcBuildingElementProxy", "IfcBuildingElementProxyType", "IfcBuildingElementType", "IfcBuildingStorey", "IfcBuildingSystem", "IfcBurner", "IfcBurnerType", "IfcCShapeProfileDef", "IfcCableCarrierFitting", "IfcCableCarrierFittingType", "IfcCableCarrierSegment", "IfcCableCarrierSegmentType", "IfcCableFitting", "IfcCableFittingType", "IfcCableSegment", "IfcCableSegmentType", "IfcCartesianPoint", "IfcCartesianPointList", "IfcCartesianPointList3D", "IfcCartesianTransformationOperator", "IfcCartesianTransformationOperator2D", "IfcCartesianTransformationOperator2DnonUniform", "IfcCartesianTransformationOperator3D", "IfcCartesianTransformationOperator3DnonUniform", "IfcCenterLineProfileDef", "IfcChiller", "IfcChillerType", "IfcChimney", "IfcChimneyType", "IfcCircle", "IfcCircleHollowProfileDef", "IfcCircleProfileDef", "IfcCivilElement", "IfcCivilElementType", "IfcClassification", "IfcClassificationReference", "IfcClosedShell", "IfcCoil", "IfcCoilType", "IfcColourRgb", "IfcColourRgbList", "IfcColourSpecification", "IfcColumn", "IfcColumnStandardCase", "IfcColumnType", "IfcCommunicationsAppliance", "IfcCommunicationsApplianceType", "IfcComplexProperty", "IfcComplexPropertyTemplate", "IfcCompositeCurve", "IfcCompositeCurveOnSurface", "IfcCompositeCurveSegment", "IfcCompositeProfileDef", "IfcCompressor", "IfcCompressorType", "IfcCondenser", "IfcCondenserType", "IfcConic", "IfcConnectedFaceSet", "IfcConnectionCurveGeometry", "IfcConnectionGeometry", "IfcConnectionPointEccentricity", "IfcConnectionPointGeometry", "IfcConnectionSurfaceGeometry", "IfcConnectionVolumeGeometry", "IfcConstraint", "IfcConstructionEquipmentResource", "IfcConstructionEquipmentResourceType", "IfcConstructionMaterialResource", "IfcConstructionMaterialResourceType", "IfcConstructionProductResource", "IfcConstructionProductResourceType", "IfcConstructionResource", "IfcConstructionResourceType", "IfcContext", "IfcContextDependentUnit", "IfcControl", "IfcController", "IfcControllerType", "IfcConversionBasedUnit", "IfcConversionBasedUnitWithOffset", "IfcCooledBeam", "IfcCooledBeamType", "IfcCoolingTower", "IfcCoolingTowerType", "IfcCoordinateOperation", "IfcCoordinateReferenceSystem", "IfcCostItem", "IfcCostSchedule", "IfcCostValue", "IfcCovering", "IfcCoveringType", "IfcCrewResource", "IfcCrewResourceType", "IfcCsgPrimitive3D", "IfcCsgSolid", "IfcCurrencyRelationship", "IfcCurtainWall", "IfcCurtainWallType", "IfcCurve", "IfcCurveBoundedPlane", "IfcCurveBoundedSurface", "IfcCurveStyle", "IfcCurveStyleFont", "IfcCurveStyleFontAndScaling", "IfcCurveStyleFontPattern", "IfcCylindricalSurface", "IfcDamper", "IfcDamperType", "IfcDerivedProfileDef", "IfcDerivedUnit", "IfcDerivedUnitElement", "IfcDimensionalExponents", "IfcDirection", "IfcDiscreteAccessory", "IfcDiscreteAccessoryType", "IfcDistributionChamberElement", "IfcDistributionChamberElementType", "IfcDistributionCircuit", "IfcDistributionControlElement", "IfcDistributionControlElementType", "IfcDistributionElement", "IfcDistributionElementType", "IfcDistributionFlowElement", "IfcDistributionFlowElementType", "IfcDistributionPort", "IfcDistributionSystem", "IfcDocumentInformation", "IfcDocumentInformationRelationship", "IfcDocumentReference", "IfcDoor", "IfcDoorLiningProperties", "IfcDoorPanelProperties", "IfcDoorStandardCase", "IfcDoorStyle", "IfcDoorType", "IfcDraughtingPreDefinedColour", "IfcDraughtingPreDefinedCurveFont", "IfcDuctFitting", "IfcDuctFittingType", "IfcDuctSegment", "IfcDuctSegmentType", "IfcDuctSilencer", "IfcDuctSilencerType", "IfcEdge", "IfcEdgeCurve", "IfcEdgeLoop", "IfcElectricAppliance", "IfcElectricApplianceType", "IfcElectricDistributionBoard", "IfcElectricDistributionBoardType", "IfcElectricFlowStorageDevice", "IfcElectricFlowStorageDeviceType", "IfcElectricGenerator", "IfcElectricGeneratorType", "IfcElectricMotor", "IfcElectricMotorType", "IfcElectricTimeControl", "IfcElectricTimeControlType", "IfcElement", "IfcElementAssembly", "IfcElementAssemblyType", "IfcElementComponent", "IfcElementComponentType", "IfcElementQuantity", "IfcElementType", "IfcElementarySurface", "IfcEllipse", "IfcEllipseProfileDef", "IfcEnergyConversionDevice", "IfcEnergyConversionDeviceType", "IfcEngine", "IfcEngineType", "IfcEvaporativeCooler", "IfcEvaporativeCoolerType", "IfcEvaporator", "IfcEvaporatorType", "IfcEvent", "IfcEventTime", "IfcEventType", "IfcExtendedProperties", "IfcExternalInformation", "IfcExternalReference", "IfcExternalReferenceRelationship", "IfcExternalSpatialElement", "IfcExternalSpatialStructureElement", "IfcExternallyDefinedHatchStyle", "IfcExternallyDefinedSurfaceStyle", "IfcExternallyDefinedTextFont", "IfcExtrudedAreaSolid", "IfcExtrudedAreaSolidTapered", "IfcFace", "IfcFaceBasedSurfaceModel", "IfcFaceBound", "IfcFaceOuterBound", "IfcFaceSurface", "IfcFacetedBrep", "IfcFacetedBrepWithVoids", "IfcFailureConnectionCondition", "IfcFan", "IfcFanType", "IfcFastener", "IfcFastenerType", "IfcFeatureElement", "IfcFeatureElementAddition", "IfcFeatureElementSubtraction", "IfcFillAreaStyle", "IfcFillAreaStyleHatching", "IfcFillAreaStyleTiles", "IfcFilter", "IfcFilterType", "IfcFireSuppressionTerminal", "IfcFireSuppressionTerminalType", "IfcFixedReferenceSweptAreaSolid", "IfcFlowController", "IfcFlowControllerType", "IfcFlowFitting", "IfcFlowFittingType", "IfcFlowInstrument", "IfcFlowInstrumentType", "IfcFlowMeter", "IfcFlowMeterType", "IfcFlowMovingDevice", "IfcFlowMovingDeviceType", "IfcFlowSegment", "IfcFlowSegmentType", "IfcFlowStorageDevice", "IfcFlowStorageDeviceType", "IfcFlowTerminal", "IfcFlowTerminalType", "IfcFlowTreatmentDevice", "IfcFlowTreatmentDeviceType", "IfcFooting", "IfcFootingType", "IfcFurnishingElement", "IfcFurnishingElementType", "IfcFurniture", "IfcFurnitureType", "IfcGeographicElement", "IfcGeographicElementType", "IfcGeometricCurveSet", "IfcGeometricRepresentationContext", "IfcGeometricRepresentationItem", "IfcGeometricRepresentationSubContext", "IfcGeometricSet", "IfcGrid", "IfcGridAxis", "IfcGridPlacement", "IfcGroup", "IfcHalfSpaceSolid", "IfcHeatExchanger", "IfcHeatExchangerType", "IfcHumidifier", "IfcHumidifierType", "IfcIShapeProfileDef", "IfcImageTexture", "IfcIndexedColourMap", "IfcIndexedTextureMap", "IfcIndexedTriangleTextureMap", "IfcInterceptor", "IfcInterceptorType", "IfcInventory", "IfcIrregularTimeSeries", "IfcIrregularTimeSeriesValue", "IfcJunctionBox", "IfcJunctionBoxType", "IfcLShapeProfileDef", "IfcLaborResource", "IfcLaborResourceType", "IfcLagTime", "IfcLamp", "IfcLampType", "IfcLibraryInformation", "IfcLibraryReference", "IfcLightDistributionData", "IfcLightFixture", "IfcLightFixtureType", "IfcLightIntensityDistribution", "IfcLightSource", "IfcLightSourceAmbient", "IfcLightSourceDirectional", "IfcLightSourceGoniometric", "IfcLightSourcePositional", "IfcLightSourceSpot", "IfcLine", "IfcLocalPlacement", "IfcLoop", "IfcManifoldSolidBrep", "IfcMapConversion", "IfcMappedItem", "IfcMaterial", "IfcMaterialClassificationRelationship", "IfcMaterialConstituent", "IfcMaterialConstituentSet", "IfcMaterialDefinition", "IfcMaterialDefinitionRepresentation", "IfcMaterialLayer", "IfcMaterialLayerSet", "IfcMaterialLayerSetUsage", "IfcMaterialLayerWithOffsets", "IfcMaterialList", "IfcMaterialProfile", "IfcMaterialProfileSet", "IfcMaterialProfileSetUsage", "IfcMaterialProfileSetUsageTapering", "IfcMaterialProfileWithOffsets", "IfcMaterialProperties", "IfcMaterialRelationship", "IfcMaterialUsageDefinition", "IfcMeasureWithUnit", "IfcMechanicalFastener", "IfcMechanicalFastenerType", "IfcMedicalDevice", "IfcMedicalDeviceType", "IfcMember", "IfcMemberStandardCase", "IfcMemberType", "IfcMetric", "IfcMirroredProfileDef", "IfcMonetaryUnit", "IfcMotorConnection", "IfcMotorConnectionType", "IfcNamedUnit", "IfcObject", "IfcObjectDefinition", "IfcObjectPlacement", "IfcObjective", "IfcOccupant", "IfcOffsetCurve2D", "IfcOffsetCurve3D", "IfcOpenShell", "IfcOpeningElement", "IfcOpeningStandardCase", "IfcOrganization", "IfcOrganizationRelationship", "IfcOrientedEdge", "IfcOuterBoundaryCurve", "IfcOutlet", "IfcOutletType", "IfcOwnerHistory", "IfcParameterizedProfileDef", "IfcPath", "IfcPcurve", "IfcPerformanceHistory", "IfcPermeableCoveringProperties", "IfcPermit", "IfcPerson", "IfcPersonAndOrganization", "IfcPhysicalComplexQuantity", "IfcPhysicalQuantity", "IfcPhysicalSimpleQuantity", "IfcPile", "IfcPileType", "IfcPipeFitting", "IfcPipeFittingType", "IfcPipeSegment", "IfcPipeSegmentType", "IfcPixelTexture", "IfcPlacement", "IfcPlanarBox", "IfcPlanarExtent", "IfcPlane", "IfcPlate", "IfcPlateStandardCase", "IfcPlateType", "IfcPoint", "IfcPointOnCurve", "IfcPointOnSurface", "IfcPolyLoop", "IfcPolygonalBoundedHalfSpace", "IfcPolyline", "IfcPort", "IfcPostalAddress", "IfcPreDefinedColour", "IfcPreDefinedCurveFont", "IfcPreDefinedItem", "IfcPreDefinedProperties", "IfcPreDefinedPropertySet", "IfcPreDefinedTextFont", "IfcPresentationItem", "IfcPresentationLayerAssignment", "IfcPresentationLayerWithStyle", "IfcPresentationStyle", "IfcPresentationStyleAssignment", "IfcProcedure", "IfcProcedureType", "IfcProcess", "IfcProduct", "IfcProductDefinitionShape", "IfcProductRepresentation", "IfcProfileDef", "IfcProfileProperties", "IfcProject", "IfcProjectLibrary", "IfcProjectOrder", "IfcProjectedCRS", "IfcProjectionElement", "IfcProperty", "IfcPropertyAbstraction", "IfcPropertyBoundedValue", "IfcPropertyDefinition", "IfcPropertyDependencyRelationship", "IfcPropertyEnumeratedValue", "IfcPropertyEnumeration", "IfcPropertyListValue", "IfcPropertyReferenceValue", "IfcPropertySet", "IfcPropertySetDefinition", "IfcPropertySetTemplate", "IfcPropertySingleValue", "IfcPropertyTableValue", "IfcPropertyTemplate", "IfcPropertyTemplateDefinition", "IfcProtectiveDevice", "IfcProtectiveDeviceTrippingUnit", "IfcProtectiveDeviceTrippingUnitType", "IfcProtectiveDeviceType", "IfcProxy", "IfcPump", "IfcPumpType", "IfcQuantityArea", "IfcQuantityCount", "IfcQuantityLength", "IfcQuantitySet", "IfcQuantityTime", "IfcQuantityVolume", "IfcQuantityWeight", "IfcRailing", "IfcRailingType", "IfcRamp", "IfcRampFlight", "IfcRampFlightType", "IfcRampType", "IfcRationalBSplineCurveWithKnots", "IfcRationalBSplineSurfaceWithKnots", "IfcRectangleHollowProfileDef", "IfcRectangleProfileDef", "IfcRectangularPyramid", "IfcRectangularTrimmedSurface", "IfcRecurrencePattern", "IfcReference", "IfcRegularTimeSeries", "IfcReinforcementBarProperties", "IfcReinforcementDefinitionProperties", "IfcReinforcingBar", "IfcReinforcingBarType", "IfcReinforcingElement", "IfcReinforcingElementType", "IfcReinforcingMesh", "IfcReinforcingMeshType", "IfcRelAggregates", "IfcRelAssigns", "IfcRelAssignsToActor", "IfcRelAssignsToControl", "IfcRelAssignsToGroup", "IfcRelAssignsToGroupByFactor", "IfcRelAssignsToProcess", "IfcRelAssignsToProduct", "IfcRelAssignsToResource", "IfcRelAssociates", "IfcRelAssociatesApproval", "IfcRelAssociatesClassification", "IfcRelAssociatesConstraint", "IfcRelAssociatesDocument", "IfcRelAssociatesLibrary", "IfcRelAssociatesMaterial", "IfcRelConnects", "IfcRelConnectsElements", "IfcRelConnectsPathElements", "IfcRelConnectsPortToElement", "IfcRelConnectsPorts", "IfcRelConnectsStructuralActivity", "IfcRelConnectsStructuralMember", "IfcRelConnectsWithEccentricity", "IfcRelConnectsWithRealizingElements", "IfcRelContainedInSpatialStructure", "IfcRelCoversBldgElements", "IfcRelCoversSpaces", "IfcRelDeclares", "IfcRelDecomposes", "IfcRelDefines", "IfcRelDefinesByObject", "IfcRelDefinesByProperties", "IfcRelDefinesByTemplate", "IfcRelDefinesByType", "IfcRelFillsElement", "IfcRelFlowControlElements", "IfcRelInterferesElements", "IfcRelNests", "IfcRelProjectsElement", "IfcRelReferencedInSpatialStructure", "IfcRelSequence", "IfcRelServicesBuildings", "IfcRelSpaceBoundary", "IfcRelSpaceBoundary1stLevel", "IfcRelSpaceBoundary2ndLevel", "IfcRelVoidsElement", "IfcRelationship", "IfcReparametrisedCompositeCurveSegment", "IfcRepresentation", "IfcRepresentationContext", "IfcRepresentationItem", "IfcRepresentationMap", "IfcResource", "IfcResourceApprovalRelationship", "IfcResourceConstraintRelationship", "IfcResourceLevelRelationship", "IfcResourceTime", "IfcRevolvedAreaSolid", "IfcRevolvedAreaSolidTapered", "IfcRightCircularCone", "IfcRightCircularCylinder", "IfcRoof", "IfcRoofType", "IfcRoot", "IfcRoundedRectangleProfileDef", "IfcSIUnit", "IfcSanitaryTerminal", "IfcSanitaryTerminalType", "IfcSchedulingTime", "IfcSectionProperties", "IfcSectionReinforcementProperties", "IfcSectionedSpine", "IfcSensor", "IfcSensorType", "IfcShadingDevice", "IfcShadingDeviceType", "IfcShapeAspect", "IfcShapeModel", "IfcShapeRepresentation", "IfcShellBasedSurfaceModel", "IfcSimpleProperty", "IfcSimplePropertyTemplate", "IfcSite", "IfcSlab", "IfcSlabElementedCase", "IfcSlabStandardCase", "IfcSlabType", "IfcSlippageConnectionCondition", "IfcSolarDevice", "IfcSolarDeviceType", "IfcSolidModel", "IfcSpace", "IfcSpaceHeater", "IfcSpaceHeaterType", "IfcSpaceType", "IfcSpatialElement", "IfcSpatialElementType", "IfcSpatialStructureElement", "IfcSpatialStructureElementType", "IfcSpatialZone", "IfcSpatialZoneType", "IfcSphere", "IfcStackTerminal", "IfcStackTerminalType", "IfcStair", "IfcStairFlight", "IfcStairFlightType", "IfcStairType", "IfcStructuralAction", "IfcStructuralActivity", "IfcStructuralAnalysisModel", "IfcStructuralConnection", "IfcStructuralConnectionCondition", "IfcStructuralCurveAction", "IfcStructuralCurveConnection", "IfcStructuralCurveMember", "IfcStructuralCurveMemberVarying", "IfcStructuralCurveReaction", "IfcStructuralItem", "IfcStructuralLinearAction", "IfcStructuralLoad", "IfcStructuralLoadCase", "IfcStructuralLoadConfiguration", "IfcStructuralLoadGroup", "IfcStructuralLoadLinearForce", "IfcStructuralLoadOrResult", "IfcStructuralLoadPlanarForce", "IfcStructuralLoadSingleDisplacement", "IfcStructuralLoadSingleDisplacementDistortion", "IfcStructuralLoadSingleForce", "IfcStructuralLoadSingleForceWarping", "IfcStructuralLoadStatic", "IfcStructuralLoadTemperature", "IfcStructuralMember", "IfcStructuralPlanarAction", "IfcStructuralPointAction", "IfcStructuralPointConnection", "IfcStructuralPointReaction", "IfcStructuralReaction", "IfcStructuralResultGroup", "IfcStructuralSurfaceAction", "IfcStructuralSurfaceConnection", "IfcStructuralSurfaceMember", "IfcStructuralSurfaceMemberVarying", "IfcStructuralSurfaceReaction", "IfcStyleModel", "IfcStyledItem", "IfcStyledRepresentation", "IfcSubContractResource", "IfcSubContractResourceType", "IfcSubedge", "IfcSurface", "IfcSurfaceCurveSweptAreaSolid", "IfcSurfaceFeature", "IfcSurfaceOfLinearExtrusion", "IfcSurfaceOfRevolution", "IfcSurfaceReinforcementArea", "IfcSurfaceStyle", "IfcSurfaceStyleLighting", "IfcSurfaceStyleRefraction", "IfcSurfaceStyleRendering", "IfcSurfaceStyleShading", "IfcSurfaceStyleWithTextures", "IfcSurfaceTexture", "IfcSweptAreaSolid", "IfcSweptDiskSolid", "IfcSweptDiskSolidPolygonal", "IfcSweptSurface", "IfcSwitchingDevice", "IfcSwitchingDeviceType", "IfcSystem", "IfcSystemFurnitureElement", "IfcSystemFurnitureElementType", "IfcTShapeProfileDef", "IfcTable", "IfcTableColumn", "IfcTableRow", "IfcTank", "IfcTankType", "IfcTask", "IfcTaskTime", "IfcTaskTimeRecurring", "IfcTaskType", "IfcTelecomAddress", "IfcTendon", "IfcTendonAnchor", "IfcTendonAnchorType", "IfcTendonType", "IfcTessellatedFaceSet", "IfcTessellatedItem", "IfcTextLiteral", "IfcTextLiteralWithExtent", "IfcTextStyle", "IfcTextStyleFontModel", "IfcTextStyleForDefinedFont", "IfcTextStyleTextModel", "IfcTextureCoordinate", "IfcTextureCoordinateGenerator", "IfcTextureMap", "IfcTextureVertex", "IfcTextureVertexList", "IfcTimePeriod", "IfcTimeSeries", "IfcTimeSeriesValue", "IfcTopologicalRepresentationItem", "IfcTopologyRepresentation", "IfcTransformer", "IfcTransformerType", "IfcTransportElement", "IfcTransportElementType", "IfcTrapeziumProfileDef", "IfcTriangulatedFaceSet", "IfcTrimmedCurve", "IfcTubeBundle", "IfcTubeBundleType", "IfcTypeObject", "IfcTypeProcess", "IfcTypeProduct", "IfcTypeResource", "IfcUShapeProfileDef", "IfcUnitAssignment", "IfcUnitaryControlElement", "IfcUnitaryControlElementType", "IfcUnitaryEquipment", "IfcUnitaryEquipmentType", "IfcValve", "IfcValveType", "IfcVector", "IfcVertex", "IfcVertexLoop", "IfcVertexPoint", "IfcVibrationIsolator", "IfcVibrationIsolatorType", "IfcVirtualElement", "IfcVirtualGridIntersection", "IfcVoidingFeature", "IfcWall", "IfcWallElementedCase", "IfcWallStandardCase", "IfcWallType", "IfcWasteTerminal", "IfcWasteTerminalType", "IfcWindow", "IfcWindowLiningProperties", "IfcWindowPanelProperties", "IfcWindowStandardCase", "IfcWindowStyle", "IfcWindowType", "IfcWorkCalendar", "IfcWorkControl", "IfcWorkPlan", "IfcWorkSchedule", "IfcWorkTime", "IfcZShapeProfileDef", "IfcZone" };
    return names[v];
}

static std::map<std::string,Type::Enum> string_map;
void Ifc4::InitStringMap() {
    string_map["IFCABSORBEDDOSEMEASURE"                        ] = Type::IfcAbsorbedDoseMeasure;
    string_map["IFCACCELERATIONMEASURE"                        ] = Type::IfcAccelerationMeasure;
    string_map["IFCAMOUNTOFSUBSTANCEMEASURE"                   ] = Type::IfcAmountOfSubstanceMeasure;
    string_map["IFCANGULARVELOCITYMEASURE"                     ] = Type::IfcAngularVelocityMeasure;
    string_map["IFCAREADENSITYMEASURE"                         ] = Type::IfcAreaDensityMeasure;
    string_map["IFCAREAMEASURE"                                ] = Type::IfcAreaMeasure;
    string_map["IFCBOOLEAN"                                    ] = Type::IfcBoolean;
    string_map["IFCCOLOUR"                                     ] = Type::IfcColour;
    string_map["IFCCOMPLEXNUMBER"                              ] = Type::IfcComplexNumber;
    string_map["IFCCOMPOUNDPLANEANGLEMEASURE"                  ] = Type::IfcCompoundPlaneAngleMeasure;
    string_map["IFCCONTEXTDEPENDENTMEASURE"                    ] = Type::IfcContextDependentMeasure;
    string_map["IFCCOUNTMEASURE"                               ] = Type::IfcCountMeasure;
    string_map["IFCCURVATUREMEASURE"                           ] = Type::IfcCurvatureMeasure;
    string_map["IFCCURVESTYLEFONTSELECT"                       ] = Type::IfcCurveStyleFontSelect;
    string_map["IFCDATE"                                       ] = Type::IfcDate;
    string_map["IFCDATETIME"                                   ] = Type::IfcDateTime;
    string_map["IFCDERIVEDMEASUREVALUE"                        ] = Type::IfcDerivedMeasureValue;
    string_map["IFCDESCRIPTIVEMEASURE"                         ] = Type::IfcDescriptiveMeasure;
    string_map["IFCDOSEEQUIVALENTMEASURE"                      ] = Type::IfcDoseEquivalentMeasure;
    string_map["IFCDURATION"                                   ] = Type::IfcDuration;
    string_map["IFCDYNAMICVISCOSITYMEASURE"                    ] = Type::IfcDynamicViscosityMeasure;
    string_map["IFCELECTRICCAPACITANCEMEASURE"                 ] = Type::IfcElectricCapacitanceMeasure;
    string_map["IFCELECTRICCHARGEMEASURE"                      ] = Type::IfcElectricChargeMeasure;
    string_map["IFCELECTRICCONDUCTANCEMEASURE"                 ] = Type::IfcElectricConductanceMeasure;
    string_map["IFCELECTRICCURRENTMEASURE"                     ] = Type::IfcElectricCurrentMeasure;
    string_map["IFCELECTRICRESISTANCEMEASURE"                  ] = Type::IfcElectricResistanceMeasure;
    string_map["IFCELECTRICVOLTAGEMEASURE"                     ] = Type::IfcElectricVoltageMeasure;
    string_map["IFCENERGYMEASURE"                              ] = Type::IfcEnergyMeasure;
    string_map["IFCFORCEMEASURE"                               ] = Type::IfcForceMeasure;
    string_map["IFCFREQUENCYMEASURE"                           ] = Type::IfcFrequencyMeasure;
    string_map["IFCHEATFLUXDENSITYMEASURE"                     ] = Type::IfcHeatFluxDensityMeasure;
    string_map["IFCHEATINGVALUEMEASURE"                        ] = Type::IfcHeatingValueMeasure;
    string_map["IFCIDENTIFIER"                                 ] = Type::IfcIdentifier;
    string_map["IFCILLUMINANCEMEASURE"                         ] = Type::IfcIlluminanceMeasure;
    string_map["IFCINDUCTANCEMEASURE"                          ] = Type::IfcInductanceMeasure;
    string_map["IFCINTEGER"                                    ] = Type::IfcInteger;
    string_map["IFCINTEGERCOUNTRATEMEASURE"                    ] = Type::IfcIntegerCountRateMeasure;
    string_map["IFCIONCONCENTRATIONMEASURE"                    ] = Type::IfcIonConcentrationMeasure;
    string_map["IFCISOTHERMALMOISTURECAPACITYMEASURE"          ] = Type::IfcIsothermalMoistureCapacityMeasure;
    string_map["IFCKINEMATICVISCOSITYMEASURE"                  ] = Type::IfcKinematicViscosityMeasure;
    string_map["IFCLABEL"                                      ] = Type::IfcLabel;
    string_map["IFCLENGTHMEASURE"                              ] = Type::IfcLengthMeasure;
    string_map["IFCLINEARFORCEMEASURE"                         ] = Type::IfcLinearForceMeasure;
    string_map["IFCLINEARMOMENTMEASURE"                        ] = Type::IfcLinearMomentMeasure;
    string_map["IFCLINEARSTIFFNESSMEASURE"                     ] = Type::IfcLinearStiffnessMeasure;
    string_map["IFCLINEARVELOCITYMEASURE"                      ] = Type::IfcLinearVelocityMeasure;
    string_map["IFCLOGICAL"                                    ] = Type::IfcLogical;
    string_map["IFCLUMINOUSFLUXMEASURE"                        ] = Type::IfcLuminousFluxMeasure;
    string_map["IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE"       ] = Type::IfcLuminousIntensityDistributionMeasure;
    string_map["IFCLUMINOUSINTENSITYMEASURE"                   ] = Type::IfcLuminousIntensityMeasure;
    string_map["IFCMAGNETICFLUXDENSITYMEASURE"                 ] = Type::IfcMagneticFluxDensityMeasure;
    string_map["IFCMAGNETICFLUXMEASURE"                        ] = Type::IfcMagneticFluxMeasure;
    string_map["IFCMASSDENSITYMEASURE"                         ] = Type::IfcMassDensityMeasure;
    string_map["IFCMASSFLOWRATEMEASURE"                        ] = Type::IfcMassFlowRateMeasure;
    string_map["IFCMASSMEASURE"                                ] = Type::IfcMassMeasure;
    string_map["IFCMASSPERLENGTHMEASURE"                       ] = Type::IfcMassPerLengthMeasure;
    string_map["IFCMEASUREVALUE"                               ] = Type::IfcMeasureValue;
    string_map["IFCMODULUSOFELASTICITYMEASURE"                 ] = Type::IfcModulusOfElasticityMeasure;
    string_map["IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE"     ] = Type::IfcModulusOfLinearSubgradeReactionMeasure;
    string_map["IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" ] = Type::IfcModulusOfRotationalSubgradeReactionMeasure;
    string_map["IFCMODULUSOFSUBGRADEREACTIONMEASURE"           ] = Type::IfcModulusOfSubgradeReactionMeasure;
    string_map["IFCMOISTUREDIFFUSIVITYMEASURE"                 ] = Type::IfcMoistureDiffusivityMeasure;
    string_map["IFCMOLECULARWEIGHTMEASURE"                     ] = Type::IfcMolecularWeightMeasure;
    string_map["IFCMOMENTOFINERTIAMEASURE"                     ] = Type::IfcMomentOfInertiaMeasure;
    string_map["IFCMONETARYMEASURE"                            ] = Type::IfcMonetaryMeasure;
    string_map["IFCNONNEGATIVELENGTHMEASURE"                   ] = Type::IfcNonNegativeLengthMeasure;
    string_map["IFCNORMALISEDRATIOMEASURE"                     ] = Type::IfcNormalisedRatioMeasure;
    string_map["IFCNULLSTYLE"                                  ] = Type::IfcNullStyle;
    string_map["IFCNUMERICMEASURE"                             ] = Type::IfcNumericMeasure;
    string_map["IFCPHMEASURE"                                  ] = Type::IfcPHMeasure;
    string_map["IFCPARAMETERVALUE"                             ] = Type::IfcParameterValue;
    string_map["IFCPLANARFORCEMEASURE"                         ] = Type::IfcPlanarForceMeasure;
    string_map["IFCPLANEANGLEMEASURE"                          ] = Type::IfcPlaneAngleMeasure;
    string_map["IFCPOSITIVELENGTHMEASURE"                      ] = Type::IfcPositiveLengthMeasure;
    string_map["IFCPOSITIVEPLANEANGLEMEASURE"                  ] = Type::IfcPositivePlaneAngleMeasure;
    string_map["IFCPOSITIVERATIOMEASURE"                       ] = Type::IfcPositiveRatioMeasure;
    string_map["IFCPOWERMEASURE"                               ] = Type::IfcPowerMeasure;
    string_map["IFCPRESSUREMEASURE"                            ] = Type::IfcPressureMeasure;
    string_map["IFCPROPERTYSETDEFINITIONSET"                   ] = Type::IfcPropertySetDefinitionSet;
    string_map["IFCRADIOACTIVITYMEASURE"                       ] = Type::IfcRadioActivityMeasure;
    string_map["IFCRATIOMEASURE"                               ] = Type::IfcRatioMeasure;
    string_map["IFCREAL"                                       ] = Type::IfcReal;
    string_map["IFCROTATIONALFREQUENCYMEASURE"                 ] = Type::IfcRotationalFrequencyMeasure;
    string_map["IFCROTATIONALMASSMEASURE"                      ] = Type::IfcRotationalMassMeasure;
    string_map["IFCROTATIONALSTIFFNESSMEASURE"                 ] = Type::IfcRotationalStiffnessMeasure;
    string_map["IFCSECTIONMODULUSMEASURE"                      ] = Type::IfcSectionModulusMeasure;
    string_map["IFCSECTIONALAREAINTEGRALMEASURE"               ] = Type::IfcSectionalAreaIntegralMeasure;
    string_map["IFCSHEARMODULUSMEASURE"                        ] = Type::IfcShearModulusMeasure;
    string_map["IFCSIMPLEVALUE"                                ] = Type::IfcSimpleValue;
    string_map["IFCSOLIDANGLEMEASURE"                          ] = Type::IfcSolidAngleMeasure;
    string_map["IFCSOUNDPOWERLEVELMEASURE"                     ] = Type::IfcSoundPowerLevelMeasure;
    string_map["IFCSOUNDPOWERMEASURE"                          ] = Type::IfcSoundPowerMeasure;
    string_map["IFCSOUNDPRESSURELEVELMEASURE"                  ] = Type::IfcSoundPressureLevelMeasure;
    string_map["IFCSOUNDPRESSUREMEASURE"                       ] = Type::IfcSoundPressureMeasure;
    string_map["IFCSPECIFICHEATCAPACITYMEASURE"                ] = Type::IfcSpecificHeatCapacityMeasure;
    string_map["IFCSPECULAREXPONENT"                           ] = Type::IfcSpecularExponent;
    string_map["IFCSPECULARROUGHNESS"                          ] = Type::IfcSpecularRoughness;
    string_map["IFCTEMPERATUREGRADIENTMEASURE"                 ] = Type::IfcTemperatureGradientMeasure;
    string_map["IFCTEMPERATURERATEOFCHANGEMEASURE"             ] = Type::IfcTemperatureRateOfChangeMeasure;
    string_map["IFCTEXT"                                       ] = Type::IfcText;
    string_map["IFCTHERMALADMITTANCEMEASURE"                   ] = Type::IfcThermalAdmittanceMeasure;
    string_map["IFCTHERMALCONDUCTIVITYMEASURE"                 ] = Type::IfcThermalConductivityMeasure;
    string_map["IFCTHERMALEXPANSIONCOEFFICIENTMEASURE"         ] = Type::IfcThermalExpansionCoefficientMeasure;
    string_map["IFCTHERMALRESISTANCEMEASURE"                   ] = Type::IfcThermalResistanceMeasure;
    string_map["IFCTHERMALTRANSMITTANCEMEASURE"                ] = Type::IfcThermalTransmittanceMeasure;
    string_map["IFCTHERMODYNAMICTEMPERATUREMEASURE"            ] = Type::IfcThermodynamicTemperatureMeasure;
    string_map["IFCTIME"                                       ] = Type::IfcTime;
    string_map["IFCTIMEMEASURE"                                ] = Type::IfcTimeMeasure;
    string_map["IFCTIMESTAMP"                                  ] = Type::IfcTimeStamp;
    string_map["IFCTORQUEMEASURE"                              ] = Type::IfcTorqueMeasure;
    string_map["IFCVALUE"                                      ] = Type::IfcValue;
    string_map["IFCVAPORPERMEABILITYMEASURE"                   ] = Type::IfcVaporPermeabilityMeasure;
    string_map["IFCVOLUMEMEASURE"                              ] = Type::IfcVolumeMeasure;
    string_map["IFCVOLUMETRICFLOWRATEMEASURE"                  ] = Type::IfcVolumetricFlowRateMeasure;
    string_map["IFCWARPINGCONSTANTMEASURE"                     ] = Type::IfcWarpingConstantMeasure;
    string_map["IFCWARPINGMOMENTMEASURE"                       ] = Type::IfcWarpingMomentMeasure;
    string_map["IFCACTIONREQUEST"                              ] = Type::IfcActionRequest;
    string_map["IFCACTOR"                                      ] = Type::IfcActor;
    string_map["IFCACTORROLE"                                  ] = Type::IfcActorRole;
    string_map["IFCACTUATOR"                                   ] = Type::IfcActuator;
    string_map["IFCACTUATORTYPE"                               ] = Type::IfcActuatorType;
    string_map["IFCADDRESS"                                    ] = Type::IfcAddress;
    string_map["IFCADVANCEDBREP"                               ] = Type::IfcAdvancedBrep;
    string_map["IFCADVANCEDBREPWITHVOIDS"                      ] = Type::IfcAdvancedBrepWithVoids;
    string_map["IFCADVANCEDFACE"                               ] = Type::IfcAdvancedFace;
    string_map["IFCAIRTERMINAL"                                ] = Type::IfcAirTerminal;
    string_map["IFCAIRTERMINALBOX"                             ] = Type::IfcAirTerminalBox;
    string_map["IFCAIRTERMINALBOXTYPE"                         ] = Type::IfcAirTerminalBoxType;
    string_map["IFCAIRTERMINALTYPE"                            ] = Type::IfcAirTerminalType;
    string_map["IFCAIRTOAIRHEATRECOVERY"                       ] = Type::IfcAirToAirHeatRecovery;
    string_map["IFCAIRTOAIRHEATRECOVERYTYPE"                   ] = Type::IfcAirToAirHeatRecoveryType;
    string_map["IFCALARM"                                      ] = Type::IfcAlarm;
    string_map["IFCALARMTYPE"                                  ] = Type::IfcAlarmType;
    string_map["IFCANNOTATION"                                 ] = Type::IfcAnnotation;
    string_map["IFCANNOTATIONFILLAREA"                         ] = Type::IfcAnnotationFillArea;
    string_map["IFCAPPLICATION"                                ] = Type::IfcApplication;
    string_map["IFCAPPLIEDVALUE"                               ] = Type::IfcAppliedValue;
    string_map["IFCAPPROVAL"                                   ] = Type::IfcApproval;
    string_map["IFCAPPROVALRELATIONSHIP"                       ] = Type::IfcApprovalRelationship;
    string_map["IFCARBITRARYCLOSEDPROFILEDEF"                  ] = Type::IfcArbitraryClosedProfileDef;
    string_map["IFCARBITRARYOPENPROFILEDEF"                    ] = Type::IfcArbitraryOpenProfileDef;
    string_map["IFCARBITRARYPROFILEDEFWITHVOIDS"               ] = Type::IfcArbitraryProfileDefWithVoids;
    string_map["IFCASSET"                                      ] = Type::IfcAsset;
    string_map["IFCASYMMETRICISHAPEPROFILEDEF"                 ] = Type::IfcAsymmetricIShapeProfileDef;
    string_map["IFCAUDIOVISUALAPPLIANCE"                       ] = Type::IfcAudioVisualAppliance;
    string_map["IFCAUDIOVISUALAPPLIANCETYPE"                   ] = Type::IfcAudioVisualApplianceType;
    string_map["IFCAXIS1PLACEMENT"                             ] = Type::IfcAxis1Placement;
    string_map["IFCAXIS2PLACEMENT2D"                           ] = Type::IfcAxis2Placement2D;
    string_map["IFCAXIS2PLACEMENT3D"                           ] = Type::IfcAxis2Placement3D;
    string_map["IFCBSPLINECURVE"                               ] = Type::IfcBSplineCurve;
    string_map["IFCBSPLINECURVEWITHKNOTS"                      ] = Type::IfcBSplineCurveWithKnots;
    string_map["IFCBSPLINESURFACE"                             ] = Type::IfcBSplineSurface;
    string_map["IFCBSPLINESURFACEWITHKNOTS"                    ] = Type::IfcBSplineSurfaceWithKnots;
    string_map["IFCBEAM"                                       ] = Type::IfcBeam;
    string_map["IFCBEAMSTANDARDCASE"                           ] = Type::IfcBeamStandardCase;
    string_map["IFCBEAMTYPE"                                   ] = Type::IfcBeamType;
    string_map["IFCBLOBTEXTURE"                                ] = Type::IfcBlobTexture;
    string_map["IFCBLOCK"                                      ] = Type::IfcBlock;
    string_map["IFCBOILER"                                     ] = Type::IfcBoiler;
    string_map["IFCBOILERTYPE"                                 ] = Type::IfcBoilerType;
    string_map["IFCBOOLEANCLIPPINGRESULT"                      ] = Type::IfcBooleanClippingResult;
    string_map["IFCBOOLEANRESULT"                              ] = Type::IfcBooleanResult;
    string_map["IFCBOUNDARYCONDITION"                          ] = Type::IfcBoundaryCondition;
    string_map["IFCBOUNDARYCURVE"                              ] = Type::IfcBoundaryCurve;
    string_map["IFCBOUNDARYEDGECONDITION"                      ] = Type::IfcBoundaryEdgeCondition;
    string_map["IFCBOUNDARYFACECONDITION"                      ] = Type::IfcBoundaryFaceCondition;
    string_map["IFCBOUNDARYNODECONDITION"                      ] = Type::IfcBoundaryNodeCondition;
    string_map["IFCBOUNDARYNODECONDITIONWARPING"               ] = Type::IfcBoundaryNodeConditionWarping;
    string_map["IFCBOUNDEDCURVE"                               ] = Type::IfcBoundedCurve;
    string_map["IFCBOUNDEDSURFACE"                             ] = Type::IfcBoundedSurface;
    string_map["IFCBOUNDINGBOX"                                ] = Type::IfcBoundingBox;
    string_map["IFCBOXEDHALFSPACE"                             ] = Type::IfcBoxedHalfSpace;
    string_map["IFCBUILDING"                                   ] = Type::IfcBuilding;
    string_map["IFCBUILDINGELEMENT"                            ] = Type::IfcBuildingElement;
    string_map["IFCBUILDINGELEMENTPART"                        ] = Type::IfcBuildingElementPart;
    string_map["IFCBUILDINGELEMENTPARTTYPE"                    ] = Type::IfcBuildingElementPartType;
    string_map["IFCBUILDINGELEMENTPROXY"                       ] = Type::IfcBuildingElementProxy;
    string_map["IFCBUILDINGELEMENTPROXYTYPE"                   ] = Type::IfcBuildingElementProxyType;
    string_map["IFCBUILDINGELEMENTTYPE"                        ] = Type::IfcBuildingElementType;
    string_map["IFCBUILDINGSTOREY"                             ] = Type::IfcBuildingStorey;
    string_map["IFCBUILDINGSYSTEM"                             ] = Type::IfcBuildingSystem;
    string_map["IFCBURNER"                                     ] = Type::IfcBurner;
    string_map["IFCBURNERTYPE"                                 ] = Type::IfcBurnerType;
    string_map["IFCCSHAPEPROFILEDEF"                           ] = Type::IfcCShapeProfileDef;
    string_map["IFCCABLECARRIERFITTING"                        ] = Type::IfcCableCarrierFitting;
    string_map["IFCCABLECARRIERFITTINGTYPE"                    ] = Type::IfcCableCarrierFittingType;
    string_map["IFCCABLECARRIERSEGMENT"                        ] = Type::IfcCableCarrierSegment;
    string_map["IFCCABLECARRIERSEGMENTTYPE"                    ] = Type::IfcCableCarrierSegmentType;
    string_map["IFCCABLEFITTING"                               ] = Type::IfcCableFitting;
    string_map["IFCCABLEFITTINGTYPE"                           ] = Type::IfcCableFittingType;
    string_map["IFCCABLESEGMENT"                               ] = Type::IfcCableSegment;
    string_map["IFCCABLESEGMENTTYPE"                           ] = Type::IfcCableSegmentType;
    string_map["IFCCARTESIANPOINT"                             ] = Type::IfcCartesianPoint;
    string_map["IFCCARTESIANPOINTLIST"                         ] = Type::IfcCartesianPointList;
    string_map["IFCCARTESIANPOINTLIST3D"                       ] = Type::IfcCartesianPointList3D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR"            ] = Type::IfcCartesianTransformationOperator;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2D"          ] = Type::IfcCartesianTransformationOperator2D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM"] = Type::IfcCartesianTransformationOperator2DnonUniform;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3D"          ] = Type::IfcCartesianTransformationOperator3D;
    string_map["IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM"] = Type::IfcCartesianTransformationOperator3DnonUniform;
    string_map["IFCCENTERLINEPROFILEDEF"                       ] = Type::IfcCenterLineProfileDef;
    string_map["IFCCHILLER"                                    ] = Type::IfcChiller;
    string_map["IFCCHILLERTYPE"                                ] = Type::IfcChillerType;
    string_map["IFCCHIMNEY"                                    ] = Type::IfcChimney;
    string_map["IFCCHIMNEYTYPE"                                ] = Type::IfcChimneyType;
    string_map["IFCCIRCLE"                                     ] = Type::IfcCircle;
    string_map["IFCCIRCLEHOLLOWPROFILEDEF"                     ] = Type::IfcCircleHollowProfileDef;
    string_map["IFCCIRCLEPROFILEDEF"                           ] = Type::IfcCircleProfileDef;
    string_map["IFCCIVILELEMENT"                               ] = Type::IfcCivilElement;
    string_map["IFCCIVILELEMENTTYPE"                           ] = Type::IfcCivilElementType;
    string_map["IFCCLASSIFICATION"                             ] = Type::IfcClassification;
    string_map["IFCCLASSIFICATIONREFERENCE"                    ] = Type::IfcClassificationReference;
    string_map["IFCCLOSEDSHELL"                                ] = Type::IfcClosedShell;
    string_map["IFCCOIL"                                       ] = Type::IfcCoil;
    string_map["IFCCOILTYPE"                                   ] = Type::IfcCoilType;
    string_map["IFCCOLOURRGB"                                  ] = Type::IfcColourRgb;
    string_map["IFCCOLOURRGBLIST"                              ] = Type::IfcColourRgbList;
    string_map["IFCCOLOURSPECIFICATION"                        ] = Type::IfcColourSpecification;
    string_map["IFCCOLUMN"                                     ] = Type::IfcColumn;
    string_map["IFCCOLUMNSTANDARDCASE"                         ] = Type::IfcColumnStandardCase;
    string_map["IFCCOLUMNTYPE"                                 ] = Type::IfcColumnType;
    string_map["IFCCOMMUNICATIONSAPPLIANCE"                    ] = Type::IfcCommunicationsAppliance;
    string_map["IFCCOMMUNICATIONSAPPLIANCETYPE"                ] = Type::IfcCommunicationsApplianceType;
    string_map["IFCCOMPLEXPROPERTY"                            ] = Type::IfcComplexProperty;
    string_map["IFCCOMPLEXPROPERTYTEMPLATE"                    ] = Type::IfcComplexPropertyTemplate;
    string_map["IFCCOMPOSITECURVE"                             ] = Type::IfcCompositeCurve;
    string_map["IFCCOMPOSITECURVEONSURFACE"                    ] = Type::IfcCompositeCurveOnSurface;
    string_map["IFCCOMPOSITECURVESEGMENT"                      ] = Type::IfcCompositeCurveSegment;
    string_map["IFCCOMPOSITEPROFILEDEF"                        ] = Type::IfcCompositeProfileDef;
    string_map["IFCCOMPRESSOR"                                 ] = Type::IfcCompressor;
    string_map["IFCCOMPRESSORTYPE"                             ] = Type::IfcCompressorType;
    string_map["IFCCONDENSER"                                  ] = Type::IfcCondenser;
    string_map["IFCCONDENSERTYPE"                              ] = Type::IfcCondenserType;
    string_map["IFCCONIC"                                      ] = Type::IfcConic;
    string_map["IFCCONNECTEDFACESET"                           ] = Type::IfcConnectedFaceSet;
    string_map["IFCCONNECTIONCURVEGEOMETRY"                    ] = Type::IfcConnectionCurveGeometry;
    string_map["IFCCONNECTIONGEOMETRY"                         ] = Type::IfcConnectionGeometry;
    string_map["IFCCONNECTIONPOINTECCENTRICITY"                ] = Type::IfcConnectionPointEccentricity;
    string_map["IFCCONNECTIONPOINTGEOMETRY"                    ] = Type::IfcConnectionPointGeometry;
    string_map["IFCCONNECTIONSURFACEGEOMETRY"                  ] = Type::IfcConnectionSurfaceGeometry;
    string_map["IFCCONNECTIONVOLUMEGEOMETRY"                   ] = Type::IfcConnectionVolumeGeometry;
    string_map["IFCCONSTRAINT"                                 ] = Type::IfcConstraint;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCE"              ] = Type::IfcConstructionEquipmentResource;
    string_map["IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE"          ] = Type::IfcConstructionEquipmentResourceType;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCE"               ] = Type::IfcConstructionMaterialResource;
    string_map["IFCCONSTRUCTIONMATERIALRESOURCETYPE"           ] = Type::IfcConstructionMaterialResourceType;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCE"                ] = Type::IfcConstructionProductResource;
    string_map["IFCCONSTRUCTIONPRODUCTRESOURCETYPE"            ] = Type::IfcConstructionProductResourceType;
    string_map["IFCCONSTRUCTIONRESOURCE"                       ] = Type::IfcConstructionResource;
    string_map["IFCCONSTRUCTIONRESOURCETYPE"                   ] = Type::IfcConstructionResourceType;
    string_map["IFCCONTEXT"                                    ] = Type::IfcContext;
    string_map["IFCCONTEXTDEPENDENTUNIT"                       ] = Type::IfcContextDependentUnit;
    string_map["IFCCONTROL"                                    ] = Type::IfcControl;
    string_map["IFCCONTROLLER"                                 ] = Type::IfcController;
    string_map["IFCCONTROLLERTYPE"                             ] = Type::IfcControllerType;
    string_map["IFCCONVERSIONBASEDUNIT"                        ] = Type::IfcConversionBasedUnit;
    string_map["IFCCONVERSIONBASEDUNITWITHOFFSET"              ] = Type::IfcConversionBasedUnitWithOffset;
    string_map["IFCCOOLEDBEAM"                                 ] = Type::IfcCooledBeam;
    string_map["IFCCOOLEDBEAMTYPE"                             ] = Type::IfcCooledBeamType;
    string_map["IFCCOOLINGTOWER"                               ] = Type::IfcCoolingTower;
    string_map["IFCCOOLINGTOWERTYPE"                           ] = Type::IfcCoolingTowerType;
    string_map["IFCCOORDINATEOPERATION"                        ] = Type::IfcCoordinateOperation;
    string_map["IFCCOORDINATEREFERENCESYSTEM"                  ] = Type::IfcCoordinateReferenceSystem;
    string_map["IFCCOSTITEM"                                   ] = Type::IfcCostItem;
    string_map["IFCCOSTSCHEDULE"                               ] = Type::IfcCostSchedule;
    string_map["IFCCOSTVALUE"                                  ] = Type::IfcCostValue;
    string_map["IFCCOVERING"                                   ] = Type::IfcCovering;
    string_map["IFCCOVERINGTYPE"                               ] = Type::IfcCoveringType;
    string_map["IFCCREWRESOURCE"                               ] = Type::IfcCrewResource;
    string_map["IFCCREWRESOURCETYPE"                           ] = Type::IfcCrewResourceType;
    string_map["IFCCSGPRIMITIVE3D"                             ] = Type::IfcCsgPrimitive3D;
    string_map["IFCCSGSOLID"                                   ] = Type::IfcCsgSolid;
    string_map["IFCCURRENCYRELATIONSHIP"                       ] = Type::IfcCurrencyRelationship;
    string_map["IFCCURTAINWALL"                                ] = Type::IfcCurtainWall;
    string_map["IFCCURTAINWALLTYPE"                            ] = Type::IfcCurtainWallType;
    string_map["IFCCURVE"                                      ] = Type::IfcCurve;
    string_map["IFCCURVEBOUNDEDPLANE"                          ] = Type::IfcCurveBoundedPlane;
    string_map["IFCCURVEBOUNDEDSURFACE"                        ] = Type::IfcCurveBoundedSurface;
    string_map["IFCCURVESTYLE"                                 ] = Type::IfcCurveStyle;
    string_map["IFCCURVESTYLEFONT"                             ] = Type::IfcCurveStyleFont;
    string_map["IFCCURVESTYLEFONTANDSCALING"                   ] = Type::IfcCurveStyleFontAndScaling;
    string_map["IFCCURVESTYLEFONTPATTERN"                      ] = Type::IfcCurveStyleFontPattern;
    string_map["IFCCYLINDRICALSURFACE"                         ] = Type::IfcCylindricalSurface;
    string_map["IFCDAMPER"                                     ] = Type::IfcDamper;
    string_map["IFCDAMPERTYPE"                                 ] = Type::IfcDamperType;
    string_map["IFCDERIVEDPROFILEDEF"                          ] = Type::IfcDerivedProfileDef;
    string_map["IFCDERIVEDUNIT"                                ] = Type::IfcDerivedUnit;
    string_map["IFCDERIVEDUNITELEMENT"                         ] = Type::IfcDerivedUnitElement;
    string_map["IFCDIMENSIONALEXPONENTS"                       ] = Type::IfcDimensionalExponents;
    string_map["IFCDIRECTION"                                  ] = Type::IfcDirection;
    string_map["IFCDISCRETEACCESSORY"                          ] = Type::IfcDiscreteAccessory;
    string_map["IFCDISCRETEACCESSORYTYPE"                      ] = Type::IfcDiscreteAccessoryType;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENT"                 ] = Type::IfcDistributionChamberElement;
    string_map["IFCDISTRIBUTIONCHAMBERELEMENTTYPE"             ] = Type::IfcDistributionChamberElementType;
    string_map["IFCDISTRIBUTIONCIRCUIT"                        ] = Type::IfcDistributionCircuit;
    string_map["IFCDISTRIBUTIONCONTROLELEMENT"                 ] = Type::IfcDistributionControlElement;
    string_map["IFCDISTRIBUTIONCONTROLELEMENTTYPE"             ] = Type::IfcDistributionControlElementType;
    string_map["IFCDISTRIBUTIONELEMENT"                        ] = Type::IfcDistributionElement;
    string_map["IFCDISTRIBUTIONELEMENTTYPE"                    ] = Type::IfcDistributionElementType;
    string_map["IFCDISTRIBUTIONFLOWELEMENT"                    ] = Type::IfcDistributionFlowElement;
    string_map["IFCDISTRIBUTIONFLOWELEMENTTYPE"                ] = Type::IfcDistributionFlowElementType;
    string_map["IFCDISTRIBUTIONPORT"                           ] = Type::IfcDistributionPort;
    string_map["IFCDISTRIBUTIONSYSTEM"                         ] = Type::IfcDistributionSystem;
    string_map["IFCDOCUMENTINFORMATION"                        ] = Type::IfcDocumentInformation;
    string_map["IFCDOCUMENTINFORMATIONRELATIONSHIP"            ] = Type::IfcDocumentInformationRelationship;
    string_map["IFCDOCUMENTREFERENCE"                          ] = Type::IfcDocumentReference;
    string_map["IFCDOOR"                                       ] = Type::IfcDoor;
    string_map["IFCDOORLININGPROPERTIES"                       ] = Type::IfcDoorLiningProperties;
    string_map["IFCDOORPANELPROPERTIES"                        ] = Type::IfcDoorPanelProperties;
    string_map["IFCDOORSTANDARDCASE"                           ] = Type::IfcDoorStandardCase;
    string_map["IFCDOORSTYLE"                                  ] = Type::IfcDoorStyle;
    string_map["IFCDOORTYPE"                                   ] = Type::IfcDoorType;
    string_map["IFCDRAUGHTINGPREDEFINEDCOLOUR"                 ] = Type::IfcDraughtingPreDefinedColour;
    string_map["IFCDRAUGHTINGPREDEFINEDCURVEFONT"              ] = Type::IfcDraughtingPreDefinedCurveFont;
    string_map["IFCDUCTFITTING"                                ] = Type::IfcDuctFitting;
    string_map["IFCDUCTFITTINGTYPE"                            ] = Type::IfcDuctFittingType;
    string_map["IFCDUCTSEGMENT"                                ] = Type::IfcDuctSegment;
    string_map["IFCDUCTSEGMENTTYPE"                            ] = Type::IfcDuctSegmentType;
    string_map["IFCDUCTSILENCER"                               ] = Type::IfcDuctSilencer;
    string_map["IFCDUCTSILENCERTYPE"                           ] = Type::IfcDuctSilencerType;
    string_map["IFCEDGE"                                       ] = Type::IfcEdge;
    string_map["IFCEDGECURVE"                                  ] = Type::IfcEdgeCurve;
    string_map["IFCEDGELOOP"                                   ] = Type::IfcEdgeLoop;
    string_map["IFCELECTRICAPPLIANCE"                          ] = Type::IfcElectricAppliance;
    string_map["IFCELECTRICAPPLIANCETYPE"                      ] = Type::IfcElectricApplianceType;
    string_map["IFCELECTRICDISTRIBUTIONBOARD"                  ] = Type::IfcElectricDistributionBoard;
    string_map["IFCELECTRICDISTRIBUTIONBOARDTYPE"              ] = Type::IfcElectricDistributionBoardType;
    string_map["IFCELECTRICFLOWSTORAGEDEVICE"                  ] = Type::IfcElectricFlowStorageDevice;
    string_map["IFCELECTRICFLOWSTORAGEDEVICETYPE"              ] = Type::IfcElectricFlowStorageDeviceType;
    string_map["IFCELECTRICGENERATOR"                          ] = Type::IfcElectricGenerator;
    string_map["IFCELECTRICGENERATORTYPE"                      ] = Type::IfcElectricGeneratorType;
    string_map["IFCELECTRICMOTOR"                              ] = Type::IfcElectricMotor;
    string_map["IFCELECTRICMOTORTYPE"                          ] = Type::IfcElectricMotorType;
    string_map["IFCELECTRICTIMECONTROL"                        ] = Type::IfcElectricTimeControl;
    string_map["IFCELECTRICTIMECONTROLTYPE"                    ] = Type::IfcElectricTimeControlType;
    string_map["IFCELEMENT"                                    ] = Type::IfcElement;
    string_map["IFCELEMENTASSEMBLY"                            ] = Type::IfcElementAssembly;
    string_map["IFCELEMENTASSEMBLYTYPE"                        ] = Type::IfcElementAssemblyType;
    string_map["IFCELEMENTCOMPONENT"                           ] = Type::IfcElementComponent;
    string_map["IFCELEMENTCOMPONENTTYPE"                       ] = Type::IfcElementComponentType;
    string_map["IFCELEMENTQUANTITY"                            ] = Type::IfcElementQuantity;
    string_map["IFCELEMENTTYPE"                                ] = Type::IfcElementType;
    string_map["IFCELEMENTARYSURFACE"                          ] = Type::IfcElementarySurface;
    string_map["IFCELLIPSE"                                    ] = Type::IfcEllipse;
    string_map["IFCELLIPSEPROFILEDEF"                          ] = Type::IfcEllipseProfileDef;
    string_map["IFCENERGYCONVERSIONDEVICE"                     ] = Type::IfcEnergyConversionDevice;
    string_map["IFCENERGYCONVERSIONDEVICETYPE"                 ] = Type::IfcEnergyConversionDeviceType;
    string_map["IFCENGINE"                                     ] = Type::IfcEngine;
    string_map["IFCENGINETYPE"                                 ] = Type::IfcEngineType;
    string_map["IFCEVAPORATIVECOOLER"                          ] = Type::IfcEvaporativeCooler;
    string_map["IFCEVAPORATIVECOOLERTYPE"                      ] = Type::IfcEvaporativeCoolerType;
    string_map["IFCEVAPORATOR"                                 ] = Type::IfcEvaporator;
    string_map["IFCEVAPORATORTYPE"                             ] = Type::IfcEvaporatorType;
    string_map["IFCEVENT"                                      ] = Type::IfcEvent;
    string_map["IFCEVENTTIME"                                  ] = Type::IfcEventTime;
    string_map["IFCEVENTTYPE"                                  ] = Type::IfcEventType;
    string_map["IFCEXTENDEDPROPERTIES"                         ] = Type::IfcExtendedProperties;
    string_map["IFCEXTERNALINFORMATION"                        ] = Type::IfcExternalInformation;
    string_map["IFCEXTERNALREFERENCE"                          ] = Type::IfcExternalReference;
    string_map["IFCEXTERNALREFERENCERELATIONSHIP"              ] = Type::IfcExternalReferenceRelationship;
    string_map["IFCEXTERNALSPATIALELEMENT"                     ] = Type::IfcExternalSpatialElement;
    string_map["IFCEXTERNALSPATIALSTRUCTUREELEMENT"            ] = Type::IfcExternalSpatialStructureElement;
    string_map["IFCEXTERNALLYDEFINEDHATCHSTYLE"                ] = Type::IfcExternallyDefinedHatchStyle;
    string_map["IFCEXTERNALLYDEFINEDSURFACESTYLE"              ] = Type::IfcExternallyDefinedSurfaceStyle;
    string_map["IFCEXTERNALLYDEFINEDTEXTFONT"                  ] = Type::IfcExternallyDefinedTextFont;
    string_map["IFCEXTRUDEDAREASOLID"                          ] = Type::IfcExtrudedAreaSolid;
    string_map["IFCEXTRUDEDAREASOLIDTAPERED"                   ] = Type::IfcExtrudedAreaSolidTapered;
    string_map["IFCFACE"                                       ] = Type::IfcFace;
    string_map["IFCFACEBASEDSURFACEMODEL"                      ] = Type::IfcFaceBasedSurfaceModel;
    string_map["IFCFACEBOUND"                                  ] = Type::IfcFaceBound;
    string_map["IFCFACEOUTERBOUND"                             ] = Type::IfcFaceOuterBound;
    string_map["IFCFACESURFACE"                                ] = Type::IfcFaceSurface;
    string_map["IFCFACETEDBREP"                                ] = Type::IfcFacetedBrep;
    string_map["IFCFACETEDBREPWITHVOIDS"                       ] = Type::IfcFacetedBrepWithVoids;
    string_map["IFCFAILURECONNECTIONCONDITION"                 ] = Type::IfcFailureConnectionCondition;
    string_map["IFCFAN"                                        ] = Type::IfcFan;
    string_map["IFCFANTYPE"                                    ] = Type::IfcFanType;
    string_map["IFCFASTENER"                                   ] = Type::IfcFastener;
    string_map["IFCFASTENERTYPE"                               ] = Type::IfcFastenerType;
    string_map["IFCFEATUREELEMENT"                             ] = Type::IfcFeatureElement;
    string_map["IFCFEATUREELEMENTADDITION"                     ] = Type::IfcFeatureElementAddition;
    string_map["IFCFEATUREELEMENTSUBTRACTION"                  ] = Type::IfcFeatureElementSubtraction;
    string_map["IFCFILLAREASTYLE"                              ] = Type::IfcFillAreaStyle;
    string_map["IFCFILLAREASTYLEHATCHING"                      ] = Type::IfcFillAreaStyleHatching;
    string_map["IFCFILLAREASTYLETILES"                         ] = Type::IfcFillAreaStyleTiles;
    string_map["IFCFILTER"                                     ] = Type::IfcFilter;
    string_map["IFCFILTERTYPE"                                 ] = Type::IfcFilterType;
    string_map["IFCFIRESUPPRESSIONTERMINAL"                    ] = Type::IfcFireSuppressionTerminal;
    string_map["IFCFIRESUPPRESSIONTERMINALTYPE"                ] = Type::IfcFireSuppressionTerminalType;
    string_map["IFCFIXEDREFERENCESWEPTAREASOLID"               ] = Type::IfcFixedReferenceSweptAreaSolid;
    string_map["IFCFLOWCONTROLLER"                             ] = Type::IfcFlowController;
    string_map["IFCFLOWCONTROLLERTYPE"                         ] = Type::IfcFlowControllerType;
    string_map["IFCFLOWFITTING"                                ] = Type::IfcFlowFitting;
    string_map["IFCFLOWFITTINGTYPE"                            ] = Type::IfcFlowFittingType;
    string_map["IFCFLOWINSTRUMENT"                             ] = Type::IfcFlowInstrument;
    string_map["IFCFLOWINSTRUMENTTYPE"                         ] = Type::IfcFlowInstrumentType;
    string_map["IFCFLOWMETER"                                  ] = Type::IfcFlowMeter;
    string_map["IFCFLOWMETERTYPE"                              ] = Type::IfcFlowMeterType;
    string_map["IFCFLOWMOVINGDEVICE"                           ] = Type::IfcFlowMovingDevice;
    string_map["IFCFLOWMOVINGDEVICETYPE"                       ] = Type::IfcFlowMovingDeviceType;
    string_map["IFCFLOWSEGMENT"                                ] = Type::IfcFlowSegment;
    string_map["IFCFLOWSEGMENTTYPE"                            ] = Type::IfcFlowSegmentType;
    string_map["IFCFLOWSTORAGEDEVICE"                          ] = Type::IfcFlowStorageDevice;
    string_map["IFCFLOWSTORAGEDEVICETYPE"                      ] = Type::IfcFlowStorageDeviceType;
    string_map["IFCFLOWTERMINAL"                               ] = Type::IfcFlowTerminal;
    string_map["IFCFLOWTERMINALTYPE"                           ] = Type::IfcFlowTerminalType;
    string_map["IFCFLOWTREATMENTDEVICE"                        ] = Type::IfcFlowTreatmentDevice;
    string_map["IFCFLOWTREATMENTDEVICETYPE"                    ] = Type::IfcFlowTreatmentDeviceType;
    string_map["IFCFOOTING"                                    ] = Type::IfcFooting;
    string_map["IFCFOOTINGTYPE"                                ] = Type::IfcFootingType;
    string_map["IFCFURNISHINGELEMENT"                          ] = Type::IfcFurnishingElement;
    string_map["IFCFURNISHINGELEMENTTYPE"                      ] = Type::IfcFurnishingElementType;
    string_map["IFCFURNITURE"                                  ] = Type::IfcFurniture;
    string_map["IFCFURNITURETYPE"                              ] = Type::IfcFurnitureType;
    string_map["IFCGEOGRAPHICELEMENT"                          ] = Type::IfcGeographicElement;
    string_map["IFCGEOGRAPHICELEMENTTYPE"                      ] = Type::IfcGeographicElementType;
    string_map["IFCGEOMETRICCURVESET"                          ] = Type::IfcGeometricCurveSet;
    string_map["IFCGEOMETRICREPRESENTATIONCONTEXT"             ] = Type::IfcGeometricRepresentationContext;
    string_map["IFCGEOMETRICREPRESENTATIONITEM"                ] = Type::IfcGeometricRepresentationItem;
    string_map["IFCGEOMETRICREPRESENTATIONSUBCONTEXT"          ] = Type::IfcGeometricRepresentationSubContext;
    string_map["IFCGEOMETRICSET"                               ] = Type::IfcGeometricSet;
    string_map["IFCGRID"                                       ] = Type::IfcGrid;
    string_map["IFCGRIDAXIS"                                   ] = Type::IfcGridAxis;
    string_map["IFCGRIDPLACEMENT"                              ] = Type::IfcGridPlacement;
    string_map["IFCGROUP"                                      ] = Type::IfcGroup;
    string_map["IFCHALFSPACESOLID"                             ] = Type::IfcHalfSpaceSolid;
    string_map["IFCHEATEXCHANGER"                              ] = Type::IfcHeatExchanger;
    string_map["IFCHEATEXCHANGERTYPE"                          ] = Type::IfcHeatExchangerType;
    string_map["IFCHUMIDIFIER"                                 ] = Type::IfcHumidifier;
    string_map["IFCHUMIDIFIERTYPE"                             ] = Type::IfcHumidifierType;
    string_map["IFCISHAPEPROFILEDEF"                           ] = Type::IfcIShapeProfileDef;
    string_map["IFCIMAGETEXTURE"                               ] = Type::IfcImageTexture;
    string_map["IFCINDEXEDCOLOURMAP"                           ] = Type::IfcIndexedColourMap;
    string_map["IFCINDEXEDTEXTUREMAP"                          ] = Type::IfcIndexedTextureMap;
    string_map["IFCINDEXEDTRIANGLETEXTUREMAP"                  ] = Type::IfcIndexedTriangleTextureMap;
    string_map["IFCINTERCEPTOR"                                ] = Type::IfcInterceptor;
    string_map["IFCINTERCEPTORTYPE"                            ] = Type::IfcInterceptorType;
    string_map["IFCINVENTORY"                                  ] = Type::IfcInventory;
    string_map["IFCIRREGULARTIMESERIES"                        ] = Type::IfcIrregularTimeSeries;
    string_map["IFCIRREGULARTIMESERIESVALUE"                   ] = Type::IfcIrregularTimeSeriesValue;
    string_map["IFCJUNCTIONBOX"                                ] = Type::IfcJunctionBox;
    string_map["IFCJUNCTIONBOXTYPE"                            ] = Type::IfcJunctionBoxType;
    string_map["IFCLSHAPEPROFILEDEF"                           ] = Type::IfcLShapeProfileDef;
    string_map["IFCLABORRESOURCE"                              ] = Type::IfcLaborResource;
    string_map["IFCLABORRESOURCETYPE"                          ] = Type::IfcLaborResourceType;
    string_map["IFCLAGTIME"                                    ] = Type::IfcLagTime;
    string_map["IFCLAMP"                                       ] = Type::IfcLamp;
    string_map["IFCLAMPTYPE"                                   ] = Type::IfcLampType;
    string_map["IFCLIBRARYINFORMATION"                         ] = Type::IfcLibraryInformation;
    string_map["IFCLIBRARYREFERENCE"                           ] = Type::IfcLibraryReference;
    string_map["IFCLIGHTDISTRIBUTIONDATA"                      ] = Type::IfcLightDistributionData;
    string_map["IFCLIGHTFIXTURE"                               ] = Type::IfcLightFixture;
    string_map["IFCLIGHTFIXTURETYPE"                           ] = Type::IfcLightFixtureType;
    string_map["IFCLIGHTINTENSITYDISTRIBUTION"                 ] = Type::IfcLightIntensityDistribution;
    string_map["IFCLIGHTSOURCE"                                ] = Type::IfcLightSource;
    string_map["IFCLIGHTSOURCEAMBIENT"                         ] = Type::IfcLightSourceAmbient;
    string_map["IFCLIGHTSOURCEDIRECTIONAL"                     ] = Type::IfcLightSourceDirectional;
    string_map["IFCLIGHTSOURCEGONIOMETRIC"                     ] = Type::IfcLightSourceGoniometric;
    string_map["IFCLIGHTSOURCEPOSITIONAL"                      ] = Type::IfcLightSourcePositional;
    string_map["IFCLIGHTSOURCESPOT"                            ] = Type::IfcLightSourceSpot;
    string_map["IFCLINE"                                       ] = Type::IfcLine;
    string_map["IFCLOCALPLACEMENT"                             ] = Type::IfcLocalPlacement;
    string_map["IFCLOOP"                                       ] = Type::IfcLoop;
    string_map["IFCMANIFOLDSOLIDBREP"                          ] = Type::IfcManifoldSolidBrep;
    string_map["IFCMAPCONVERSION"                              ] = Type::IfcMapConversion;
    string_map["IFCMAPPEDITEM"                                 ] = Type::IfcMappedItem;
    string_map["IFCMATERIAL"                                   ] = Type::IfcMaterial;
    string_map["IFCMATERIALCLASSIFICATIONRELATIONSHIP"         ] = Type::IfcMaterialClassificationRelationship;
    string_map["IFCMATERIALCONSTITUENT"                        ] = Type::IfcMaterialConstituent;
    string_map["IFCMATERIALCONSTITUENTSET"                     ] = Type::IfcMaterialConstituentSet;
    string_map["IFCMATERIALDEFINITION"                         ] = Type::IfcMaterialDefinition;
    string_map["IFCMATERIALDEFINITIONREPRESENTATION"           ] = Type::IfcMaterialDefinitionRepresentation;
    string_map["IFCMATERIALLAYER"                              ] = Type::IfcMaterialLayer;
    string_map["IFCMATERIALLAYERSET"                           ] = Type::IfcMaterialLayerSet;
    string_map["IFCMATERIALLAYERSETUSAGE"                      ] = Type::IfcMaterialLayerSetUsage;
    string_map["IFCMATERIALLAYERWITHOFFSETS"                   ] = Type::IfcMaterialLayerWithOffsets;
    string_map["IFCMATERIALLIST"                               ] = Type::IfcMaterialList;
    string_map["IFCMATERIALPROFILE"                            ] = Type::IfcMaterialProfile;
    string_map["IFCMATERIALPROFILESET"                         ] = Type::IfcMaterialProfileSet;
    string_map["IFCMATERIALPROFILESETUSAGE"                    ] = Type::IfcMaterialProfileSetUsage;
    string_map["IFCMATERIALPROFILESETUSAGETAPERING"            ] = Type::IfcMaterialProfileSetUsageTapering;
    string_map["IFCMATERIALPROFILEWITHOFFSETS"                 ] = Type::IfcMaterialProfileWithOffsets;
    string_map["IFCMATERIALPROPERTIES"                         ] = Type::IfcMaterialProperties;
    string_map["IFCMATERIALRELATIONSHIP"                       ] = Type::IfcMaterialRelationship;
    string_map["IFCMATERIALUSAGEDEFINITION"                    ] = Type::IfcMaterialUsageDefinition;
    string_map["IFCMEASUREWITHUNIT"                            ] = Type::IfcMeasureWithUnit;
    string_map["IFCMECHANICALFASTENER"                         ] = Type::IfcMechanicalFastener;
    string_map["IFCMECHANICALFASTENERTYPE"                     ] = Type::IfcMechanicalFastenerType;
    string_map["IFCMEDICALDEVICE"                              ] = Type::IfcMedicalDevice;
    string_map["IFCMEDICALDEVICETYPE"                          ] = Type::IfcMedicalDeviceType;
    string_map["IFCMEMBER"                                     ] = Type::IfcMember;
    string_map["IFCMEMBERSTANDARDCASE"                         ] = Type::IfcMemberStandardCase;
    string_map["IFCMEMBERTYPE"                                 ] = Type::IfcMemberType;
    string_map["IFCMETRIC"                                     ] = Type::IfcMetric;
    string_map["IFCMIRROREDPROFILEDEF"                         ] = Type::IfcMirroredProfileDef;
    string_map["IFCMONETARYUNIT"                               ] = Type::IfcMonetaryUnit;
    string_map["IFCMOTORCONNECTION"                            ] = Type::IfcMotorConnection;
    string_map["IFCMOTORCONNECTIONTYPE"                        ] = Type::IfcMotorConnectionType;
    string_map["IFCNAMEDUNIT"                                  ] = Type::IfcNamedUnit;
    string_map["IFCOBJECT"                                     ] = Type::IfcObject;
    string_map["IFCOBJECTDEFINITION"                           ] = Type::IfcObjectDefinition;
    string_map["IFCOBJECTPLACEMENT"                            ] = Type::IfcObjectPlacement;
    string_map["IFCOBJECTIVE"                                  ] = Type::IfcObjective;
    string_map["IFCOCCUPANT"                                   ] = Type::IfcOccupant;
    string_map["IFCOFFSETCURVE2D"                              ] = Type::IfcOffsetCurve2D;
    string_map["IFCOFFSETCURVE3D"                              ] = Type::IfcOffsetCurve3D;
    string_map["IFCOPENSHELL"                                  ] = Type::IfcOpenShell;
    string_map["IFCOPENINGELEMENT"                             ] = Type::IfcOpeningElement;
    string_map["IFCOPENINGSTANDARDCASE"                        ] = Type::IfcOpeningStandardCase;
    string_map["IFCORGANIZATION"                               ] = Type::IfcOrganization;
    string_map["IFCORGANIZATIONRELATIONSHIP"                   ] = Type::IfcOrganizationRelationship;
    string_map["IFCORIENTEDEDGE"                               ] = Type::IfcOrientedEdge;
    string_map["IFCOUTERBOUNDARYCURVE"                         ] = Type::IfcOuterBoundaryCurve;
    string_map["IFCOUTLET"                                     ] = Type::IfcOutlet;
    string_map["IFCOUTLETTYPE"                                 ] = Type::IfcOutletType;
    string_map["IFCOWNERHISTORY"                               ] = Type::IfcOwnerHistory;
    string_map["IFCPARAMETERIZEDPROFILEDEF"                    ] = Type::IfcParameterizedProfileDef;
    string_map["IFCPATH"                                       ] = Type::IfcPath;
    string_map["IFCPCURVE"                                     ] = Type::IfcPcurve;
    string_map["IFCPERFORMANCEHISTORY"                         ] = Type::IfcPerformanceHistory;
    string_map["IFCPERMEABLECOVERINGPROPERTIES"                ] = Type::IfcPermeableCoveringProperties;
    string_map["IFCPERMIT"                                     ] = Type::IfcPermit;
    string_map["IFCPERSON"                                     ] = Type::IfcPerson;
    string_map["IFCPERSONANDORGANIZATION"                      ] = Type::IfcPersonAndOrganization;
    string_map["IFCPHYSICALCOMPLEXQUANTITY"                    ] = Type::IfcPhysicalComplexQuantity;
    string_map["IFCPHYSICALQUANTITY"                           ] = Type::IfcPhysicalQuantity;
    string_map["IFCPHYSICALSIMPLEQUANTITY"                     ] = Type::IfcPhysicalSimpleQuantity;
    string_map["IFCPILE"                                       ] = Type::IfcPile;
    string_map["IFCPILETYPE"                                   ] = Type::IfcPileType;
    string_map["IFCPIPEFITTING"                                ] = Type::IfcPipeFitting;
    string_map["IFCPIPEFITTINGTYPE"                            ] = Type::IfcPipeFittingType;
    string_map["IFCPIPESEGMENT"                                ] = Type::IfcPipeSegment;
    string_map["IFCPIPESEGMENTTYPE"                            ] = Type::IfcPipeSegmentType;
    string_map["IFCPIXELTEXTURE"                               ] = Type::IfcPixelTexture;
    string_map["IFCPLACEMENT"                                  ] = Type::IfcPlacement;
    string_map["IFCPLANARBOX"                                  ] = Type::IfcPlanarBox;
    string_map["IFCPLANAREXTENT"                               ] = Type::IfcPlanarExtent;
    string_map["IFCPLANE"                                      ] = Type::IfcPlane;
    string_map["IFCPLATE"                                      ] = Type::IfcPlate;
    string_map["IFCPLATESTANDARDCASE"                          ] = Type::IfcPlateStandardCase;
    string_map["IFCPLATETYPE"                                  ] = Type::IfcPlateType;
    string_map["IFCPOINT"                                      ] = Type::IfcPoint;
    string_map["IFCPOINTONCURVE"                               ] = Type::IfcPointOnCurve;
    string_map["IFCPOINTONSURFACE"                             ] = Type::IfcPointOnSurface;
    string_map["IFCPOLYLOOP"                                   ] = Type::IfcPolyLoop;
    string_map["IFCPOLYGONALBOUNDEDHALFSPACE"                  ] = Type::IfcPolygonalBoundedHalfSpace;
    string_map["IFCPOLYLINE"                                   ] = Type::IfcPolyline;
    string_map["IFCPORT"                                       ] = Type::IfcPort;
    string_map["IFCPOSTALADDRESS"                              ] = Type::IfcPostalAddress;
    string_map["IFCPREDEFINEDCOLOUR"                           ] = Type::IfcPreDefinedColour;
    string_map["IFCPREDEFINEDCURVEFONT"                        ] = Type::IfcPreDefinedCurveFont;
    string_map["IFCPREDEFINEDITEM"                             ] = Type::IfcPreDefinedItem;
    string_map["IFCPREDEFINEDPROPERTIES"                       ] = Type::IfcPreDefinedProperties;
    string_map["IFCPREDEFINEDPROPERTYSET"                      ] = Type::IfcPreDefinedPropertySet;
    string_map["IFCPREDEFINEDTEXTFONT"                         ] = Type::IfcPreDefinedTextFont;
    string_map["IFCPRESENTATIONITEM"                           ] = Type::IfcPresentationItem;
    string_map["IFCPRESENTATIONLAYERASSIGNMENT"                ] = Type::IfcPresentationLayerAssignment;
    string_map["IFCPRESENTATIONLAYERWITHSTYLE"                 ] = Type::IfcPresentationLayerWithStyle;
    string_map["IFCPRESENTATIONSTYLE"                          ] = Type::IfcPresentationStyle;
    string_map["IFCPRESENTATIONSTYLEASSIGNMENT"                ] = Type::IfcPresentationStyleAssignment;
    string_map["IFCPROCEDURE"                                  ] = Type::IfcProcedure;
    string_map["IFCPROCEDURETYPE"                              ] = Type::IfcProcedureType;
    string_map["IFCPROCESS"                                    ] = Type::IfcProcess;
    string_map["IFCPRODUCT"                                    ] = Type::IfcProduct;
    string_map["IFCPRODUCTDEFINITIONSHAPE"                     ] = Type::IfcProductDefinitionShape;
    string_map["IFCPRODUCTREPRESENTATION"                      ] = Type::IfcProductRepresentation;
    string_map["IFCPROFILEDEF"                                 ] = Type::IfcProfileDef;
    string_map["IFCPROFILEPROPERTIES"                          ] = Type::IfcProfileProperties;
    string_map["IFCPROJECT"                                    ] = Type::IfcProject;
    string_map["IFCPROJECTLIBRARY"                             ] = Type::IfcProjectLibrary;
    string_map["IFCPROJECTORDER"                               ] = Type::IfcProjectOrder;
    string_map["IFCPROJECTEDCRS"                               ] = Type::IfcProjectedCRS;
    string_map["IFCPROJECTIONELEMENT"                          ] = Type::IfcProjectionElement;
    string_map["IFCPROPERTY"                                   ] = Type::IfcProperty;
    string_map["IFCPROPERTYABSTRACTION"                        ] = Type::IfcPropertyAbstraction;
    string_map["IFCPROPERTYBOUNDEDVALUE"                       ] = Type::IfcPropertyBoundedValue;
    string_map["IFCPROPERTYDEFINITION"                         ] = Type::IfcPropertyDefinition;
    string_map["IFCPROPERTYDEPENDENCYRELATIONSHIP"             ] = Type::IfcPropertyDependencyRelationship;
    string_map["IFCPROPERTYENUMERATEDVALUE"                    ] = Type::IfcPropertyEnumeratedValue;
    string_map["IFCPROPERTYENUMERATION"                        ] = Type::IfcPropertyEnumeration;
    string_map["IFCPROPERTYLISTVALUE"                          ] = Type::IfcPropertyListValue;
    string_map["IFCPROPERTYREFERENCEVALUE"                     ] = Type::IfcPropertyReferenceValue;
    string_map["IFCPROPERTYSET"                                ] = Type::IfcPropertySet;
    string_map["IFCPROPERTYSETDEFINITION"                      ] = Type::IfcPropertySetDefinition;
    string_map["IFCPROPERTYSETTEMPLATE"                        ] = Type::IfcPropertySetTemplate;
    string_map["IFCPROPERTYSINGLEVALUE"                        ] = Type::IfcPropertySingleValue;
    string_map["IFCPROPERTYTABLEVALUE"                         ] = Type::IfcPropertyTableValue;
    string_map["IFCPROPERTYTEMPLATE"                           ] = Type::IfcPropertyTemplate;
    string_map["IFCPROPERTYTEMPLATEDEFINITION"                 ] = Type::IfcPropertyTemplateDefinition;
    string_map["IFCPROTECTIVEDEVICE"                           ] = Type::IfcProtectiveDevice;
    string_map["IFCPROTECTIVEDEVICETRIPPINGUNIT"               ] = Type::IfcProtectiveDeviceTrippingUnit;
    string_map["IFCPROTECTIVEDEVICETRIPPINGUNITTYPE"           ] = Type::IfcProtectiveDeviceTrippingUnitType;
    string_map["IFCPROTECTIVEDEVICETYPE"                       ] = Type::IfcProtectiveDeviceType;
    string_map["IFCPROXY"                                      ] = Type::IfcProxy;
    string_map["IFCPUMP"                                       ] = Type::IfcPump;
    string_map["IFCPUMPTYPE"                                   ] = Type::IfcPumpType;
    string_map["IFCQUANTITYAREA"                               ] = Type::IfcQuantityArea;
    string_map["IFCQUANTITYCOUNT"                              ] = Type::IfcQuantityCount;
    string_map["IFCQUANTITYLENGTH"                             ] = Type::IfcQuantityLength;
    string_map["IFCQUANTITYSET"                                ] = Type::IfcQuantitySet;
    string_map["IFCQUANTITYTIME"                               ] = Type::IfcQuantityTime;
    string_map["IFCQUANTITYVOLUME"                             ] = Type::IfcQuantityVolume;
    string_map["IFCQUANTITYWEIGHT"                             ] = Type::IfcQuantityWeight;
    string_map["IFCRAILING"                                    ] = Type::IfcRailing;
    string_map["IFCRAILINGTYPE"                                ] = Type::IfcRailingType;
    string_map["IFCRAMP"                                       ] = Type::IfcRamp;
    string_map["IFCRAMPFLIGHT"                                 ] = Type::IfcRampFlight;
    string_map["IFCRAMPFLIGHTTYPE"                             ] = Type::IfcRampFlightType;
    string_map["IFCRAMPTYPE"                                   ] = Type::IfcRampType;
    string_map["IFCRATIONALBSPLINECURVEWITHKNOTS"              ] = Type::IfcRationalBSplineCurveWithKnots;
    string_map["IFCRATIONALBSPLINESURFACEWITHKNOTS"            ] = Type::IfcRationalBSplineSurfaceWithKnots;
    string_map["IFCRECTANGLEHOLLOWPROFILEDEF"                  ] = Type::IfcRectangleHollowProfileDef;
    string_map["IFCRECTANGLEPROFILEDEF"                        ] = Type::IfcRectangleProfileDef;
    string_map["IFCRECTANGULARPYRAMID"                         ] = Type::IfcRectangularPyramid;
    string_map["IFCRECTANGULARTRIMMEDSURFACE"                  ] = Type::IfcRectangularTrimmedSurface;
    string_map["IFCRECURRENCEPATTERN"                          ] = Type::IfcRecurrencePattern;
    string_map["IFCREFERENCE"                                  ] = Type::IfcReference;
    string_map["IFCREGULARTIMESERIES"                          ] = Type::IfcRegularTimeSeries;
    string_map["IFCREINFORCEMENTBARPROPERTIES"                 ] = Type::IfcReinforcementBarProperties;
    string_map["IFCREINFORCEMENTDEFINITIONPROPERTIES"          ] = Type::IfcReinforcementDefinitionProperties;
    string_map["IFCREINFORCINGBAR"                             ] = Type::IfcReinforcingBar;
    string_map["IFCREINFORCINGBARTYPE"                         ] = Type::IfcReinforcingBarType;
    string_map["IFCREINFORCINGELEMENT"                         ] = Type::IfcReinforcingElement;
    string_map["IFCREINFORCINGELEMENTTYPE"                     ] = Type::IfcReinforcingElementType;
    string_map["IFCREINFORCINGMESH"                            ] = Type::IfcReinforcingMesh;
    string_map["IFCREINFORCINGMESHTYPE"                        ] = Type::IfcReinforcingMeshType;
    string_map["IFCRELAGGREGATES"                              ] = Type::IfcRelAggregates;
    string_map["IFCRELASSIGNS"                                 ] = Type::IfcRelAssigns;
    string_map["IFCRELASSIGNSTOACTOR"                          ] = Type::IfcRelAssignsToActor;
    string_map["IFCRELASSIGNSTOCONTROL"                        ] = Type::IfcRelAssignsToControl;
    string_map["IFCRELASSIGNSTOGROUP"                          ] = Type::IfcRelAssignsToGroup;
    string_map["IFCRELASSIGNSTOGROUPBYFACTOR"                  ] = Type::IfcRelAssignsToGroupByFactor;
    string_map["IFCRELASSIGNSTOPROCESS"                        ] = Type::IfcRelAssignsToProcess;
    string_map["IFCRELASSIGNSTOPRODUCT"                        ] = Type::IfcRelAssignsToProduct;
    string_map["IFCRELASSIGNSTORESOURCE"                       ] = Type::IfcRelAssignsToResource;
    string_map["IFCRELASSOCIATES"                              ] = Type::IfcRelAssociates;
    string_map["IFCRELASSOCIATESAPPROVAL"                      ] = Type::IfcRelAssociatesApproval;
    string_map["IFCRELASSOCIATESCLASSIFICATION"                ] = Type::IfcRelAssociatesClassification;
    string_map["IFCRELASSOCIATESCONSTRAINT"                    ] = Type::IfcRelAssociatesConstraint;
    string_map["IFCRELASSOCIATESDOCUMENT"                      ] = Type::IfcRelAssociatesDocument;
    string_map["IFCRELASSOCIATESLIBRARY"                       ] = Type::IfcRelAssociatesLibrary;
    string_map["IFCRELASSOCIATESMATERIAL"                      ] = Type::IfcRelAssociatesMaterial;
    string_map["IFCRELCONNECTS"                                ] = Type::IfcRelConnects;
    string_map["IFCRELCONNECTSELEMENTS"                        ] = Type::IfcRelConnectsElements;
    string_map["IFCRELCONNECTSPATHELEMENTS"                    ] = Type::IfcRelConnectsPathElements;
    string_map["IFCRELCONNECTSPORTTOELEMENT"                   ] = Type::IfcRelConnectsPortToElement;
    string_map["IFCRELCONNECTSPORTS"                           ] = Type::IfcRelConnectsPorts;
    string_map["IFCRELCONNECTSSTRUCTURALACTIVITY"              ] = Type::IfcRelConnectsStructuralActivity;
    string_map["IFCRELCONNECTSSTRUCTURALMEMBER"                ] = Type::IfcRelConnectsStructuralMember;
    string_map["IFCRELCONNECTSWITHECCENTRICITY"                ] = Type::IfcRelConnectsWithEccentricity;
    string_map["IFCRELCONNECTSWITHREALIZINGELEMENTS"           ] = Type::IfcRelConnectsWithRealizingElements;
    string_map["IFCRELCONTAINEDINSPATIALSTRUCTURE"             ] = Type::IfcRelContainedInSpatialStructure;
    string_map["IFCRELCOVERSBLDGELEMENTS"                      ] = Type::IfcRelCoversBldgElements;
    string_map["IFCRELCOVERSSPACES"                            ] = Type::IfcRelCoversSpaces;
    string_map["IFCRELDECLARES"                                ] = Type::IfcRelDeclares;
    string_map["IFCRELDECOMPOSES"                              ] = Type::IfcRelDecomposes;
    string_map["IFCRELDEFINES"                                 ] = Type::IfcRelDefines;
    string_map["IFCRELDEFINESBYOBJECT"                         ] = Type::IfcRelDefinesByObject;
    string_map["IFCRELDEFINESBYPROPERTIES"                     ] = Type::IfcRelDefinesByProperties;
    string_map["IFCRELDEFINESBYTEMPLATE"                       ] = Type::IfcRelDefinesByTemplate;
    string_map["IFCRELDEFINESBYTYPE"                           ] = Type::IfcRelDefinesByType;
    string_map["IFCRELFILLSELEMENT"                            ] = Type::IfcRelFillsElement;
    string_map["IFCRELFLOWCONTROLELEMENTS"                     ] = Type::IfcRelFlowControlElements;
    string_map["IFCRELINTERFERESELEMENTS"                      ] = Type::IfcRelInterferesElements;
    string_map["IFCRELNESTS"                                   ] = Type::IfcRelNests;
    string_map["IFCRELPROJECTSELEMENT"                         ] = Type::IfcRelProjectsElement;
    string_map["IFCRELREFERENCEDINSPATIALSTRUCTURE"            ] = Type::IfcRelReferencedInSpatialStructure;
    string_map["IFCRELSEQUENCE"                                ] = Type::IfcRelSequence;
    string_map["IFCRELSERVICESBUILDINGS"                       ] = Type::IfcRelServicesBuildings;
    string_map["IFCRELSPACEBOUNDARY"                           ] = Type::IfcRelSpaceBoundary;
    string_map["IFCRELSPACEBOUNDARY1STLEVEL"                   ] = Type::IfcRelSpaceBoundary1stLevel;
    string_map["IFCRELSPACEBOUNDARY2NDLEVEL"                   ] = Type::IfcRelSpaceBoundary2ndLevel;
    string_map["IFCRELVOIDSELEMENT"                            ] = Type::IfcRelVoidsElement;
    string_map["IFCRELATIONSHIP"                               ] = Type::IfcRelationship;
    string_map["IFCREPARAMETRISEDCOMPOSITECURVESEGMENT"        ] = Type::IfcReparametrisedCompositeCurveSegment;
    string_map["IFCREPRESENTATION"                             ] = Type::IfcRepresentation;
    string_map["IFCREPRESENTATIONCONTEXT"                      ] = Type::IfcRepresentationContext;
    string_map["IFCREPRESENTATIONITEM"                         ] = Type::IfcRepresentationItem;
    string_map["IFCREPRESENTATIONMAP"                          ] = Type::IfcRepresentationMap;
    string_map["IFCRESOURCE"                                   ] = Type::IfcResource;
    string_map["IFCRESOURCEAPPROVALRELATIONSHIP"               ] = Type::IfcResourceApprovalRelationship;
    string_map["IFCRESOURCECONSTRAINTRELATIONSHIP"             ] = Type::IfcResourceConstraintRelationship;
    string_map["IFCRESOURCELEVELRELATIONSHIP"                  ] = Type::IfcResourceLevelRelationship;
    string_map["IFCRESOURCETIME"                               ] = Type::IfcResourceTime;
    string_map["IFCREVOLVEDAREASOLID"                          ] = Type::IfcRevolvedAreaSolid;
    string_map["IFCREVOLVEDAREASOLIDTAPERED"                   ] = Type::IfcRevolvedAreaSolidTapered;
    string_map["IFCRIGHTCIRCULARCONE"                          ] = Type::IfcRightCircularCone;
    string_map["IFCRIGHTCIRCULARCYLINDER"                      ] = Type::IfcRightCircularCylinder;
    string_map["IFCROOF"                                       ] = Type::IfcRoof;
    string_map["IFCROOFTYPE"                                   ] = Type::IfcRoofType;
    string_map["IFCROOT"                                       ] = Type::IfcRoot;
    string_map["IFCROUNDEDRECTANGLEPROFILEDEF"                 ] = Type::IfcRoundedRectangleProfileDef;
    string_map["IFCSIUNIT"                                     ] = Type::IfcSIUnit;
    string_map["IFCSANITARYTERMINAL"                           ] = Type::IfcSanitaryTerminal;
    string_map["IFCSANITARYTERMINALTYPE"                       ] = Type::IfcSanitaryTerminalType;
    string_map["IFCSCHEDULINGTIME"                             ] = Type::IfcSchedulingTime;
    string_map["IFCSECTIONPROPERTIES"                          ] = Type::IfcSectionProperties;
    string_map["IFCSECTIONREINFORCEMENTPROPERTIES"             ] = Type::IfcSectionReinforcementProperties;
    string_map["IFCSECTIONEDSPINE"                             ] = Type::IfcSectionedSpine;
    string_map["IFCSENSOR"                                     ] = Type::IfcSensor;
    string_map["IFCSENSORTYPE"                                 ] = Type::IfcSensorType;
    string_map["IFCSHADINGDEVICE"                              ] = Type::IfcShadingDevice;
    string_map["IFCSHADINGDEVICETYPE"                          ] = Type::IfcShadingDeviceType;
    string_map["IFCSHAPEASPECT"                                ] = Type::IfcShapeAspect;
    string_map["IFCSHAPEMODEL"                                 ] = Type::IfcShapeModel;
    string_map["IFCSHAPEREPRESENTATION"                        ] = Type::IfcShapeRepresentation;
    string_map["IFCSHELLBASEDSURFACEMODEL"                     ] = Type::IfcShellBasedSurfaceModel;
    string_map["IFCSIMPLEPROPERTY"                             ] = Type::IfcSimpleProperty;
    string_map["IFCSIMPLEPROPERTYTEMPLATE"                     ] = Type::IfcSimplePropertyTemplate;
    string_map["IFCSITE"                                       ] = Type::IfcSite;
    string_map["IFCSLAB"                                       ] = Type::IfcSlab;
    string_map["IFCSLABELEMENTEDCASE"                          ] = Type::IfcSlabElementedCase;
    string_map["IFCSLABSTANDARDCASE"                           ] = Type::IfcSlabStandardCase;
    string_map["IFCSLABTYPE"                                   ] = Type::IfcSlabType;
    string_map["IFCSLIPPAGECONNECTIONCONDITION"                ] = Type::IfcSlippageConnectionCondition;
    string_map["IFCSOLARDEVICE"                                ] = Type::IfcSolarDevice;
    string_map["IFCSOLARDEVICETYPE"                            ] = Type::IfcSolarDeviceType;
    string_map["IFCSOLIDMODEL"                                 ] = Type::IfcSolidModel;
    string_map["IFCSPACE"                                      ] = Type::IfcSpace;
    string_map["IFCSPACEHEATER"                                ] = Type::IfcSpaceHeater;
    string_map["IFCSPACEHEATERTYPE"                            ] = Type::IfcSpaceHeaterType;
    string_map["IFCSPACETYPE"                                  ] = Type::IfcSpaceType;
    string_map["IFCSPATIALELEMENT"                             ] = Type::IfcSpatialElement;
    string_map["IFCSPATIALELEMENTTYPE"                         ] = Type::IfcSpatialElementType;
    string_map["IFCSPATIALSTRUCTUREELEMENT"                    ] = Type::IfcSpatialStructureElement;
    string_map["IFCSPATIALSTRUCTUREELEMENTTYPE"                ] = Type::IfcSpatialStructureElementType;
    string_map["IFCSPATIALZONE"                                ] = Type::IfcSpatialZone;
    string_map["IFCSPATIALZONETYPE"                            ] = Type::IfcSpatialZoneType;
    string_map["IFCSPHERE"                                     ] = Type::IfcSphere;
    string_map["IFCSTACKTERMINAL"                              ] = Type::IfcStackTerminal;
    string_map["IFCSTACKTERMINALTYPE"                          ] = Type::IfcStackTerminalType;
    string_map["IFCSTAIR"                                      ] = Type::IfcStair;
    string_map["IFCSTAIRFLIGHT"                                ] = Type::IfcStairFlight;
    string_map["IFCSTAIRFLIGHTTYPE"                            ] = Type::IfcStairFlightType;
    string_map["IFCSTAIRTYPE"                                  ] = Type::IfcStairType;
    string_map["IFCSTRUCTURALACTION"                           ] = Type::IfcStructuralAction;
    string_map["IFCSTRUCTURALACTIVITY"                         ] = Type::IfcStructuralActivity;
    string_map["IFCSTRUCTURALANALYSISMODEL"                    ] = Type::IfcStructuralAnalysisModel;
    string_map["IFCSTRUCTURALCONNECTION"                       ] = Type::IfcStructuralConnection;
    string_map["IFCSTRUCTURALCONNECTIONCONDITION"              ] = Type::IfcStructuralConnectionCondition;
    string_map["IFCSTRUCTURALCURVEACTION"                      ] = Type::IfcStructuralCurveAction;
    string_map["IFCSTRUCTURALCURVECONNECTION"                  ] = Type::IfcStructuralCurveConnection;
    string_map["IFCSTRUCTURALCURVEMEMBER"                      ] = Type::IfcStructuralCurveMember;
    string_map["IFCSTRUCTURALCURVEMEMBERVARYING"               ] = Type::IfcStructuralCurveMemberVarying;
    string_map["IFCSTRUCTURALCURVEREACTION"                    ] = Type::IfcStructuralCurveReaction;
    string_map["IFCSTRUCTURALITEM"                             ] = Type::IfcStructuralItem;
    string_map["IFCSTRUCTURALLINEARACTION"                     ] = Type::IfcStructuralLinearAction;
    string_map["IFCSTRUCTURALLOAD"                             ] = Type::IfcStructuralLoad;
    string_map["IFCSTRUCTURALLOADCASE"                         ] = Type::IfcStructuralLoadCase;
    string_map["IFCSTRUCTURALLOADCONFIGURATION"                ] = Type::IfcStructuralLoadConfiguration;
    string_map["IFCSTRUCTURALLOADGROUP"                        ] = Type::IfcStructuralLoadGroup;
    string_map["IFCSTRUCTURALLOADLINEARFORCE"                  ] = Type::IfcStructuralLoadLinearForce;
    string_map["IFCSTRUCTURALLOADORRESULT"                     ] = Type::IfcStructuralLoadOrResult;
    string_map["IFCSTRUCTURALLOADPLANARFORCE"                  ] = Type::IfcStructuralLoadPlanarForce;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENT"           ] = Type::IfcStructuralLoadSingleDisplacement;
    string_map["IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION" ] = Type::IfcStructuralLoadSingleDisplacementDistortion;
    string_map["IFCSTRUCTURALLOADSINGLEFORCE"                  ] = Type::IfcStructuralLoadSingleForce;
    string_map["IFCSTRUCTURALLOADSINGLEFORCEWARPING"           ] = Type::IfcStructuralLoadSingleForceWarping;
    string_map["IFCSTRUCTURALLOADSTATIC"                       ] = Type::IfcStructuralLoadStatic;
    string_map["IFCSTRUCTURALLOADTEMPERATURE"                  ] = Type::IfcStructuralLoadTemperature;
    string_map["IFCSTRUCTURALMEMBER"                           ] = Type::IfcStructuralMember;
    string_map["IFCSTRUCTURALPLANARACTION"                     ] = Type::IfcStructuralPlanarAction;
    string_map["IFCSTRUCTURALPOINTACTION"                      ] = Type::IfcStructuralPointAction;
    string_map["IFCSTRUCTURALPOINTCONNECTION"                  ] = Type::IfcStructuralPointConnection;
    string_map["IFCSTRUCTURALPOINTREACTION"                    ] = Type::IfcStructuralPointReaction;
    string_map["IFCSTRUCTURALREACTION"                         ] = Type::IfcStructuralReaction;
    string_map["IFCSTRUCTURALRESULTGROUP"                      ] = Type::IfcStructuralResultGroup;
    string_map["IFCSTRUCTURALSURFACEACTION"                    ] = Type::IfcStructuralSurfaceAction;
    string_map["IFCSTRUCTURALSURFACECONNECTION"                ] = Type::IfcStructuralSurfaceConnection;
    string_map["IFCSTRUCTURALSURFACEMEMBER"                    ] = Type::IfcStructuralSurfaceMember;
    string_map["IFCSTRUCTURALSURFACEMEMBERVARYING"             ] = Type::IfcStructuralSurfaceMemberVarying;
    string_map["IFCSTRUCTURALSURFACEREACTION"                  ] = Type::IfcStructuralSurfaceReaction;
    string_map["IFCSTYLEMODEL"                                 ] = Type::IfcStyleModel;
    string_map["IFCSTYLEDITEM"                                 ] = Type::IfcStyledItem;
    string_map["IFCSTYLEDREPRESENTATION"                       ] = Type::IfcStyledRepresentation;
    string_map["IFCSUBCONTRACTRESOURCE"                        ] = Type::IfcSubContractResource;
    string_map["IFCSUBCONTRACTRESOURCETYPE"                    ] = Type::IfcSubContractResourceType;
    string_map["IFCSUBEDGE"                                    ] = Type::IfcSubedge;
    string_map["IFCSURFACE"                                    ] = Type::IfcSurface;
    string_map["IFCSURFACECURVESWEPTAREASOLID"                 ] = Type::IfcSurfaceCurveSweptAreaSolid;
    string_map["IFCSURFACEFEATURE"                             ] = Type::IfcSurfaceFeature;
    string_map["IFCSURFACEOFLINEAREXTRUSION"                   ] = Type::IfcSurfaceOfLinearExtrusion;
    string_map["IFCSURFACEOFREVOLUTION"                        ] = Type::IfcSurfaceOfRevolution;
    string_map["IFCSURFACEREINFORCEMENTAREA"                   ] = Type::IfcSurfaceReinforcementArea;
    string_map["IFCSURFACESTYLE"                               ] = Type::IfcSurfaceStyle;
    string_map["IFCSURFACESTYLELIGHTING"                       ] = Type::IfcSurfaceStyleLighting;
    string_map["IFCSURFACESTYLEREFRACTION"                     ] = Type::IfcSurfaceStyleRefraction;
    string_map["IFCSURFACESTYLERENDERING"                      ] = Type::IfcSurfaceStyleRendering;
    string_map["IFCSURFACESTYLESHADING"                        ] = Type::IfcSurfaceStyleShading;
    string_map["IFCSURFACESTYLEWITHTEXTURES"                   ] = Type::IfcSurfaceStyleWithTextures;
    string_map["IFCSURFACETEXTURE"                             ] = Type::IfcSurfaceTexture;
    string_map["IFCSWEPTAREASOLID"                             ] = Type::IfcSweptAreaSolid;
    string_map["IFCSWEPTDISKSOLID"                             ] = Type::IfcSweptDiskSolid;
    string_map["IFCSWEPTDISKSOLIDPOLYGONAL"                    ] = Type::IfcSweptDiskSolidPolygonal;
    string_map["IFCSWEPTSURFACE"                               ] = Type::IfcSweptSurface;
    string_map["IFCSWITCHINGDEVICE"                            ] = Type::IfcSwitchingDevice;
    string_map["IFCSWITCHINGDEVICETYPE"                        ] = Type::IfcSwitchingDeviceType;
    string_map["IFCSYSTEM"                                     ] = Type::IfcSystem;
    string_map["IFCSYSTEMFURNITUREELEMENT"                     ] = Type::IfcSystemFurnitureElement;
    string_map["IFCSYSTEMFURNITUREELEMENTTYPE"                 ] = Type::IfcSystemFurnitureElementType;
    string_map["IFCTSHAPEPROFILEDEF"                           ] = Type::IfcTShapeProfileDef;
    string_map["IFCTABLE"                                      ] = Type::IfcTable;
    string_map["IFCTABLECOLUMN"                                ] = Type::IfcTableColumn;
    string_map["IFCTABLEROW"                                   ] = Type::IfcTableRow;
    string_map["IFCTANK"                                       ] = Type::IfcTank;
    string_map["IFCTANKTYPE"                                   ] = Type::IfcTankType;
    string_map["IFCTASK"                                       ] = Type::IfcTask;
    string_map["IFCTASKTIME"                                   ] = Type::IfcTaskTime;
    string_map["IFCTASKTIMERECURRING"                          ] = Type::IfcTaskTimeRecurring;
    string_map["IFCTASKTYPE"                                   ] = Type::IfcTaskType;
    string_map["IFCTELECOMADDRESS"                             ] = Type::IfcTelecomAddress;
    string_map["IFCTENDON"                                     ] = Type::IfcTendon;
    string_map["IFCTENDONANCHOR"                               ] = Type::IfcTendonAnchor;
    string_map["IFCTENDONANCHORTYPE"                           ] = Type::IfcTendonAnchorType;
    string_map["IFCTENDONTYPE"                                 ] = Type::IfcTendonType;
    string_map["IFCTESSELLATEDFACESET"                         ] = Type::IfcTessellatedFaceSet;
    string_map["IFCTESSELLATEDITEM"                            ] = Type::IfcTessellatedItem;
    string_map["IFCTEXTLITERAL"                                ] = Type::IfcTextLiteral;
    string_map["IFCTEXTLITERALWITHEXTENT"                      ] = Type::IfcTextLiteralWithExtent;
    string_map["IFCTEXTSTYLE"                                  ] = Type::IfcTextStyle;
    string_map["IFCTEXTSTYLEFONTMODEL"                         ] = Type::IfcTextStyleFontModel;
    string_map["IFCTEXTSTYLEFORDEFINEDFONT"                    ] = Type::IfcTextStyleForDefinedFont;
    string_map["IFCTEXTSTYLETEXTMODEL"                         ] = Type::IfcTextStyleTextModel;
    string_map["IFCTEXTURECOORDINATE"                          ] = Type::IfcTextureCoordinate;
    string_map["IFCTEXTURECOORDINATEGENERATOR"                 ] = Type::IfcTextureCoordinateGenerator;
    string_map["IFCTEXTUREMAP"                                 ] = Type::IfcTextureMap;
    string_map["IFCTEXTUREVERTEX"                              ] = Type::IfcTextureVertex;
    string_map["IFCTEXTUREVERTEXLIST"                          ] = Type::IfcTextureVertexList;
    string_map["IFCTIMEPERIOD"                                 ] = Type::IfcTimePeriod;
    string_map["IFCTIMESERIES"                                 ] = Type::IfcTimeSeries;
    string_map["IFCTIMESERIESVALUE"                            ] = Type::IfcTimeSeriesValue;
    string_map["IFCTOPOLOGICALREPRESENTATIONITEM"              ] = Type::IfcTopologicalRepresentationItem;
    string_map["IFCTOPOLOGYREPRESENTATION"                     ] = Type::IfcTopologyRepresentation;
    string_map["IFCTRANSFORMER"                                ] = Type::IfcTransformer;
    string_map["IFCTRANSFORMERTYPE"                            ] = Type::IfcTransformerType;
    string_map["IFCTRANSPORTELEMENT"                           ] = Type::IfcTransportElement;
    string_map["IFCTRANSPORTELEMENTTYPE"                       ] = Type::IfcTransportElementType;
    string_map["IFCTRAPEZIUMPROFILEDEF"                        ] = Type::IfcTrapeziumProfileDef;
    string_map["IFCTRIANGULATEDFACESET"                        ] = Type::IfcTriangulatedFaceSet;
    string_map["IFCTRIMMEDCURVE"                               ] = Type::IfcTrimmedCurve;
    string_map["IFCTUBEBUNDLE"                                 ] = Type::IfcTubeBundle;
    string_map["IFCTUBEBUNDLETYPE"                             ] = Type::IfcTubeBundleType;
    string_map["IFCTYPEOBJECT"                                 ] = Type::IfcTypeObject;
    string_map["IFCTYPEPROCESS"                                ] = Type::IfcTypeProcess;
    string_map["IFCTYPEPRODUCT"                                ] = Type::IfcTypeProduct;
    string_map["IFCTYPERESOURCE"                               ] = Type::IfcTypeResource;
    string_map["IFCUSHAPEPROFILEDEF"                           ] = Type::IfcUShapeProfileDef;
    string_map["IFCUNITASSIGNMENT"                             ] = Type::IfcUnitAssignment;
    string_map["IFCUNITARYCONTROLELEMENT"                      ] = Type::IfcUnitaryControlElement;
    string_map["IFCUNITARYCONTROLELEMENTTYPE"                  ] = Type::IfcUnitaryControlElementType;
    string_map["IFCUNITARYEQUIPMENT"                           ] = Type::IfcUnitaryEquipment;
    string_map["IFCUNITARYEQUIPMENTTYPE"                       ] = Type::IfcUnitaryEquipmentType;
    string_map["IFCVALVE"                                      ] = Type::IfcValve;
    string_map["IFCVALVETYPE"                                  ] = Type::IfcValveType;
    string_map["IFCVECTOR"                                     ] = Type::IfcVector;
    string_map["IFCVERTEX"                                     ] = Type::IfcVertex;
    string_map["IFCVERTEXLOOP"                                 ] = Type::IfcVertexLoop;
    string_map["IFCVERTEXPOINT"                                ] = Type::IfcVertexPoint;
    string_map["IFCVIBRATIONISOLATOR"                          ] = Type::IfcVibrationIsolator;
    string_map["IFCVIBRATIONISOLATORTYPE"                      ] = Type::IfcVibrationIsolatorType;
    string_map["IFCVIRTUALELEMENT"                             ] = Type::IfcVirtualElement;
    string_map["IFCVIRTUALGRIDINTERSECTION"                    ] = Type::IfcVirtualGridIntersection;
    string_map["IFCVOIDINGFEATURE"                             ] = Type::IfcVoidingFeature;
    string_map["IFCWALL"                                       ] = Type::IfcWall;
    string_map["IFCWALLELEMENTEDCASE"                          ] = Type::IfcWallElementedCase;
    string_map["IFCWALLSTANDARDCASE"                           ] = Type::IfcWallStandardCase;
    string_map["IFCWALLTYPE"                                   ] = Type::IfcWallType;
    string_map["IFCWASTETERMINAL"                              ] = Type::IfcWasteTerminal;
    string_map["IFCWASTETERMINALTYPE"                          ] = Type::IfcWasteTerminalType;
    string_map["IFCWINDOW"                                     ] = Type::IfcWindow;
    string_map["IFCWINDOWLININGPROPERTIES"                     ] = Type::IfcWindowLiningProperties;
    string_map["IFCWINDOWPANELPROPERTIES"                      ] = Type::IfcWindowPanelProperties;
    string_map["IFCWINDOWSTANDARDCASE"                         ] = Type::IfcWindowStandardCase;
    string_map["IFCWINDOWSTYLE"                                ] = Type::IfcWindowStyle;
    string_map["IFCWINDOWTYPE"                                 ] = Type::IfcWindowType;
    string_map["IFCWORKCALENDAR"                               ] = Type::IfcWorkCalendar;
    string_map["IFCWORKCONTROL"                                ] = Type::IfcWorkControl;
    string_map["IFCWORKPLAN"                                   ] = Type::IfcWorkPlan;
    string_map["IFCWORKSCHEDULE"                               ] = Type::IfcWorkSchedule;
    string_map["IFCWORKTIME"                                   ] = Type::IfcWorkTime;
    string_map["IFCZSHAPEPROFILEDEF"                           ] = Type::IfcZShapeProfileDef;
    string_map["IFCZONE"                                       ] = Type::IfcZone;
}

Type::Enum Type::FromString(const std::string& s) {
    std::map<std::string,Type::Enum>::const_iterator it = string_map.find(s);
    if ( it == string_map.end() ) throw IfcException("Unable to find find keyword in schema");
    else return it->second;
}

Type::Enum Type::Parent(Enum v){
    if (v < 0 || v >= 882) return (Enum)-1;
    if(v==IfcActionRequest                              ) { return IfcControl; }
    if(v==IfcActor                                      ) { return IfcObject; }
    if(v==IfcActuator                                   ) { return IfcDistributionControlElement; }
    if(v==IfcActuatorType                               ) { return IfcDistributionControlElementType; }
    if(v==IfcAdvancedBrep                               ) { return IfcManifoldSolidBrep; }
    if(v==IfcAdvancedBrepWithVoids                      ) { return IfcAdvancedBrep; }
    if(v==IfcAdvancedFace                               ) { return IfcFaceSurface; }
    if(v==IfcAirTerminal                                ) { return IfcFlowTerminal; }
    if(v==IfcAirTerminalBox                             ) { return IfcFlowController; }
    if(v==IfcAirTerminalBoxType                         ) { return IfcFlowControllerType; }
    if(v==IfcAirTerminalType                            ) { return IfcFlowTerminalType; }
    if(v==IfcAirToAirHeatRecovery                       ) { return IfcEnergyConversionDevice; }
    if(v==IfcAirToAirHeatRecoveryType                   ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcAlarm                                      ) { return IfcDistributionControlElement; }
    if(v==IfcAlarmType                                  ) { return IfcDistributionControlElementType; }
    if(v==IfcAnnotation                                 ) { return IfcProduct; }
    if(v==IfcAnnotationFillArea                         ) { return IfcGeometricRepresentationItem; }
    if(v==IfcApprovalRelationship                       ) { return IfcResourceLevelRelationship; }
    if(v==IfcArbitraryClosedProfileDef                  ) { return IfcProfileDef; }
    if(v==IfcArbitraryOpenProfileDef                    ) { return IfcProfileDef; }
    if(v==IfcArbitraryProfileDefWithVoids               ) { return IfcArbitraryClosedProfileDef; }
    if(v==IfcAsset                                      ) { return IfcGroup; }
    if(v==IfcAsymmetricIShapeProfileDef                 ) { return IfcParameterizedProfileDef; }
    if(v==IfcAudioVisualAppliance                       ) { return IfcFlowTerminal; }
    if(v==IfcAudioVisualApplianceType                   ) { return IfcFlowTerminalType; }
    if(v==IfcAxis1Placement                             ) { return IfcPlacement; }
    if(v==IfcAxis2Placement2D                           ) { return IfcPlacement; }
    if(v==IfcAxis2Placement3D                           ) { return IfcPlacement; }
    if(v==IfcBSplineCurve                               ) { return IfcBoundedCurve; }
    if(v==IfcBSplineCurveWithKnots                      ) { return IfcBSplineCurve; }
    if(v==IfcBSplineSurface                             ) { return IfcBoundedSurface; }
    if(v==IfcBSplineSurfaceWithKnots                    ) { return IfcBSplineSurface; }
    if(v==IfcBeam                                       ) { return IfcBuildingElement; }
    if(v==IfcBeamStandardCase                           ) { return IfcBeam; }
    if(v==IfcBeamType                                   ) { return IfcBuildingElementType; }
    if(v==IfcBlobTexture                                ) { return IfcSurfaceTexture; }
    if(v==IfcBlock                                      ) { return IfcCsgPrimitive3D; }
    if(v==IfcBoiler                                     ) { return IfcEnergyConversionDevice; }
    if(v==IfcBoilerType                                 ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcBooleanClippingResult                      ) { return IfcBooleanResult; }
    if(v==IfcBooleanResult                              ) { return IfcGeometricRepresentationItem; }
    if(v==IfcBoundaryCurve                              ) { return IfcCompositeCurveOnSurface; }
    if(v==IfcBoundaryEdgeCondition                      ) { return IfcBoundaryCondition; }
    if(v==IfcBoundaryFaceCondition                      ) { return IfcBoundaryCondition; }
    if(v==IfcBoundaryNodeCondition                      ) { return IfcBoundaryCondition; }
    if(v==IfcBoundaryNodeConditionWarping               ) { return IfcBoundaryNodeCondition; }
    if(v==IfcBoundedCurve                               ) { return IfcCurve; }
    if(v==IfcBoundedSurface                             ) { return IfcSurface; }
    if(v==IfcBoundingBox                                ) { return IfcGeometricRepresentationItem; }
    if(v==IfcBoxedHalfSpace                             ) { return IfcHalfSpaceSolid; }
    if(v==IfcBuilding                                   ) { return IfcSpatialStructureElement; }
    if(v==IfcBuildingElement                            ) { return IfcElement; }
    if(v==IfcBuildingElementPart                        ) { return IfcElementComponent; }
    if(v==IfcBuildingElementPartType                    ) { return IfcElementComponentType; }
    if(v==IfcBuildingElementProxy                       ) { return IfcBuildingElement; }
    if(v==IfcBuildingElementProxyType                   ) { return IfcBuildingElementType; }
    if(v==IfcBuildingElementType                        ) { return IfcElementType; }
    if(v==IfcBuildingStorey                             ) { return IfcSpatialStructureElement; }
    if(v==IfcBuildingSystem                             ) { return IfcSystem; }
    if(v==IfcBurner                                     ) { return IfcEnergyConversionDevice; }
    if(v==IfcBurnerType                                 ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcCShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcCableCarrierFitting                        ) { return IfcFlowFitting; }
    if(v==IfcCableCarrierFittingType                    ) { return IfcFlowFittingType; }
    if(v==IfcCableCarrierSegment                        ) { return IfcFlowSegment; }
    if(v==IfcCableCarrierSegmentType                    ) { return IfcFlowSegmentType; }
    if(v==IfcCableFitting                               ) { return IfcFlowFitting; }
    if(v==IfcCableFittingType                           ) { return IfcFlowFittingType; }
    if(v==IfcCableSegment                               ) { return IfcFlowSegment; }
    if(v==IfcCableSegmentType                           ) { return IfcFlowSegmentType; }
    if(v==IfcCartesianPoint                             ) { return IfcPoint; }
    if(v==IfcCartesianPointList                         ) { return IfcGeometricRepresentationItem; }
    if(v==IfcCartesianPointList3D                       ) { return IfcCartesianPointList; }
    if(v==IfcCartesianTransformationOperator            ) { return IfcGeometricRepresentationItem; }
    if(v==IfcCartesianTransformationOperator2D          ) { return IfcCartesianTransformationOperator; }
    if(v==IfcCartesianTransformationOperator2DnonUniform) { return IfcCartesianTransformationOperator2D; }
    if(v==IfcCartesianTransformationOperator3D          ) { return IfcCartesianTransformationOperator; }
    if(v==IfcCartesianTransformationOperator3DnonUniform) { return IfcCartesianTransformationOperator3D; }
    if(v==IfcCenterLineProfileDef                       ) { return IfcArbitraryOpenProfileDef; }
    if(v==IfcChiller                                    ) { return IfcEnergyConversionDevice; }
    if(v==IfcChillerType                                ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcChimney                                    ) { return IfcBuildingElement; }
    if(v==IfcChimneyType                                ) { return IfcBuildingElementType; }
    if(v==IfcCircle                                     ) { return IfcConic; }
    if(v==IfcCircleHollowProfileDef                     ) { return IfcCircleProfileDef; }
    if(v==IfcCircleProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcCivilElement                               ) { return IfcElement; }
    if(v==IfcCivilElementType                           ) { return IfcElementType; }
    if(v==IfcClassification                             ) { return IfcExternalInformation; }
    if(v==IfcClassificationReference                    ) { return IfcExternalReference; }
    if(v==IfcClosedShell                                ) { return IfcConnectedFaceSet; }
    if(v==IfcCoil                                       ) { return IfcEnergyConversionDevice; }
    if(v==IfcCoilType                                   ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcColourRgb                                  ) { return IfcColourSpecification; }
    if(v==IfcColourRgbList                              ) { return IfcPresentationItem; }
    if(v==IfcColourSpecification                        ) { return IfcPresentationItem; }
    if(v==IfcColumn                                     ) { return IfcBuildingElement; }
    if(v==IfcColumnStandardCase                         ) { return IfcColumn; }
    if(v==IfcColumnType                                 ) { return IfcBuildingElementType; }
    if(v==IfcCommunicationsAppliance                    ) { return IfcFlowTerminal; }
    if(v==IfcCommunicationsApplianceType                ) { return IfcFlowTerminalType; }
    if(v==IfcComplexProperty                            ) { return IfcProperty; }
    if(v==IfcComplexPropertyTemplate                    ) { return IfcPropertyTemplate; }
    if(v==IfcCompositeCurve                             ) { return IfcBoundedCurve; }
    if(v==IfcCompositeCurveOnSurface                    ) { return IfcCompositeCurve; }
    if(v==IfcCompositeCurveSegment                      ) { return IfcGeometricRepresentationItem; }
    if(v==IfcCompositeProfileDef                        ) { return IfcProfileDef; }
    if(v==IfcCompressor                                 ) { return IfcFlowMovingDevice; }
    if(v==IfcCompressorType                             ) { return IfcFlowMovingDeviceType; }
    if(v==IfcCondenser                                  ) { return IfcEnergyConversionDevice; }
    if(v==IfcCondenserType                              ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcConic                                      ) { return IfcCurve; }
    if(v==IfcConnectedFaceSet                           ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcConnectionCurveGeometry                    ) { return IfcConnectionGeometry; }
    if(v==IfcConnectionPointEccentricity                ) { return IfcConnectionPointGeometry; }
    if(v==IfcConnectionPointGeometry                    ) { return IfcConnectionGeometry; }
    if(v==IfcConnectionSurfaceGeometry                  ) { return IfcConnectionGeometry; }
    if(v==IfcConnectionVolumeGeometry                   ) { return IfcConnectionGeometry; }
    if(v==IfcConstructionEquipmentResource              ) { return IfcConstructionResource; }
    if(v==IfcConstructionEquipmentResourceType          ) { return IfcConstructionResourceType; }
    if(v==IfcConstructionMaterialResource               ) { return IfcConstructionResource; }
    if(v==IfcConstructionMaterialResourceType           ) { return IfcConstructionResourceType; }
    if(v==IfcConstructionProductResource                ) { return IfcConstructionResource; }
    if(v==IfcConstructionProductResourceType            ) { return IfcConstructionResourceType; }
    if(v==IfcConstructionResource                       ) { return IfcResource; }
    if(v==IfcConstructionResourceType                   ) { return IfcTypeResource; }
    if(v==IfcContext                                    ) { return IfcObjectDefinition; }
    if(v==IfcContextDependentUnit                       ) { return IfcNamedUnit; }
    if(v==IfcControl                                    ) { return IfcObject; }
    if(v==IfcController                                 ) { return IfcDistributionControlElement; }
    if(v==IfcControllerType                             ) { return IfcDistributionControlElementType; }
    if(v==IfcConversionBasedUnit                        ) { return IfcNamedUnit; }
    if(v==IfcConversionBasedUnitWithOffset              ) { return IfcConversionBasedUnit; }
    if(v==IfcCooledBeam                                 ) { return IfcEnergyConversionDevice; }
    if(v==IfcCooledBeamType                             ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcCoolingTower                               ) { return IfcEnergyConversionDevice; }
    if(v==IfcCoolingTowerType                           ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcCostItem                                   ) { return IfcControl; }
    if(v==IfcCostSchedule                               ) { return IfcControl; }
    if(v==IfcCostValue                                  ) { return IfcAppliedValue; }
    if(v==IfcCovering                                   ) { return IfcBuildingElement; }
    if(v==IfcCoveringType                               ) { return IfcBuildingElementType; }
    if(v==IfcCrewResource                               ) { return IfcConstructionResource; }
    if(v==IfcCrewResourceType                           ) { return IfcConstructionResourceType; }
    if(v==IfcCsgPrimitive3D                             ) { return IfcGeometricRepresentationItem; }
    if(v==IfcCsgSolid                                   ) { return IfcSolidModel; }
    if(v==IfcCurrencyRelationship                       ) { return IfcResourceLevelRelationship; }
    if(v==IfcCurtainWall                                ) { return IfcBuildingElement; }
    if(v==IfcCurtainWallType                            ) { return IfcBuildingElementType; }
    if(v==IfcCurve                                      ) { return IfcGeometricRepresentationItem; }
    if(v==IfcCurveBoundedPlane                          ) { return IfcBoundedSurface; }
    if(v==IfcCurveBoundedSurface                        ) { return IfcBoundedSurface; }
    if(v==IfcCurveStyle                                 ) { return IfcPresentationStyle; }
    if(v==IfcCurveStyleFont                             ) { return IfcPresentationItem; }
    if(v==IfcCurveStyleFontAndScaling                   ) { return IfcPresentationItem; }
    if(v==IfcCurveStyleFontPattern                      ) { return IfcPresentationItem; }
    if(v==IfcCylindricalSurface                         ) { return IfcElementarySurface; }
    if(v==IfcDamper                                     ) { return IfcFlowController; }
    if(v==IfcDamperType                                 ) { return IfcFlowControllerType; }
    if(v==IfcDerivedProfileDef                          ) { return IfcProfileDef; }
    if(v==IfcDirection                                  ) { return IfcGeometricRepresentationItem; }
    if(v==IfcDiscreteAccessory                          ) { return IfcElementComponent; }
    if(v==IfcDiscreteAccessoryType                      ) { return IfcElementComponentType; }
    if(v==IfcDistributionChamberElement                 ) { return IfcDistributionFlowElement; }
    if(v==IfcDistributionChamberElementType             ) { return IfcDistributionFlowElementType; }
    if(v==IfcDistributionCircuit                        ) { return IfcDistributionSystem; }
    if(v==IfcDistributionControlElement                 ) { return IfcDistributionElement; }
    if(v==IfcDistributionControlElementType             ) { return IfcDistributionElementType; }
    if(v==IfcDistributionElement                        ) { return IfcElement; }
    if(v==IfcDistributionElementType                    ) { return IfcElementType; }
    if(v==IfcDistributionFlowElement                    ) { return IfcDistributionElement; }
    if(v==IfcDistributionFlowElementType                ) { return IfcDistributionElementType; }
    if(v==IfcDistributionPort                           ) { return IfcPort; }
    if(v==IfcDistributionSystem                         ) { return IfcSystem; }
    if(v==IfcDocumentInformation                        ) { return IfcExternalInformation; }
    if(v==IfcDocumentInformationRelationship            ) { return IfcResourceLevelRelationship; }
    if(v==IfcDocumentReference                          ) { return IfcExternalReference; }
    if(v==IfcDoor                                       ) { return IfcBuildingElement; }
    if(v==IfcDoorLiningProperties                       ) { return IfcPreDefinedPropertySet; }
    if(v==IfcDoorPanelProperties                        ) { return IfcPreDefinedPropertySet; }
    if(v==IfcDoorStandardCase                           ) { return IfcDoor; }
    if(v==IfcDoorStyle                                  ) { return IfcTypeProduct; }
    if(v==IfcDoorType                                   ) { return IfcBuildingElementType; }
    if(v==IfcDraughtingPreDefinedColour                 ) { return IfcPreDefinedColour; }
    if(v==IfcDraughtingPreDefinedCurveFont              ) { return IfcPreDefinedCurveFont; }
    if(v==IfcDuctFitting                                ) { return IfcFlowFitting; }
    if(v==IfcDuctFittingType                            ) { return IfcFlowFittingType; }
    if(v==IfcDuctSegment                                ) { return IfcFlowSegment; }
    if(v==IfcDuctSegmentType                            ) { return IfcFlowSegmentType; }
    if(v==IfcDuctSilencer                               ) { return IfcFlowTreatmentDevice; }
    if(v==IfcDuctSilencerType                           ) { return IfcFlowTreatmentDeviceType; }
    if(v==IfcEdge                                       ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcEdgeCurve                                  ) { return IfcEdge; }
    if(v==IfcEdgeLoop                                   ) { return IfcLoop; }
    if(v==IfcElectricAppliance                          ) { return IfcFlowTerminal; }
    if(v==IfcElectricApplianceType                      ) { return IfcFlowTerminalType; }
    if(v==IfcElectricDistributionBoard                  ) { return IfcFlowController; }
    if(v==IfcElectricDistributionBoardType              ) { return IfcFlowControllerType; }
    if(v==IfcElectricFlowStorageDevice                  ) { return IfcFlowStorageDevice; }
    if(v==IfcElectricFlowStorageDeviceType              ) { return IfcFlowStorageDeviceType; }
    if(v==IfcElectricGenerator                          ) { return IfcEnergyConversionDevice; }
    if(v==IfcElectricGeneratorType                      ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcElectricMotor                              ) { return IfcEnergyConversionDevice; }
    if(v==IfcElectricMotorType                          ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcElectricTimeControl                        ) { return IfcFlowController; }
    if(v==IfcElectricTimeControlType                    ) { return IfcFlowControllerType; }
    if(v==IfcElement                                    ) { return IfcProduct; }
    if(v==IfcElementAssembly                            ) { return IfcElement; }
    if(v==IfcElementAssemblyType                        ) { return IfcElementType; }
    if(v==IfcElementComponent                           ) { return IfcElement; }
    if(v==IfcElementComponentType                       ) { return IfcElementType; }
    if(v==IfcElementQuantity                            ) { return IfcQuantitySet; }
    if(v==IfcElementType                                ) { return IfcTypeProduct; }
    if(v==IfcElementarySurface                          ) { return IfcSurface; }
    if(v==IfcEllipse                                    ) { return IfcConic; }
    if(v==IfcEllipseProfileDef                          ) { return IfcParameterizedProfileDef; }
    if(v==IfcEnergyConversionDevice                     ) { return IfcDistributionFlowElement; }
    if(v==IfcEnergyConversionDeviceType                 ) { return IfcDistributionFlowElementType; }
    if(v==IfcEngine                                     ) { return IfcEnergyConversionDevice; }
    if(v==IfcEngineType                                 ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcEvaporativeCooler                          ) { return IfcEnergyConversionDevice; }
    if(v==IfcEvaporativeCoolerType                      ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcEvaporator                                 ) { return IfcEnergyConversionDevice; }
    if(v==IfcEvaporatorType                             ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcEvent                                      ) { return IfcProcess; }
    if(v==IfcEventTime                                  ) { return IfcSchedulingTime; }
    if(v==IfcEventType                                  ) { return IfcTypeProcess; }
    if(v==IfcExtendedProperties                         ) { return IfcPropertyAbstraction; }
    if(v==IfcExternalReferenceRelationship              ) { return IfcResourceLevelRelationship; }
    if(v==IfcExternalSpatialElement                     ) { return IfcExternalSpatialStructureElement; }
    if(v==IfcExternalSpatialStructureElement            ) { return IfcSpatialElement; }
    if(v==IfcExternallyDefinedHatchStyle                ) { return IfcExternalReference; }
    if(v==IfcExternallyDefinedSurfaceStyle              ) { return IfcExternalReference; }
    if(v==IfcExternallyDefinedTextFont                  ) { return IfcExternalReference; }
    if(v==IfcExtrudedAreaSolid                          ) { return IfcSweptAreaSolid; }
    if(v==IfcExtrudedAreaSolidTapered                   ) { return IfcExtrudedAreaSolid; }
    if(v==IfcFace                                       ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcFaceBasedSurfaceModel                      ) { return IfcGeometricRepresentationItem; }
    if(v==IfcFaceBound                                  ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcFaceOuterBound                             ) { return IfcFaceBound; }
    if(v==IfcFaceSurface                                ) { return IfcFace; }
    if(v==IfcFacetedBrep                                ) { return IfcManifoldSolidBrep; }
    if(v==IfcFacetedBrepWithVoids                       ) { return IfcFacetedBrep; }
    if(v==IfcFailureConnectionCondition                 ) { return IfcStructuralConnectionCondition; }
    if(v==IfcFan                                        ) { return IfcFlowMovingDevice; }
    if(v==IfcFanType                                    ) { return IfcFlowMovingDeviceType; }
    if(v==IfcFastener                                   ) { return IfcElementComponent; }
    if(v==IfcFastenerType                               ) { return IfcElementComponentType; }
    if(v==IfcFeatureElement                             ) { return IfcElement; }
    if(v==IfcFeatureElementAddition                     ) { return IfcFeatureElement; }
    if(v==IfcFeatureElementSubtraction                  ) { return IfcFeatureElement; }
    if(v==IfcFillAreaStyle                              ) { return IfcPresentationStyle; }
    if(v==IfcFillAreaStyleHatching                      ) { return IfcGeometricRepresentationItem; }
    if(v==IfcFillAreaStyleTiles                         ) { return IfcGeometricRepresentationItem; }
    if(v==IfcFilter                                     ) { return IfcFlowTreatmentDevice; }
    if(v==IfcFilterType                                 ) { return IfcFlowTreatmentDeviceType; }
    if(v==IfcFireSuppressionTerminal                    ) { return IfcFlowTerminal; }
    if(v==IfcFireSuppressionTerminalType                ) { return IfcFlowTerminalType; }
    if(v==IfcFixedReferenceSweptAreaSolid               ) { return IfcSweptAreaSolid; }
    if(v==IfcFlowController                             ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowControllerType                         ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowFitting                                ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowFittingType                            ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowInstrument                             ) { return IfcDistributionControlElement; }
    if(v==IfcFlowInstrumentType                         ) { return IfcDistributionControlElementType; }
    if(v==IfcFlowMeter                                  ) { return IfcFlowController; }
    if(v==IfcFlowMeterType                              ) { return IfcFlowControllerType; }
    if(v==IfcFlowMovingDevice                           ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowMovingDeviceType                       ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowSegment                                ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowSegmentType                            ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowStorageDevice                          ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowStorageDeviceType                      ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowTerminal                               ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowTerminalType                           ) { return IfcDistributionFlowElementType; }
    if(v==IfcFlowTreatmentDevice                        ) { return IfcDistributionFlowElement; }
    if(v==IfcFlowTreatmentDeviceType                    ) { return IfcDistributionFlowElementType; }
    if(v==IfcFooting                                    ) { return IfcBuildingElement; }
    if(v==IfcFootingType                                ) { return IfcBuildingElementType; }
    if(v==IfcFurnishingElement                          ) { return IfcElement; }
    if(v==IfcFurnishingElementType                      ) { return IfcElementType; }
    if(v==IfcFurniture                                  ) { return IfcFurnishingElement; }
    if(v==IfcFurnitureType                              ) { return IfcFurnishingElementType; }
    if(v==IfcGeographicElement                          ) { return IfcElement; }
    if(v==IfcGeographicElementType                      ) { return IfcElementType; }
    if(v==IfcGeometricCurveSet                          ) { return IfcGeometricSet; }
    if(v==IfcGeometricRepresentationContext             ) { return IfcRepresentationContext; }
    if(v==IfcGeometricRepresentationItem                ) { return IfcRepresentationItem; }
    if(v==IfcGeometricRepresentationSubContext          ) { return IfcGeometricRepresentationContext; }
    if(v==IfcGeometricSet                               ) { return IfcGeometricRepresentationItem; }
    if(v==IfcGrid                                       ) { return IfcProduct; }
    if(v==IfcGridPlacement                              ) { return IfcObjectPlacement; }
    if(v==IfcGroup                                      ) { return IfcObject; }
    if(v==IfcHalfSpaceSolid                             ) { return IfcGeometricRepresentationItem; }
    if(v==IfcHeatExchanger                              ) { return IfcEnergyConversionDevice; }
    if(v==IfcHeatExchangerType                          ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcHumidifier                                 ) { return IfcEnergyConversionDevice; }
    if(v==IfcHumidifierType                             ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcIShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcImageTexture                               ) { return IfcSurfaceTexture; }
    if(v==IfcIndexedColourMap                           ) { return IfcPresentationItem; }
    if(v==IfcIndexedTextureMap                          ) { return IfcTextureCoordinate; }
    if(v==IfcIndexedTriangleTextureMap                  ) { return IfcIndexedTextureMap; }
    if(v==IfcInterceptor                                ) { return IfcFlowTreatmentDevice; }
    if(v==IfcInterceptorType                            ) { return IfcFlowTreatmentDeviceType; }
    if(v==IfcInventory                                  ) { return IfcGroup; }
    if(v==IfcIrregularTimeSeries                        ) { return IfcTimeSeries; }
    if(v==IfcJunctionBox                                ) { return IfcFlowFitting; }
    if(v==IfcJunctionBoxType                            ) { return IfcFlowFittingType; }
    if(v==IfcLShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcLaborResource                              ) { return IfcConstructionResource; }
    if(v==IfcLaborResourceType                          ) { return IfcConstructionResourceType; }
    if(v==IfcLagTime                                    ) { return IfcSchedulingTime; }
    if(v==IfcLamp                                       ) { return IfcFlowTerminal; }
    if(v==IfcLampType                                   ) { return IfcFlowTerminalType; }
    if(v==IfcLibraryInformation                         ) { return IfcExternalInformation; }
    if(v==IfcLibraryReference                           ) { return IfcExternalReference; }
    if(v==IfcLightFixture                               ) { return IfcFlowTerminal; }
    if(v==IfcLightFixtureType                           ) { return IfcFlowTerminalType; }
    if(v==IfcLightSource                                ) { return IfcGeometricRepresentationItem; }
    if(v==IfcLightSourceAmbient                         ) { return IfcLightSource; }
    if(v==IfcLightSourceDirectional                     ) { return IfcLightSource; }
    if(v==IfcLightSourceGoniometric                     ) { return IfcLightSource; }
    if(v==IfcLightSourcePositional                      ) { return IfcLightSource; }
    if(v==IfcLightSourceSpot                            ) { return IfcLightSourcePositional; }
    if(v==IfcLine                                       ) { return IfcCurve; }
    if(v==IfcLocalPlacement                             ) { return IfcObjectPlacement; }
    if(v==IfcLoop                                       ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcManifoldSolidBrep                          ) { return IfcSolidModel; }
    if(v==IfcMapConversion                              ) { return IfcCoordinateOperation; }
    if(v==IfcMappedItem                                 ) { return IfcRepresentationItem; }
    if(v==IfcMaterial                                   ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialConstituent                        ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialConstituentSet                     ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialDefinitionRepresentation           ) { return IfcProductRepresentation; }
    if(v==IfcMaterialLayer                              ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialLayerSet                           ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialLayerSetUsage                      ) { return IfcMaterialUsageDefinition; }
    if(v==IfcMaterialLayerWithOffsets                   ) { return IfcMaterialLayer; }
    if(v==IfcMaterialProfile                            ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialProfileSet                         ) { return IfcMaterialDefinition; }
    if(v==IfcMaterialProfileSetUsage                    ) { return IfcMaterialUsageDefinition; }
    if(v==IfcMaterialProfileSetUsageTapering            ) { return IfcMaterialProfileSetUsage; }
    if(v==IfcMaterialProfileWithOffsets                 ) { return IfcMaterialProfile; }
    if(v==IfcMaterialProperties                         ) { return IfcExtendedProperties; }
    if(v==IfcMaterialRelationship                       ) { return IfcResourceLevelRelationship; }
    if(v==IfcMechanicalFastener                         ) { return IfcElementComponent; }
    if(v==IfcMechanicalFastenerType                     ) { return IfcElementComponentType; }
    if(v==IfcMedicalDevice                              ) { return IfcFlowTerminal; }
    if(v==IfcMedicalDeviceType                          ) { return IfcFlowTerminalType; }
    if(v==IfcMember                                     ) { return IfcBuildingElement; }
    if(v==IfcMemberStandardCase                         ) { return IfcMember; }
    if(v==IfcMemberType                                 ) { return IfcBuildingElementType; }
    if(v==IfcMetric                                     ) { return IfcConstraint; }
    if(v==IfcMirroredProfileDef                         ) { return IfcDerivedProfileDef; }
    if(v==IfcMotorConnection                            ) { return IfcEnergyConversionDevice; }
    if(v==IfcMotorConnectionType                        ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcObject                                     ) { return IfcObjectDefinition; }
    if(v==IfcObjectDefinition                           ) { return IfcRoot; }
    if(v==IfcObjective                                  ) { return IfcConstraint; }
    if(v==IfcOccupant                                   ) { return IfcActor; }
    if(v==IfcOffsetCurve2D                              ) { return IfcCurve; }
    if(v==IfcOffsetCurve3D                              ) { return IfcCurve; }
    if(v==IfcOpenShell                                  ) { return IfcConnectedFaceSet; }
    if(v==IfcOpeningElement                             ) { return IfcFeatureElementSubtraction; }
    if(v==IfcOpeningStandardCase                        ) { return IfcOpeningElement; }
    if(v==IfcOrganizationRelationship                   ) { return IfcResourceLevelRelationship; }
    if(v==IfcOrientedEdge                               ) { return IfcEdge; }
    if(v==IfcOuterBoundaryCurve                         ) { return IfcBoundaryCurve; }
    if(v==IfcOutlet                                     ) { return IfcFlowTerminal; }
    if(v==IfcOutletType                                 ) { return IfcFlowTerminalType; }
    if(v==IfcParameterizedProfileDef                    ) { return IfcProfileDef; }
    if(v==IfcPath                                       ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcPcurve                                     ) { return IfcCurve; }
    if(v==IfcPerformanceHistory                         ) { return IfcControl; }
    if(v==IfcPermeableCoveringProperties                ) { return IfcPreDefinedPropertySet; }
    if(v==IfcPermit                                     ) { return IfcControl; }
    if(v==IfcPhysicalComplexQuantity                    ) { return IfcPhysicalQuantity; }
    if(v==IfcPhysicalSimpleQuantity                     ) { return IfcPhysicalQuantity; }
    if(v==IfcPile                                       ) { return IfcBuildingElement; }
    if(v==IfcPileType                                   ) { return IfcBuildingElementType; }
    if(v==IfcPipeFitting                                ) { return IfcFlowFitting; }
    if(v==IfcPipeFittingType                            ) { return IfcFlowFittingType; }
    if(v==IfcPipeSegment                                ) { return IfcFlowSegment; }
    if(v==IfcPipeSegmentType                            ) { return IfcFlowSegmentType; }
    if(v==IfcPixelTexture                               ) { return IfcSurfaceTexture; }
    if(v==IfcPlacement                                  ) { return IfcGeometricRepresentationItem; }
    if(v==IfcPlanarBox                                  ) { return IfcPlanarExtent; }
    if(v==IfcPlanarExtent                               ) { return IfcGeometricRepresentationItem; }
    if(v==IfcPlane                                      ) { return IfcElementarySurface; }
    if(v==IfcPlate                                      ) { return IfcBuildingElement; }
    if(v==IfcPlateStandardCase                          ) { return IfcPlate; }
    if(v==IfcPlateType                                  ) { return IfcBuildingElementType; }
    if(v==IfcPoint                                      ) { return IfcGeometricRepresentationItem; }
    if(v==IfcPointOnCurve                               ) { return IfcPoint; }
    if(v==IfcPointOnSurface                             ) { return IfcPoint; }
    if(v==IfcPolyLoop                                   ) { return IfcLoop; }
    if(v==IfcPolygonalBoundedHalfSpace                  ) { return IfcHalfSpaceSolid; }
    if(v==IfcPolyline                                   ) { return IfcBoundedCurve; }
    if(v==IfcPort                                       ) { return IfcProduct; }
    if(v==IfcPostalAddress                              ) { return IfcAddress; }
    if(v==IfcPreDefinedColour                           ) { return IfcPreDefinedItem; }
    if(v==IfcPreDefinedCurveFont                        ) { return IfcPreDefinedItem; }
    if(v==IfcPreDefinedItem                             ) { return IfcPresentationItem; }
    if(v==IfcPreDefinedProperties                       ) { return IfcPropertyAbstraction; }
    if(v==IfcPreDefinedPropertySet                      ) { return IfcPropertySetDefinition; }
    if(v==IfcPreDefinedTextFont                         ) { return IfcPreDefinedItem; }
    if(v==IfcPresentationLayerWithStyle                 ) { return IfcPresentationLayerAssignment; }
    if(v==IfcProcedure                                  ) { return IfcProcess; }
    if(v==IfcProcedureType                              ) { return IfcTypeProcess; }
    if(v==IfcProcess                                    ) { return IfcObject; }
    if(v==IfcProduct                                    ) { return IfcObject; }
    if(v==IfcProductDefinitionShape                     ) { return IfcProductRepresentation; }
    if(v==IfcProfileProperties                          ) { return IfcExtendedProperties; }
    if(v==IfcProject                                    ) { return IfcContext; }
    if(v==IfcProjectLibrary                             ) { return IfcContext; }
    if(v==IfcProjectOrder                               ) { return IfcControl; }
    if(v==IfcProjectedCRS                               ) { return IfcCoordinateReferenceSystem; }
    if(v==IfcProjectionElement                          ) { return IfcFeatureElementAddition; }
    if(v==IfcProperty                                   ) { return IfcPropertyAbstraction; }
    if(v==IfcPropertyBoundedValue                       ) { return IfcSimpleProperty; }
    if(v==IfcPropertyDefinition                         ) { return IfcRoot; }
    if(v==IfcPropertyDependencyRelationship             ) { return IfcResourceLevelRelationship; }
    if(v==IfcPropertyEnumeratedValue                    ) { return IfcSimpleProperty; }
    if(v==IfcPropertyEnumeration                        ) { return IfcPropertyAbstraction; }
    if(v==IfcPropertyListValue                          ) { return IfcSimpleProperty; }
    if(v==IfcPropertyReferenceValue                     ) { return IfcSimpleProperty; }
    if(v==IfcPropertySet                                ) { return IfcPropertySetDefinition; }
    if(v==IfcPropertySetDefinition                      ) { return IfcPropertyDefinition; }
    if(v==IfcPropertySetTemplate                        ) { return IfcPropertyTemplateDefinition; }
    if(v==IfcPropertySingleValue                        ) { return IfcSimpleProperty; }
    if(v==IfcPropertyTableValue                         ) { return IfcSimpleProperty; }
    if(v==IfcPropertyTemplate                           ) { return IfcPropertyTemplateDefinition; }
    if(v==IfcPropertyTemplateDefinition                 ) { return IfcPropertyDefinition; }
    if(v==IfcProtectiveDevice                           ) { return IfcFlowController; }
    if(v==IfcProtectiveDeviceTrippingUnit               ) { return IfcDistributionControlElement; }
    if(v==IfcProtectiveDeviceTrippingUnitType           ) { return IfcDistributionControlElementType; }
    if(v==IfcProtectiveDeviceType                       ) { return IfcFlowControllerType; }
    if(v==IfcProxy                                      ) { return IfcProduct; }
    if(v==IfcPump                                       ) { return IfcFlowMovingDevice; }
    if(v==IfcPumpType                                   ) { return IfcFlowMovingDeviceType; }
    if(v==IfcQuantityArea                               ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcQuantityCount                              ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcQuantityLength                             ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcQuantitySet                                ) { return IfcPropertySetDefinition; }
    if(v==IfcQuantityTime                               ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcQuantityVolume                             ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcQuantityWeight                             ) { return IfcPhysicalSimpleQuantity; }
    if(v==IfcRailing                                    ) { return IfcBuildingElement; }
    if(v==IfcRailingType                                ) { return IfcBuildingElementType; }
    if(v==IfcRamp                                       ) { return IfcBuildingElement; }
    if(v==IfcRampFlight                                 ) { return IfcBuildingElement; }
    if(v==IfcRampFlightType                             ) { return IfcBuildingElementType; }
    if(v==IfcRampType                                   ) { return IfcBuildingElementType; }
    if(v==IfcRationalBSplineCurveWithKnots              ) { return IfcBSplineCurveWithKnots; }
    if(v==IfcRationalBSplineSurfaceWithKnots            ) { return IfcBSplineSurfaceWithKnots; }
    if(v==IfcRectangleHollowProfileDef                  ) { return IfcRectangleProfileDef; }
    if(v==IfcRectangleProfileDef                        ) { return IfcParameterizedProfileDef; }
    if(v==IfcRectangularPyramid                         ) { return IfcCsgPrimitive3D; }
    if(v==IfcRectangularTrimmedSurface                  ) { return IfcBoundedSurface; }
    if(v==IfcRegularTimeSeries                          ) { return IfcTimeSeries; }
    if(v==IfcReinforcementBarProperties                 ) { return IfcPreDefinedProperties; }
    if(v==IfcReinforcementDefinitionProperties          ) { return IfcPreDefinedPropertySet; }
    if(v==IfcReinforcingBar                             ) { return IfcReinforcingElement; }
    if(v==IfcReinforcingBarType                         ) { return IfcReinforcingElementType; }
    if(v==IfcReinforcingElement                         ) { return IfcElementComponent; }
    if(v==IfcReinforcingElementType                     ) { return IfcElementComponentType; }
    if(v==IfcReinforcingMesh                            ) { return IfcReinforcingElement; }
    if(v==IfcReinforcingMeshType                        ) { return IfcReinforcingElementType; }
    if(v==IfcRelAggregates                              ) { return IfcRelDecomposes; }
    if(v==IfcRelAssigns                                 ) { return IfcRelationship; }
    if(v==IfcRelAssignsToActor                          ) { return IfcRelAssigns; }
    if(v==IfcRelAssignsToControl                        ) { return IfcRelAssigns; }
    if(v==IfcRelAssignsToGroup                          ) { return IfcRelAssigns; }
    if(v==IfcRelAssignsToGroupByFactor                  ) { return IfcRelAssignsToGroup; }
    if(v==IfcRelAssignsToProcess                        ) { return IfcRelAssigns; }
    if(v==IfcRelAssignsToProduct                        ) { return IfcRelAssigns; }
    if(v==IfcRelAssignsToResource                       ) { return IfcRelAssigns; }
    if(v==IfcRelAssociates                              ) { return IfcRelationship; }
    if(v==IfcRelAssociatesApproval                      ) { return IfcRelAssociates; }
    if(v==IfcRelAssociatesClassification                ) { return IfcRelAssociates; }
    if(v==IfcRelAssociatesConstraint                    ) { return IfcRelAssociates; }
    if(v==IfcRelAssociatesDocument                      ) { return IfcRelAssociates; }
    if(v==IfcRelAssociatesLibrary                       ) { return IfcRelAssociates; }
    if(v==IfcRelAssociatesMaterial                      ) { return IfcRelAssociates; }
    if(v==IfcRelConnects                                ) { return IfcRelationship; }
    if(v==IfcRelConnectsElements                        ) { return IfcRelConnects; }
    if(v==IfcRelConnectsPathElements                    ) { return IfcRelConnectsElements; }
    if(v==IfcRelConnectsPortToElement                   ) { return IfcRelConnects; }
    if(v==IfcRelConnectsPorts                           ) { return IfcRelConnects; }
    if(v==IfcRelConnectsStructuralActivity              ) { return IfcRelConnects; }
    if(v==IfcRelConnectsStructuralMember                ) { return IfcRelConnects; }
    if(v==IfcRelConnectsWithEccentricity                ) { return IfcRelConnectsStructuralMember; }
    if(v==IfcRelConnectsWithRealizingElements           ) { return IfcRelConnectsElements; }
    if(v==IfcRelContainedInSpatialStructure             ) { return IfcRelConnects; }
    if(v==IfcRelCoversBldgElements                      ) { return IfcRelConnects; }
    if(v==IfcRelCoversSpaces                            ) { return IfcRelConnects; }
    if(v==IfcRelDeclares                                ) { return IfcRelationship; }
    if(v==IfcRelDecomposes                              ) { return IfcRelationship; }
    if(v==IfcRelDefines                                 ) { return IfcRelationship; }
    if(v==IfcRelDefinesByObject                         ) { return IfcRelDefines; }
    if(v==IfcRelDefinesByProperties                     ) { return IfcRelDefines; }
    if(v==IfcRelDefinesByTemplate                       ) { return IfcRelDefines; }
    if(v==IfcRelDefinesByType                           ) { return IfcRelDefines; }
    if(v==IfcRelFillsElement                            ) { return IfcRelConnects; }
    if(v==IfcRelFlowControlElements                     ) { return IfcRelConnects; }
    if(v==IfcRelInterferesElements                      ) { return IfcRelConnects; }
    if(v==IfcRelNests                                   ) { return IfcRelDecomposes; }
    if(v==IfcRelProjectsElement                         ) { return IfcRelDecomposes; }
    if(v==IfcRelReferencedInSpatialStructure            ) { return IfcRelConnects; }
    if(v==IfcRelSequence                                ) { return IfcRelConnects; }
    if(v==IfcRelServicesBuildings                       ) { return IfcRelConnects; }
    if(v==IfcRelSpaceBoundary                           ) { return IfcRelConnects; }
    if(v==IfcRelSpaceBoundary1stLevel                   ) { return IfcRelSpaceBoundary; }
    if(v==IfcRelSpaceBoundary2ndLevel                   ) { return IfcRelSpaceBoundary1stLevel; }
    if(v==IfcRelVoidsElement                            ) { return IfcRelDecomposes; }
    if(v==IfcRelationship                               ) { return IfcRoot; }
    if(v==IfcReparametrisedCompositeCurveSegment        ) { return IfcCompositeCurveSegment; }
    if(v==IfcResource                                   ) { return IfcObject; }
    if(v==IfcResourceApprovalRelationship               ) { return IfcResourceLevelRelationship; }
    if(v==IfcResourceConstraintRelationship             ) { return IfcResourceLevelRelationship; }
    if(v==IfcResourceTime                               ) { return IfcSchedulingTime; }
    if(v==IfcRevolvedAreaSolid                          ) { return IfcSweptAreaSolid; }
    if(v==IfcRevolvedAreaSolidTapered                   ) { return IfcRevolvedAreaSolid; }
    if(v==IfcRightCircularCone                          ) { return IfcCsgPrimitive3D; }
    if(v==IfcRightCircularCylinder                      ) { return IfcCsgPrimitive3D; }
    if(v==IfcRoof                                       ) { return IfcBuildingElement; }
    if(v==IfcRoofType                                   ) { return IfcBuildingElementType; }
    if(v==IfcRoundedRectangleProfileDef                 ) { return IfcRectangleProfileDef; }
    if(v==IfcSIUnit                                     ) { return IfcNamedUnit; }
    if(v==IfcSanitaryTerminal                           ) { return IfcFlowTerminal; }
    if(v==IfcSanitaryTerminalType                       ) { return IfcFlowTerminalType; }
    if(v==IfcSectionProperties                          ) { return IfcPreDefinedProperties; }
    if(v==IfcSectionReinforcementProperties             ) { return IfcPreDefinedProperties; }
    if(v==IfcSectionedSpine                             ) { return IfcGeometricRepresentationItem; }
    if(v==IfcSensor                                     ) { return IfcDistributionControlElement; }
    if(v==IfcSensorType                                 ) { return IfcDistributionControlElementType; }
    if(v==IfcShadingDevice                              ) { return IfcBuildingElement; }
    if(v==IfcShadingDeviceType                          ) { return IfcBuildingElementType; }
    if(v==IfcShapeModel                                 ) { return IfcRepresentation; }
    if(v==IfcShapeRepresentation                        ) { return IfcShapeModel; }
    if(v==IfcShellBasedSurfaceModel                     ) { return IfcGeometricRepresentationItem; }
    if(v==IfcSimpleProperty                             ) { return IfcProperty; }
    if(v==IfcSimplePropertyTemplate                     ) { return IfcPropertyTemplate; }
    if(v==IfcSite                                       ) { return IfcSpatialStructureElement; }
    if(v==IfcSlab                                       ) { return IfcBuildingElement; }
    if(v==IfcSlabElementedCase                          ) { return IfcSlab; }
    if(v==IfcSlabStandardCase                           ) { return IfcSlab; }
    if(v==IfcSlabType                                   ) { return IfcBuildingElementType; }
    if(v==IfcSlippageConnectionCondition                ) { return IfcStructuralConnectionCondition; }
    if(v==IfcSolarDevice                                ) { return IfcEnergyConversionDevice; }
    if(v==IfcSolarDeviceType                            ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcSolidModel                                 ) { return IfcGeometricRepresentationItem; }
    if(v==IfcSpace                                      ) { return IfcSpatialStructureElement; }
    if(v==IfcSpaceHeater                                ) { return IfcFlowTerminal; }
    if(v==IfcSpaceHeaterType                            ) { return IfcFlowTerminalType; }
    if(v==IfcSpaceType                                  ) { return IfcSpatialStructureElementType; }
    if(v==IfcSpatialElement                             ) { return IfcProduct; }
    if(v==IfcSpatialElementType                         ) { return IfcTypeProduct; }
    if(v==IfcSpatialStructureElement                    ) { return IfcSpatialElement; }
    if(v==IfcSpatialStructureElementType                ) { return IfcSpatialElementType; }
    if(v==IfcSpatialZone                                ) { return IfcSpatialElement; }
    if(v==IfcSpatialZoneType                            ) { return IfcSpatialElementType; }
    if(v==IfcSphere                                     ) { return IfcCsgPrimitive3D; }
    if(v==IfcStackTerminal                              ) { return IfcFlowTerminal; }
    if(v==IfcStackTerminalType                          ) { return IfcFlowTerminalType; }
    if(v==IfcStair                                      ) { return IfcBuildingElement; }
    if(v==IfcStairFlight                                ) { return IfcBuildingElement; }
    if(v==IfcStairFlightType                            ) { return IfcBuildingElementType; }
    if(v==IfcStairType                                  ) { return IfcBuildingElementType; }
    if(v==IfcStructuralAction                           ) { return IfcStructuralActivity; }
    if(v==IfcStructuralActivity                         ) { return IfcProduct; }
    if(v==IfcStructuralAnalysisModel                    ) { return IfcSystem; }
    if(v==IfcStructuralConnection                       ) { return IfcStructuralItem; }
    if(v==IfcStructuralCurveAction                      ) { return IfcStructuralAction; }
    if(v==IfcStructuralCurveConnection                  ) { return IfcStructuralConnection; }
    if(v==IfcStructuralCurveMember                      ) { return IfcStructuralMember; }
    if(v==IfcStructuralCurveMemberVarying               ) { return IfcStructuralCurveMember; }
    if(v==IfcStructuralCurveReaction                    ) { return IfcStructuralReaction; }
    if(v==IfcStructuralItem                             ) { return IfcProduct; }
    if(v==IfcStructuralLinearAction                     ) { return IfcStructuralCurveAction; }
    if(v==IfcStructuralLoadCase                         ) { return IfcStructuralLoadGroup; }
    if(v==IfcStructuralLoadConfiguration                ) { return IfcStructuralLoad; }
    if(v==IfcStructuralLoadGroup                        ) { return IfcGroup; }
    if(v==IfcStructuralLoadLinearForce                  ) { return IfcStructuralLoadStatic; }
    if(v==IfcStructuralLoadOrResult                     ) { return IfcStructuralLoad; }
    if(v==IfcStructuralLoadPlanarForce                  ) { return IfcStructuralLoadStatic; }
    if(v==IfcStructuralLoadSingleDisplacement           ) { return IfcStructuralLoadStatic; }
    if(v==IfcStructuralLoadSingleDisplacementDistortion ) { return IfcStructuralLoadSingleDisplacement; }
    if(v==IfcStructuralLoadSingleForce                  ) { return IfcStructuralLoadStatic; }
    if(v==IfcStructuralLoadSingleForceWarping           ) { return IfcStructuralLoadSingleForce; }
    if(v==IfcStructuralLoadStatic                       ) { return IfcStructuralLoadOrResult; }
    if(v==IfcStructuralLoadTemperature                  ) { return IfcStructuralLoadStatic; }
    if(v==IfcStructuralMember                           ) { return IfcStructuralItem; }
    if(v==IfcStructuralPlanarAction                     ) { return IfcStructuralSurfaceAction; }
    if(v==IfcStructuralPointAction                      ) { return IfcStructuralAction; }
    if(v==IfcStructuralPointConnection                  ) { return IfcStructuralConnection; }
    if(v==IfcStructuralPointReaction                    ) { return IfcStructuralReaction; }
    if(v==IfcStructuralReaction                         ) { return IfcStructuralActivity; }
    if(v==IfcStructuralResultGroup                      ) { return IfcGroup; }
    if(v==IfcStructuralSurfaceAction                    ) { return IfcStructuralAction; }
    if(v==IfcStructuralSurfaceConnection                ) { return IfcStructuralConnection; }
    if(v==IfcStructuralSurfaceMember                    ) { return IfcStructuralMember; }
    if(v==IfcStructuralSurfaceMemberVarying             ) { return IfcStructuralSurfaceMember; }
    if(v==IfcStructuralSurfaceReaction                  ) { return IfcStructuralReaction; }
    if(v==IfcStyleModel                                 ) { return IfcRepresentation; }
    if(v==IfcStyledItem                                 ) { return IfcRepresentationItem; }
    if(v==IfcStyledRepresentation                       ) { return IfcStyleModel; }
    if(v==IfcSubContractResource                        ) { return IfcConstructionResource; }
    if(v==IfcSubContractResourceType                    ) { return IfcConstructionResourceType; }
    if(v==IfcSubedge                                    ) { return IfcEdge; }
    if(v==IfcSurface                                    ) { return IfcGeometricRepresentationItem; }
    if(v==IfcSurfaceCurveSweptAreaSolid                 ) { return IfcSweptAreaSolid; }
    if(v==IfcSurfaceFeature                             ) { return IfcFeatureElement; }
    if(v==IfcSurfaceOfLinearExtrusion                   ) { return IfcSweptSurface; }
    if(v==IfcSurfaceOfRevolution                        ) { return IfcSweptSurface; }
    if(v==IfcSurfaceReinforcementArea                   ) { return IfcStructuralLoadOrResult; }
    if(v==IfcSurfaceStyle                               ) { return IfcPresentationStyle; }
    if(v==IfcSurfaceStyleLighting                       ) { return IfcPresentationItem; }
    if(v==IfcSurfaceStyleRefraction                     ) { return IfcPresentationItem; }
    if(v==IfcSurfaceStyleRendering                      ) { return IfcSurfaceStyleShading; }
    if(v==IfcSurfaceStyleShading                        ) { return IfcPresentationItem; }
    if(v==IfcSurfaceStyleWithTextures                   ) { return IfcPresentationItem; }
    if(v==IfcSurfaceTexture                             ) { return IfcPresentationItem; }
    if(v==IfcSweptAreaSolid                             ) { return IfcSolidModel; }
    if(v==IfcSweptDiskSolid                             ) { return IfcSolidModel; }
    if(v==IfcSweptDiskSolidPolygonal                    ) { return IfcSweptDiskSolid; }
    if(v==IfcSweptSurface                               ) { return IfcSurface; }
    if(v==IfcSwitchingDevice                            ) { return IfcFlowController; }
    if(v==IfcSwitchingDeviceType                        ) { return IfcFlowControllerType; }
    if(v==IfcSystem                                     ) { return IfcGroup; }
    if(v==IfcSystemFurnitureElement                     ) { return IfcFurnishingElement; }
    if(v==IfcSystemFurnitureElementType                 ) { return IfcFurnishingElementType; }
    if(v==IfcTShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcTank                                       ) { return IfcFlowStorageDevice; }
    if(v==IfcTankType                                   ) { return IfcFlowStorageDeviceType; }
    if(v==IfcTask                                       ) { return IfcProcess; }
    if(v==IfcTaskTime                                   ) { return IfcSchedulingTime; }
    if(v==IfcTaskTimeRecurring                          ) { return IfcTaskTime; }
    if(v==IfcTaskType                                   ) { return IfcTypeProcess; }
    if(v==IfcTelecomAddress                             ) { return IfcAddress; }
    if(v==IfcTendon                                     ) { return IfcReinforcingElement; }
    if(v==IfcTendonAnchor                               ) { return IfcReinforcingElement; }
    if(v==IfcTendonAnchorType                           ) { return IfcReinforcingElementType; }
    if(v==IfcTendonType                                 ) { return IfcReinforcingElementType; }
    if(v==IfcTessellatedFaceSet                         ) { return IfcTessellatedItem; }
    if(v==IfcTessellatedItem                            ) { return IfcGeometricRepresentationItem; }
    if(v==IfcTextLiteral                                ) { return IfcGeometricRepresentationItem; }
    if(v==IfcTextLiteralWithExtent                      ) { return IfcTextLiteral; }
    if(v==IfcTextStyle                                  ) { return IfcPresentationStyle; }
    if(v==IfcTextStyleFontModel                         ) { return IfcPreDefinedTextFont; }
    if(v==IfcTextStyleForDefinedFont                    ) { return IfcPresentationItem; }
    if(v==IfcTextStyleTextModel                         ) { return IfcPresentationItem; }
    if(v==IfcTextureCoordinate                          ) { return IfcPresentationItem; }
    if(v==IfcTextureCoordinateGenerator                 ) { return IfcTextureCoordinate; }
    if(v==IfcTextureMap                                 ) { return IfcTextureCoordinate; }
    if(v==IfcTextureVertex                              ) { return IfcPresentationItem; }
    if(v==IfcTextureVertexList                          ) { return IfcPresentationItem; }
    if(v==IfcTopologicalRepresentationItem              ) { return IfcRepresentationItem; }
    if(v==IfcTopologyRepresentation                     ) { return IfcShapeModel; }
    if(v==IfcTransformer                                ) { return IfcEnergyConversionDevice; }
    if(v==IfcTransformerType                            ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcTransportElement                           ) { return IfcElement; }
    if(v==IfcTransportElementType                       ) { return IfcElementType; }
    if(v==IfcTrapeziumProfileDef                        ) { return IfcParameterizedProfileDef; }
    if(v==IfcTriangulatedFaceSet                        ) { return IfcTessellatedFaceSet; }
    if(v==IfcTrimmedCurve                               ) { return IfcBoundedCurve; }
    if(v==IfcTubeBundle                                 ) { return IfcEnergyConversionDevice; }
    if(v==IfcTubeBundleType                             ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcTypeObject                                 ) { return IfcObjectDefinition; }
    if(v==IfcTypeProcess                                ) { return IfcTypeObject; }
    if(v==IfcTypeProduct                                ) { return IfcTypeObject; }
    if(v==IfcTypeResource                               ) { return IfcTypeObject; }
    if(v==IfcUShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcUnitaryControlElement                      ) { return IfcDistributionControlElement; }
    if(v==IfcUnitaryControlElementType                  ) { return IfcDistributionControlElementType; }
    if(v==IfcUnitaryEquipment                           ) { return IfcEnergyConversionDevice; }
    if(v==IfcUnitaryEquipmentType                       ) { return IfcEnergyConversionDeviceType; }
    if(v==IfcValve                                      ) { return IfcFlowController; }
    if(v==IfcValveType                                  ) { return IfcFlowControllerType; }
    if(v==IfcVector                                     ) { return IfcGeometricRepresentationItem; }
    if(v==IfcVertex                                     ) { return IfcTopologicalRepresentationItem; }
    if(v==IfcVertexLoop                                 ) { return IfcLoop; }
    if(v==IfcVertexPoint                                ) { return IfcVertex; }
    if(v==IfcVibrationIsolator                          ) { return IfcElementComponent; }
    if(v==IfcVibrationIsolatorType                      ) { return IfcElementComponentType; }
    if(v==IfcVirtualElement                             ) { return IfcElement; }
    if(v==IfcVoidingFeature                             ) { return IfcFeatureElementSubtraction; }
    if(v==IfcWall                                       ) { return IfcBuildingElement; }
    if(v==IfcWallElementedCase                          ) { return IfcWall; }
    if(v==IfcWallStandardCase                           ) { return IfcWall; }
    if(v==IfcWallType                                   ) { return IfcBuildingElementType; }
    if(v==IfcWasteTerminal                              ) { return IfcFlowTerminal; }
    if(v==IfcWasteTerminalType                          ) { return IfcFlowTerminalType; }
    if(v==IfcWindow                                     ) { return IfcBuildingElement; }
    if(v==IfcWindowLiningProperties                     ) { return IfcPreDefinedPropertySet; }
    if(v==IfcWindowPanelProperties                      ) { return IfcPreDefinedPropertySet; }
    if(v==IfcWindowStandardCase                         ) { return IfcWindow; }
    if(v==IfcWindowStyle                                ) { return IfcTypeProduct; }
    if(v==IfcWindowType                                 ) { return IfcBuildingElementType; }
    if(v==IfcWorkCalendar                               ) { return IfcControl; }
    if(v==IfcWorkControl                                ) { return IfcControl; }
    if(v==IfcWorkPlan                                   ) { return IfcWorkControl; }
    if(v==IfcWorkSchedule                               ) { return IfcWorkControl; }
    if(v==IfcWorkTime                                   ) { return IfcSchedulingTime; }
    if(v==IfcZShapeProfileDef                           ) { return IfcParameterizedProfileDef; }
    if(v==IfcZone                                       ) { return IfcSystem; }
    return (Enum)-1;
}

bool Type::IsSimple(Enum v) {
    return v == Type::IfcAbsorbedDoseMeasure || v == Type::IfcAccelerationMeasure || v == Type::IfcAmountOfSubstanceMeasure || v == Type::IfcAngularVelocityMeasure || v == Type::IfcAreaDensityMeasure || v == Type::IfcAreaMeasure || v == Type::IfcBoolean || v == Type::IfcColour || v == Type::IfcComplexNumber || v == Type::IfcCompoundPlaneAngleMeasure || v == Type::IfcContextDependentMeasure || v == Type::IfcCountMeasure || v == Type::IfcCurvatureMeasure || v == Type::IfcCurveStyleFontSelect || v == Type::IfcDate || v == Type::IfcDateTime || v == Type::IfcDerivedMeasureValue || v == Type::IfcDescriptiveMeasure || v == Type::IfcDoseEquivalentMeasure || v == Type::IfcDuration || v == Type::IfcDynamicViscosityMeasure || v == Type::IfcElectricCapacitanceMeasure || v == Type::IfcElectricChargeMeasure || v == Type::IfcElectricConductanceMeasure || v == Type::IfcElectricCurrentMeasure || v == Type::IfcElectricResistanceMeasure || v == Type::IfcElectricVoltageMeasure || v == Type::IfcEnergyMeasure || v == Type::IfcForceMeasure || v == Type::IfcFrequencyMeasure || v == Type::IfcHeatFluxDensityMeasure || v == Type::IfcHeatingValueMeasure || v == Type::IfcIdentifier || v == Type::IfcIlluminanceMeasure || v == Type::IfcInductanceMeasure || v == Type::IfcInteger || v == Type::IfcIntegerCountRateMeasure || v == Type::IfcIonConcentrationMeasure || v == Type::IfcIsothermalMoistureCapacityMeasure || v == Type::IfcKinematicViscosityMeasure || v == Type::IfcLabel || v == Type::IfcLengthMeasure || v == Type::IfcLinearForceMeasure || v == Type::IfcLinearMomentMeasure || v == Type::IfcLinearStiffnessMeasure || v == Type::IfcLinearVelocityMeasure || v == Type::IfcLogical || v == Type::IfcLuminousFluxMeasure || v == Type::IfcLuminousIntensityDistributionMeasure || v == Type::IfcLuminousIntensityMeasure || v == Type::IfcMagneticFluxDensityMeasure || v == Type::IfcMagneticFluxMeasure || v == Type::IfcMassDensityMeasure || v == Type::IfcMassFlowRateMeasure || v == Type::IfcMassMeasure || v == Type::IfcMassPerLengthMeasure || v == Type::IfcMeasureValue || v == Type::IfcModulusOfElasticityMeasure || v == Type::IfcModulusOfLinearSubgradeReactionMeasure || v == Type::IfcModulusOfRotationalSubgradeReactionMeasure || v == Type::IfcModulusOfSubgradeReactionMeasure || v == Type::IfcMoistureDiffusivityMeasure || v == Type::IfcMolecularWeightMeasure || v == Type::IfcMomentOfInertiaMeasure || v == Type::IfcMonetaryMeasure || v == Type::IfcNonNegativeLengthMeasure || v == Type::IfcNormalisedRatioMeasure || v == Type::IfcNullStyle || v == Type::IfcNumericMeasure || v == Type::IfcPHMeasure || v == Type::IfcParameterValue || v == Type::IfcPlanarForceMeasure || v == Type::IfcPlaneAngleMeasure || v == Type::IfcPositiveLengthMeasure || v == Type::IfcPositivePlaneAngleMeasure || v == Type::IfcPositiveRatioMeasure || v == Type::IfcPowerMeasure || v == Type::IfcPressureMeasure || v == Type::IfcPropertySetDefinitionSet || v == Type::IfcRadioActivityMeasure || v == Type::IfcRatioMeasure || v == Type::IfcReal || v == Type::IfcRotationalFrequencyMeasure || v == Type::IfcRotationalMassMeasure || v == Type::IfcRotationalStiffnessMeasure || v == Type::IfcSectionModulusMeasure || v == Type::IfcSectionalAreaIntegralMeasure || v == Type::IfcShearModulusMeasure || v == Type::IfcSimpleValue || v == Type::IfcSolidAngleMeasure || v == Type::IfcSoundPowerLevelMeasure || v == Type::IfcSoundPowerMeasure || v == Type::IfcSoundPressureLevelMeasure || v == Type::IfcSoundPressureMeasure || v == Type::IfcSpecificHeatCapacityMeasure || v == Type::IfcSpecularExponent || v == Type::IfcSpecularRoughness || v == Type::IfcTemperatureGradientMeasure || v == Type::IfcTemperatureRateOfChangeMeasure || v == Type::IfcText || v == Type::IfcThermalAdmittanceMeasure || v == Type::IfcThermalConductivityMeasure || v == Type::IfcThermalExpansionCoefficientMeasure || v == Type::IfcThermalResistanceMeasure || v == Type::IfcThermalTransmittanceMeasure || v == Type::IfcThermodynamicTemperatureMeasure || v == Type::IfcTime || v == Type::IfcTimeMeasure || v == Type::IfcTimeStamp || v == Type::IfcTorqueMeasure || v == Type::IfcValue || v == Type::IfcVaporPermeabilityMeasure || v == Type::IfcVolumeMeasure || v == Type::IfcVolumetricFlowRateMeasure || v == Type::IfcWarpingConstantMeasure || v == Type::IfcWarpingMomentMeasure;
}


const char* IfcActionRequestTypeEnum::ToString(IfcActionRequestTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EMAIL", "FAX", "PHONE", "POST", "VERBAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionRequestTypeEnum::IfcActionRequestTypeEnum IfcActionRequestTypeEnum::FromString(const std::string& s) {
    if (s == "EMAIL") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_EMAIL;
    if (s == "FAX") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_FAX;
    if (s == "PHONE") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_PHONE;
    if (s == "POST") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_POST;
    if (s == "VERBAL") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_VERBAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionRequestTypeEnum::IfcActionRequestType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActionSourceTypeEnum::ToString(IfcActionSourceTypeEnum v) {
    if ( v < 0 || v >= 27 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DEAD_LOAD_G", "COMPLETION_G1", "LIVE_LOAD_Q", "SNOW_S", "WIND_W", "PRESTRESSING_P", "SETTLEMENT_U", "TEMPERATURE_T", "EARTHQUAKE_E", "FIRE", "IMPULSE", "IMPACT", "TRANSPORT", "ERECTION", "PROPPING", "SYSTEM_IMPERFECTION", "SHRINKAGE", "CREEP", "LACK_OF_FIT", "BUOYANCY", "ICE", "CURRENT", "WAVE", "RAIN", "BRAKES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcActionSourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEAD_LOAD_G") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_DEAD_LOAD_G;
    if (s == "COMPLETION_G1") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_COMPLETION_G1;
    if (s == "LIVE_LOAD_Q") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_LIVE_LOAD_Q;
    if (s == "SNOW_S") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SNOW_S;
    if (s == "WIND_W") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_WIND_W;
    if (s == "PRESTRESSING_P") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_PRESTRESSING_P;
    if (s == "SETTLEMENT_U") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SETTLEMENT_U;
    if (s == "TEMPERATURE_T") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_TEMPERATURE_T;
    if (s == "EARTHQUAKE_E") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_EARTHQUAKE_E;
    if (s == "FIRE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_FIRE;
    if (s == "IMPULSE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_IMPULSE;
    if (s == "IMPACT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_IMPACT;
    if (s == "TRANSPORT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_TRANSPORT;
    if (s == "ERECTION") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_ERECTION;
    if (s == "PROPPING") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_PROPPING;
    if (s == "SYSTEM_IMPERFECTION") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SYSTEM_IMPERFECTION;
    if (s == "SHRINKAGE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_SHRINKAGE;
    if (s == "CREEP") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_CREEP;
    if (s == "LACK_OF_FIT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_LACK_OF_FIT;
    if (s == "BUOYANCY") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_BUOYANCY;
    if (s == "ICE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_ICE;
    if (s == "CURRENT") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_CURRENT;
    if (s == "WAVE") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_WAVE;
    if (s == "RAIN") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_RAIN;
    if (s == "BRAKES") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_BRAKES;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionSourceTypeEnum::IfcActionSourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActionTypeEnum::ToString(IfcActionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PERMANENT_G", "VARIABLE_Q", "EXTRAORDINARY_A", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActionTypeEnum::IfcActionTypeEnum IfcActionTypeEnum::FromString(const std::string& s) {
    if (s == "PERMANENT_G") return ::Ifc4::IfcActionTypeEnum::IfcActionType_PERMANENT_G;
    if (s == "VARIABLE_Q") return ::Ifc4::IfcActionTypeEnum::IfcActionType_VARIABLE_Q;
    if (s == "EXTRAORDINARY_A") return ::Ifc4::IfcActionTypeEnum::IfcActionType_EXTRAORDINARY_A;
    if (s == "USERDEFINED") return ::Ifc4::IfcActionTypeEnum::IfcActionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActionTypeEnum::IfcActionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcActuatorTypeEnum::ToString(IfcActuatorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRICACTUATOR", "HANDOPERATEDACTUATOR", "HYDRAULICACTUATOR", "PNEUMATICACTUATOR", "THERMOSTATICACTUATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_ELECTRICACTUATOR;
    if (s == "HANDOPERATEDACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_HANDOPERATEDACTUATOR;
    if (s == "HYDRAULICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_HYDRAULICACTUATOR;
    if (s == "PNEUMATICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_PNEUMATICACTUATOR;
    if (s == "THERMOSTATICACTUATOR") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_THERMOSTATICACTUATOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcActuatorTypeEnum::IfcActuatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAddressTypeEnum::ToString(IfcAddressTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "HOME", "DISTRIBUTIONPOINT", "USERDEFINED" };
    return names[v];
}

IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddressTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_OFFICE;
    if (s == "SITE") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_SITE;
    if (s == "HOME") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_HOME;
    if (s == "DISTRIBUTIONPOINT") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_DISTRIBUTIONPOINT;
    if (s == "USERDEFINED") return ::Ifc4::IfcAddressTypeEnum::IfcAddressType_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalBoxTypeEnum::ToString(IfcAirTerminalBoxTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSTANTFLOW", "VARIABLEFLOWPRESSUREDEPENDANT", "VARIABLEFLOWPRESSUREINDEPENDANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTANTFLOW") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_CONSTANTFLOW;
    if (s == "VARIABLEFLOWPRESSUREDEPENDANT") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT;
    if (s == "VARIABLEFLOWPRESSUREINDEPENDANT") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirTerminalTypeEnum::ToString(IfcAirTerminalTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIFFUSER", "GRILLE", "LOUVRE", "REGISTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "DIFFUSER") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_DIFFUSER;
    if (s == "GRILLE") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_GRILLE;
    if (s == "LOUVRE") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_LOUVRE;
    if (s == "REGISTER") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_REGISTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirTerminalTypeEnum::IfcAirTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAirToAirHeatRecoveryTypeEnum::ToString(IfcAirToAirHeatRecoveryTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIXEDPLATECOUNTERFLOWEXCHANGER", "FIXEDPLATECROSSFLOWEXCHANGER", "FIXEDPLATEPARALLELFLOWEXCHANGER", "ROTARYWHEEL", "RUNAROUNDCOILLOOP", "HEATPIPE", "TWINTOWERENTHALPYRECOVERYLOOPS", "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS", "THERMOSIPHONCOILTYPEHEATEXCHANGERS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryTypeEnum::FromString(const std::string& s) {
    if (s == "FIXEDPLATECOUNTERFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER;
    if (s == "FIXEDPLATECROSSFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER;
    if (s == "FIXEDPLATEPARALLELFLOWEXCHANGER") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER;
    if (s == "ROTARYWHEEL") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_ROTARYWHEEL;
    if (s == "RUNAROUNDCOILLOOP") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP;
    if (s == "HEATPIPE") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_HEATPIPE;
    if (s == "TWINTOWERENTHALPYRECOVERYLOOPS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS;
    if (s == "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS;
    if (s == "THERMOSIPHONCOILTYPEHEATEXCHANGERS") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS;
    if (s == "USERDEFINED") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAlarmTypeEnum::ToString(IfcAlarmTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELL", "BREAKGLASSBUTTON", "LIGHT", "MANUALPULLBOX", "SIREN", "WHISTLE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmTypeEnum::FromString(const std::string& s) {
    if (s == "BELL") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_BELL;
    if (s == "BREAKGLASSBUTTON") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_BREAKGLASSBUTTON;
    if (s == "LIGHT") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_LIGHT;
    if (s == "MANUALPULLBOX") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_MANUALPULLBOX;
    if (s == "SIREN") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_SIREN;
    if (s == "WHISTLE") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_WHISTLE;
    if (s == "USERDEFINED") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAlarmTypeEnum::IfcAlarmType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisModelTypeEnum::ToString(IfcAnalysisModelTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "IN_PLANE_LOADING_2D", "OUT_PLANE_LOADING_2D", "LOADING_3D", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcAnalysisModelTypeEnum::FromString(const std::string& s) {
    if (s == "IN_PLANE_LOADING_2D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_IN_PLANE_LOADING_2D;
    if (s == "OUT_PLANE_LOADING_2D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_OUT_PLANE_LOADING_2D;
    if (s == "LOADING_3D") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_LOADING_3D;
    if (s == "USERDEFINED") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAnalysisModelTypeEnum::IfcAnalysisModelType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAnalysisTheoryTypeEnum::ToString(IfcAnalysisTheoryTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIRST_ORDER_THEORY", "SECOND_ORDER_THEORY", "THIRD_ORDER_THEORY", "FULL_NONLINEAR_THEORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcAnalysisTheoryTypeEnum::FromString(const std::string& s) {
    if (s == "FIRST_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FIRST_ORDER_THEORY;
    if (s == "SECOND_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_SECOND_ORDER_THEORY;
    if (s == "THIRD_ORDER_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_THIRD_ORDER_THEORY;
    if (s == "FULL_NONLINEAR_THEORY") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcArithmeticOperatorEnum::ToString(IfcArithmeticOperatorEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADD", "DIVIDE", "MULTIPLY", "SUBTRACT" };
    return names[v];
}

IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcArithmeticOperatorEnum::FromString(const std::string& s) {
    if (s == "ADD") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_ADD;
    if (s == "DIVIDE") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_DIVIDE;
    if (s == "MULTIPLY") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_MULTIPLY;
    if (s == "SUBTRACT") return ::Ifc4::IfcArithmeticOperatorEnum::IfcArithmeticOperator_SUBTRACT;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAssemblyPlaceEnum::ToString(IfcAssemblyPlaceEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SITE", "FACTORY", "NOTDEFINED" };
    return names[v];
}

IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcAssemblyPlaceEnum::FromString(const std::string& s) {
    if (s == "SITE") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_SITE;
    if (s == "FACTORY") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_FACTORY;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAssemblyPlaceEnum::IfcAssemblyPlace_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcAudioVisualApplianceTypeEnum::ToString(IfcAudioVisualApplianceTypeEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AMPLIFIER", "CAMERA", "DISPLAY", "MICROPHONE", "PLAYER", "PROJECTOR", "RECEIVER", "SPEAKER", "SWITCHER", "TELEPHONE", "TUNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "AMPLIFIER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_AMPLIFIER;
    if (s == "CAMERA") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_CAMERA;
    if (s == "DISPLAY") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_DISPLAY;
    if (s == "MICROPHONE") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_MICROPHONE;
    if (s == "PLAYER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_PLAYER;
    if (s == "PROJECTOR") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_PROJECTOR;
    if (s == "RECEIVER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_RECEIVER;
    if (s == "SPEAKER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_SPEAKER;
    if (s == "SWITCHER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_SWITCHER;
    if (s == "TELEPHONE") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_TELEPHONE;
    if (s == "TUNER") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_TUNER;
    if (s == "USERDEFINED") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBSplineCurveForm::ToString(IfcBSplineCurveForm v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POLYLINE_FORM", "CIRCULAR_ARC", "ELLIPTIC_ARC", "PARABOLIC_ARC", "HYPERBOLIC_ARC", "UNSPECIFIED" };
    return names[v];
}

IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurveForm::FromString(const std::string& s) {
    if (s == "POLYLINE_FORM") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_POLYLINE_FORM;
    if (s == "CIRCULAR_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_CIRCULAR_ARC;
    if (s == "ELLIPTIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_ELLIPTIC_ARC;
    if (s == "PARABOLIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_PARABOLIC_ARC;
    if (s == "HYPERBOLIC_ARC") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_HYPERBOLIC_ARC;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcBSplineCurveForm::IfcBSplineCurveForm_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBSplineSurfaceForm::ToString(IfcBSplineSurfaceForm v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLANE_SURF", "CYLINDRICAL_SURF", "CONICAL_SURF", "SPHERICAL_SURF", "TOROIDAL_SURF", "SURF_OF_REVOLUTION", "RULED_SURF", "GENERALISED_CONE", "QUADRIC_SURF", "SURF_OF_LINEAR_EXTRUSION", "UNSPECIFIED" };
    return names[v];
}

IfcBSplineSurfaceForm::IfcBSplineSurfaceForm IfcBSplineSurfaceForm::FromString(const std::string& s) {
    if (s == "PLANE_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_PLANE_SURF;
    if (s == "CYLINDRICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_CYLINDRICAL_SURF;
    if (s == "CONICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_CONICAL_SURF;
    if (s == "SPHERICAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SPHERICAL_SURF;
    if (s == "TOROIDAL_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_TOROIDAL_SURF;
    if (s == "SURF_OF_REVOLUTION") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SURF_OF_REVOLUTION;
    if (s == "RULED_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_RULED_SURF;
    if (s == "GENERALISED_CONE") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_GENERALISED_CONE;
    if (s == "QUADRIC_SURF") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_QUADRIC_SURF;
    if (s == "SURF_OF_LINEAR_EXTRUSION") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_SURF_OF_LINEAR_EXTRUSION;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcBSplineSurfaceForm::IfcBSplineSurfaceForm_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBeamTypeEnum::ToString(IfcBeamTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEAM", "JOIST", "HOLLOWCORE", "LINTEL", "SPANDREL", "T_BEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamTypeEnum::FromString(const std::string& s) {
    if (s == "BEAM") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_BEAM;
    if (s == "JOIST") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_JOIST;
    if (s == "HOLLOWCORE") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_HOLLOWCORE;
    if (s == "LINTEL") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_LINTEL;
    if (s == "SPANDREL") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_SPANDREL;
    if (s == "T_BEAM") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_T_BEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBeamTypeEnum::IfcBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBenchmarkEnum::ToString(IfcBenchmarkEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GREATERTHAN", "GREATERTHANOREQUALTO", "LESSTHAN", "LESSTHANOREQUALTO", "EQUALTO", "NOTEQUALTO", "INCLUDES", "NOTINCLUDES", "INCLUDEDIN", "NOTINCLUDEDIN" };
    return names[v];
}

IfcBenchmarkEnum::IfcBenchmarkEnum IfcBenchmarkEnum::FromString(const std::string& s) {
    if (s == "GREATERTHAN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_GREATERTHAN;
    if (s == "GREATERTHANOREQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_GREATERTHANOREQUALTO;
    if (s == "LESSTHAN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_LESSTHAN;
    if (s == "LESSTHANOREQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_LESSTHANOREQUALTO;
    if (s == "EQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_EQUALTO;
    if (s == "NOTEQUALTO") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTEQUALTO;
    if (s == "INCLUDES") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_INCLUDES;
    if (s == "NOTINCLUDES") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTINCLUDES;
    if (s == "INCLUDEDIN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_INCLUDEDIN;
    if (s == "NOTINCLUDEDIN") return ::Ifc4::IfcBenchmarkEnum::IfcBenchmark_NOTINCLUDEDIN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBoilerTypeEnum::ToString(IfcBoilerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WATER", "STEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerTypeEnum::FromString(const std::string& s) {
    if (s == "WATER") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_WATER;
    if (s == "STEAM") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_STEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBoilerTypeEnum::IfcBoilerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBooleanOperator::ToString(IfcBooleanOperator v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNION", "INTERSECTION", "DIFFERENCE" };
    return names[v];
}

IfcBooleanOperator::IfcBooleanOperator IfcBooleanOperator::FromString(const std::string& s) {
    if (s == "UNION") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_UNION;
    if (s == "INTERSECTION") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_INTERSECTION;
    if (s == "DIFFERENCE") return ::Ifc4::IfcBooleanOperator::IfcBooleanOperator_DIFFERENCE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingElementPartTypeEnum::ToString(IfcBuildingElementPartTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "INSULATION", "PRECASTPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPartTypeEnum::FromString(const std::string& s) {
    if (s == "INSULATION") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_INSULATION;
    if (s == "PRECASTPANEL") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_PRECASTPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingElementPartTypeEnum::IfcBuildingElementPartType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingElementProxyTypeEnum::ToString(IfcBuildingElementProxyTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL", "PROVISIONFORVOID", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyTypeEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_COMPLEX;
    if (s == "ELEMENT") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_ELEMENT;
    if (s == "PARTIAL") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_PARTIAL;
    if (s == "PROVISIONFORVOID") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_PROVISIONFORVOID;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBuildingSystemTypeEnum::ToString(IfcBuildingSystemTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FENESTRATION", "FOUNDATION", "LOADBEARING", "OUTERSHELL", "SHADING", "TRANSPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum IfcBuildingSystemTypeEnum::FromString(const std::string& s) {
    if (s == "FENESTRATION") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_FENESTRATION;
    if (s == "FOUNDATION") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_FOUNDATION;
    if (s == "LOADBEARING") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_LOADBEARING;
    if (s == "OUTERSHELL") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_OUTERSHELL;
    if (s == "SHADING") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_SHADING;
    if (s == "TRANSPORT") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_TRANSPORT;
    if (s == "USERDEFINED") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBuildingSystemTypeEnum::IfcBuildingSystemType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcBurnerTypeEnum::ToString(IfcBurnerTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurnerTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcBurnerTypeEnum::IfcBurnerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcBurnerTypeEnum::IfcBurnerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierFittingTypeEnum::ToString(IfcCableCarrierFittingTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CROSS", "REDUCER", "TEE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_BEND;
    if (s == "CROSS") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_CROSS;
    if (s == "REDUCER") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_REDUCER;
    if (s == "TEE") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_TEE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableCarrierSegmentTypeEnum::ToString(IfcCableCarrierSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLELADDERSEGMENT", "CABLETRAYSEGMENT", "CABLETRUNKINGSEGMENT", "CONDUITSEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CABLELADDERSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLELADDERSEGMENT;
    if (s == "CABLETRAYSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRAYSEGMENT;
    if (s == "CABLETRUNKINGSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT;
    if (s == "CONDUITSEGMENT") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_CONDUITSEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableFittingTypeEnum::ToString(IfcCableFittingTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFittingTypeEnum::FromString(const std::string& s) {
    if (s == "CONNECTOR") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_JUNCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableFittingTypeEnum::IfcCableFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCableSegmentTypeEnum::ToString(IfcCableSegmentTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUSBARSEGMENT", "CABLESEGMENT", "CONDUCTORSEGMENT", "CORESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "BUSBARSEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_BUSBARSEGMENT;
    if (s == "CABLESEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CABLESEGMENT;
    if (s == "CONDUCTORSEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CONDUCTORSEGMENT;
    if (s == "CORESEGMENT") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_CORESEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCableSegmentTypeEnum::IfcCableSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChangeActionEnum::ToString(IfcChangeActionEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NOCHANGE", "MODIFIED", "ADDED", "DELETED", "NOTDEFINED" };
    return names[v];
}

IfcChangeActionEnum::IfcChangeActionEnum IfcChangeActionEnum::FromString(const std::string& s) {
    if (s == "NOCHANGE") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_NOCHANGE;
    if (s == "MODIFIED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_MODIFIED;
    if (s == "ADDED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_ADDED;
    if (s == "DELETED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_DELETED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChangeActionEnum::IfcChangeAction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChillerTypeEnum::ToString(IfcChillerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCOOLED", "WATERCOOLED", "HEATRECOVERY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_AIRCOOLED;
    if (s == "WATERCOOLED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_WATERCOOLED;
    if (s == "HEATRECOVERY") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_HEATRECOVERY;
    if (s == "USERDEFINED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChillerTypeEnum::IfcChillerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcChimneyTypeEnum::ToString(IfcChimneyTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimneyTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcChimneyTypeEnum::IfcChimneyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcChimneyTypeEnum::IfcChimneyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoilTypeEnum::ToString(IfcCoilTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DXCOOLINGCOIL", "ELECTRICHEATINGCOIL", "GASHEATINGCOIL", "HYDRONICCOIL", "STEAMHEATINGCOIL", "WATERCOOLINGCOIL", "WATERHEATINGCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilTypeEnum::FromString(const std::string& s) {
    if (s == "DXCOOLINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_DXCOOLINGCOIL;
    if (s == "ELECTRICHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_ELECTRICHEATINGCOIL;
    if (s == "GASHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_GASHEATINGCOIL;
    if (s == "HYDRONICCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_HYDRONICCOIL;
    if (s == "STEAMHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_STEAMHEATINGCOIL;
    if (s == "WATERCOOLINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_WATERCOOLINGCOIL;
    if (s == "WATERHEATINGCOIL") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_WATERHEATINGCOIL;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoilTypeEnum::IfcCoilType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcColumnTypeEnum::ToString(IfcColumnTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COLUMN", "PILASTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnTypeEnum::FromString(const std::string& s) {
    if (s == "COLUMN") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_COLUMN;
    if (s == "PILASTER") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_PILASTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcColumnTypeEnum::IfcColumnType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCommunicationsApplianceTypeEnum::ToString(IfcCommunicationsApplianceTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANTENNA", "COMPUTER", "FAX", "GATEWAY", "MODEM", "NETWORKAPPLIANCE", "NETWORKBRIDGE", "NETWORKHUB", "PRINTER", "REPEATER", "ROUTER", "SCANNER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "ANTENNA") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_ANTENNA;
    if (s == "COMPUTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_COMPUTER;
    if (s == "FAX") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_FAX;
    if (s == "GATEWAY") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_GATEWAY;
    if (s == "MODEM") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_MODEM;
    if (s == "NETWORKAPPLIANCE") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKAPPLIANCE;
    if (s == "NETWORKBRIDGE") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKBRIDGE;
    if (s == "NETWORKHUB") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NETWORKHUB;
    if (s == "PRINTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_PRINTER;
    if (s == "REPEATER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_REPEATER;
    if (s == "ROUTER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_ROUTER;
    if (s == "SCANNER") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_SCANNER;
    if (s == "USERDEFINED") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcComplexPropertyTemplateTypeEnum::ToString(IfcComplexPropertyTemplateTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "P_COMPLEX", "Q_COMPLEX" };
    return names[v];
}

IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum IfcComplexPropertyTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "P_COMPLEX") return ::Ifc4::IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateType_P_COMPLEX;
    if (s == "Q_COMPLEX") return ::Ifc4::IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateType_Q_COMPLEX;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCompressorTypeEnum::ToString(IfcCompressorTypeEnum v) {
    if ( v < 0 || v >= 17 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DYNAMIC", "RECIPROCATING", "ROTARY", "SCROLL", "TROCHOIDAL", "SINGLESTAGE", "BOOSTER", "OPENTYPE", "HERMETIC", "SEMIHERMETIC", "WELDEDSHELLHERMETIC", "ROLLINGPISTON", "ROTARYVANE", "SINGLESCREW", "TWINSCREW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorTypeEnum::FromString(const std::string& s) {
    if (s == "DYNAMIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_DYNAMIC;
    if (s == "RECIPROCATING") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_RECIPROCATING;
    if (s == "ROTARY") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROTARY;
    if (s == "SCROLL") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SCROLL;
    if (s == "TROCHOIDAL") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_TROCHOIDAL;
    if (s == "SINGLESTAGE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SINGLESTAGE;
    if (s == "BOOSTER") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_BOOSTER;
    if (s == "OPENTYPE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_OPENTYPE;
    if (s == "HERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_HERMETIC;
    if (s == "SEMIHERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SEMIHERMETIC;
    if (s == "WELDEDSHELLHERMETIC") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_WELDEDSHELLHERMETIC;
    if (s == "ROLLINGPISTON") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROLLINGPISTON;
    if (s == "ROTARYVANE") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_ROTARYVANE;
    if (s == "SINGLESCREW") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_SINGLESCREW;
    if (s == "TWINSCREW") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_TWINSCREW;
    if (s == "USERDEFINED") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCompressorTypeEnum::IfcCompressorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCondenserTypeEnum::ToString(IfcCondenserTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCOOLED", "EVAPORATIVECOOLED", "WATERCOOLED", "WATERCOOLEDBRAZEDPLATE", "WATERCOOLEDSHELLCOIL", "WATERCOOLEDSHELLTUBE", "WATERCOOLEDTUBEINTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserTypeEnum::FromString(const std::string& s) {
    if (s == "AIRCOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_AIRCOOLED;
    if (s == "EVAPORATIVECOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_EVAPORATIVECOOLED;
    if (s == "WATERCOOLED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLED;
    if (s == "WATERCOOLEDBRAZEDPLATE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDBRAZEDPLATE;
    if (s == "WATERCOOLEDSHELLCOIL") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLCOIL;
    if (s == "WATERCOOLEDSHELLTUBE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDSHELLTUBE;
    if (s == "WATERCOOLEDTUBEINTUBE") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_WATERCOOLEDTUBEINTUBE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCondenserTypeEnum::IfcCondenserType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConnectionTypeEnum::ToString(IfcConnectionTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ATPATH", "ATSTART", "ATEND", "NOTDEFINED" };
    return names[v];
}

IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "ATPATH") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATPATH;
    if (s == "ATSTART") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATSTART;
    if (s == "ATEND") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_ATEND;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConnectionTypeEnum::IfcConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstraintEnum::ToString(IfcConstraintEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HARD", "SOFT", "ADVISORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstraintEnum::IfcConstraintEnum IfcConstraintEnum::FromString(const std::string& s) {
    if (s == "HARD") return ::Ifc4::IfcConstraintEnum::IfcConstraint_HARD;
    if (s == "SOFT") return ::Ifc4::IfcConstraintEnum::IfcConstraint_SOFT;
    if (s == "ADVISORY") return ::Ifc4::IfcConstraintEnum::IfcConstraint_ADVISORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstraintEnum::IfcConstraint_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstraintEnum::IfcConstraint_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionEquipmentResourceTypeEnum::ToString(IfcConstructionEquipmentResourceTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DEMOLISHING", "EARTHMOVING", "ERECTING", "HEATING", "LIGHTING", "PAVING", "PUMPING", "TRANSPORTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResourceTypeEnum::FromString(const std::string& s) {
    if (s == "DEMOLISHING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_DEMOLISHING;
    if (s == "EARTHMOVING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_EARTHMOVING;
    if (s == "ERECTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_ERECTING;
    if (s == "HEATING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_HEATING;
    if (s == "LIGHTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_LIGHTING;
    if (s == "PAVING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_PAVING;
    if (s == "PUMPING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_PUMPING;
    if (s == "TRANSPORTING") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_TRANSPORTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionMaterialResourceTypeEnum::ToString(IfcConstructionMaterialResourceTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AGGREGATES", "CONCRETE", "DRYWALL", "FUEL", "GYPSUM", "MASONRY", "METAL", "PLASTIC", "WOOD", "NOTDEFINED", "USERDEFINED" };
    return names[v];
}

IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResourceTypeEnum::FromString(const std::string& s) {
    if (s == "AGGREGATES") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_AGGREGATES;
    if (s == "CONCRETE") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_CONCRETE;
    if (s == "DRYWALL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_DRYWALL;
    if (s == "FUEL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_FUEL;
    if (s == "GYPSUM") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_GYPSUM;
    if (s == "MASONRY") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_MASONRY;
    if (s == "METAL") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_METAL;
    if (s == "PLASTIC") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_PLASTIC;
    if (s == "WOOD") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_WOOD;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_NOTDEFINED;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceType_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcConstructionProductResourceTypeEnum::ToString(IfcConstructionProductResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSEMBLY", "FORMWORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResourceTypeEnum::FromString(const std::string& s) {
    if (s == "ASSEMBLY") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_ASSEMBLY;
    if (s == "FORMWORK") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_FORMWORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcControllerTypeEnum::ToString(IfcControllerTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOATING", "PROGRAMMABLE", "PROPORTIONAL", "MULTIPOSITION", "TWOPOSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerTypeEnum::FromString(const std::string& s) {
    if (s == "FLOATING") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_FLOATING;
    if (s == "PROGRAMMABLE") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_PROGRAMMABLE;
    if (s == "PROPORTIONAL") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_PROPORTIONAL;
    if (s == "MULTIPOSITION") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_MULTIPOSITION;
    if (s == "TWOPOSITION") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_TWOPOSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcControllerTypeEnum::IfcControllerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCooledBeamTypeEnum::ToString(IfcCooledBeamTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTIVE", "PASSIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamTypeEnum::FromString(const std::string& s) {
    if (s == "ACTIVE") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_ACTIVE;
    if (s == "PASSIVE") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_PASSIVE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCooledBeamTypeEnum::IfcCooledBeamType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoolingTowerTypeEnum::ToString(IfcCoolingTowerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NATURALDRAFT", "MECHANICALINDUCEDDRAFT", "MECHANICALFORCEDDRAFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerTypeEnum::FromString(const std::string& s) {
    if (s == "NATURALDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NATURALDRAFT;
    if (s == "MECHANICALINDUCEDDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALINDUCEDDRAFT;
    if (s == "MECHANICALFORCEDDRAFT") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_MECHANICALFORCEDDRAFT;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoolingTowerTypeEnum::IfcCoolingTowerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCostItemTypeEnum::ToString(IfcCostItemTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCostItemTypeEnum::IfcCostItemTypeEnum IfcCostItemTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcCostItemTypeEnum::IfcCostItemType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCostItemTypeEnum::IfcCostItemType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCostScheduleTypeEnum::ToString(IfcCostScheduleTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BUDGET", "COSTPLAN", "ESTIMATE", "TENDER", "PRICEDBILLOFQUANTITIES", "UNPRICEDBILLOFQUANTITIES", "SCHEDULEOFRATES", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "BUDGET") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_BUDGET;
    if (s == "COSTPLAN") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_COSTPLAN;
    if (s == "ESTIMATE") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_ESTIMATE;
    if (s == "TENDER") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_TENDER;
    if (s == "PRICEDBILLOFQUANTITIES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_PRICEDBILLOFQUANTITIES;
    if (s == "UNPRICEDBILLOFQUANTITIES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES;
    if (s == "SCHEDULEOFRATES") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_SCHEDULEOFRATES;
    if (s == "USERDEFINED") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCostScheduleTypeEnum::IfcCostScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCoveringTypeEnum::ToString(IfcCoveringTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CEILING", "FLOORING", "CLADDING", "ROOFING", "MOLDING", "SKIRTINGBOARD", "INSULATION", "MEMBRANE", "SLEEVING", "WRAPPING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringTypeEnum::FromString(const std::string& s) {
    if (s == "CEILING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_CEILING;
    if (s == "FLOORING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_FLOORING;
    if (s == "CLADDING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_CLADDING;
    if (s == "ROOFING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_ROOFING;
    if (s == "MOLDING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_MOLDING;
    if (s == "SKIRTINGBOARD") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_SKIRTINGBOARD;
    if (s == "INSULATION") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_INSULATION;
    if (s == "MEMBRANE") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_MEMBRANE;
    if (s == "SLEEVING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_SLEEVING;
    if (s == "WRAPPING") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_WRAPPING;
    if (s == "USERDEFINED") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCoveringTypeEnum::IfcCoveringType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCrewResourceTypeEnum::ToString(IfcCrewResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OFFICE", "SITE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResourceTypeEnum::FromString(const std::string& s) {
    if (s == "OFFICE") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_OFFICE;
    if (s == "SITE") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_SITE;
    if (s == "USERDEFINED") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCrewResourceTypeEnum::IfcCrewResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurtainWallTypeEnum::ToString(IfcCurtainWallTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcCurtainWallTypeEnum::IfcCurtainWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCurtainWallTypeEnum::IfcCurtainWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcCurveInterpolationEnum::ToString(IfcCurveInterpolationEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LINEAR", "LOG_LINEAR", "LOG_LOG", "NOTDEFINED" };
    return names[v];
}

IfcCurveInterpolationEnum::IfcCurveInterpolationEnum IfcCurveInterpolationEnum::FromString(const std::string& s) {
    if (s == "LINEAR") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LINEAR;
    if (s == "LOG_LINEAR") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LOG_LINEAR;
    if (s == "LOG_LOG") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_LOG_LOG;
    if (s == "NOTDEFINED") return ::Ifc4::IfcCurveInterpolationEnum::IfcCurveInterpolation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDamperTypeEnum::ToString(IfcDamperTypeEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BACKDRAFTDAMPER", "BALANCINGDAMPER", "BLASTDAMPER", "CONTROLDAMPER", "FIREDAMPER", "FIRESMOKEDAMPER", "FUMEHOODEXHAUST", "GRAVITYDAMPER", "GRAVITYRELIEFDAMPER", "RELIEFDAMPER", "SMOKEDAMPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperTypeEnum::FromString(const std::string& s) {
    if (s == "BACKDRAFTDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BACKDRAFTDAMPER;
    if (s == "BALANCINGDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BALANCINGDAMPER;
    if (s == "BLASTDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_BLASTDAMPER;
    if (s == "CONTROLDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_CONTROLDAMPER;
    if (s == "FIREDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FIREDAMPER;
    if (s == "FIRESMOKEDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FIRESMOKEDAMPER;
    if (s == "FUMEHOODEXHAUST") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_FUMEHOODEXHAUST;
    if (s == "GRAVITYDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_GRAVITYDAMPER;
    if (s == "GRAVITYRELIEFDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_GRAVITYRELIEFDAMPER;
    if (s == "RELIEFDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_RELIEFDAMPER;
    if (s == "SMOKEDAMPER") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_SMOKEDAMPER;
    if (s == "USERDEFINED") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDamperTypeEnum::IfcDamperType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDataOriginEnum::ToString(IfcDataOriginEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MEASURED", "PREDICTED", "SIMULATED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDataOriginEnum::IfcDataOriginEnum IfcDataOriginEnum::FromString(const std::string& s) {
    if (s == "MEASURED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_MEASURED;
    if (s == "PREDICTED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_PREDICTED;
    if (s == "SIMULATED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_SIMULATED;
    if (s == "USERDEFINED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDataOriginEnum::IfcDataOrigin_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDerivedUnitEnum::ToString(IfcDerivedUnitEnum v) {
    if ( v < 0 || v >= 53 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANGULARVELOCITYUNIT", "AREADENSITYUNIT", "COMPOUNDPLANEANGLEUNIT", "DYNAMICVISCOSITYUNIT", "HEATFLUXDENSITYUNIT", "INTEGERCOUNTRATEUNIT", "ISOTHERMALMOISTURECAPACITYUNIT", "KINEMATICVISCOSITYUNIT", "LINEARVELOCITYUNIT", "MASSDENSITYUNIT", "MASSFLOWRATEUNIT", "MOISTUREDIFFUSIVITYUNIT", "MOLECULARWEIGHTUNIT", "SPECIFICHEATCAPACITYUNIT", "THERMALADMITTANCEUNIT", "THERMALCONDUCTANCEUNIT", "THERMALRESISTANCEUNIT", "THERMALTRANSMITTANCEUNIT", "VAPORPERMEABILITYUNIT", "VOLUMETRICFLOWRATEUNIT", "ROTATIONALFREQUENCYUNIT", "TORQUEUNIT", "MOMENTOFINERTIAUNIT", "LINEARMOMENTUNIT", "LINEARFORCEUNIT", "PLANARFORCEUNIT", "MODULUSOFELASTICITYUNIT", "SHEARMODULUSUNIT", "LINEARSTIFFNESSUNIT", "ROTATIONALSTIFFNESSUNIT", "MODULUSOFSUBGRADEREACTIONUNIT", "ACCELERATIONUNIT", "CURVATUREUNIT", "HEATINGVALUEUNIT", "IONCONCENTRATIONUNIT", "LUMINOUSINTENSITYDISTRIBUTIONUNIT", "MASSPERLENGTHUNIT", "MODULUSOFLINEARSUBGRADEREACTIONUNIT", "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT", "PHUNIT", "ROTATIONALMASSUNIT", "SECTIONAREAINTEGRALUNIT", "SECTIONMODULUSUNIT", "SOUNDPOWERLEVELUNIT", "SOUNDPOWERUNIT", "SOUNDPRESSURELEVELUNIT", "SOUNDPRESSUREUNIT", "TEMPERATUREGRADIENTUNIT", "TEMPERATURERATEOFCHANGEUNIT", "THERMALEXPANSIONCOEFFICIENTUNIT", "WARPINGCONSTANTUNIT", "WARPINGMOMENTUNIT", "USERDEFINED" };
    return names[v];
}

IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnitEnum::FromString(const std::string& s) {
    if (s == "ANGULARVELOCITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ANGULARVELOCITYUNIT;
    if (s == "AREADENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_AREADENSITYUNIT;
    if (s == "COMPOUNDPLANEANGLEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT;
    if (s == "DYNAMICVISCOSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_DYNAMICVISCOSITYUNIT;
    if (s == "HEATFLUXDENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_HEATFLUXDENSITYUNIT;
    if (s == "INTEGERCOUNTRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_INTEGERCOUNTRATEUNIT;
    if (s == "ISOTHERMALMOISTURECAPACITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT;
    if (s == "KINEMATICVISCOSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_KINEMATICVISCOSITYUNIT;
    if (s == "LINEARVELOCITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARVELOCITYUNIT;
    if (s == "MASSDENSITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSDENSITYUNIT;
    if (s == "MASSFLOWRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSFLOWRATEUNIT;
    if (s == "MOISTUREDIFFUSIVITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT;
    if (s == "MOLECULARWEIGHTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOLECULARWEIGHTUNIT;
    if (s == "SPECIFICHEATCAPACITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT;
    if (s == "THERMALADMITTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALADMITTANCEUNIT;
    if (s == "THERMALCONDUCTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALCONDUCTANCEUNIT;
    if (s == "THERMALRESISTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALRESISTANCEUNIT;
    if (s == "THERMALTRANSMITTANCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALTRANSMITTANCEUNIT;
    if (s == "VAPORPERMEABILITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_VAPORPERMEABILITYUNIT;
    if (s == "VOLUMETRICFLOWRATEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT;
    if (s == "ROTATIONALFREQUENCYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALFREQUENCYUNIT;
    if (s == "TORQUEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TORQUEUNIT;
    if (s == "MOMENTOFINERTIAUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MOMENTOFINERTIAUNIT;
    if (s == "LINEARMOMENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARMOMENTUNIT;
    if (s == "LINEARFORCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARFORCEUNIT;
    if (s == "PLANARFORCEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_PLANARFORCEUNIT;
    if (s == "MODULUSOFELASTICITYUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFELASTICITYUNIT;
    if (s == "SHEARMODULUSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SHEARMODULUSUNIT;
    if (s == "LINEARSTIFFNESSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LINEARSTIFFNESSUNIT;
    if (s == "ROTATIONALSTIFFNESSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT;
    if (s == "MODULUSOFSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT;
    if (s == "ACCELERATIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ACCELERATIONUNIT;
    if (s == "CURVATUREUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_CURVATUREUNIT;
    if (s == "HEATINGVALUEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_HEATINGVALUEUNIT;
    if (s == "IONCONCENTRATIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_IONCONCENTRATIONUNIT;
    if (s == "LUMINOUSINTENSITYDISTRIBUTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT;
    if (s == "MASSPERLENGTHUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MASSPERLENGTHUNIT;
    if (s == "MODULUSOFLINEARSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT;
    if (s == "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT;
    if (s == "PHUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_PHUNIT;
    if (s == "ROTATIONALMASSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_ROTATIONALMASSUNIT;
    if (s == "SECTIONAREAINTEGRALUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONAREAINTEGRALUNIT;
    if (s == "SECTIONMODULUSUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SECTIONMODULUSUNIT;
    if (s == "SOUNDPOWERLEVELUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERLEVELUNIT;
    if (s == "SOUNDPOWERUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPOWERUNIT;
    if (s == "SOUNDPRESSURELEVELUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSURELEVELUNIT;
    if (s == "SOUNDPRESSUREUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_SOUNDPRESSUREUNIT;
    if (s == "TEMPERATUREGRADIENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATUREGRADIENTUNIT;
    if (s == "TEMPERATURERATEOFCHANGEUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_TEMPERATURERATEOFCHANGEUNIT;
    if (s == "THERMALEXPANSIONCOEFFICIENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT;
    if (s == "WARPINGCONSTANTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGCONSTANTUNIT;
    if (s == "WARPINGMOMENTUNIT") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_WARPINGMOMENTUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDerivedUnitEnum::IfcDerivedUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDirectionSenseEnum::ToString(IfcDirectionSenseEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE" };
    return names[v];
}

IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcDirectionSenseEnum::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc4::IfcDirectionSenseEnum::IfcDirectionSense_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc4::IfcDirectionSenseEnum::IfcDirectionSense_NEGATIVE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDiscreteAccessoryTypeEnum::ToString(IfcDiscreteAccessoryTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORPLATE", "BRACKET", "SHOE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessoryTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORPLATE") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_ANCHORPLATE;
    if (s == "BRACKET") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_BRACKET;
    if (s == "SHOE") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_SHOE;
    if (s == "USERDEFINED") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionChamberElementTypeEnum::ToString(IfcDistributionChamberElementTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FORMEDDUCT", "INSPECTIONCHAMBER", "INSPECTIONPIT", "MANHOLE", "METERCHAMBER", "SUMP", "TRENCH", "VALVECHAMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementTypeEnum::FromString(const std::string& s) {
    if (s == "FORMEDDUCT") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_FORMEDDUCT;
    if (s == "INSPECTIONCHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONCHAMBER;
    if (s == "INSPECTIONPIT") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_INSPECTIONPIT;
    if (s == "MANHOLE") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_MANHOLE;
    if (s == "METERCHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_METERCHAMBER;
    if (s == "SUMP") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_SUMP;
    if (s == "TRENCH") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_TRENCH;
    if (s == "VALVECHAMBER") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_VALVECHAMBER;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionPortTypeEnum::ToString(IfcDistributionPortTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CABLE", "CABLECARRIER", "DUCT", "PIPE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum IfcDistributionPortTypeEnum::FromString(const std::string& s) {
    if (s == "CABLE") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_CABLE;
    if (s == "CABLECARRIER") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_CABLECARRIER;
    if (s == "DUCT") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_DUCT;
    if (s == "PIPE") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_PIPE;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionPortTypeEnum::IfcDistributionPortType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDistributionSystemEnum::ToString(IfcDistributionSystemEnum v) {
    if ( v < 0 || v >= 44 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRCONDITIONING", "AUDIOVISUAL", "CHEMICAL", "CHILLEDWATER", "COMMUNICATION", "COMPRESSEDAIR", "CONDENSERWATER", "CONTROL", "CONVEYING", "DATA", "DISPOSAL", "DOMESTICCOLDWATER", "DOMESTICHOTWATER", "DRAINAGE", "EARTHING", "ELECTRICAL", "ELECTROACOUSTIC", "EXHAUST", "FIREPROTECTION", "FUEL", "GAS", "HAZARDOUS", "HEATING", "LIGHTING", "LIGHTNINGPROTECTION", "MUNICIPALSOLIDWASTE", "OIL", "OPERATIONAL", "POWERGENERATION", "RAINWATER", "REFRIGERATION", "SECURITY", "SEWAGE", "SIGNAL", "STORMWATER", "TELEPHONE", "TV", "VACUUM", "VENT", "VENTILATION", "WASTEWATER", "WATERSUPPLY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionSystemEnum::FromString(const std::string& s) {
    if (s == "AIRCONDITIONING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_AIRCONDITIONING;
    if (s == "AUDIOVISUAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_AUDIOVISUAL;
    if (s == "CHEMICAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CHEMICAL;
    if (s == "CHILLEDWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CHILLEDWATER;
    if (s == "COMMUNICATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_COMMUNICATION;
    if (s == "COMPRESSEDAIR") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_COMPRESSEDAIR;
    if (s == "CONDENSERWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONDENSERWATER;
    if (s == "CONTROL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONTROL;
    if (s == "CONVEYING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_CONVEYING;
    if (s == "DATA") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DATA;
    if (s == "DISPOSAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DISPOSAL;
    if (s == "DOMESTICCOLDWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DOMESTICCOLDWATER;
    if (s == "DOMESTICHOTWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DOMESTICHOTWATER;
    if (s == "DRAINAGE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_DRAINAGE;
    if (s == "EARTHING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_EARTHING;
    if (s == "ELECTRICAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_ELECTRICAL;
    if (s == "ELECTROACOUSTIC") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_ELECTROACOUSTIC;
    if (s == "EXHAUST") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_EXHAUST;
    if (s == "FIREPROTECTION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_FIREPROTECTION;
    if (s == "FUEL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_FUEL;
    if (s == "GAS") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_GAS;
    if (s == "HAZARDOUS") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_HAZARDOUS;
    if (s == "HEATING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_HEATING;
    if (s == "LIGHTING") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_LIGHTING;
    if (s == "LIGHTNINGPROTECTION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_LIGHTNINGPROTECTION;
    if (s == "MUNICIPALSOLIDWASTE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_MUNICIPALSOLIDWASTE;
    if (s == "OIL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_OIL;
    if (s == "OPERATIONAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_OPERATIONAL;
    if (s == "POWERGENERATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_POWERGENERATION;
    if (s == "RAINWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_RAINWATER;
    if (s == "REFRIGERATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_REFRIGERATION;
    if (s == "SECURITY") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SECURITY;
    if (s == "SEWAGE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SEWAGE;
    if (s == "SIGNAL") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_SIGNAL;
    if (s == "STORMWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_STORMWATER;
    if (s == "TELEPHONE") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_TELEPHONE;
    if (s == "TV") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_TV;
    if (s == "VACUUM") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VACUUM;
    if (s == "VENT") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VENT;
    if (s == "VENTILATION") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_VENTILATION;
    if (s == "WASTEWATER") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_WASTEWATER;
    if (s == "WATERSUPPLY") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_WATERSUPPLY;
    if (s == "USERDEFINED") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDistributionSystemEnum::IfcDistributionSystem_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentConfidentialityEnum::ToString(IfcDocumentConfidentialityEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PUBLIC", "RESTRICTED", "CONFIDENTIAL", "PERSONAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentConfidentialityEnum::FromString(const std::string& s) {
    if (s == "PUBLIC") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PUBLIC;
    if (s == "RESTRICTED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_RESTRICTED;
    if (s == "CONFIDENTIAL") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_CONFIDENTIAL;
    if (s == "PERSONAL") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_PERSONAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDocumentConfidentialityEnum::IfcDocumentConfidentiality_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDocumentStatusEnum::ToString(IfcDocumentStatusEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DRAFT", "FINALDRAFT", "FINAL", "REVISION", "NOTDEFINED" };
    return names[v];
}

IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentStatusEnum::FromString(const std::string& s) {
    if (s == "DRAFT") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_DRAFT;
    if (s == "FINALDRAFT") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_FINALDRAFT;
    if (s == "FINAL") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_FINAL;
    if (s == "REVISION") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_REVISION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDocumentStatusEnum::IfcDocumentStatus_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelOperationEnum::ToString(IfcDoorPanelOperationEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SWINGING", "DOUBLE_ACTING", "SLIDING", "FOLDING", "REVOLVING", "ROLLINGUP", "FIXEDPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SWINGING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SWINGING;
    if (s == "DOUBLE_ACTING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_DOUBLE_ACTING;
    if (s == "SLIDING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_SLIDING;
    if (s == "FOLDING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_ROLLINGUP;
    if (s == "FIXEDPANEL") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_FIXEDPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorPanelOperationEnum::IfcDoorPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorPanelPositionEnum::ToString(IfcDoorPanelPositionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "NOTDEFINED" };
    return names[v];
}

IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_RIGHT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorPanelPositionEnum::IfcDoorPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleConstructionEnum::ToString(IfcDoorStyleConstructionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "ALUMINIUM_PLASTIC", "PLASTIC", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_WOOD;
    if (s == "ALUMINIUM_PLASTIC") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_ALUMINIUM_PLASTIC;
    if (s == "PLASTIC") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_PLASTIC;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorStyleConstructionEnum::IfcDoorStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorStyleOperationEnum::ToString(IfcDoorStyleOperationEnum v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_ROLLINGUP;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorStyleOperationEnum::IfcDoorStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorTypeEnum::ToString(IfcDoorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DOOR", "GATE", "TRAPDOOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoorTypeEnum::FromString(const std::string& s) {
    if (s == "DOOR") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_DOOR;
    if (s == "GATE") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_GATE;
    if (s == "TRAPDOOR") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_TRAPDOOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorTypeEnum::IfcDoorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDoorTypeOperationEnum::ToString(IfcDoorTypeOperationEnum v) {
    if ( v < 0 || v >= 20 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_SWING_LEFT", "SINGLE_SWING_RIGHT", "DOUBLE_DOOR_SINGLE_SWING", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT", "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT", "DOUBLE_SWING_LEFT", "DOUBLE_SWING_RIGHT", "DOUBLE_DOOR_DOUBLE_SWING", "SLIDING_TO_LEFT", "SLIDING_TO_RIGHT", "DOUBLE_DOOR_SLIDING", "FOLDING_TO_LEFT", "FOLDING_TO_RIGHT", "DOUBLE_DOOR_FOLDING", "REVOLVING", "ROLLINGUP", "SWING_FIXED_LEFT", "SWING_FIXED_RIGHT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoorTypeOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_SWING_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SINGLE_SWING_LEFT;
    if (s == "SINGLE_SWING_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SINGLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT;
    if (s == "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT;
    if (s == "DOUBLE_SWING_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_SWING_LEFT;
    if (s == "DOUBLE_SWING_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_SWING_RIGHT;
    if (s == "DOUBLE_DOOR_DOUBLE_SWING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_DOUBLE_SWING;
    if (s == "SLIDING_TO_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SLIDING_TO_LEFT;
    if (s == "SLIDING_TO_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SLIDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_SLIDING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_SLIDING;
    if (s == "FOLDING_TO_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_FOLDING_TO_LEFT;
    if (s == "FOLDING_TO_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_FOLDING_TO_RIGHT;
    if (s == "DOUBLE_DOOR_FOLDING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_DOUBLE_DOOR_FOLDING;
    if (s == "REVOLVING") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_REVOLVING;
    if (s == "ROLLINGUP") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_ROLLINGUP;
    if (s == "SWING_FIXED_LEFT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SWING_FIXED_LEFT;
    if (s == "SWING_FIXED_RIGHT") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_SWING_FIXED_RIGHT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDoorTypeOperationEnum::IfcDoorTypeOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctFittingTypeEnum::ToString(IfcDuctFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctFittingTypeEnum::IfcDuctFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSegmentTypeEnum::ToString(IfcDuctSegmentTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGIDSEGMENT", "FLEXIBLESEGMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "RIGIDSEGMENT") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_RIGIDSEGMENT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_FLEXIBLESEGMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctSegmentTypeEnum::IfcDuctSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcDuctSilencerTypeEnum::ToString(IfcDuctSilencerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLATOVAL", "RECTANGULAR", "ROUND", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerTypeEnum::FromString(const std::string& s) {
    if (s == "FLATOVAL") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_FLATOVAL;
    if (s == "RECTANGULAR") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_RECTANGULAR;
    if (s == "ROUND") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_ROUND;
    if (s == "USERDEFINED") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcDuctSilencerTypeEnum::IfcDuctSilencerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricApplianceTypeEnum::ToString(IfcElectricApplianceTypeEnum v) {
    if ( v < 0 || v >= 18 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DISHWASHER", "ELECTRICCOOKER", "FREESTANDINGELECTRICHEATER", "FREESTANDINGFAN", "FREESTANDINGWATERHEATER", "FREESTANDINGWATERCOOLER", "FREEZER", "FRIDGE_FREEZER", "HANDDRYER", "KITCHENMACHINE", "MICROWAVE", "PHOTOCOPIER", "REFRIGERATOR", "TUMBLEDRYER", "VENDINGMACHINE", "WASHINGMACHINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceTypeEnum::FromString(const std::string& s) {
    if (s == "DISHWASHER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_DISHWASHER;
    if (s == "ELECTRICCOOKER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_ELECTRICCOOKER;
    if (s == "FREESTANDINGELECTRICHEATER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGELECTRICHEATER;
    if (s == "FREESTANDINGFAN") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGFAN;
    if (s == "FREESTANDINGWATERHEATER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGWATERHEATER;
    if (s == "FREESTANDINGWATERCOOLER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREESTANDINGWATERCOOLER;
    if (s == "FREEZER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FREEZER;
    if (s == "FRIDGE_FREEZER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_FRIDGE_FREEZER;
    if (s == "HANDDRYER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_HANDDRYER;
    if (s == "KITCHENMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_KITCHENMACHINE;
    if (s == "MICROWAVE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_MICROWAVE;
    if (s == "PHOTOCOPIER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_PHOTOCOPIER;
    if (s == "REFRIGERATOR") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_REFRIGERATOR;
    if (s == "TUMBLEDRYER") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_TUMBLEDRYER;
    if (s == "VENDINGMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_VENDINGMACHINE;
    if (s == "WASHINGMACHINE") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_WASHINGMACHINE;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricApplianceTypeEnum::IfcElectricApplianceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricDistributionBoardTypeEnum::ToString(IfcElectricDistributionBoardTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSUMERUNIT", "DISTRIBUTIONBOARD", "MOTORCONTROLCENTRE", "SWITCHBOARD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoardTypeEnum::FromString(const std::string& s) {
    if (s == "CONSUMERUNIT") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_CONSUMERUNIT;
    if (s == "DISTRIBUTIONBOARD") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_DISTRIBUTIONBOARD;
    if (s == "MOTORCONTROLCENTRE") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_MOTORCONTROLCENTRE;
    if (s == "SWITCHBOARD") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_SWITCHBOARD;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricFlowStorageDeviceTypeEnum::ToString(IfcElectricFlowStorageDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATTERY", "CAPACITORBANK", "HARMONICFILTER", "INDUCTORBANK", "UPS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "BATTERY") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_BATTERY;
    if (s == "CAPACITORBANK") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_CAPACITORBANK;
    if (s == "HARMONICFILTER") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_HARMONICFILTER;
    if (s == "INDUCTORBANK") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_INDUCTORBANK;
    if (s == "UPS") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_UPS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricGeneratorTypeEnum::ToString(IfcElectricGeneratorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHP", "ENGINEGENERATOR", "STANDALONE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorTypeEnum::FromString(const std::string& s) {
    if (s == "CHP") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_CHP;
    if (s == "ENGINEGENERATOR") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_ENGINEGENERATOR;
    if (s == "STANDALONE") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_STANDALONE;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricGeneratorTypeEnum::IfcElectricGeneratorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricMotorTypeEnum::ToString(IfcElectricMotorTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DC", "INDUCTION", "POLYPHASE", "RELUCTANCESYNCHRONOUS", "SYNCHRONOUS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorTypeEnum::FromString(const std::string& s) {
    if (s == "DC") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_DC;
    if (s == "INDUCTION") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_INDUCTION;
    if (s == "POLYPHASE") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_POLYPHASE;
    if (s == "RELUCTANCESYNCHRONOUS") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_RELUCTANCESYNCHRONOUS;
    if (s == "SYNCHRONOUS") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_SYNCHRONOUS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricMotorTypeEnum::IfcElectricMotorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElectricTimeControlTypeEnum::ToString(IfcElectricTimeControlTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TIMECLOCK", "TIMEDELAY", "RELAY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlTypeEnum::FromString(const std::string& s) {
    if (s == "TIMECLOCK") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMECLOCK;
    if (s == "TIMEDELAY") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_TIMEDELAY;
    if (s == "RELAY") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_RELAY;
    if (s == "USERDEFINED") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElectricTimeControlTypeEnum::IfcElectricTimeControlType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementAssemblyTypeEnum::ToString(IfcElementAssemblyTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACCESSORY_ASSEMBLY", "ARCH", "BEAM_GRID", "BRACED_FRAME", "GIRDER", "REINFORCEMENT_UNIT", "RIGID_FRAME", "SLAB_FIELD", "TRUSS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssemblyTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESSORY_ASSEMBLY") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ACCESSORY_ASSEMBLY;
    if (s == "ARCH") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_ARCH;
    if (s == "BEAM_GRID") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BEAM_GRID;
    if (s == "BRACED_FRAME") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_BRACED_FRAME;
    if (s == "GIRDER") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_GIRDER;
    if (s == "REINFORCEMENT_UNIT") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_REINFORCEMENT_UNIT;
    if (s == "RIGID_FRAME") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_RIGID_FRAME;
    if (s == "SLAB_FIELD") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_SLAB_FIELD;
    if (s == "TRUSS") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_TRUSS;
    if (s == "USERDEFINED") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcElementAssemblyTypeEnum::IfcElementAssemblyType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcElementCompositionEnum::ToString(IfcElementCompositionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPLEX", "ELEMENT", "PARTIAL" };
    return names[v];
}

IfcElementCompositionEnum::IfcElementCompositionEnum IfcElementCompositionEnum::FromString(const std::string& s) {
    if (s == "COMPLEX") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_COMPLEX;
    if (s == "ELEMENT") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_ELEMENT;
    if (s == "PARTIAL") return ::Ifc4::IfcElementCompositionEnum::IfcElementComposition_PARTIAL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEngineTypeEnum::ToString(IfcEngineTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXTERNALCOMBUSTION", "INTERNALCOMBUSTION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngineTypeEnum::FromString(const std::string& s) {
    if (s == "EXTERNALCOMBUSTION") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_EXTERNALCOMBUSTION;
    if (s == "INTERNALCOMBUSTION") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_INTERNALCOMBUSTION;
    if (s == "USERDEFINED") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEngineTypeEnum::IfcEngineType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporativeCoolerTypeEnum::ToString(IfcEvaporativeCoolerTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER", "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER", "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER", "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER", "DIRECTEVAPORATIVEAIRWASHER", "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER", "INDIRECTEVAPORATIVEWETCOIL", "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER", "INDIRECTDIRECTCOMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER;
    if (s == "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER;
    if (s == "DIRECTEVAPORATIVEAIRWASHER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER;
    if (s == "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER;
    if (s == "INDIRECTEVAPORATIVEWETCOIL") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL;
    if (s == "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER;
    if (s == "INDIRECTDIRECTCOMBINATION") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEvaporatorTypeEnum::ToString(IfcEvaporatorTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DIRECTEXPANSION", "DIRECTEXPANSIONSHELLANDTUBE", "DIRECTEXPANSIONTUBEINTUBE", "DIRECTEXPANSIONBRAZEDPLATE", "FLOODEDSHELLANDTUBE", "SHELLANDCOIL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorTypeEnum::FromString(const std::string& s) {
    if (s == "DIRECTEXPANSION") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSION;
    if (s == "DIRECTEXPANSIONSHELLANDTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE;
    if (s == "DIRECTEXPANSIONTUBEINTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE;
    if (s == "DIRECTEXPANSIONBRAZEDPLATE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE;
    if (s == "FLOODEDSHELLANDTUBE") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_FLOODEDSHELLANDTUBE;
    if (s == "SHELLANDCOIL") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_SHELLANDCOIL;
    if (s == "USERDEFINED") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEvaporatorTypeEnum::IfcEvaporatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEventTriggerTypeEnum::ToString(IfcEventTriggerTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EVENTRULE", "EVENTMESSAGE", "EVENTTIME", "EVENTCOMPLEX", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEventTriggerTypeEnum::FromString(const std::string& s) {
    if (s == "EVENTRULE") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTRULE;
    if (s == "EVENTMESSAGE") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTMESSAGE;
    if (s == "EVENTTIME") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTTIME;
    if (s == "EVENTCOMPLEX") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_EVENTCOMPLEX;
    if (s == "USERDEFINED") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEventTriggerTypeEnum::IfcEventTriggerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcEventTypeEnum::ToString(IfcEventTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STARTEVENT", "ENDEVENT", "INTERMEDIATEEVENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcEventTypeEnum::IfcEventTypeEnum IfcEventTypeEnum::FromString(const std::string& s) {
    if (s == "STARTEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_STARTEVENT;
    if (s == "ENDEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_ENDEVENT;
    if (s == "INTERMEDIATEEVENT") return ::Ifc4::IfcEventTypeEnum::IfcEventType_INTERMEDIATEEVENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcEventTypeEnum::IfcEventType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcEventTypeEnum::IfcEventType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcExternalSpatialElementTypeEnum::ToString(IfcExternalSpatialElementTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXTERNAL", "EXTERNAL_EARTH", "EXTERNAL_WATER", "EXTERNAL_FIRE", "USERDEFINED", "NOTDEFIEND" };
    return names[v];
}

IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum IfcExternalSpatialElementTypeEnum::FromString(const std::string& s) {
    if (s == "EXTERNAL") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL;
    if (s == "EXTERNAL_EARTH") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_EARTH;
    if (s == "EXTERNAL_WATER") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_WATER;
    if (s == "EXTERNAL_FIRE") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_EXTERNAL_FIRE;
    if (s == "USERDEFINED") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_USERDEFINED;
    if (s == "NOTDEFIEND") return ::Ifc4::IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementType_NOTDEFIEND;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFanTypeEnum::ToString(IfcFanTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CENTRIFUGALFORWARDCURVED", "CENTRIFUGALRADIAL", "CENTRIFUGALBACKWARDINCLINEDCURVED", "CENTRIFUGALAIRFOIL", "TUBEAXIAL", "VANEAXIAL", "PROPELLORAXIAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFanTypeEnum::IfcFanTypeEnum IfcFanTypeEnum::FromString(const std::string& s) {
    if (s == "CENTRIFUGALFORWARDCURVED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALFORWARDCURVED;
    if (s == "CENTRIFUGALRADIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALRADIAL;
    if (s == "CENTRIFUGALBACKWARDINCLINEDCURVED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED;
    if (s == "CENTRIFUGALAIRFOIL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_CENTRIFUGALAIRFOIL;
    if (s == "TUBEAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_TUBEAXIAL;
    if (s == "VANEAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_VANEAXIAL;
    if (s == "PROPELLORAXIAL") return ::Ifc4::IfcFanTypeEnum::IfcFanType_PROPELLORAXIAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFanTypeEnum::IfcFanType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFastenerTypeEnum::ToString(IfcFastenerTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GLUE", "MORTAR", "WELD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastenerTypeEnum::FromString(const std::string& s) {
    if (s == "GLUE") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_GLUE;
    if (s == "MORTAR") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_MORTAR;
    if (s == "WELD") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_WELD;
    if (s == "USERDEFINED") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFastenerTypeEnum::IfcFastenerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFilterTypeEnum::ToString(IfcFilterTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRPARTICLEFILTER", "COMPRESSEDAIRFILTER", "ODORFILTER", "OILFILTER", "STRAINER", "WATERFILTER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterTypeEnum::FromString(const std::string& s) {
    if (s == "AIRPARTICLEFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_AIRPARTICLEFILTER;
    if (s == "COMPRESSEDAIRFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_COMPRESSEDAIRFILTER;
    if (s == "ODORFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_ODORFILTER;
    if (s == "OILFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_OILFILTER;
    if (s == "STRAINER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_STRAINER;
    if (s == "WATERFILTER") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_WATERFILTER;
    if (s == "USERDEFINED") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFilterTypeEnum::IfcFilterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFireSuppressionTerminalTypeEnum::ToString(IfcFireSuppressionTerminalTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BREECHINGINLET", "FIREHYDRANT", "HOSEREEL", "SPRINKLER", "SPRINKLERDEFLECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BREECHINGINLET") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_BREECHINGINLET;
    if (s == "FIREHYDRANT") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_FIREHYDRANT;
    if (s == "HOSEREEL") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_HOSEREEL;
    if (s == "SPRINKLER") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLER;
    if (s == "SPRINKLERDEFLECTOR") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowDirectionEnum::ToString(IfcFlowDirectionEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SOURCE", "SINK", "SOURCEANDSINK", "NOTDEFINED" };
    return names[v];
}

IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcFlowDirectionEnum::FromString(const std::string& s) {
    if (s == "SOURCE") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SOURCE;
    if (s == "SINK") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SINK;
    if (s == "SOURCEANDSINK") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_SOURCEANDSINK;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowDirectionEnum::IfcFlowDirection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowInstrumentTypeEnum::ToString(IfcFlowInstrumentTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRESSUREGAUGE", "THERMOMETER", "AMMETER", "FREQUENCYMETER", "POWERFACTORMETER", "PHASEANGLEMETER", "VOLTMETER_PEAK", "VOLTMETER_RMS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentTypeEnum::FromString(const std::string& s) {
    if (s == "PRESSUREGAUGE") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PRESSUREGAUGE;
    if (s == "THERMOMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_THERMOMETER;
    if (s == "AMMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_AMMETER;
    if (s == "FREQUENCYMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_FREQUENCYMETER;
    if (s == "POWERFACTORMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_POWERFACTORMETER;
    if (s == "PHASEANGLEMETER") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_PHASEANGLEMETER;
    if (s == "VOLTMETER_PEAK") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_PEAK;
    if (s == "VOLTMETER_RMS") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_VOLTMETER_RMS;
    if (s == "USERDEFINED") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowInstrumentTypeEnum::IfcFlowInstrumentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFlowMeterTypeEnum::ToString(IfcFlowMeterTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ENERGYMETER", "GASMETER", "OILMETER", "WATERMETER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterTypeEnum::FromString(const std::string& s) {
    if (s == "ENERGYMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_ENERGYMETER;
    if (s == "GASMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_GASMETER;
    if (s == "OILMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_OILMETER;
    if (s == "WATERMETER") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_WATERMETER;
    if (s == "USERDEFINED") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFlowMeterTypeEnum::IfcFlowMeterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFootingTypeEnum::ToString(IfcFootingTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CAISSON_FOUNDATION", "FOOTING_BEAM", "PAD_FOOTING", "PILE_CAP", "STRIP_FOOTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFootingTypeEnum::IfcFootingTypeEnum IfcFootingTypeEnum::FromString(const std::string& s) {
    if (s == "CAISSON_FOUNDATION") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_CAISSON_FOUNDATION;
    if (s == "FOOTING_BEAM") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_FOOTING_BEAM;
    if (s == "PAD_FOOTING") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_PAD_FOOTING;
    if (s == "PILE_CAP") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_PILE_CAP;
    if (s == "STRIP_FOOTING") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_STRIP_FOOTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFootingTypeEnum::IfcFootingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcFurnitureTypeEnum::ToString(IfcFurnitureTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHAIR", "TABLE", "DESK", "BED", "FILECABINET", "SHELF", "SOFA", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurnitureTypeEnum::FromString(const std::string& s) {
    if (s == "CHAIR") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_CHAIR;
    if (s == "TABLE") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_TABLE;
    if (s == "DESK") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_DESK;
    if (s == "BED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_BED;
    if (s == "FILECABINET") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_FILECABINET;
    if (s == "SHELF") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_SHELF;
    if (s == "SOFA") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_SOFA;
    if (s == "USERDEFINED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcFurnitureTypeEnum::IfcFurnitureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGeographicElementTypeEnum::ToString(IfcGeographicElementTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TERRAIN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElementTypeEnum::FromString(const std::string& s) {
    if (s == "TERRAIN") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_TERRAIN;
    if (s == "USERDEFINED") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGeographicElementTypeEnum::IfcGeographicElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGeometricProjectionEnum::ToString(IfcGeometricProjectionEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRAPH_VIEW", "SKETCH_VIEW", "MODEL_VIEW", "PLAN_VIEW", "REFLECTED_PLAN_VIEW", "SECTION_VIEW", "ELEVATION_VIEW", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricProjectionEnum::FromString(const std::string& s) {
    if (s == "GRAPH_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_GRAPH_VIEW;
    if (s == "SKETCH_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_SKETCH_VIEW;
    if (s == "MODEL_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_MODEL_VIEW;
    if (s == "PLAN_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_PLAN_VIEW;
    if (s == "REFLECTED_PLAN_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_REFLECTED_PLAN_VIEW;
    if (s == "SECTION_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_SECTION_VIEW;
    if (s == "ELEVATION_VIEW") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_ELEVATION_VIEW;
    if (s == "USERDEFINED") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGeometricProjectionEnum::IfcGeometricProjection_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGlobalOrLocalEnum::ToString(IfcGlobalOrLocalEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GLOBAL_COORDS", "LOCAL_COORDS" };
    return names[v];
}

IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcGlobalOrLocalEnum::FromString(const std::string& s) {
    if (s == "GLOBAL_COORDS") return ::Ifc4::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_GLOBAL_COORDS;
    if (s == "LOCAL_COORDS") return ::Ifc4::IfcGlobalOrLocalEnum::IfcGlobalOrLocal_LOCAL_COORDS;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcGridTypeEnum::ToString(IfcGridTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RECTANGULAR", "RADIAL", "TRIANGULAR", "IRREGULAR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcGridTypeEnum::IfcGridTypeEnum IfcGridTypeEnum::FromString(const std::string& s) {
    if (s == "RECTANGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_RECTANGULAR;
    if (s == "RADIAL") return ::Ifc4::IfcGridTypeEnum::IfcGridType_RADIAL;
    if (s == "TRIANGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_TRIANGULAR;
    if (s == "IRREGULAR") return ::Ifc4::IfcGridTypeEnum::IfcGridType_IRREGULAR;
    if (s == "USERDEFINED") return ::Ifc4::IfcGridTypeEnum::IfcGridType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcGridTypeEnum::IfcGridType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHeatExchangerTypeEnum::ToString(IfcHeatExchangerTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLATE", "SHELLANDTUBE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerTypeEnum::FromString(const std::string& s) {
    if (s == "PLATE") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_PLATE;
    if (s == "SHELLANDTUBE") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_SHELLANDTUBE;
    if (s == "USERDEFINED") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcHeatExchangerTypeEnum::IfcHeatExchangerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcHumidifierTypeEnum::ToString(IfcHumidifierTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STEAMINJECTION", "ADIABATICAIRWASHER", "ADIABATICPAN", "ADIABATICWETTEDELEMENT", "ADIABATICATOMIZING", "ADIABATICULTRASONIC", "ADIABATICRIGIDMEDIA", "ADIABATICCOMPRESSEDAIRNOZZLE", "ASSISTEDELECTRIC", "ASSISTEDNATURALGAS", "ASSISTEDPROPANE", "ASSISTEDBUTANE", "ASSISTEDSTEAM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierTypeEnum::FromString(const std::string& s) {
    if (s == "STEAMINJECTION") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_STEAMINJECTION;
    if (s == "ADIABATICAIRWASHER") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICAIRWASHER;
    if (s == "ADIABATICPAN") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICPAN;
    if (s == "ADIABATICWETTEDELEMENT") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICWETTEDELEMENT;
    if (s == "ADIABATICATOMIZING") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICATOMIZING;
    if (s == "ADIABATICULTRASONIC") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICULTRASONIC;
    if (s == "ADIABATICRIGIDMEDIA") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICRIGIDMEDIA;
    if (s == "ADIABATICCOMPRESSEDAIRNOZZLE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE;
    if (s == "ASSISTEDELECTRIC") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDELECTRIC;
    if (s == "ASSISTEDNATURALGAS") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDNATURALGAS;
    if (s == "ASSISTEDPROPANE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDPROPANE;
    if (s == "ASSISTEDBUTANE") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDBUTANE;
    if (s == "ASSISTEDSTEAM") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_ASSISTEDSTEAM;
    if (s == "USERDEFINED") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcHumidifierTypeEnum::IfcHumidifierType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInterceptorTypeEnum::ToString(IfcInterceptorTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CYCLONIC", "GREASE", "OIL", "PETROL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptorTypeEnum::FromString(const std::string& s) {
    if (s == "CYCLONIC") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_CYCLONIC;
    if (s == "GREASE") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_GREASE;
    if (s == "OIL") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_OIL;
    if (s == "PETROL") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_PETROL;
    if (s == "USERDEFINED") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInterceptorTypeEnum::IfcInterceptorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInternalOrExternalEnum::ToString(IfcInternalOrExternalEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "INTERNAL", "EXTERNAL", "EXTERNAL_EARTH", "EXTERNAL_WATER", "EXTERNAL_FIRE", "NOTDEFINED" };
    return names[v];
}

IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcInternalOrExternalEnum::FromString(const std::string& s) {
    if (s == "INTERNAL") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL;
    if (s == "EXTERNAL_EARTH") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_EARTH;
    if (s == "EXTERNAL_WATER") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_WATER;
    if (s == "EXTERNAL_FIRE") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_EXTERNAL_FIRE;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInternalOrExternalEnum::IfcInternalOrExternal_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcInventoryTypeEnum::ToString(IfcInventoryTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSETINVENTORY", "SPACEINVENTORY", "FURNITUREINVENTORY", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventoryTypeEnum::FromString(const std::string& s) {
    if (s == "ASSETINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_ASSETINVENTORY;
    if (s == "SPACEINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_SPACEINVENTORY;
    if (s == "FURNITUREINVENTORY") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_FURNITUREINVENTORY;
    if (s == "USERDEFINED") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcInventoryTypeEnum::IfcInventoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcJunctionBoxTypeEnum::ToString(IfcJunctionBoxTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DATA", "POWER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxTypeEnum::FromString(const std::string& s) {
    if (s == "DATA") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_DATA;
    if (s == "POWER") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_POWER;
    if (s == "USERDEFINED") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcJunctionBoxTypeEnum::IfcJunctionBoxType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcKnotType::ToString(IfcKnotType v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNIFORM_KNOTS", "QUASI_UNIFORM_KNOTS", "PIECEWISE_BEZIER_KNOTS", "UNSPECIFIED" };
    return names[v];
}

IfcKnotType::IfcKnotType IfcKnotType::FromString(const std::string& s) {
    if (s == "UNIFORM_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_UNIFORM_KNOTS;
    if (s == "QUASI_UNIFORM_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_QUASI_UNIFORM_KNOTS;
    if (s == "PIECEWISE_BEZIER_KNOTS") return ::Ifc4::IfcKnotType::IfcKnotType_PIECEWISE_BEZIER_KNOTS;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcKnotType::IfcKnotType_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLaborResourceTypeEnum::ToString(IfcLaborResourceTypeEnum v) {
    if ( v < 0 || v >= 21 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADMINISTRATION", "CARPENTRY", "CLEANING", "CONCRETE", "DRYWALL", "ELECTRIC", "FINISHING", "FLOORING", "GENERAL", "HVAC", "LANDSCAPING", "MASONRY", "PAINTING", "PAVING", "PLUMBING", "ROOFING", "SITEGRADING", "STEELWORK", "SURVEYING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResourceTypeEnum::FromString(const std::string& s) {
    if (s == "ADMINISTRATION") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ADMINISTRATION;
    if (s == "CARPENTRY") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CARPENTRY;
    if (s == "CLEANING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CLEANING;
    if (s == "CONCRETE") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_CONCRETE;
    if (s == "DRYWALL") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_DRYWALL;
    if (s == "ELECTRIC") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ELECTRIC;
    if (s == "FINISHING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_FINISHING;
    if (s == "FLOORING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_FLOORING;
    if (s == "GENERAL") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_GENERAL;
    if (s == "HVAC") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_HVAC;
    if (s == "LANDSCAPING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_LANDSCAPING;
    if (s == "MASONRY") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_MASONRY;
    if (s == "PAINTING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PAINTING;
    if (s == "PAVING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PAVING;
    if (s == "PLUMBING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_PLUMBING;
    if (s == "ROOFING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_ROOFING;
    if (s == "SITEGRADING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_SITEGRADING;
    if (s == "STEELWORK") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_STEELWORK;
    if (s == "SURVEYING") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_SURVEYING;
    if (s == "USERDEFINED") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLaborResourceTypeEnum::IfcLaborResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLampTypeEnum::ToString(IfcLampTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HALOGEN", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LED", "METALHALIDE", "OLED", "TUNGSTENFILAMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLampTypeEnum::IfcLampTypeEnum IfcLampTypeEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_FLUORESCENT;
    if (s == "HALOGEN") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HALOGEN;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc4::IfcLampTypeEnum::IfcLampType_HIGHPRESSURESODIUM;
    if (s == "LED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_LED;
    if (s == "METALHALIDE") return ::Ifc4::IfcLampTypeEnum::IfcLampType_METALHALIDE;
    if (s == "OLED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_OLED;
    if (s == "TUNGSTENFILAMENT") return ::Ifc4::IfcLampTypeEnum::IfcLampType_TUNGSTENFILAMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLampTypeEnum::IfcLampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLayerSetDirectionEnum::ToString(IfcLayerSetDirectionEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AXIS1", "AXIS2", "AXIS3" };
    return names[v];
}

IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcLayerSetDirectionEnum::FromString(const std::string& s) {
    if (s == "AXIS1") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS1;
    if (s == "AXIS2") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS2;
    if (s == "AXIS3") return ::Ifc4::IfcLayerSetDirectionEnum::IfcLayerSetDirection_AXIS3;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightDistributionCurveEnum::ToString(IfcLightDistributionCurveEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "TYPE_A", "TYPE_B", "TYPE_C", "NOTDEFINED" };
    return names[v];
}

IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightDistributionCurveEnum::FromString(const std::string& s) {
    if (s == "TYPE_A") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_A;
    if (s == "TYPE_B") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_B;
    if (s == "TYPE_C") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_TYPE_C;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightDistributionCurveEnum::IfcLightDistributionCurve_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightEmissionSourceEnum::ToString(IfcLightEmissionSourceEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPACTFLUORESCENT", "FLUORESCENT", "HIGHPRESSUREMERCURY", "HIGHPRESSURESODIUM", "LIGHTEMITTINGDIODE", "LOWPRESSURESODIUM", "LOWVOLTAGEHALOGEN", "MAINVOLTAGEHALOGEN", "METALHALIDE", "TUNGSTENFILAMENT", "NOTDEFINED" };
    return names[v];
}

IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightEmissionSourceEnum::FromString(const std::string& s) {
    if (s == "COMPACTFLUORESCENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_COMPACTFLUORESCENT;
    if (s == "FLUORESCENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_FLUORESCENT;
    if (s == "HIGHPRESSUREMERCURY") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSUREMERCURY;
    if (s == "HIGHPRESSURESODIUM") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_HIGHPRESSURESODIUM;
    if (s == "LIGHTEMITTINGDIODE") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LIGHTEMITTINGDIODE;
    if (s == "LOWPRESSURESODIUM") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWPRESSURESODIUM;
    if (s == "LOWVOLTAGEHALOGEN") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_LOWVOLTAGEHALOGEN;
    if (s == "MAINVOLTAGEHALOGEN") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_MAINVOLTAGEHALOGEN;
    if (s == "METALHALIDE") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_METALHALIDE;
    if (s == "TUNGSTENFILAMENT") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_TUNGSTENFILAMENT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightEmissionSourceEnum::IfcLightEmissionSource_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLightFixtureTypeEnum::ToString(IfcLightFixtureTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POINTSOURCE", "DIRECTIONSOURCE", "SECURITYLIGHTING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureTypeEnum::FromString(const std::string& s) {
    if (s == "POINTSOURCE") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_POINTSOURCE;
    if (s == "DIRECTIONSOURCE") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_DIRECTIONSOURCE;
    if (s == "SECURITYLIGHTING") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_SECURITYLIGHTING;
    if (s == "USERDEFINED") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLightFixtureTypeEnum::IfcLightFixtureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLoadGroupTypeEnum::ToString(IfcLoadGroupTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOAD_GROUP", "LOAD_CASE", "LOAD_COMBINATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcLoadGroupTypeEnum::FromString(const std::string& s) {
    if (s == "LOAD_GROUP") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_GROUP;
    if (s == "LOAD_CASE") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_CASE;
    if (s == "LOAD_COMBINATION") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_LOAD_COMBINATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcLoadGroupTypeEnum::IfcLoadGroupType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcLogicalOperatorEnum::ToString(IfcLogicalOperatorEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LOGICALAND", "LOGICALOR", "LOGICALXOR", "LOGICALNOTAND", "LOGICALNOTOR" };
    return names[v];
}

IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcLogicalOperatorEnum::FromString(const std::string& s) {
    if (s == "LOGICALAND") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALAND;
    if (s == "LOGICALOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALOR;
    if (s == "LOGICALXOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALXOR;
    if (s == "LOGICALNOTAND") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALNOTAND;
    if (s == "LOGICALNOTOR") return ::Ifc4::IfcLogicalOperatorEnum::IfcLogicalOperator_LOGICALNOTOR;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMechanicalFastenerTypeEnum::ToString(IfcMechanicalFastenerTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORBOLT", "BOLT", "DOWEL", "NAIL", "NAILPLATE", "RIVET", "SCREW", "SHEARCONNECTOR", "STAPLE", "STUDSHEARCONNECTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastenerTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORBOLT") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_ANCHORBOLT;
    if (s == "BOLT") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_BOLT;
    if (s == "DOWEL") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_DOWEL;
    if (s == "NAIL") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NAIL;
    if (s == "NAILPLATE") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NAILPLATE;
    if (s == "RIVET") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_RIVET;
    if (s == "SCREW") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_SCREW;
    if (s == "SHEARCONNECTOR") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_SHEARCONNECTOR;
    if (s == "STAPLE") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_STAPLE;
    if (s == "STUDSHEARCONNECTOR") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_STUDSHEARCONNECTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMedicalDeviceTypeEnum::ToString(IfcMedicalDeviceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRSTATION", "FEEDAIRUNIT", "OXYGENGENERATOR", "OXYGENPLANT", "VACUUMSTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "AIRSTATION") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_AIRSTATION;
    if (s == "FEEDAIRUNIT") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_FEEDAIRUNIT;
    if (s == "OXYGENGENERATOR") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_OXYGENGENERATOR;
    if (s == "OXYGENPLANT") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_OXYGENPLANT;
    if (s == "VACUUMSTATION") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_VACUUMSTATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMedicalDeviceTypeEnum::IfcMedicalDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMemberTypeEnum::ToString(IfcMemberTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BRACE", "CHORD", "COLLAR", "MEMBER", "MULLION", "PLATE", "POST", "PURLIN", "RAFTER", "STRINGER", "STRUT", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BRACE") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_BRACE;
    if (s == "CHORD") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_CHORD;
    if (s == "COLLAR") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_COLLAR;
    if (s == "MEMBER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_MEMBER;
    if (s == "MULLION") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_MULLION;
    if (s == "PLATE") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_PLATE;
    if (s == "POST") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_POST;
    if (s == "PURLIN") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_PURLIN;
    if (s == "RAFTER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_RAFTER;
    if (s == "STRINGER") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STRINGER;
    if (s == "STRUT") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STRUT;
    if (s == "STUD") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_STUD;
    if (s == "USERDEFINED") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMemberTypeEnum::IfcMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcMotorConnectionTypeEnum::ToString(IfcMotorConnectionTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BELTDRIVE", "COUPLING", "DIRECTDRIVE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionTypeEnum::FromString(const std::string& s) {
    if (s == "BELTDRIVE") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_BELTDRIVE;
    if (s == "COUPLING") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_COUPLING;
    if (s == "DIRECTDRIVE") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_DIRECTDRIVE;
    if (s == "USERDEFINED") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcMotorConnectionTypeEnum::IfcMotorConnectionType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcNullStyle::ToString(IfcNullStyle v) {
    if ( v < 0 || v >= 1 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "NULL" };
    return names[v];
}

IfcNullStyle::IfcNullStyle IfcNullStyle::FromString(const std::string& s) {
    if (s == "NULL") return ::Ifc4::IfcNullStyle::IfcNullStyle_NULL;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectTypeEnum::ToString(IfcObjectTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PRODUCT", "PROCESS", "CONTROL", "RESOURCE", "ACTOR", "GROUP", "PROJECT", "NOTDEFINED" };
    return names[v];
}

IfcObjectTypeEnum::IfcObjectTypeEnum IfcObjectTypeEnum::FromString(const std::string& s) {
    if (s == "PRODUCT") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PRODUCT;
    if (s == "PROCESS") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PROCESS;
    if (s == "CONTROL") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_CONTROL;
    if (s == "RESOURCE") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_RESOURCE;
    if (s == "ACTOR") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_ACTOR;
    if (s == "GROUP") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_GROUP;
    if (s == "PROJECT") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_PROJECT;
    if (s == "NOTDEFINED") return ::Ifc4::IfcObjectTypeEnum::IfcObjectType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcObjectiveEnum::ToString(IfcObjectiveEnum v) {
    if ( v < 0 || v >= 13 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CODECOMPLIANCE", "CODEWAIVER", "DESIGNINTENT", "EXTERNAL", "HEALTHANDSAFETY", "MERGECONFLICT", "MODELVIEW", "PARAMETER", "REQUIREMENT", "SPECIFICATION", "TRIGGERCONDITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcObjectiveEnum::IfcObjectiveEnum IfcObjectiveEnum::FromString(const std::string& s) {
    if (s == "CODECOMPLIANCE") return ::Ifc4::IfcObjectiveEnum::IfcObjective_CODECOMPLIANCE;
    if (s == "CODEWAIVER") return ::Ifc4::IfcObjectiveEnum::IfcObjective_CODEWAIVER;
    if (s == "DESIGNINTENT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_DESIGNINTENT;
    if (s == "EXTERNAL") return ::Ifc4::IfcObjectiveEnum::IfcObjective_EXTERNAL;
    if (s == "HEALTHANDSAFETY") return ::Ifc4::IfcObjectiveEnum::IfcObjective_HEALTHANDSAFETY;
    if (s == "MERGECONFLICT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_MERGECONFLICT;
    if (s == "MODELVIEW") return ::Ifc4::IfcObjectiveEnum::IfcObjective_MODELVIEW;
    if (s == "PARAMETER") return ::Ifc4::IfcObjectiveEnum::IfcObjective_PARAMETER;
    if (s == "REQUIREMENT") return ::Ifc4::IfcObjectiveEnum::IfcObjective_REQUIREMENT;
    if (s == "SPECIFICATION") return ::Ifc4::IfcObjectiveEnum::IfcObjective_SPECIFICATION;
    if (s == "TRIGGERCONDITION") return ::Ifc4::IfcObjectiveEnum::IfcObjective_TRIGGERCONDITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcObjectiveEnum::IfcObjective_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcObjectiveEnum::IfcObjective_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOccupantTypeEnum::ToString(IfcOccupantTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ASSIGNEE", "ASSIGNOR", "LESSEE", "LESSOR", "LETTINGAGENT", "OWNER", "TENANT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupantTypeEnum::FromString(const std::string& s) {
    if (s == "ASSIGNEE") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNEE;
    if (s == "ASSIGNOR") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_ASSIGNOR;
    if (s == "LESSEE") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LESSEE;
    if (s == "LESSOR") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LESSOR;
    if (s == "LETTINGAGENT") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_LETTINGAGENT;
    if (s == "OWNER") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_OWNER;
    if (s == "TENANT") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_TENANT;
    if (s == "USERDEFINED") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOccupantTypeEnum::IfcOccupantType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOpeningElementTypeEnum::ToString(IfcOpeningElementTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "OPENING", "RECESS", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum IfcOpeningElementTypeEnum::FromString(const std::string& s) {
    if (s == "OPENING") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_OPENING;
    if (s == "RECESS") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_RECESS;
    if (s == "USERDEFINED") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOpeningElementTypeEnum::IfcOpeningElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcOutletTypeEnum::ToString(IfcOutletTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AUDIOVISUALOUTLET", "COMMUNICATIONSOUTLET", "POWEROUTLET", "DATAOUTLET", "TELEPHONEOUTLET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletTypeEnum::FromString(const std::string& s) {
    if (s == "AUDIOVISUALOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_AUDIOVISUALOUTLET;
    if (s == "COMMUNICATIONSOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_COMMUNICATIONSOUTLET;
    if (s == "POWEROUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_POWEROUTLET;
    if (s == "DATAOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_DATAOUTLET;
    if (s == "TELEPHONEOUTLET") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_TELEPHONEOUTLET;
    if (s == "USERDEFINED") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcOutletTypeEnum::IfcOutletType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPerformanceHistoryTypeEnum::ToString(IfcPerformanceHistoryTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum IfcPerformanceHistoryTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPermeableCoveringOperationEnum::ToString(IfcPermeableCoveringOperationEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "GRILL", "LOUVER", "SCREEN", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringOperationEnum::FromString(const std::string& s) {
    if (s == "GRILL") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_GRILL;
    if (s == "LOUVER") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_LOUVER;
    if (s == "SCREEN") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_SCREEN;
    if (s == "USERDEFINED") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPermitTypeEnum::ToString(IfcPermitTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACCESS", "BUILDING", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPermitTypeEnum::IfcPermitTypeEnum IfcPermitTypeEnum::FromString(const std::string& s) {
    if (s == "ACCESS") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_ACCESS;
    if (s == "BUILDING") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_BUILDING;
    if (s == "WORK") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_WORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPermitTypeEnum::IfcPermitType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPhysicalOrVirtualEnum::ToString(IfcPhysicalOrVirtualEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PHYSICAL", "VIRTUAL", "NOTDEFINED" };
    return names[v];
}

IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcPhysicalOrVirtualEnum::FromString(const std::string& s) {
    if (s == "PHYSICAL") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_PHYSICAL;
    if (s == "VIRTUAL") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_VIRTUAL;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtual_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileConstructionEnum::ToString(IfcPileConstructionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CAST_IN_PLACE", "COMPOSITE", "PRECAST_CONCRETE", "PREFAB_STEEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileConstructionEnum::IfcPileConstructionEnum IfcPileConstructionEnum::FromString(const std::string& s) {
    if (s == "CAST_IN_PLACE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_CAST_IN_PLACE;
    if (s == "COMPOSITE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_COMPOSITE;
    if (s == "PRECAST_CONCRETE") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_PRECAST_CONCRETE;
    if (s == "PREFAB_STEEL") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_PREFAB_STEEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPileConstructionEnum::IfcPileConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPileTypeEnum::ToString(IfcPileTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BORED", "DRIVEN", "JETGROUTING", "COHESION", "FRICTION", "SUPPORT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPileTypeEnum::IfcPileTypeEnum IfcPileTypeEnum::FromString(const std::string& s) {
    if (s == "BORED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_BORED;
    if (s == "DRIVEN") return ::Ifc4::IfcPileTypeEnum::IfcPileType_DRIVEN;
    if (s == "JETGROUTING") return ::Ifc4::IfcPileTypeEnum::IfcPileType_JETGROUTING;
    if (s == "COHESION") return ::Ifc4::IfcPileTypeEnum::IfcPileType_COHESION;
    if (s == "FRICTION") return ::Ifc4::IfcPileTypeEnum::IfcPileType_FRICTION;
    if (s == "SUPPORT") return ::Ifc4::IfcPileTypeEnum::IfcPileType_SUPPORT;
    if (s == "USERDEFINED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPileTypeEnum::IfcPileType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeFittingTypeEnum::ToString(IfcPipeFittingTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BEND", "CONNECTOR", "ENTRY", "EXIT", "JUNCTION", "OBSTRUCTION", "TRANSITION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingTypeEnum::FromString(const std::string& s) {
    if (s == "BEND") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_BEND;
    if (s == "CONNECTOR") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_CONNECTOR;
    if (s == "ENTRY") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_ENTRY;
    if (s == "EXIT") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_EXIT;
    if (s == "JUNCTION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_JUNCTION;
    if (s == "OBSTRUCTION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_OBSTRUCTION;
    if (s == "TRANSITION") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_TRANSITION;
    if (s == "USERDEFINED") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPipeFittingTypeEnum::IfcPipeFittingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPipeSegmentTypeEnum::ToString(IfcPipeSegmentTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CULVERT", "FLEXIBLESEGMENT", "RIGIDSEGMENT", "GUTTER", "SPOOL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentTypeEnum::FromString(const std::string& s) {
    if (s == "CULVERT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_CULVERT;
    if (s == "FLEXIBLESEGMENT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_FLEXIBLESEGMENT;
    if (s == "RIGIDSEGMENT") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_RIGIDSEGMENT;
    if (s == "GUTTER") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_GUTTER;
    if (s == "SPOOL") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_SPOOL;
    if (s == "USERDEFINED") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPipeSegmentTypeEnum::IfcPipeSegmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPlateTypeEnum::ToString(IfcPlateTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURTAIN_PANEL", "SHEET", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateTypeEnum::FromString(const std::string& s) {
    if (s == "CURTAIN_PANEL") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_CURTAIN_PANEL;
    if (s == "SHEET") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_SHEET;
    if (s == "USERDEFINED") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPlateTypeEnum::IfcPlateType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProcedureTypeEnum::ToString(IfcProcedureTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ADVICE_CAUTION", "ADVICE_NOTE", "ADVICE_WARNING", "CALIBRATION", "DIAGNOSTIC", "SHUTDOWN", "STARTUP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedureTypeEnum::FromString(const std::string& s) {
    if (s == "ADVICE_CAUTION") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_CAUTION;
    if (s == "ADVICE_NOTE") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_NOTE;
    if (s == "ADVICE_WARNING") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_ADVICE_WARNING;
    if (s == "CALIBRATION") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_CALIBRATION;
    if (s == "DIAGNOSTIC") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_DIAGNOSTIC;
    if (s == "SHUTDOWN") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_SHUTDOWN;
    if (s == "STARTUP") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_STARTUP;
    if (s == "USERDEFINED") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProcedureTypeEnum::IfcProcedureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProfileTypeEnum::ToString(IfcProfileTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURVE", "AREA" };
    return names[v];
}

IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileTypeEnum::FromString(const std::string& s) {
    if (s == "CURVE") return ::Ifc4::IfcProfileTypeEnum::IfcProfileType_CURVE;
    if (s == "AREA") return ::Ifc4::IfcProfileTypeEnum::IfcProfileType_AREA;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectOrderTypeEnum::ToString(IfcProjectOrderTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CHANGEORDER", "MAINTENANCEWORKORDER", "MOVEORDER", "PURCHASEORDER", "WORKORDER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrderTypeEnum::FromString(const std::string& s) {
    if (s == "CHANGEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_CHANGEORDER;
    if (s == "MAINTENANCEWORKORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_MAINTENANCEWORKORDER;
    if (s == "MOVEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_MOVEORDER;
    if (s == "PURCHASEORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_PURCHASEORDER;
    if (s == "WORKORDER") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_WORKORDER;
    if (s == "USERDEFINED") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProjectOrderTypeEnum::IfcProjectOrderType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectedOrTrueLengthEnum::ToString(IfcProjectedOrTrueLengthEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PROJECTED_LENGTH", "TRUE_LENGTH" };
    return names[v];
}

IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcProjectedOrTrueLengthEnum::FromString(const std::string& s) {
    if (s == "PROJECTED_LENGTH") return ::Ifc4::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_PROJECTED_LENGTH;
    if (s == "TRUE_LENGTH") return ::Ifc4::IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLength_TRUE_LENGTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProjectionElementTypeEnum::ToString(IfcProjectionElementTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum IfcProjectionElementTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcProjectionElementTypeEnum::IfcProjectionElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProjectionElementTypeEnum::IfcProjectionElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPropertySetTemplateTypeEnum::ToString(IfcPropertySetTemplateTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PSET_TYPEDRIVENONLY", "PSET_TYPEDRIVENOVERRIDE", "PSET_OCCURRENCEDRIVEN", "PSET_PERFORMANCEDRIVEN", "QTO_TYPEDRIVENONLY", "QTO_TYPEDRIVENOVERRIDE", "QTO_OCCURRENCEDRIVEN", "NOTDEFINED" };
    return names[v];
}

IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum IfcPropertySetTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "PSET_TYPEDRIVENONLY") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_TYPEDRIVENONLY;
    if (s == "PSET_TYPEDRIVENOVERRIDE") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_TYPEDRIVENOVERRIDE;
    if (s == "PSET_OCCURRENCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_OCCURRENCEDRIVEN;
    if (s == "PSET_PERFORMANCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_PSET_PERFORMANCEDRIVEN;
    if (s == "QTO_TYPEDRIVENONLY") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_TYPEDRIVENONLY;
    if (s == "QTO_TYPEDRIVENOVERRIDE") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_TYPEDRIVENOVERRIDE;
    if (s == "QTO_OCCURRENCEDRIVEN") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_QTO_OCCURRENCEDRIVEN;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(IfcProtectiveDeviceTrippingUnitTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELECTRONIC", "ELECTROMAGNETIC", "RESIDUALCURRENT", "THERMAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(const std::string& s) {
    if (s == "ELECTRONIC") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_ELECTRONIC;
    if (s == "ELECTROMAGNETIC") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_ELECTROMAGNETIC;
    if (s == "RESIDUALCURRENT") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_RESIDUALCURRENT;
    if (s == "THERMAL") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_THERMAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcProtectiveDeviceTypeEnum::ToString(IfcProtectiveDeviceTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CIRCUITBREAKER", "EARTHLEAKAGECIRCUITBREAKER", "EARTHINGSWITCH", "FUSEDISCONNECTOR", "RESIDUALCURRENTCIRCUITBREAKER", "RESIDUALCURRENTSWITCH", "VARISTOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_CIRCUITBREAKER;
    if (s == "EARTHLEAKAGECIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHLEAKAGECIRCUITBREAKER;
    if (s == "EARTHINGSWITCH") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_EARTHINGSWITCH;
    if (s == "FUSEDISCONNECTOR") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_FUSEDISCONNECTOR;
    if (s == "RESIDUALCURRENTCIRCUITBREAKER") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER;
    if (s == "RESIDUALCURRENTSWITCH") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH;
    if (s == "VARISTOR") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_VARISTOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcPumpTypeEnum::ToString(IfcPumpTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CIRCULATOR", "ENDSUCTION", "SPLITCASE", "SUBMERSIBLEPUMP", "SUMPPUMP", "VERTICALINLINE", "VERTICALTURBINE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpTypeEnum::FromString(const std::string& s) {
    if (s == "CIRCULATOR") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_CIRCULATOR;
    if (s == "ENDSUCTION") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_ENDSUCTION;
    if (s == "SPLITCASE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SPLITCASE;
    if (s == "SUBMERSIBLEPUMP") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SUBMERSIBLEPUMP;
    if (s == "SUMPPUMP") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_SUMPPUMP;
    if (s == "VERTICALINLINE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_VERTICALINLINE;
    if (s == "VERTICALTURBINE") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_VERTICALTURBINE;
    if (s == "USERDEFINED") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcPumpTypeEnum::IfcPumpType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRailingTypeEnum::ToString(IfcRailingTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "HANDRAIL", "GUARDRAIL", "BALUSTRADE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingTypeEnum::FromString(const std::string& s) {
    if (s == "HANDRAIL") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_HANDRAIL;
    if (s == "GUARDRAIL") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_GUARDRAIL;
    if (s == "BALUSTRADE") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_BALUSTRADE;
    if (s == "USERDEFINED") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRailingTypeEnum::IfcRailingType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampFlightTypeEnum::ToString(IfcRampFlightTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "SPIRAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_STRAIGHT;
    if (s == "SPIRAL") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_SPIRAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRampFlightTypeEnum::IfcRampFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRampTypeEnum::ToString(IfcRampTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_RAMP", "TWO_STRAIGHT_RUN_RAMP", "QUARTER_TURN_RAMP", "TWO_QUARTER_TURN_RAMP", "HALF_TURN_RAMP", "SPIRAL_RAMP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRampTypeEnum::IfcRampTypeEnum IfcRampTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_STRAIGHT_RUN_RAMP;
    if (s == "TWO_STRAIGHT_RUN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_TWO_STRAIGHT_RUN_RAMP;
    if (s == "QUARTER_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_QUARTER_TURN_RAMP;
    if (s == "TWO_QUARTER_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_TWO_QUARTER_TURN_RAMP;
    if (s == "HALF_TURN_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_HALF_TURN_RAMP;
    if (s == "SPIRAL_RAMP") return ::Ifc4::IfcRampTypeEnum::IfcRampType_SPIRAL_RAMP;
    if (s == "USERDEFINED") return ::Ifc4::IfcRampTypeEnum::IfcRampType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRampTypeEnum::IfcRampType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRecurrenceTypeEnum::ToString(IfcRecurrenceTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DAILY", "WEEKLY", "MONTHLY_BY_DAY_OF_MONTH", "MONTHLY_BY_POSITION", "BY_DAY_COUNT", "BY_WEEKDAY_COUNT", "YEARLY_BY_DAY_OF_MONTH", "YEARLY_BY_POSITION" };
    return names[v];
}

IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum IfcRecurrenceTypeEnum::FromString(const std::string& s) {
    if (s == "DAILY") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_DAILY;
    if (s == "WEEKLY") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_WEEKLY;
    if (s == "MONTHLY_BY_DAY_OF_MONTH") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_MONTHLY_BY_DAY_OF_MONTH;
    if (s == "MONTHLY_BY_POSITION") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_MONTHLY_BY_POSITION;
    if (s == "BY_DAY_COUNT") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_BY_DAY_COUNT;
    if (s == "BY_WEEKDAY_COUNT") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_BY_WEEKDAY_COUNT;
    if (s == "YEARLY_BY_DAY_OF_MONTH") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_YEARLY_BY_DAY_OF_MONTH;
    if (s == "YEARLY_BY_POSITION") return ::Ifc4::IfcRecurrenceTypeEnum::IfcRecurrenceType_YEARLY_BY_POSITION;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReflectanceMethodEnum::ToString(IfcReflectanceMethodEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BLINN", "FLAT", "GLASS", "MATT", "METAL", "MIRROR", "PHONG", "PLASTIC", "STRAUSS", "NOTDEFINED" };
    return names[v];
}

IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcReflectanceMethodEnum::FromString(const std::string& s) {
    if (s == "BLINN") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_BLINN;
    if (s == "FLAT") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_FLAT;
    if (s == "GLASS") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_GLASS;
    if (s == "MATT") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_MATT;
    if (s == "METAL") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_METAL;
    if (s == "MIRROR") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_MIRROR;
    if (s == "PHONG") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_PHONG;
    if (s == "PLASTIC") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_PLASTIC;
    if (s == "STRAUSS") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_STRAUSS;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReflectanceMethodEnum::IfcReflectanceMethod_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarRoleEnum::ToString(IfcReinforcingBarRoleEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MAIN", "SHEAR", "LIGATURE", "STUD", "PUNCHING", "EDGE", "RING", "ANCHORING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcReinforcingBarRoleEnum::FromString(const std::string& s) {
    if (s == "MAIN") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_MAIN;
    if (s == "SHEAR") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_SHEAR;
    if (s == "LIGATURE") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_LIGATURE;
    if (s == "STUD") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_STUD;
    if (s == "PUNCHING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_PUNCHING;
    if (s == "EDGE") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_EDGE;
    if (s == "RING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_RING;
    if (s == "ANCHORING") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_ANCHORING;
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingBarRoleEnum::IfcReinforcingBarRole_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarSurfaceEnum::ToString(IfcReinforcingBarSurfaceEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PLAIN", "TEXTURED" };
    return names[v];
}

IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBarSurfaceEnum::FromString(const std::string& s) {
    if (s == "PLAIN") return ::Ifc4::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_PLAIN;
    if (s == "TEXTURED") return ::Ifc4::IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurface_TEXTURED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingBarTypeEnum::ToString(IfcReinforcingBarTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ANCHORING", "EDGE", "LIGATURE", "MAIN", "PUNCHING", "RING", "SHEAR", "STUD", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBarTypeEnum::FromString(const std::string& s) {
    if (s == "ANCHORING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_ANCHORING;
    if (s == "EDGE") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_EDGE;
    if (s == "LIGATURE") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_LIGATURE;
    if (s == "MAIN") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_MAIN;
    if (s == "PUNCHING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_PUNCHING;
    if (s == "RING") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_RING;
    if (s == "SHEAR") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_SHEAR;
    if (s == "STUD") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_STUD;
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingBarTypeEnum::IfcReinforcingBarType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcReinforcingMeshTypeEnum::ToString(IfcReinforcingMeshTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMeshTypeEnum::FromString(const std::string& s) {
    if (s == "USERDEFINED") return ::Ifc4::IfcReinforcingMeshTypeEnum::IfcReinforcingMeshType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcReinforcingMeshTypeEnum::IfcReinforcingMeshType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoleEnum::ToString(IfcRoleEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SUPPLIER", "MANUFACTURER", "CONTRACTOR", "SUBCONTRACTOR", "ARCHITECT", "STRUCTURALENGINEER", "COSTENGINEER", "CLIENT", "BUILDINGOWNER", "BUILDINGOPERATOR", "MECHANICALENGINEER", "ELECTRICALENGINEER", "PROJECTMANAGER", "FACILITIESMANAGER", "CIVILENGINEER", "COMMISSIONINGENGINEER", "ENGINEER", "OWNER", "CONSULTANT", "CONSTRUCTIONMANAGER", "FIELDCONSTRUCTIONMANAGER", "RESELLER", "USERDEFINED" };
    return names[v];
}

IfcRoleEnum::IfcRoleEnum IfcRoleEnum::FromString(const std::string& s) {
    if (s == "SUPPLIER") return ::Ifc4::IfcRoleEnum::IfcRole_SUPPLIER;
    if (s == "MANUFACTURER") return ::Ifc4::IfcRoleEnum::IfcRole_MANUFACTURER;
    if (s == "CONTRACTOR") return ::Ifc4::IfcRoleEnum::IfcRole_CONTRACTOR;
    if (s == "SUBCONTRACTOR") return ::Ifc4::IfcRoleEnum::IfcRole_SUBCONTRACTOR;
    if (s == "ARCHITECT") return ::Ifc4::IfcRoleEnum::IfcRole_ARCHITECT;
    if (s == "STRUCTURALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_STRUCTURALENGINEER;
    if (s == "COSTENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_COSTENGINEER;
    if (s == "CLIENT") return ::Ifc4::IfcRoleEnum::IfcRole_CLIENT;
    if (s == "BUILDINGOWNER") return ::Ifc4::IfcRoleEnum::IfcRole_BUILDINGOWNER;
    if (s == "BUILDINGOPERATOR") return ::Ifc4::IfcRoleEnum::IfcRole_BUILDINGOPERATOR;
    if (s == "MECHANICALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_MECHANICALENGINEER;
    if (s == "ELECTRICALENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_ELECTRICALENGINEER;
    if (s == "PROJECTMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_PROJECTMANAGER;
    if (s == "FACILITIESMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_FACILITIESMANAGER;
    if (s == "CIVILENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_CIVILENGINEER;
    if (s == "COMMISSIONINGENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_COMMISSIONINGENGINEER;
    if (s == "ENGINEER") return ::Ifc4::IfcRoleEnum::IfcRole_ENGINEER;
    if (s == "OWNER") return ::Ifc4::IfcRoleEnum::IfcRole_OWNER;
    if (s == "CONSULTANT") return ::Ifc4::IfcRoleEnum::IfcRole_CONSULTANT;
    if (s == "CONSTRUCTIONMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_CONSTRUCTIONMANAGER;
    if (s == "FIELDCONSTRUCTIONMANAGER") return ::Ifc4::IfcRoleEnum::IfcRole_FIELDCONSTRUCTIONMANAGER;
    if (s == "RESELLER") return ::Ifc4::IfcRoleEnum::IfcRole_RESELLER;
    if (s == "USERDEFINED") return ::Ifc4::IfcRoleEnum::IfcRole_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcRoofTypeEnum::ToString(IfcRoofTypeEnum v) {
    if ( v < 0 || v >= 15 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLAT_ROOF", "SHED_ROOF", "GABLE_ROOF", "HIP_ROOF", "HIPPED_GABLE_ROOF", "GAMBREL_ROOF", "MANSARD_ROOF", "BARREL_ROOF", "RAINBOW_ROOF", "BUTTERFLY_ROOF", "PAVILION_ROOF", "DOME_ROOF", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoofTypeEnum::FromString(const std::string& s) {
    if (s == "FLAT_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_FLAT_ROOF;
    if (s == "SHED_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_SHED_ROOF;
    if (s == "GABLE_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_GABLE_ROOF;
    if (s == "HIP_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_HIP_ROOF;
    if (s == "HIPPED_GABLE_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_HIPPED_GABLE_ROOF;
    if (s == "GAMBREL_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_GAMBREL_ROOF;
    if (s == "MANSARD_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_MANSARD_ROOF;
    if (s == "BARREL_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_BARREL_ROOF;
    if (s == "RAINBOW_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_RAINBOW_ROOF;
    if (s == "BUTTERFLY_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_BUTTERFLY_ROOF;
    if (s == "PAVILION_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_PAVILION_ROOF;
    if (s == "DOME_ROOF") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_DOME_ROOF;
    if (s == "FREEFORM") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcRoofTypeEnum::IfcRoofType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIPrefix::ToString(IfcSIPrefix v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "EXA", "PETA", "TERA", "GIGA", "MEGA", "KILO", "HECTO", "DECA", "DECI", "CENTI", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO" };
    return names[v];
}

IfcSIPrefix::IfcSIPrefix IfcSIPrefix::FromString(const std::string& s) {
    if (s == "EXA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_EXA;
    if (s == "PETA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_PETA;
    if (s == "TERA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_TERA;
    if (s == "GIGA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_GIGA;
    if (s == "MEGA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MEGA;
    if (s == "KILO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_KILO;
    if (s == "HECTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_HECTO;
    if (s == "DECA") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_DECA;
    if (s == "DECI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_DECI;
    if (s == "CENTI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_CENTI;
    if (s == "MILLI") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MILLI;
    if (s == "MICRO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_MICRO;
    if (s == "NANO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_NANO;
    if (s == "PICO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_PICO;
    if (s == "FEMTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_FEMTO;
    if (s == "ATTO") return ::Ifc4::IfcSIPrefix::IfcSIPrefix_ATTO;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSIUnitName::ToString(IfcSIUnitName v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AMPERE", "BECQUEREL", "CANDELA", "COULOMB", "CUBIC_METRE", "DEGREE_CELSIUS", "FARAD", "GRAM", "GRAY", "HENRY", "HERTZ", "JOULE", "KELVIN", "LUMEN", "LUX", "METRE", "MOLE", "NEWTON", "OHM", "PASCAL", "RADIAN", "SECOND", "SIEMENS", "SIEVERT", "SQUARE_METRE", "STERADIAN", "TESLA", "VOLT", "WATT", "WEBER" };
    return names[v];
}

IfcSIUnitName::IfcSIUnitName IfcSIUnitName::FromString(const std::string& s) {
    if (s == "AMPERE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_AMPERE;
    if (s == "BECQUEREL") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_BECQUEREL;
    if (s == "CANDELA") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_CANDELA;
    if (s == "COULOMB") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_COULOMB;
    if (s == "CUBIC_METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_CUBIC_METRE;
    if (s == "DEGREE_CELSIUS") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_DEGREE_CELSIUS;
    if (s == "FARAD") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_FARAD;
    if (s == "GRAM") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_GRAM;
    if (s == "GRAY") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_GRAY;
    if (s == "HENRY") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_HENRY;
    if (s == "HERTZ") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_HERTZ;
    if (s == "JOULE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_JOULE;
    if (s == "KELVIN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_KELVIN;
    if (s == "LUMEN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_LUMEN;
    if (s == "LUX") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_LUX;
    if (s == "METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_METRE;
    if (s == "MOLE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_MOLE;
    if (s == "NEWTON") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_NEWTON;
    if (s == "OHM") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_OHM;
    if (s == "PASCAL") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_PASCAL;
    if (s == "RADIAN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_RADIAN;
    if (s == "SECOND") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SECOND;
    if (s == "SIEMENS") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SIEMENS;
    if (s == "SIEVERT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SIEVERT;
    if (s == "SQUARE_METRE") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_SQUARE_METRE;
    if (s == "STERADIAN") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_STERADIAN;
    if (s == "TESLA") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_TESLA;
    if (s == "VOLT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_VOLT;
    if (s == "WATT") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_WATT;
    if (s == "WEBER") return ::Ifc4::IfcSIUnitName::IfcSIUnitName_WEBER;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSanitaryTerminalTypeEnum::ToString(IfcSanitaryTerminalTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BATH", "BIDET", "CISTERN", "SHOWER", "SINK", "SANITARYFOUNTAIN", "TOILETPAN", "URINAL", "WASHHANDBASIN", "WCSEAT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BATH") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BATH;
    if (s == "BIDET") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_BIDET;
    if (s == "CISTERN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_CISTERN;
    if (s == "SHOWER") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SHOWER;
    if (s == "SINK") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SINK;
    if (s == "SANITARYFOUNTAIN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_SANITARYFOUNTAIN;
    if (s == "TOILETPAN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_TOILETPAN;
    if (s == "URINAL") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_URINAL;
    if (s == "WASHHANDBASIN") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WASHHANDBASIN;
    if (s == "WCSEAT") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_WCSEAT;
    if (s == "USERDEFINED") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSectionTypeEnum::ToString(IfcSectionTypeEnum v) {
    if ( v < 0 || v >= 2 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "UNIFORM", "TAPERED" };
    return names[v];
}

IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionTypeEnum::FromString(const std::string& s) {
    if (s == "UNIFORM") return ::Ifc4::IfcSectionTypeEnum::IfcSectionType_UNIFORM;
    if (s == "TAPERED") return ::Ifc4::IfcSectionTypeEnum::IfcSectionType_TAPERED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSensorTypeEnum::ToString(IfcSensorTypeEnum v) {
    if ( v < 0 || v >= 22 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONDUCTANCESENSOR", "CONTACTSENSOR", "FIRESENSOR", "FLOWSENSOR", "GASSENSOR", "HEATSENSOR", "HUMIDITYSENSOR", "IONCONCENTRATIONSENSOR", "LEVELSENSOR", "LIGHTSENSOR", "MOISTURESENSOR", "MOVEMENTSENSOR", "PHSENSOR", "PRESSURESENSOR", "RADIATIONSENSOR", "RADIOACTIVITYSENSOR", "SMOKESENSOR", "SOUNDSENSOR", "TEMPERATURESENSOR", "WINDSENSOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorTypeEnum::FromString(const std::string& s) {
    if (s == "CONDUCTANCESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_CONDUCTANCESENSOR;
    if (s == "CONTACTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_CONTACTSENSOR;
    if (s == "FIRESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_FIRESENSOR;
    if (s == "FLOWSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_FLOWSENSOR;
    if (s == "GASSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_GASSENSOR;
    if (s == "HEATSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_HEATSENSOR;
    if (s == "HUMIDITYSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_HUMIDITYSENSOR;
    if (s == "IONCONCENTRATIONSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_IONCONCENTRATIONSENSOR;
    if (s == "LEVELSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_LEVELSENSOR;
    if (s == "LIGHTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_LIGHTSENSOR;
    if (s == "MOISTURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_MOISTURESENSOR;
    if (s == "MOVEMENTSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_MOVEMENTSENSOR;
    if (s == "PHSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_PHSENSOR;
    if (s == "PRESSURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_PRESSURESENSOR;
    if (s == "RADIATIONSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_RADIATIONSENSOR;
    if (s == "RADIOACTIVITYSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_RADIOACTIVITYSENSOR;
    if (s == "SMOKESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_SMOKESENSOR;
    if (s == "SOUNDSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_SOUNDSENSOR;
    if (s == "TEMPERATURESENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_TEMPERATURESENSOR;
    if (s == "WINDSENSOR") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_WINDSENSOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSensorTypeEnum::IfcSensorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSequenceEnum::ToString(IfcSequenceEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "START_START", "START_FINISH", "FINISH_START", "FINISH_FINISH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSequenceEnum::IfcSequenceEnum IfcSequenceEnum::FromString(const std::string& s) {
    if (s == "START_START") return ::Ifc4::IfcSequenceEnum::IfcSequence_START_START;
    if (s == "START_FINISH") return ::Ifc4::IfcSequenceEnum::IfcSequence_START_FINISH;
    if (s == "FINISH_START") return ::Ifc4::IfcSequenceEnum::IfcSequence_FINISH_START;
    if (s == "FINISH_FINISH") return ::Ifc4::IfcSequenceEnum::IfcSequence_FINISH_FINISH;
    if (s == "USERDEFINED") return ::Ifc4::IfcSequenceEnum::IfcSequence_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSequenceEnum::IfcSequence_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcShadingDeviceTypeEnum::ToString(IfcShadingDeviceTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "JALOUSIE", "SHUTTER", "AWNING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "JALOUSIE") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_JALOUSIE;
    if (s == "SHUTTER") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_SHUTTER;
    if (s == "AWNING") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_AWNING;
    if (s == "USERDEFINED") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcShadingDeviceTypeEnum::IfcShadingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSimplePropertyTemplateTypeEnum::ToString(IfcSimplePropertyTemplateTypeEnum v) {
    if ( v < 0 || v >= 12 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "P_SINGLEVALUE", "P_ENUMERATEDVALUE", "P_BOUNDEDVALUE", "P_LISTVALUE", "P_TABLEVALUE", "P_REFERENCEVALUE", "Q_LENGTH", "Q_AREA", "Q_VOLUME", "Q_COUNT", "Q_WEIGHT", "Q_TIME" };
    return names[v];
}

IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum IfcSimplePropertyTemplateTypeEnum::FromString(const std::string& s) {
    if (s == "P_SINGLEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_SINGLEVALUE;
    if (s == "P_ENUMERATEDVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_ENUMERATEDVALUE;
    if (s == "P_BOUNDEDVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_BOUNDEDVALUE;
    if (s == "P_LISTVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_LISTVALUE;
    if (s == "P_TABLEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_TABLEVALUE;
    if (s == "P_REFERENCEVALUE") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_P_REFERENCEVALUE;
    if (s == "Q_LENGTH") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_LENGTH;
    if (s == "Q_AREA") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_AREA;
    if (s == "Q_VOLUME") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_VOLUME;
    if (s == "Q_COUNT") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_COUNT;
    if (s == "Q_WEIGHT") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_WEIGHT;
    if (s == "Q_TIME") return ::Ifc4::IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateType_Q_TIME;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSlabTypeEnum::ToString(IfcSlabTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOOR", "ROOF", "LANDING", "BASESLAB", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabTypeEnum::FromString(const std::string& s) {
    if (s == "FLOOR") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_FLOOR;
    if (s == "ROOF") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_ROOF;
    if (s == "LANDING") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_LANDING;
    if (s == "BASESLAB") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_BASESLAB;
    if (s == "USERDEFINED") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSlabTypeEnum::IfcSlabType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSolarDeviceTypeEnum::ToString(IfcSolarDeviceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SOLARCOLLECTOR", "SOLARPANEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "SOLARCOLLECTOR") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_SOLARCOLLECTOR;
    if (s == "SOLARPANEL") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_SOLARPANEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSolarDeviceTypeEnum::IfcSolarDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceHeaterTypeEnum::ToString(IfcSpaceHeaterTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONVECTOR", "RADIATOR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterTypeEnum::FromString(const std::string& s) {
    if (s == "CONVECTOR") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_CONVECTOR;
    if (s == "RADIATOR") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_RADIATOR;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpaceHeaterTypeEnum::IfcSpaceHeaterType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpaceTypeEnum::ToString(IfcSpaceTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SPACE", "PARKING", "GFA", "INTERNAL", "EXTERNAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceTypeEnum::FromString(const std::string& s) {
    if (s == "SPACE") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_SPACE;
    if (s == "PARKING") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_PARKING;
    if (s == "GFA") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_GFA;
    if (s == "INTERNAL") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_INTERNAL;
    if (s == "EXTERNAL") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_EXTERNAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpaceTypeEnum::IfcSpaceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSpatialZoneTypeEnum::ToString(IfcSpatialZoneTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONSTRUCTION", "FIRESAFETY", "LIGHTING", "OCCUPANCY", "SECURITY", "THERMAL", "TRANSPORT", "VENTILATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZoneTypeEnum::FromString(const std::string& s) {
    if (s == "CONSTRUCTION") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_CONSTRUCTION;
    if (s == "FIRESAFETY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_FIRESAFETY;
    if (s == "LIGHTING") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_LIGHTING;
    if (s == "OCCUPANCY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_OCCUPANCY;
    if (s == "SECURITY") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_SECURITY;
    if (s == "THERMAL") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_THERMAL;
    if (s == "TRANSPORT") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_TRANSPORT;
    if (s == "VENTILATION") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_VENTILATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSpatialZoneTypeEnum::IfcSpatialZoneType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStackTerminalTypeEnum::ToString(IfcStackTerminalTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BIRDCAGE", "COWL", "RAINWATERHOPPER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "BIRDCAGE") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_BIRDCAGE;
    if (s == "COWL") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_COWL;
    if (s == "RAINWATERHOPPER") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_RAINWATERHOPPER;
    if (s == "USERDEFINED") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStackTerminalTypeEnum::IfcStackTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairFlightTypeEnum::ToString(IfcStairFlightTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT", "WINDER", "SPIRAL", "CURVED", "FREEFORM", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_STRAIGHT;
    if (s == "WINDER") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_WINDER;
    if (s == "SPIRAL") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_SPIRAL;
    if (s == "CURVED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_CURVED;
    if (s == "FREEFORM") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_FREEFORM;
    if (s == "USERDEFINED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStairFlightTypeEnum::IfcStairFlightType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStairTypeEnum::ToString(IfcStairTypeEnum v) {
    if ( v < 0 || v >= 16 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "STRAIGHT_RUN_STAIR", "TWO_STRAIGHT_RUN_STAIR", "QUARTER_WINDING_STAIR", "QUARTER_TURN_STAIR", "HALF_WINDING_STAIR", "HALF_TURN_STAIR", "TWO_QUARTER_WINDING_STAIR", "TWO_QUARTER_TURN_STAIR", "THREE_QUARTER_WINDING_STAIR", "THREE_QUARTER_TURN_STAIR", "SPIRAL_STAIR", "DOUBLE_RETURN_STAIR", "CURVED_RUN_STAIR", "TWO_CURVED_RUN_STAIR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStairTypeEnum::IfcStairTypeEnum IfcStairTypeEnum::FromString(const std::string& s) {
    if (s == "STRAIGHT_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_STRAIGHT_RUN_STAIR;
    if (s == "TWO_STRAIGHT_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_STRAIGHT_RUN_STAIR;
    if (s == "QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_QUARTER_WINDING_STAIR;
    if (s == "QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_QUARTER_TURN_STAIR;
    if (s == "HALF_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_HALF_WINDING_STAIR;
    if (s == "HALF_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_HALF_TURN_STAIR;
    if (s == "TWO_QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_WINDING_STAIR;
    if (s == "TWO_QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_QUARTER_TURN_STAIR;
    if (s == "THREE_QUARTER_WINDING_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_WINDING_STAIR;
    if (s == "THREE_QUARTER_TURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_THREE_QUARTER_TURN_STAIR;
    if (s == "SPIRAL_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_SPIRAL_STAIR;
    if (s == "DOUBLE_RETURN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_DOUBLE_RETURN_STAIR;
    if (s == "CURVED_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_CURVED_RUN_STAIR;
    if (s == "TWO_CURVED_RUN_STAIR") return ::Ifc4::IfcStairTypeEnum::IfcStairType_TWO_CURVED_RUN_STAIR;
    if (s == "USERDEFINED") return ::Ifc4::IfcStairTypeEnum::IfcStairType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStairTypeEnum::IfcStairType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStateEnum::ToString(IfcStateEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "READWRITE", "READONLY", "LOCKED", "READWRITELOCKED", "READONLYLOCKED" };
    return names[v];
}

IfcStateEnum::IfcStateEnum IfcStateEnum::FromString(const std::string& s) {
    if (s == "READWRITE") return ::Ifc4::IfcStateEnum::IfcState_READWRITE;
    if (s == "READONLY") return ::Ifc4::IfcStateEnum::IfcState_READONLY;
    if (s == "LOCKED") return ::Ifc4::IfcStateEnum::IfcState_LOCKED;
    if (s == "READWRITELOCKED") return ::Ifc4::IfcStateEnum::IfcState_READWRITELOCKED;
    if (s == "READONLYLOCKED") return ::Ifc4::IfcStateEnum::IfcState_READONLYLOCKED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralCurveActivityTypeEnum::ToString(IfcStructuralCurveActivityTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONST", "LINEAR", "POLYGONAL", "EQUIDISTANT", "SINUS", "PARABOLA", "DISCRETE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveActivityTypeEnum::FromString(const std::string& s) {
    if (s == "CONST") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_CONST;
    if (s == "LINEAR") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_LINEAR;
    if (s == "POLYGONAL") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_POLYGONAL;
    if (s == "EQUIDISTANT") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_EQUIDISTANT;
    if (s == "SINUS") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_SINUS;
    if (s == "PARABOLA") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_PARABOLA;
    if (s == "DISCRETE") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_DISCRETE;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralCurveMemberTypeEnum::ToString(IfcStructuralCurveMemberTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "RIGID_JOINED_MEMBER", "PIN_JOINED_MEMBER", "CABLE", "TENSION_MEMBER", "COMPRESSION_MEMBER", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum IfcStructuralCurveMemberTypeEnum::FromString(const std::string& s) {
    if (s == "RIGID_JOINED_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_RIGID_JOINED_MEMBER;
    if (s == "PIN_JOINED_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_PIN_JOINED_MEMBER;
    if (s == "CABLE") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_CABLE;
    if (s == "TENSION_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_TENSION_MEMBER;
    if (s == "COMPRESSION_MEMBER") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_COMPRESSION_MEMBER;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralSurfaceActivityTypeEnum::ToString(IfcStructuralSurfaceActivityTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONST", "BILINEAR", "DISCRETE", "ISOCONTOUR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceActivityTypeEnum::FromString(const std::string& s) {
    if (s == "CONST") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_CONST;
    if (s == "BILINEAR") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_BILINEAR;
    if (s == "DISCRETE") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_DISCRETE;
    if (s == "ISOCONTOUR") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_ISOCONTOUR;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcStructuralSurfaceMemberTypeEnum::ToString(IfcStructuralSurfaceMemberTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BENDING_ELEMENT", "MEMBRANE_ELEMENT", "SHELL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum IfcStructuralSurfaceMemberTypeEnum::FromString(const std::string& s) {
    if (s == "BENDING_ELEMENT") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_BENDING_ELEMENT;
    if (s == "MEMBRANE_ELEMENT") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_MEMBRANE_ELEMENT;
    if (s == "SHELL") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_SHELL;
    if (s == "USERDEFINED") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSubContractResourceTypeEnum::ToString(IfcSubContractResourceTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PURCHASE", "WORK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResourceTypeEnum::FromString(const std::string& s) {
    if (s == "PURCHASE") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_PURCHASE;
    if (s == "WORK") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_WORK;
    if (s == "USERDEFINED") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSubContractResourceTypeEnum::IfcSubContractResourceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceFeatureTypeEnum::ToString(IfcSurfaceFeatureTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MARK", "TAG", "TREATMENT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum IfcSurfaceFeatureTypeEnum::FromString(const std::string& s) {
    if (s == "MARK") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_MARK;
    if (s == "TAG") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_TAG;
    if (s == "TREATMENT") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_TREATMENT;
    if (s == "USERDEFINED") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSurfaceSide::ToString(IfcSurfaceSide v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "POSITIVE", "NEGATIVE", "BOTH" };
    return names[v];
}

IfcSurfaceSide::IfcSurfaceSide IfcSurfaceSide::FromString(const std::string& s) {
    if (s == "POSITIVE") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_POSITIVE;
    if (s == "NEGATIVE") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_NEGATIVE;
    if (s == "BOTH") return ::Ifc4::IfcSurfaceSide::IfcSurfaceSide_BOTH;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSwitchingDeviceTypeEnum::ToString(IfcSwitchingDeviceTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTACTOR", "DIMMERSWITCH", "EMERGENCYSTOP", "KEYPAD", "MOMENTARYSWITCH", "SELECTORSWITCH", "STARTER", "SWITCHDISCONNECTOR", "TOGGLESWITCH", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceTypeEnum::FromString(const std::string& s) {
    if (s == "CONTACTOR") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_CONTACTOR;
    if (s == "DIMMERSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_DIMMERSWITCH;
    if (s == "EMERGENCYSTOP") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_EMERGENCYSTOP;
    if (s == "KEYPAD") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_KEYPAD;
    if (s == "MOMENTARYSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_MOMENTARYSWITCH;
    if (s == "SELECTORSWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SELECTORSWITCH;
    if (s == "STARTER") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_STARTER;
    if (s == "SWITCHDISCONNECTOR") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_SWITCHDISCONNECTOR;
    if (s == "TOGGLESWITCH") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_TOGGLESWITCH;
    if (s == "USERDEFINED") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcSystemFurnitureElementTypeEnum::ToString(IfcSystemFurnitureElementTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "PANEL", "WORKSURFACE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElementTypeEnum::FromString(const std::string& s) {
    if (s == "PANEL") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_PANEL;
    if (s == "WORKSURFACE") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_WORKSURFACE;
    if (s == "USERDEFINED") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTankTypeEnum::ToString(IfcTankTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BASIN", "BREAKPRESSURE", "EXPANSION", "FEEDANDEXPANSION", "PRESSUREVESSEL", "STORAGE", "VESSEL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTankTypeEnum::IfcTankTypeEnum IfcTankTypeEnum::FromString(const std::string& s) {
    if (s == "BASIN") return ::Ifc4::IfcTankTypeEnum::IfcTankType_BASIN;
    if (s == "BREAKPRESSURE") return ::Ifc4::IfcTankTypeEnum::IfcTankType_BREAKPRESSURE;
    if (s == "EXPANSION") return ::Ifc4::IfcTankTypeEnum::IfcTankType_EXPANSION;
    if (s == "FEEDANDEXPANSION") return ::Ifc4::IfcTankTypeEnum::IfcTankType_FEEDANDEXPANSION;
    if (s == "PRESSUREVESSEL") return ::Ifc4::IfcTankTypeEnum::IfcTankType_PRESSUREVESSEL;
    if (s == "STORAGE") return ::Ifc4::IfcTankTypeEnum::IfcTankType_STORAGE;
    if (s == "VESSEL") return ::Ifc4::IfcTankTypeEnum::IfcTankType_VESSEL;
    if (s == "USERDEFINED") return ::Ifc4::IfcTankTypeEnum::IfcTankType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTankTypeEnum::IfcTankType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTaskDurationEnum::ToString(IfcTaskDurationEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELAPSEDTIME", "WORKTIME", "NOTDEFINED" };
    return names[v];
}

IfcTaskDurationEnum::IfcTaskDurationEnum IfcTaskDurationEnum::FromString(const std::string& s) {
    if (s == "ELAPSEDTIME") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_ELAPSEDTIME;
    if (s == "WORKTIME") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_WORKTIME;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTaskDurationEnum::IfcTaskDuration_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTaskTypeEnum::ToString(IfcTaskTypeEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ATTENDANCE", "CONSTRUCTION", "DEMOLITION", "DISMANTLE", "DISPOSAL", "INSTALLATION", "LOGISTIC", "MAINTENANCE", "MOVE", "OPERATION", "REMOVAL", "RENOVATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTaskTypeEnum::IfcTaskTypeEnum IfcTaskTypeEnum::FromString(const std::string& s) {
    if (s == "ATTENDANCE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_ATTENDANCE;
    if (s == "CONSTRUCTION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_CONSTRUCTION;
    if (s == "DEMOLITION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DEMOLITION;
    if (s == "DISMANTLE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DISMANTLE;
    if (s == "DISPOSAL") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_DISPOSAL;
    if (s == "INSTALLATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_INSTALLATION;
    if (s == "LOGISTIC") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_LOGISTIC;
    if (s == "MAINTENANCE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_MAINTENANCE;
    if (s == "MOVE") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_MOVE;
    if (s == "OPERATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_OPERATION;
    if (s == "REMOVAL") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_REMOVAL;
    if (s == "RENOVATION") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_RENOVATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTaskTypeEnum::IfcTaskType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTendonAnchorTypeEnum::ToString(IfcTendonAnchorTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COUPLER", "FIXED_END", "TENSIONING_END", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchorTypeEnum::FromString(const std::string& s) {
    if (s == "COUPLER") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_COUPLER;
    if (s == "FIXED_END") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_FIXED_END;
    if (s == "TENSIONING_END") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_TENSIONING_END;
    if (s == "USERDEFINED") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTendonAnchorTypeEnum::IfcTendonAnchorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTendonTypeEnum::ToString(IfcTendonTypeEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "BAR", "COATED", "STRAND", "WIRE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendonTypeEnum::FromString(const std::string& s) {
    if (s == "BAR") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_BAR;
    if (s == "COATED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_COATED;
    if (s == "STRAND") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_STRAND;
    if (s == "WIRE") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_WIRE;
    if (s == "USERDEFINED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTendonTypeEnum::IfcTendonType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTextPath::ToString(IfcTextPath v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "RIGHT", "UP", "DOWN" };
    return names[v];
}

IfcTextPath::IfcTextPath IfcTextPath::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcTextPath::IfcTextPath_LEFT;
    if (s == "RIGHT") return ::Ifc4::IfcTextPath::IfcTextPath_RIGHT;
    if (s == "UP") return ::Ifc4::IfcTextPath::IfcTextPath_UP;
    if (s == "DOWN") return ::Ifc4::IfcTextPath::IfcTextPath_DOWN;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTimeSeriesDataTypeEnum::ToString(IfcTimeSeriesDataTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CONTINUOUS", "DISCRETE", "DISCRETEBINARY", "PIECEWISEBINARY", "PIECEWISECONSTANT", "PIECEWISECONTINUOUS", "NOTDEFINED" };
    return names[v];
}

IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeriesDataTypeEnum::FromString(const std::string& s) {
    if (s == "CONTINUOUS") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_CONTINUOUS;
    if (s == "DISCRETE") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETE;
    if (s == "DISCRETEBINARY") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_DISCRETEBINARY;
    if (s == "PIECEWISEBINARY") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISEBINARY;
    if (s == "PIECEWISECONSTANT") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONSTANT;
    if (s == "PIECEWISECONTINUOUS") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_PIECEWISECONTINUOUS;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransformerTypeEnum::ToString(IfcTransformerTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CURRENT", "FREQUENCY", "INVERTER", "RECTIFIER", "VOLTAGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerTypeEnum::FromString(const std::string& s) {
    if (s == "CURRENT") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_CURRENT;
    if (s == "FREQUENCY") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_FREQUENCY;
    if (s == "INVERTER") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_INVERTER;
    if (s == "RECTIFIER") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_RECTIFIER;
    if (s == "VOLTAGE") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_VOLTAGE;
    if (s == "USERDEFINED") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTransformerTypeEnum::IfcTransformerType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransitionCode::ToString(IfcTransitionCode v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "DISCONTINUOUS", "CONTINUOUS", "CONTSAMEGRADIENT", "CONTSAMEGRADIENTSAMECURVATURE" };
    return names[v];
}

IfcTransitionCode::IfcTransitionCode IfcTransitionCode::FromString(const std::string& s) {
    if (s == "DISCONTINUOUS") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_DISCONTINUOUS;
    if (s == "CONTINUOUS") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTINUOUS;
    if (s == "CONTSAMEGRADIENT") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENT;
    if (s == "CONTSAMEGRADIENTSAMECURVATURE") return ::Ifc4::IfcTransitionCode::IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTransportElementTypeEnum::ToString(IfcTransportElementTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ELEVATOR", "ESCALATOR", "MOVINGWALKWAY", "CRANEWAY", "LIFTINGGEAR", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementTypeEnum::FromString(const std::string& s) {
    if (s == "ELEVATOR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_ELEVATOR;
    if (s == "ESCALATOR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_ESCALATOR;
    if (s == "MOVINGWALKWAY") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_MOVINGWALKWAY;
    if (s == "CRANEWAY") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_CRANEWAY;
    if (s == "LIFTINGGEAR") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_LIFTINGGEAR;
    if (s == "USERDEFINED") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTransportElementTypeEnum::IfcTransportElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTrimmingPreference::ToString(IfcTrimmingPreference v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CARTESIAN", "PARAMETER", "UNSPECIFIED" };
    return names[v];
}

IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmingPreference::FromString(const std::string& s) {
    if (s == "CARTESIAN") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_CARTESIAN;
    if (s == "PARAMETER") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_PARAMETER;
    if (s == "UNSPECIFIED") return ::Ifc4::IfcTrimmingPreference::IfcTrimmingPreference_UNSPECIFIED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcTubeBundleTypeEnum::ToString(IfcTubeBundleTypeEnum v) {
    if ( v < 0 || v >= 3 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FINNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleTypeEnum::FromString(const std::string& s) {
    if (s == "FINNED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_FINNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcTubeBundleTypeEnum::IfcTubeBundleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitEnum::ToString(IfcUnitEnum v) {
    if ( v < 0 || v >= 30 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ABSORBEDDOSEUNIT", "AMOUNTOFSUBSTANCEUNIT", "AREAUNIT", "DOSEEQUIVALENTUNIT", "ELECTRICCAPACITANCEUNIT", "ELECTRICCHARGEUNIT", "ELECTRICCONDUCTANCEUNIT", "ELECTRICCURRENTUNIT", "ELECTRICRESISTANCEUNIT", "ELECTRICVOLTAGEUNIT", "ENERGYUNIT", "FORCEUNIT", "FREQUENCYUNIT", "ILLUMINANCEUNIT", "INDUCTANCEUNIT", "LENGTHUNIT", "LUMINOUSFLUXUNIT", "LUMINOUSINTENSITYUNIT", "MAGNETICFLUXDENSITYUNIT", "MAGNETICFLUXUNIT", "MASSUNIT", "PLANEANGLEUNIT", "POWERUNIT", "PRESSUREUNIT", "RADIOACTIVITYUNIT", "SOLIDANGLEUNIT", "THERMODYNAMICTEMPERATUREUNIT", "TIMEUNIT", "VOLUMEUNIT", "USERDEFINED" };
    return names[v];
}

IfcUnitEnum::IfcUnitEnum IfcUnitEnum::FromString(const std::string& s) {
    if (s == "ABSORBEDDOSEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ABSORBEDDOSEUNIT;
    if (s == "AMOUNTOFSUBSTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_AMOUNTOFSUBSTANCEUNIT;
    if (s == "AREAUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_AREAUNIT;
    if (s == "DOSEEQUIVALENTUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_DOSEEQUIVALENTUNIT;
    if (s == "ELECTRICCAPACITANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCAPACITANCEUNIT;
    if (s == "ELECTRICCHARGEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCHARGEUNIT;
    if (s == "ELECTRICCONDUCTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCONDUCTANCEUNIT;
    if (s == "ELECTRICCURRENTUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICCURRENTUNIT;
    if (s == "ELECTRICRESISTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICRESISTANCEUNIT;
    if (s == "ELECTRICVOLTAGEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ELECTRICVOLTAGEUNIT;
    if (s == "ENERGYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ENERGYUNIT;
    if (s == "FORCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_FORCEUNIT;
    if (s == "FREQUENCYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_FREQUENCYUNIT;
    if (s == "ILLUMINANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_ILLUMINANCEUNIT;
    if (s == "INDUCTANCEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_INDUCTANCEUNIT;
    if (s == "LENGTHUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LENGTHUNIT;
    if (s == "LUMINOUSFLUXUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LUMINOUSFLUXUNIT;
    if (s == "LUMINOUSINTENSITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_LUMINOUSINTENSITYUNIT;
    if (s == "MAGNETICFLUXDENSITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MAGNETICFLUXDENSITYUNIT;
    if (s == "MAGNETICFLUXUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MAGNETICFLUXUNIT;
    if (s == "MASSUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_MASSUNIT;
    if (s == "PLANEANGLEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_PLANEANGLEUNIT;
    if (s == "POWERUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_POWERUNIT;
    if (s == "PRESSUREUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_PRESSUREUNIT;
    if (s == "RADIOACTIVITYUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_RADIOACTIVITYUNIT;
    if (s == "SOLIDANGLEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_SOLIDANGLEUNIT;
    if (s == "THERMODYNAMICTEMPERATUREUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_THERMODYNAMICTEMPERATUREUNIT;
    if (s == "TIMEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_TIMEUNIT;
    if (s == "VOLUMEUNIT") return ::Ifc4::IfcUnitEnum::IfcUnit_VOLUMEUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitEnum::IfcUnit_USERDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitaryControlElementTypeEnum::ToString(IfcUnitaryControlElementTypeEnum v) {
    if ( v < 0 || v >= 10 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALARMPANEL", "CONTROLPANEL", "GASDETECTIONPANEL", "INDICATORPANEL", "MIMICPANEL", "HUMIDISTAT", "THERMOSTAT", "WEATHERSTATION", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElementTypeEnum::FromString(const std::string& s) {
    if (s == "ALARMPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_ALARMPANEL;
    if (s == "CONTROLPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_CONTROLPANEL;
    if (s == "GASDETECTIONPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_GASDETECTIONPANEL;
    if (s == "INDICATORPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_INDICATORPANEL;
    if (s == "MIMICPANEL") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_MIMICPANEL;
    if (s == "HUMIDISTAT") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_HUMIDISTAT;
    if (s == "THERMOSTAT") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_THERMOSTAT;
    if (s == "WEATHERSTATION") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_WEATHERSTATION;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcUnitaryEquipmentTypeEnum::ToString(IfcUnitaryEquipmentTypeEnum v) {
    if ( v < 0 || v >= 7 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRHANDLER", "AIRCONDITIONINGUNIT", "DEHUMIDIFIER", "SPLITSYSTEM", "ROOFTOPUNIT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentTypeEnum::FromString(const std::string& s) {
    if (s == "AIRHANDLER") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRHANDLER;
    if (s == "AIRCONDITIONINGUNIT") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT;
    if (s == "DEHUMIDIFIER") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_DEHUMIDIFIER;
    if (s == "SPLITSYSTEM") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_SPLITSYSTEM;
    if (s == "ROOFTOPUNIT") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_ROOFTOPUNIT;
    if (s == "USERDEFINED") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcValveTypeEnum::ToString(IfcValveTypeEnum v) {
    if ( v < 0 || v >= 23 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "AIRRELEASE", "ANTIVACUUM", "CHANGEOVER", "CHECK", "COMMISSIONING", "DIVERTING", "DRAWOFFCOCK", "DOUBLECHECK", "DOUBLEREGULATING", "FAUCET", "FLUSHING", "GASCOCK", "GASTAP", "ISOLATING", "MIXING", "PRESSUREREDUCING", "PRESSURERELIEF", "REGULATING", "SAFETYCUTOFF", "STEAMTRAP", "STOPCOCK", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcValveTypeEnum::IfcValveTypeEnum IfcValveTypeEnum::FromString(const std::string& s) {
    if (s == "AIRRELEASE") return ::Ifc4::IfcValveTypeEnum::IfcValveType_AIRRELEASE;
    if (s == "ANTIVACUUM") return ::Ifc4::IfcValveTypeEnum::IfcValveType_ANTIVACUUM;
    if (s == "CHANGEOVER") return ::Ifc4::IfcValveTypeEnum::IfcValveType_CHANGEOVER;
    if (s == "CHECK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_CHECK;
    if (s == "COMMISSIONING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_COMMISSIONING;
    if (s == "DIVERTING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DIVERTING;
    if (s == "DRAWOFFCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DRAWOFFCOCK;
    if (s == "DOUBLECHECK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DOUBLECHECK;
    if (s == "DOUBLEREGULATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_DOUBLEREGULATING;
    if (s == "FAUCET") return ::Ifc4::IfcValveTypeEnum::IfcValveType_FAUCET;
    if (s == "FLUSHING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_FLUSHING;
    if (s == "GASCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_GASCOCK;
    if (s == "GASTAP") return ::Ifc4::IfcValveTypeEnum::IfcValveType_GASTAP;
    if (s == "ISOLATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_ISOLATING;
    if (s == "MIXING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_MIXING;
    if (s == "PRESSUREREDUCING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_PRESSUREREDUCING;
    if (s == "PRESSURERELIEF") return ::Ifc4::IfcValveTypeEnum::IfcValveType_PRESSURERELIEF;
    if (s == "REGULATING") return ::Ifc4::IfcValveTypeEnum::IfcValveType_REGULATING;
    if (s == "SAFETYCUTOFF") return ::Ifc4::IfcValveTypeEnum::IfcValveType_SAFETYCUTOFF;
    if (s == "STEAMTRAP") return ::Ifc4::IfcValveTypeEnum::IfcValveType_STEAMTRAP;
    if (s == "STOPCOCK") return ::Ifc4::IfcValveTypeEnum::IfcValveType_STOPCOCK;
    if (s == "USERDEFINED") return ::Ifc4::IfcValveTypeEnum::IfcValveType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcValveTypeEnum::IfcValveType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcVibrationIsolatorTypeEnum::ToString(IfcVibrationIsolatorTypeEnum v) {
    if ( v < 0 || v >= 4 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "COMPRESSION", "SPRING", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorTypeEnum::FromString(const std::string& s) {
    if (s == "COMPRESSION") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_COMPRESSION;
    if (s == "SPRING") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_SPRING;
    if (s == "USERDEFINED") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcVoidingFeatureTypeEnum::ToString(IfcVoidingFeatureTypeEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "CUTOUT", "NOTCH", "HOLE", "MITER", "CHAMFER", "EDGE", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum IfcVoidingFeatureTypeEnum::FromString(const std::string& s) {
    if (s == "CUTOUT") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_CUTOUT;
    if (s == "NOTCH") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_NOTCH;
    if (s == "HOLE") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_HOLE;
    if (s == "MITER") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_MITER;
    if (s == "CHAMFER") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_CHAMFER;
    if (s == "EDGE") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_EDGE;
    if (s == "USERDEFINED") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcVoidingFeatureTypeEnum::IfcVoidingFeatureType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWallTypeEnum::ToString(IfcWallTypeEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "MOVABLE", "PARAPET", "PARTITIONING", "PLUMBINGWALL", "SHEAR", "SOLIDWALL", "STANDARD", "POLYGONAL", "ELEMENTEDWALL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWallTypeEnum::IfcWallTypeEnum IfcWallTypeEnum::FromString(const std::string& s) {
    if (s == "MOVABLE") return ::Ifc4::IfcWallTypeEnum::IfcWallType_MOVABLE;
    if (s == "PARAPET") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PARAPET;
    if (s == "PARTITIONING") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PARTITIONING;
    if (s == "PLUMBINGWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_PLUMBINGWALL;
    if (s == "SHEAR") return ::Ifc4::IfcWallTypeEnum::IfcWallType_SHEAR;
    if (s == "SOLIDWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_SOLIDWALL;
    if (s == "STANDARD") return ::Ifc4::IfcWallTypeEnum::IfcWallType_STANDARD;
    if (s == "POLYGONAL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_POLYGONAL;
    if (s == "ELEMENTEDWALL") return ::Ifc4::IfcWallTypeEnum::IfcWallType_ELEMENTEDWALL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWallTypeEnum::IfcWallType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWallTypeEnum::IfcWallType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWasteTerminalTypeEnum::ToString(IfcWasteTerminalTypeEnum v) {
    if ( v < 0 || v >= 9 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FLOORTRAP", "FLOORWASTE", "GULLYSUMP", "GULLYTRAP", "ROOFDRAIN", "WASTEDISPOSALUNIT", "WASTETRAP", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalTypeEnum::FromString(const std::string& s) {
    if (s == "FLOORTRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORTRAP;
    if (s == "FLOORWASTE") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_FLOORWASTE;
    if (s == "GULLYSUMP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYSUMP;
    if (s == "GULLYTRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_GULLYTRAP;
    if (s == "ROOFDRAIN") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_ROOFDRAIN;
    if (s == "WASTEDISPOSALUNIT") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTEDISPOSALUNIT;
    if (s == "WASTETRAP") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_WASTETRAP;
    if (s == "USERDEFINED") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWasteTerminalTypeEnum::IfcWasteTerminalType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelOperationEnum::ToString(IfcWindowPanelOperationEnum v) {
    if ( v < 0 || v >= 14 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SIDEHUNGRIGHTHAND", "SIDEHUNGLEFTHAND", "TILTANDTURNRIGHTHAND", "TILTANDTURNLEFTHAND", "TOPHUNG", "BOTTOMHUNG", "PIVOTHORIZONTAL", "PIVOTVERTICAL", "SLIDINGHORIZONTAL", "SLIDINGVERTICAL", "REMOVABLECASEMENT", "FIXEDCASEMENT", "OTHEROPERATION", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelOperationEnum::FromString(const std::string& s) {
    if (s == "SIDEHUNGRIGHTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGRIGHTHAND;
    if (s == "SIDEHUNGLEFTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SIDEHUNGLEFTHAND;
    if (s == "TILTANDTURNRIGHTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNRIGHTHAND;
    if (s == "TILTANDTURNLEFTHAND") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TILTANDTURNLEFTHAND;
    if (s == "TOPHUNG") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_TOPHUNG;
    if (s == "BOTTOMHUNG") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_BOTTOMHUNG;
    if (s == "PIVOTHORIZONTAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTHORIZONTAL;
    if (s == "PIVOTVERTICAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_PIVOTVERTICAL;
    if (s == "SLIDINGHORIZONTAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGHORIZONTAL;
    if (s == "SLIDINGVERTICAL") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_SLIDINGVERTICAL;
    if (s == "REMOVABLECASEMENT") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_REMOVABLECASEMENT;
    if (s == "FIXEDCASEMENT") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_FIXEDCASEMENT;
    if (s == "OTHEROPERATION") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_OTHEROPERATION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowPanelOperationEnum::IfcWindowPanelOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowPanelPositionEnum::ToString(IfcWindowPanelPositionEnum v) {
    if ( v < 0 || v >= 6 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "LEFT", "MIDDLE", "RIGHT", "BOTTOM", "TOP", "NOTDEFINED" };
    return names[v];
}

IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelPositionEnum::FromString(const std::string& s) {
    if (s == "LEFT") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_LEFT;
    if (s == "MIDDLE") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_MIDDLE;
    if (s == "RIGHT") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_RIGHT;
    if (s == "BOTTOM") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_BOTTOM;
    if (s == "TOP") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_TOP;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowPanelPositionEnum::IfcWindowPanelPosition_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleConstructionEnum::ToString(IfcWindowStyleConstructionEnum v) {
    if ( v < 0 || v >= 8 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ALUMINIUM", "HIGH_GRADE_STEEL", "STEEL", "WOOD", "ALUMINIUM_WOOD", "PLASTIC", "OTHER_CONSTRUCTION", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyleConstructionEnum::FromString(const std::string& s) {
    if (s == "ALUMINIUM") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM;
    if (s == "HIGH_GRADE_STEEL") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_HIGH_GRADE_STEEL;
    if (s == "STEEL") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_STEEL;
    if (s == "WOOD") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_WOOD;
    if (s == "ALUMINIUM_WOOD") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_ALUMINIUM_WOOD;
    if (s == "PLASTIC") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_PLASTIC;
    if (s == "OTHER_CONSTRUCTION") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_OTHER_CONSTRUCTION;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowStyleConstructionEnum::IfcWindowStyleConstruction_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowStyleOperationEnum::ToString(IfcWindowStyleOperationEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyleOperationEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowStyleOperationEnum::IfcWindowStyleOperation_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowTypeEnum::ToString(IfcWindowTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "WINDOW", "SKYLIGHT", "LIGHTDOME", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindowTypeEnum::FromString(const std::string& s) {
    if (s == "WINDOW") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_WINDOW;
    if (s == "SKYLIGHT") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_SKYLIGHT;
    if (s == "LIGHTDOME") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_LIGHTDOME;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowTypeEnum::IfcWindowType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWindowTypePartitioningEnum::ToString(IfcWindowTypePartitioningEnum v) {
    if ( v < 0 || v >= 11 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "SINGLE_PANEL", "DOUBLE_PANEL_VERTICAL", "DOUBLE_PANEL_HORIZONTAL", "TRIPLE_PANEL_VERTICAL", "TRIPLE_PANEL_BOTTOM", "TRIPLE_PANEL_TOP", "TRIPLE_PANEL_LEFT", "TRIPLE_PANEL_RIGHT", "TRIPLE_PANEL_HORIZONTAL", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindowTypePartitioningEnum::FromString(const std::string& s) {
    if (s == "SINGLE_PANEL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_SINGLE_PANEL;
    if (s == "DOUBLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_DOUBLE_PANEL_VERTICAL;
    if (s == "DOUBLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_DOUBLE_PANEL_HORIZONTAL;
    if (s == "TRIPLE_PANEL_VERTICAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_VERTICAL;
    if (s == "TRIPLE_PANEL_BOTTOM") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_BOTTOM;
    if (s == "TRIPLE_PANEL_TOP") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_TOP;
    if (s == "TRIPLE_PANEL_LEFT") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_LEFT;
    if (s == "TRIPLE_PANEL_RIGHT") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_RIGHT;
    if (s == "TRIPLE_PANEL_HORIZONTAL") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_TRIPLE_PANEL_HORIZONTAL;
    if (s == "USERDEFINED") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWindowTypePartitioningEnum::IfcWindowTypePartitioning_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkCalendarTypeEnum::ToString(IfcWorkCalendarTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "FIRSTSHIFT", "SECONDSHIFT", "THIRDSHIFT", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum IfcWorkCalendarTypeEnum::FromString(const std::string& s) {
    if (s == "FIRSTSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_FIRSTSHIFT;
    if (s == "SECONDSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_SECONDSHIFT;
    if (s == "THIRDSHIFT") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_THIRDSHIFT;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkCalendarTypeEnum::IfcWorkCalendarType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkPlanTypeEnum::ToString(IfcWorkPlanTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum IfcWorkPlanTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_ACTUAL;
    if (s == "BASELINE") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_BASELINE;
    if (s == "PLANNED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkPlanTypeEnum::IfcWorkPlanType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}

const char* IfcWorkScheduleTypeEnum::ToString(IfcWorkScheduleTypeEnum v) {
    if ( v < 0 || v >= 5 ) throw IfcException("Unable to find find keyword in schema");
    const char* names[] = { "ACTUAL", "BASELINE", "PLANNED", "USERDEFINED", "NOTDEFINED" };
    return names[v];
}

IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum IfcWorkScheduleTypeEnum::FromString(const std::string& s) {
    if (s == "ACTUAL") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_ACTUAL;
    if (s == "BASELINE") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_BASELINE;
    if (s == "PLANNED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_PLANNED;
    if (s == "USERDEFINED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_USERDEFINED;
    if (s == "NOTDEFINED") return ::Ifc4::IfcWorkScheduleTypeEnum::IfcWorkScheduleType_NOTDEFINED;
    throw IfcException("Unable to find find keyword in schema");
}


#define RETURN_INVERSE(T)     IfcEntities e = entity->getInverse(T::Class());     SHARED_PTR< IfcTemplatedEntityList<T> > l ( new IfcTemplatedEntityList<T>() );     for ( IfcEntityList::it it = e->begin(); it != e->end(); ++ it ) {         l->push(reinterpret_pointer_cast<IfcBaseClass,T>(*it));     }     return l;

#define RETURN_AS_SINGLE(T,a)     return reinterpret_pointer_cast<IfcBaseClass,T>(*entity->getArgument(a));

#define RETURN_AS_LIST(T,a)      IfcEntities e = *entity->getArgument(a);      SHARED_PTR< IfcTemplatedEntityList<T> > l ( new IfcTemplatedEntityList<T>() );      for ( IfcEntityList::it it = e->begin(); it != e->end(); ++ it ) {          l->push(reinterpret_pointer_cast<IfcBaseClass,T>(*it));     }      return l;

#define RETURN_AS_LIST_LIST(T, a) \
	IfcEntitiesList e = *entity->getArgument(a); \
	SHARED_PTR< IfcTemplatedEntityListList<T> > l ( new IfcTemplatedEntityListList<T>() ); \
	for ( IfcEntityListList::it it = e->begin(); it != e->end(); ++ it ) { \
		auto q = *it; \
		std::vector<T*> li; \
		for ( auto jt = q.begin(); jt != q.end(); ++jt) { \
			li.push_back((T*)*jt); \
		} \
		l->push(li); \
	} \
	return l;

// Function implementations for IfcActionRequest
bool IfcActionRequest::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcActionRequestTypeEnum::IfcActionRequestTypeEnum IfcActionRequest::PredefinedType() { return IfcActionRequestTypeEnum::FromString(*entity->getArgument(6)); }
void IfcActionRequest::setPredefinedType(IfcActionRequestTypeEnum::IfcActionRequestTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcActionRequestTypeEnum::ToString(v)); }
bool IfcActionRequest::hasStatus() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcActionRequest::Status() { return *entity->getArgument(7); }
void IfcActionRequest::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcActionRequest::hasLongDescription() { return !entity->getArgument(8)->isNull(); }
IfcText IfcActionRequest::LongDescription() { return *entity->getArgument(8); }
void IfcActionRequest::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcActionRequest::is(Type::Enum v) const { return v == Type::IfcActionRequest || IfcControl::is(v); }
Type::Enum IfcActionRequest::type() const { return Type::IfcActionRequest; }
Type::Enum IfcActionRequest::Class() { return Type::IfcActionRequest; }
IfcActionRequest::IfcActionRequest(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcActionRequest)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActionRequest::IfcActionRequest(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcActionRequestTypeEnum::IfcActionRequestTypeEnum > v7_PredefinedType, boost::optional< IfcLabel > v8_Status, boost::optional< IfcText > v9_LongDescription) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcActionRequestTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } if (v8_Status) { e->setArgument(7,(*v8_Status)); } else { e->setArgument(7); } if (v9_LongDescription) { e->setArgument(8,(*v9_LongDescription)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcActor
IfcActorSelect IfcActor::TheActor() { return *entity->getArgument(5); }
void IfcActor::setTheActor(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcRelAssignsToActor::list IfcActor::IsActingUpon() { RETURN_INVERSE(IfcRelAssignsToActor) }
bool IfcActor::is(Type::Enum v) const { return v == Type::IfcActor || IfcObject::is(v); }
Type::Enum IfcActor::type() const { return Type::IfcActor; }
Type::Enum IfcActor::Class() { return Type::IfcActor; }
IfcActor::IfcActor(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcActor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActor::IfcActor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcActorSelect v6_TheActor) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_TheActor)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcActorRole
IfcRoleEnum::IfcRoleEnum IfcActorRole::Role() { return IfcRoleEnum::FromString(*entity->getArgument(0)); }
void IfcActorRole::setRole(IfcRoleEnum::IfcRoleEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcRoleEnum::ToString(v)); }
bool IfcActorRole::hasUserDefinedRole() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcActorRole::UserDefinedRole() { return *entity->getArgument(1); }
void IfcActorRole::setUserDefinedRole(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcActorRole::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcActorRole::Description() { return *entity->getArgument(2); }
void IfcActorRole::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcExternalReferenceRelationship::list IfcActorRole::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcActorRole::is(Type::Enum v) const { return v == Type::IfcActorRole; }
Type::Enum IfcActorRole::type() const { return Type::IfcActorRole; }
Type::Enum IfcActorRole::Class() { return Type::IfcActorRole; }
IfcActorRole::IfcActorRole(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcActorRole)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActorRole::IfcActorRole(IfcRoleEnum::IfcRoleEnum v1_Role, boost::optional< IfcLabel > v2_UserDefinedRole, boost::optional< IfcText > v3_Description) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_Role,IfcRoleEnum::ToString(v1_Role)); if (v2_UserDefinedRole) { e->setArgument(1,(*v2_UserDefinedRole)); } else { e->setArgument(1); } if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcActuator
bool IfcActuator::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuator::PredefinedType() { return IfcActuatorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcActuator::setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcActuatorTypeEnum::ToString(v)); }
bool IfcActuator::is(Type::Enum v) const { return v == Type::IfcActuator || IfcDistributionControlElement::is(v); }
Type::Enum IfcActuator::type() const { return Type::IfcActuator; }
Type::Enum IfcActuator::Class() { return Type::IfcActuator; }
IfcActuator::IfcActuator(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcActuator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActuator::IfcActuator(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcActuatorTypeEnum::IfcActuatorTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcActuatorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcActuatorType
IfcActuatorTypeEnum::IfcActuatorTypeEnum IfcActuatorType::PredefinedType() { return IfcActuatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcActuatorType::setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcActuatorTypeEnum::ToString(v)); }
bool IfcActuatorType::is(Type::Enum v) const { return v == Type::IfcActuatorType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcActuatorType::type() const { return Type::IfcActuatorType; }
Type::Enum IfcActuatorType::Class() { return Type::IfcActuatorType; }
IfcActuatorType::IfcActuatorType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcActuatorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcActuatorType::IfcActuatorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcActuatorTypeEnum::IfcActuatorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcActuatorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAddress
bool IfcAddress::hasPurpose() { return !entity->getArgument(0)->isNull(); }
IfcAddressTypeEnum::IfcAddressTypeEnum IfcAddress::Purpose() { return IfcAddressTypeEnum::FromString(*entity->getArgument(0)); }
void IfcAddress::setPurpose(IfcAddressTypeEnum::IfcAddressTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcAddressTypeEnum::ToString(v)); }
bool IfcAddress::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcAddress::Description() { return *entity->getArgument(1); }
void IfcAddress::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcAddress::hasUserDefinedPurpose() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcAddress::UserDefinedPurpose() { return *entity->getArgument(2); }
void IfcAddress::setUserDefinedPurpose(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPerson::list IfcAddress::OfPerson() { RETURN_INVERSE(IfcPerson) }
IfcOrganization::list IfcAddress::OfOrganization() { RETURN_INVERSE(IfcOrganization) }
bool IfcAddress::is(Type::Enum v) const { return v == Type::IfcAddress; }
Type::Enum IfcAddress::type() const { return Type::IfcAddress; }
Type::Enum IfcAddress::Class() { return Type::IfcAddress; }
IfcAddress::IfcAddress(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcAddress)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAddress::IfcAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< IfcText > v2_Description, boost::optional< IfcLabel > v3_UserDefinedPurpose) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Purpose) { e->setArgument(0,*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_UserDefinedPurpose) { e->setArgument(2,(*v3_UserDefinedPurpose)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAdvancedBrep
bool IfcAdvancedBrep::is(Type::Enum v) const { return v == Type::IfcAdvancedBrep || IfcManifoldSolidBrep::is(v); }
Type::Enum IfcAdvancedBrep::type() const { return Type::IfcAdvancedBrep; }
Type::Enum IfcAdvancedBrep::Class() { return Type::IfcAdvancedBrep; }
IfcAdvancedBrep::IfcAdvancedBrep(IfcAbstractEntityPtr e) : IfcManifoldSolidBrep((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAdvancedBrep)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAdvancedBrep::IfcAdvancedBrep(IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Outer)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAdvancedBrepWithVoids
SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > IfcAdvancedBrepWithVoids::Voids() { RETURN_AS_LIST(IfcClosedShell,1) }
void IfcAdvancedBrepWithVoids::setVoids(SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcAdvancedBrepWithVoids::is(Type::Enum v) const { return v == Type::IfcAdvancedBrepWithVoids || IfcAdvancedBrep::is(v); }
Type::Enum IfcAdvancedBrepWithVoids::type() const { return Type::IfcAdvancedBrepWithVoids; }
Type::Enum IfcAdvancedBrepWithVoids::Class() { return Type::IfcAdvancedBrepWithVoids; }
IfcAdvancedBrepWithVoids::IfcAdvancedBrepWithVoids(IfcAbstractEntityPtr e) : IfcAdvancedBrep((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAdvancedBrepWithVoids)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAdvancedBrepWithVoids::IfcAdvancedBrepWithVoids(IfcClosedShell* v1_Outer, SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > v2_Voids) : IfcAdvancedBrep((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Outer)); e->setArgument(1,(v2_Voids)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAdvancedFace
bool IfcAdvancedFace::is(Type::Enum v) const { return v == Type::IfcAdvancedFace || IfcFaceSurface::is(v); }
Type::Enum IfcAdvancedFace::type() const { return Type::IfcAdvancedFace; }
Type::Enum IfcAdvancedFace::Class() { return Type::IfcAdvancedFace; }
IfcAdvancedFace::IfcAdvancedFace(IfcAbstractEntityPtr e) : IfcFaceSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAdvancedFace)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAdvancedFace::IfcAdvancedFace(SHARED_PTR< IfcTemplatedEntityList< IfcFaceBound > > v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFaceSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Bounds)->generalize()); e->setArgument(1,(v2_FaceSurface)); e->setArgument(2,(v3_SameSense)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirTerminal
bool IfcAirTerminal::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminal::PredefinedType() { return IfcAirTerminalTypeEnum::FromString(*entity->getArgument(8)); }
void IfcAirTerminal::setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAirTerminalTypeEnum::ToString(v)); }
bool IfcAirTerminal::is(Type::Enum v) const { return v == Type::IfcAirTerminal || IfcFlowTerminal::is(v); }
Type::Enum IfcAirTerminal::type() const { return Type::IfcAirTerminal; }
Type::Enum IfcAirTerminal::Class() { return Type::IfcAirTerminal; }
IfcAirTerminal::IfcAirTerminal(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminal::IfcAirTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcAirTerminalTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirTerminalBox
bool IfcAirTerminalBox::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBox::PredefinedType() { return IfcAirTerminalBoxTypeEnum::FromString(*entity->getArgument(8)); }
void IfcAirTerminalBox::setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAirTerminalBoxTypeEnum::ToString(v)); }
bool IfcAirTerminalBox::is(Type::Enum v) const { return v == Type::IfcAirTerminalBox || IfcFlowController::is(v); }
Type::Enum IfcAirTerminalBox::type() const { return Type::IfcAirTerminalBox; }
Type::Enum IfcAirTerminalBox::Class() { return Type::IfcAirTerminalBox; }
IfcAirTerminalBox::IfcAirTerminalBox(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirTerminalBox)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminalBox::IfcAirTerminalBox(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcAirTerminalBoxTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirTerminalBoxType
IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum IfcAirTerminalBoxType::PredefinedType() { return IfcAirTerminalBoxTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirTerminalBoxType::setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAirTerminalBoxTypeEnum::ToString(v)); }
bool IfcAirTerminalBoxType::is(Type::Enum v) const { return v == Type::IfcAirTerminalBoxType || IfcFlowControllerType::is(v); }
Type::Enum IfcAirTerminalBoxType::type() const { return Type::IfcAirTerminalBoxType; }
Type::Enum IfcAirTerminalBoxType::Class() { return Type::IfcAirTerminalBoxType; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirTerminalBoxType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminalBoxType::IfcAirTerminalBoxType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcAirTerminalBoxTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirTerminalType
IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum IfcAirTerminalType::PredefinedType() { return IfcAirTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirTerminalType::setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAirTerminalTypeEnum::ToString(v)); }
bool IfcAirTerminalType::is(Type::Enum v) const { return v == Type::IfcAirTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcAirTerminalType::type() const { return Type::IfcAirTerminalType; }
Type::Enum IfcAirTerminalType::Class() { return Type::IfcAirTerminalType; }
IfcAirTerminalType::IfcAirTerminalType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirTerminalType::IfcAirTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcAirTerminalTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirToAirHeatRecovery
bool IfcAirToAirHeatRecovery::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecovery::PredefinedType() { return IfcAirToAirHeatRecoveryTypeEnum::FromString(*entity->getArgument(8)); }
void IfcAirToAirHeatRecovery::setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAirToAirHeatRecoveryTypeEnum::ToString(v)); }
bool IfcAirToAirHeatRecovery::is(Type::Enum v) const { return v == Type::IfcAirToAirHeatRecovery || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcAirToAirHeatRecovery::type() const { return Type::IfcAirToAirHeatRecovery; }
Type::Enum IfcAirToAirHeatRecovery::Class() { return Type::IfcAirToAirHeatRecovery; }
IfcAirToAirHeatRecovery::IfcAirToAirHeatRecovery(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirToAirHeatRecovery)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirToAirHeatRecovery::IfcAirToAirHeatRecovery(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcAirToAirHeatRecoveryTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAirToAirHeatRecoveryType
IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum IfcAirToAirHeatRecoveryType::PredefinedType() { return IfcAirToAirHeatRecoveryTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAirToAirHeatRecoveryType::setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAirToAirHeatRecoveryTypeEnum::ToString(v)); }
bool IfcAirToAirHeatRecoveryType::is(Type::Enum v) const { return v == Type::IfcAirToAirHeatRecoveryType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcAirToAirHeatRecoveryType::type() const { return Type::IfcAirToAirHeatRecoveryType; }
Type::Enum IfcAirToAirHeatRecoveryType::Class() { return Type::IfcAirToAirHeatRecoveryType; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAirToAirHeatRecoveryType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAirToAirHeatRecoveryType::IfcAirToAirHeatRecoveryType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcAirToAirHeatRecoveryTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAlarm
bool IfcAlarm::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarm::PredefinedType() { return IfcAlarmTypeEnum::FromString(*entity->getArgument(8)); }
void IfcAlarm::setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAlarmTypeEnum::ToString(v)); }
bool IfcAlarm::is(Type::Enum v) const { return v == Type::IfcAlarm || IfcDistributionControlElement::is(v); }
Type::Enum IfcAlarm::type() const { return Type::IfcAlarm; }
Type::Enum IfcAlarm::Class() { return Type::IfcAlarm; }
IfcAlarm::IfcAlarm(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAlarm)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAlarm::IfcAlarm(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAlarmTypeEnum::IfcAlarmTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcAlarmTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAlarmType
IfcAlarmTypeEnum::IfcAlarmTypeEnum IfcAlarmType::PredefinedType() { return IfcAlarmTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAlarmType::setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAlarmTypeEnum::ToString(v)); }
bool IfcAlarmType::is(Type::Enum v) const { return v == Type::IfcAlarmType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcAlarmType::type() const { return Type::IfcAlarmType; }
Type::Enum IfcAlarmType::Class() { return Type::IfcAlarmType; }
IfcAlarmType::IfcAlarmType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAlarmType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAlarmType::IfcAlarmType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAlarmTypeEnum::IfcAlarmTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcAlarmTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAnnotation
IfcRelContainedInSpatialStructure::list IfcAnnotation::ContainedInStructure() { RETURN_INVERSE(IfcRelContainedInSpatialStructure) }
bool IfcAnnotation::is(Type::Enum v) const { return v == Type::IfcAnnotation || IfcProduct::is(v); }
Type::Enum IfcAnnotation::type() const { return Type::IfcAnnotation; }
Type::Enum IfcAnnotation::Class() { return Type::IfcAnnotation; }
IfcAnnotation::IfcAnnotation(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAnnotation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotation::IfcAnnotation(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAnnotationFillArea
IfcCurve* IfcAnnotationFillArea::OuterBoundary() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcAnnotationFillArea::setOuterBoundary(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcAnnotationFillArea::hasInnerBoundaries() { return !entity->getArgument(1)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > IfcAnnotationFillArea::InnerBoundaries() { RETURN_AS_LIST(IfcCurve,1) }
void IfcAnnotationFillArea::setInnerBoundaries(SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcAnnotationFillArea::is(Type::Enum v) const { return v == Type::IfcAnnotationFillArea || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcAnnotationFillArea::type() const { return Type::IfcAnnotationFillArea; }
Type::Enum IfcAnnotationFillArea::Class() { return Type::IfcAnnotationFillArea; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAnnotationFillArea)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAnnotationFillArea::IfcAnnotationFillArea(IfcCurve* v1_OuterBoundary, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > > v2_InnerBoundaries) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_OuterBoundary)); if (v2_InnerBoundaries) { e->setArgument(1,(*v2_InnerBoundaries)->generalize()); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcApplication
IfcOrganization* IfcApplication::ApplicationDeveloper() { return (IfcOrganization*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcApplication::setApplicationDeveloper(IfcOrganization* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLabel IfcApplication::Version() { return *entity->getArgument(1); }
void IfcApplication::setVersion(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcLabel IfcApplication::ApplicationFullName() { return *entity->getArgument(2); }
void IfcApplication::setApplicationFullName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcIdentifier IfcApplication::ApplicationIdentifier() { return *entity->getArgument(3); }
void IfcApplication::setApplicationIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcApplication::is(Type::Enum v) const { return v == Type::IfcApplication; }
Type::Enum IfcApplication::type() const { return Type::IfcApplication; }
Type::Enum IfcApplication::Class() { return Type::IfcApplication; }
IfcApplication::IfcApplication(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcApplication)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApplication::IfcApplication(IfcOrganization* v1_ApplicationDeveloper, IfcLabel v2_Version, IfcLabel v3_ApplicationFullName, IfcIdentifier v4_ApplicationIdentifier) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ApplicationDeveloper)); e->setArgument(1,(v2_Version)); e->setArgument(2,(v3_ApplicationFullName)); e->setArgument(3,(v4_ApplicationIdentifier)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAppliedValue
bool IfcAppliedValue::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcAppliedValue::Name() { return *entity->getArgument(0); }
void IfcAppliedValue::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcAppliedValue::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcAppliedValue::Description() { return *entity->getArgument(1); }
void IfcAppliedValue::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcAppliedValue::hasAppliedValue() { return !entity->getArgument(2)->isNull(); }
IfcAppliedValueSelect IfcAppliedValue::AppliedValue() { return *entity->getArgument(2); }
void IfcAppliedValue::setAppliedValue(IfcAppliedValueSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcAppliedValue::hasUnitBasis() { return !entity->getArgument(3)->isNull(); }
IfcMeasureWithUnit* IfcAppliedValue::UnitBasis() { return (IfcMeasureWithUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcAppliedValue::setUnitBasis(IfcMeasureWithUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcAppliedValue::hasApplicableDate() { return !entity->getArgument(4)->isNull(); }
IfcDate IfcAppliedValue::ApplicableDate() { return *entity->getArgument(4); }
void IfcAppliedValue::setApplicableDate(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcAppliedValue::hasFixedUntilDate() { return !entity->getArgument(5)->isNull(); }
IfcDate IfcAppliedValue::FixedUntilDate() { return *entity->getArgument(5); }
void IfcAppliedValue::setFixedUntilDate(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcAppliedValue::hasCategory() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcAppliedValue::Category() { return *entity->getArgument(6); }
void IfcAppliedValue::setCategory(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcAppliedValue::hasCondition() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcAppliedValue::Condition() { return *entity->getArgument(7); }
void IfcAppliedValue::setCondition(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcAppliedValue::hasArithmeticOperator() { return !entity->getArgument(8)->isNull(); }
IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum IfcAppliedValue::ArithmeticOperator() { return IfcArithmeticOperatorEnum::FromString(*entity->getArgument(8)); }
void IfcAppliedValue::setArithmeticOperator(IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcArithmeticOperatorEnum::ToString(v)); }
bool IfcAppliedValue::hasComponents() { return !entity->getArgument(9)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > IfcAppliedValue::Components() { RETURN_AS_LIST(IfcAppliedValue,9) }
void IfcAppliedValue::setComponents(SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v->generalize()); }
IfcExternalReferenceRelationship::list IfcAppliedValue::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcAppliedValue::is(Type::Enum v) const { return v == Type::IfcAppliedValue; }
Type::Enum IfcAppliedValue::type() const { return Type::IfcAppliedValue; }
Type::Enum IfcAppliedValue::Class() { return Type::IfcAppliedValue; }
IfcAppliedValue::IfcAppliedValue(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcAppliedValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAppliedValue::IfcAppliedValue(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcAppliedValueSelect > v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< IfcDate > v5_ApplicableDate, boost::optional< IfcDate > v6_FixedUntilDate, boost::optional< IfcLabel > v7_Category, boost::optional< IfcLabel > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_Components) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_AppliedValue) { e->setArgument(2,(*v3_AppliedValue)); } else { e->setArgument(2); } e->setArgument(3,(v4_UnitBasis)); if (v5_ApplicableDate) { e->setArgument(4,(*v5_ApplicableDate)); } else { e->setArgument(4); } if (v6_FixedUntilDate) { e->setArgument(5,(*v6_FixedUntilDate)); } else { e->setArgument(5); } if (v7_Category) { e->setArgument(6,(*v7_Category)); } else { e->setArgument(6); } if (v8_Condition) { e->setArgument(7,(*v8_Condition)); } else { e->setArgument(7); } if (v9_ArithmeticOperator) { e->setArgument(8,*v9_ArithmeticOperator,IfcArithmeticOperatorEnum::ToString(*v9_ArithmeticOperator)); } else { e->setArgument(8); } if (v10_Components) { e->setArgument(9,(*v10_Components)->generalize()); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcApproval
bool IfcApproval::hasIdentifier() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcApproval::Identifier() { return *entity->getArgument(0); }
void IfcApproval::setIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcApproval::hasName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcApproval::Name() { return *entity->getArgument(1); }
void IfcApproval::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcApproval::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcApproval::Description() { return *entity->getArgument(2); }
void IfcApproval::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcApproval::hasTimeOfApproval() { return !entity->getArgument(3)->isNull(); }
IfcDateTime IfcApproval::TimeOfApproval() { return *entity->getArgument(3); }
void IfcApproval::setTimeOfApproval(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcApproval::hasStatus() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcApproval::Status() { return *entity->getArgument(4); }
void IfcApproval::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcApproval::hasLevel() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcApproval::Level() { return *entity->getArgument(5); }
void IfcApproval::setLevel(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcApproval::hasQualifier() { return !entity->getArgument(6)->isNull(); }
IfcText IfcApproval::Qualifier() { return *entity->getArgument(6); }
void IfcApproval::setQualifier(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcApproval::hasRequestingApproval() { return !entity->getArgument(7)->isNull(); }
IfcActorSelect IfcApproval::RequestingApproval() { return *entity->getArgument(7); }
void IfcApproval::setRequestingApproval(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcApproval::hasGivingApproval() { return !entity->getArgument(8)->isNull(); }
IfcActorSelect IfcApproval::GivingApproval() { return *entity->getArgument(8); }
void IfcApproval::setGivingApproval(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcExternalReferenceRelationship::list IfcApproval::HasExternalReferences() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
IfcRelAssociatesApproval::list IfcApproval::ApprovedObjects() { RETURN_INVERSE(IfcRelAssociatesApproval) }
IfcResourceApprovalRelationship::list IfcApproval::ApprovedResources() { RETURN_INVERSE(IfcResourceApprovalRelationship) }
IfcApprovalRelationship::list IfcApproval::IsRelatedWith() { RETURN_INVERSE(IfcApprovalRelationship) }
IfcApprovalRelationship::list IfcApproval::Relates() { RETURN_INVERSE(IfcApprovalRelationship) }
bool IfcApproval::is(Type::Enum v) const { return v == Type::IfcApproval; }
Type::Enum IfcApproval::type() const { return Type::IfcApproval; }
Type::Enum IfcApproval::Class() { return Type::IfcApproval; }
IfcApproval::IfcApproval(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcApproval)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApproval::IfcApproval(boost::optional< IfcIdentifier > v1_Identifier, boost::optional< IfcLabel > v2_Name, boost::optional< IfcText > v3_Description, boost::optional< IfcDateTime > v4_TimeOfApproval, boost::optional< IfcLabel > v5_Status, boost::optional< IfcLabel > v6_Level, boost::optional< IfcText > v7_Qualifier, boost::optional< IfcActorSelect > v8_RequestingApproval, boost::optional< IfcActorSelect > v9_GivingApproval) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Identifier) { e->setArgument(0,(*v1_Identifier)); } else { e->setArgument(0); } if (v2_Name) { e->setArgument(1,(*v2_Name)); } else { e->setArgument(1); } if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } if (v4_TimeOfApproval) { e->setArgument(3,(*v4_TimeOfApproval)); } else { e->setArgument(3); } if (v5_Status) { e->setArgument(4,(*v5_Status)); } else { e->setArgument(4); } if (v6_Level) { e->setArgument(5,(*v6_Level)); } else { e->setArgument(5); } if (v7_Qualifier) { e->setArgument(6,(*v7_Qualifier)); } else { e->setArgument(6); } if (v8_RequestingApproval) { e->setArgument(7,(*v8_RequestingApproval)); } else { e->setArgument(7); } if (v9_GivingApproval) { e->setArgument(8,(*v9_GivingApproval)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcApprovalRelationship
IfcApproval* IfcApprovalRelationship::RelatingApproval() { return (IfcApproval*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcApprovalRelationship::setRelatingApproval(IfcApproval* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcApproval > > IfcApprovalRelationship::RelatedApprovals() { RETURN_AS_LIST(IfcApproval,3) }
void IfcApprovalRelationship::setRelatedApprovals(SHARED_PTR< IfcTemplatedEntityList< IfcApproval > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcApprovalRelationship::is(Type::Enum v) const { return v == Type::IfcApprovalRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcApprovalRelationship::type() const { return Type::IfcApprovalRelationship; }
Type::Enum IfcApprovalRelationship::Class() { return Type::IfcApprovalRelationship; }
IfcApprovalRelationship::IfcApprovalRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcApprovalRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcApprovalRelationship::IfcApprovalRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcApproval* v3_RelatingApproval, SHARED_PTR< IfcTemplatedEntityList< IfcApproval > > v4_RelatedApprovals) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingApproval)); e->setArgument(3,(v4_RelatedApprovals)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcArbitraryClosedProfileDef
IfcCurve* IfcArbitraryClosedProfileDef::OuterCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcArbitraryClosedProfileDef::setOuterCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcArbitraryClosedProfileDef::is(Type::Enum v) const { return v == Type::IfcArbitraryClosedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcArbitraryClosedProfileDef::type() const { return Type::IfcArbitraryClosedProfileDef; }
Type::Enum IfcArbitraryClosedProfileDef::Class() { return Type::IfcArbitraryClosedProfileDef; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcAbstractEntityPtr e) : IfcProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcArbitraryClosedProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryClosedProfileDef::IfcArbitraryClosedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcCurve* v3_OuterCurve) : IfcProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_OuterCurve)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcArbitraryOpenProfileDef
IfcBoundedCurve* IfcArbitraryOpenProfileDef::Curve() { return (IfcBoundedCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcArbitraryOpenProfileDef::setCurve(IfcBoundedCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcArbitraryOpenProfileDef::is(Type::Enum v) const { return v == Type::IfcArbitraryOpenProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcArbitraryOpenProfileDef::type() const { return Type::IfcArbitraryOpenProfileDef; }
Type::Enum IfcArbitraryOpenProfileDef::Class() { return Type::IfcArbitraryOpenProfileDef; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcAbstractEntityPtr e) : IfcProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcArbitraryOpenProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryOpenProfileDef::IfcArbitraryOpenProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcBoundedCurve* v3_Curve) : IfcProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Curve)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcArbitraryProfileDefWithVoids
SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > IfcArbitraryProfileDefWithVoids::InnerCurves() { RETURN_AS_LIST(IfcCurve,3) }
void IfcArbitraryProfileDefWithVoids::setInnerCurves(SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcArbitraryProfileDefWithVoids::is(Type::Enum v) const { return v == Type::IfcArbitraryProfileDefWithVoids || IfcArbitraryClosedProfileDef::is(v); }
Type::Enum IfcArbitraryProfileDefWithVoids::type() const { return Type::IfcArbitraryProfileDefWithVoids; }
Type::Enum IfcArbitraryProfileDefWithVoids::Class() { return Type::IfcArbitraryProfileDefWithVoids; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcAbstractEntityPtr e) : IfcArbitraryClosedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcArbitraryProfileDefWithVoids)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcArbitraryProfileDefWithVoids::IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcCurve* v3_OuterCurve, SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > v4_InnerCurves) : IfcArbitraryClosedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_OuterCurve)); e->setArgument(3,(v4_InnerCurves)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAsset
bool IfcAsset::hasIdentification() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcAsset::Identification() { return *entity->getArgument(5); }
void IfcAsset::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcAsset::hasOriginalValue() { return !entity->getArgument(6)->isNull(); }
IfcCostValue* IfcAsset::OriginalValue() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcAsset::setOriginalValue(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcAsset::hasCurrentValue() { return !entity->getArgument(7)->isNull(); }
IfcCostValue* IfcAsset::CurrentValue() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcAsset::setCurrentValue(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcAsset::hasTotalReplacementCost() { return !entity->getArgument(8)->isNull(); }
IfcCostValue* IfcAsset::TotalReplacementCost() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcAsset::setTotalReplacementCost(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcAsset::hasOwner() { return !entity->getArgument(9)->isNull(); }
IfcActorSelect IfcAsset::Owner() { return *entity->getArgument(9); }
void IfcAsset::setOwner(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcAsset::hasUser() { return !entity->getArgument(10)->isNull(); }
IfcActorSelect IfcAsset::User() { return *entity->getArgument(10); }
void IfcAsset::setUser(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcAsset::hasResponsiblePerson() { return !entity->getArgument(11)->isNull(); }
IfcPerson* IfcAsset::ResponsiblePerson() { return (IfcPerson*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(11))); }
void IfcAsset::setResponsiblePerson(IfcPerson* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcAsset::hasIncorporationDate() { return !entity->getArgument(12)->isNull(); }
IfcDate IfcAsset::IncorporationDate() { return *entity->getArgument(12); }
void IfcAsset::setIncorporationDate(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcAsset::hasDepreciatedValue() { return !entity->getArgument(13)->isNull(); }
IfcCostValue* IfcAsset::DepreciatedValue() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(13))); }
void IfcAsset::setDepreciatedValue(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcAsset::is(Type::Enum v) const { return v == Type::IfcAsset || IfcGroup::is(v); }
Type::Enum IfcAsset::type() const { return Type::IfcAsset; }
Type::Enum IfcAsset::Class() { return Type::IfcAsset; }
IfcAsset::IfcAsset(IfcAbstractEntityPtr e) : IfcGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAsset)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAsset::IfcAsset(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, IfcCostValue* v7_OriginalValue, IfcCostValue* v8_CurrentValue, IfcCostValue* v9_TotalReplacementCost, boost::optional< IfcActorSelect > v10_Owner, boost::optional< IfcActorSelect > v11_User, IfcPerson* v12_ResponsiblePerson, boost::optional< IfcDate > v13_IncorporationDate, IfcCostValue* v14_DepreciatedValue) : IfcGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } e->setArgument(6,(v7_OriginalValue)); e->setArgument(7,(v8_CurrentValue)); e->setArgument(8,(v9_TotalReplacementCost)); if (v10_Owner) { e->setArgument(9,(*v10_Owner)); } else { e->setArgument(9); } if (v11_User) { e->setArgument(10,(*v11_User)); } else { e->setArgument(10); } e->setArgument(11,(v12_ResponsiblePerson)); if (v13_IncorporationDate) { e->setArgument(12,(*v13_IncorporationDate)); } else { e->setArgument(12); } e->setArgument(13,(v14_DepreciatedValue)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAsymmetricIShapeProfileDef
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::BottomFlangeWidth() { return *entity->getArgument(3); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::OverallDepth() { return *entity->getArgument(4); }
void IfcAsymmetricIShapeProfileDef::setOverallDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::WebThickness() { return *entity->getArgument(5); }
void IfcAsymmetricIShapeProfileDef::setWebThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::BottomFlangeThickness() { return *entity->getArgument(6); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcAsymmetricIShapeProfileDef::BottomFlangeFilletRadius() { return *entity->getArgument(7); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::TopFlangeWidth() { return *entity->getArgument(8); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeThickness() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcAsymmetricIShapeProfileDef::TopFlangeThickness() { return *entity->getArgument(9); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeFilletRadius() { return !entity->getArgument(10)->isNull(); }
IfcNonNegativeLengthMeasure IfcAsymmetricIShapeProfileDef::TopFlangeFilletRadius() { return *entity->getArgument(10); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeEdgeRadius() { return !entity->getArgument(11)->isNull(); }
IfcNonNegativeLengthMeasure IfcAsymmetricIShapeProfileDef::BottomFlangeEdgeRadius() { return *entity->getArgument(11); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcAsymmetricIShapeProfileDef::hasBottomFlangeSlope() { return !entity->getArgument(12)->isNull(); }
IfcPlaneAngleMeasure IfcAsymmetricIShapeProfileDef::BottomFlangeSlope() { return *entity->getArgument(12); }
void IfcAsymmetricIShapeProfileDef::setBottomFlangeSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeEdgeRadius() { return !entity->getArgument(13)->isNull(); }
IfcNonNegativeLengthMeasure IfcAsymmetricIShapeProfileDef::TopFlangeEdgeRadius() { return *entity->getArgument(13); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcAsymmetricIShapeProfileDef::hasTopFlangeSlope() { return !entity->getArgument(14)->isNull(); }
IfcPlaneAngleMeasure IfcAsymmetricIShapeProfileDef::TopFlangeSlope() { return *entity->getArgument(14); }
void IfcAsymmetricIShapeProfileDef::setTopFlangeSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcAsymmetricIShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcAsymmetricIShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcAsymmetricIShapeProfileDef::type() const { return Type::IfcAsymmetricIShapeProfileDef; }
Type::Enum IfcAsymmetricIShapeProfileDef::Class() { return Type::IfcAsymmetricIShapeProfileDef; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAsymmetricIShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAsymmetricIShapeProfileDef::IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_BottomFlangeWidth, IfcPositiveLengthMeasure v5_OverallDepth, IfcPositiveLengthMeasure v6_WebThickness, IfcPositiveLengthMeasure v7_BottomFlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_BottomFlangeFilletRadius, IfcPositiveLengthMeasure v9_TopFlangeWidth, boost::optional< IfcPositiveLengthMeasure > v10_TopFlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v11_TopFlangeFilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v12_BottomFlangeEdgeRadius, boost::optional< IfcPlaneAngleMeasure > v13_BottomFlangeSlope, boost::optional< IfcNonNegativeLengthMeasure > v14_TopFlangeEdgeRadius, boost::optional< IfcPlaneAngleMeasure > v15_TopFlangeSlope) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_BottomFlangeWidth)); e->setArgument(4,(v5_OverallDepth)); e->setArgument(5,(v6_WebThickness)); e->setArgument(6,(v7_BottomFlangeThickness)); if (v8_BottomFlangeFilletRadius) { e->setArgument(7,(*v8_BottomFlangeFilletRadius)); } else { e->setArgument(7); } e->setArgument(8,(v9_TopFlangeWidth)); if (v10_TopFlangeThickness) { e->setArgument(9,(*v10_TopFlangeThickness)); } else { e->setArgument(9); } if (v11_TopFlangeFilletRadius) { e->setArgument(10,(*v11_TopFlangeFilletRadius)); } else { e->setArgument(10); } if (v12_BottomFlangeEdgeRadius) { e->setArgument(11,(*v12_BottomFlangeEdgeRadius)); } else { e->setArgument(11); } if (v13_BottomFlangeSlope) { e->setArgument(12,(*v13_BottomFlangeSlope)); } else { e->setArgument(12); } if (v14_TopFlangeEdgeRadius) { e->setArgument(13,(*v14_TopFlangeEdgeRadius)); } else { e->setArgument(13); } if (v15_TopFlangeSlope) { e->setArgument(14,(*v15_TopFlangeSlope)); } else { e->setArgument(14); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAudioVisualAppliance
bool IfcAudioVisualAppliance::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualAppliance::PredefinedType() { return IfcAudioVisualApplianceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcAudioVisualAppliance::setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAudioVisualApplianceTypeEnum::ToString(v)); }
bool IfcAudioVisualAppliance::is(Type::Enum v) const { return v == Type::IfcAudioVisualAppliance || IfcFlowTerminal::is(v); }
Type::Enum IfcAudioVisualAppliance::type() const { return Type::IfcAudioVisualAppliance; }
Type::Enum IfcAudioVisualAppliance::Class() { return Type::IfcAudioVisualAppliance; }
IfcAudioVisualAppliance::IfcAudioVisualAppliance(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAudioVisualAppliance)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAudioVisualAppliance::IfcAudioVisualAppliance(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcAudioVisualApplianceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAudioVisualApplianceType
IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum IfcAudioVisualApplianceType::PredefinedType() { return IfcAudioVisualApplianceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcAudioVisualApplianceType::setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAudioVisualApplianceTypeEnum::ToString(v)); }
bool IfcAudioVisualApplianceType::is(Type::Enum v) const { return v == Type::IfcAudioVisualApplianceType || IfcFlowTerminalType::is(v); }
Type::Enum IfcAudioVisualApplianceType::type() const { return Type::IfcAudioVisualApplianceType; }
Type::Enum IfcAudioVisualApplianceType::Class() { return Type::IfcAudioVisualApplianceType; }
IfcAudioVisualApplianceType::IfcAudioVisualApplianceType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAudioVisualApplianceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAudioVisualApplianceType::IfcAudioVisualApplianceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcAudioVisualApplianceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAxis1Placement
bool IfcAxis1Placement::hasAxis() { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis1Placement::Axis() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcAxis1Placement::setAxis(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcAxis1Placement::is(Type::Enum v) const { return v == Type::IfcAxis1Placement || IfcPlacement::is(v); }
Type::Enum IfcAxis1Placement::type() const { return Type::IfcAxis1Placement; }
Type::Enum IfcAxis1Placement::Class() { return Type::IfcAxis1Placement; }
IfcAxis1Placement::IfcAxis1Placement(IfcAbstractEntityPtr e) : IfcPlacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAxis1Placement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis1Placement::IfcAxis1Placement(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis) : IfcPlacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Location)); e->setArgument(1,(v2_Axis)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAxis2Placement2D
bool IfcAxis2Placement2D::hasRefDirection() { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement2D::RefDirection() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcAxis2Placement2D::setRefDirection(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcAxis2Placement2D::is(Type::Enum v) const { return v == Type::IfcAxis2Placement2D || IfcPlacement::is(v); }
Type::Enum IfcAxis2Placement2D::type() const { return Type::IfcAxis2Placement2D; }
Type::Enum IfcAxis2Placement2D::Class() { return Type::IfcAxis2Placement2D; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcAbstractEntityPtr e) : IfcPlacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAxis2Placement2D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis2Placement2D::IfcAxis2Placement2D(IfcCartesianPoint* v1_Location, IfcDirection* v2_RefDirection) : IfcPlacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Location)); e->setArgument(1,(v2_RefDirection)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcAxis2Placement3D
bool IfcAxis2Placement3D::hasAxis() { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcAxis2Placement3D::Axis() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcAxis2Placement3D::setAxis(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcAxis2Placement3D::hasRefDirection() { return !entity->getArgument(2)->isNull(); }
IfcDirection* IfcAxis2Placement3D::RefDirection() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcAxis2Placement3D::setRefDirection(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcAxis2Placement3D::is(Type::Enum v) const { return v == Type::IfcAxis2Placement3D || IfcPlacement::is(v); }
Type::Enum IfcAxis2Placement3D::type() const { return Type::IfcAxis2Placement3D; }
Type::Enum IfcAxis2Placement3D::Class() { return Type::IfcAxis2Placement3D; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcAbstractEntityPtr e) : IfcPlacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcAxis2Placement3D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcAxis2Placement3D::IfcAxis2Placement3D(IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis, IfcDirection* v3_RefDirection) : IfcPlacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Location)); e->setArgument(1,(v2_Axis)); e->setArgument(2,(v3_RefDirection)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBSplineCurve
int IfcBSplineCurve::Degree() { return *entity->getArgument(0); }
void IfcBSplineCurve::setDegree(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > IfcBSplineCurve::ControlPointsList() { RETURN_AS_LIST(IfcCartesianPoint,1) }
void IfcBSplineCurve::setControlPointsList(SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
IfcBSplineCurveForm::IfcBSplineCurveForm IfcBSplineCurve::CurveForm() { return IfcBSplineCurveForm::FromString(*entity->getArgument(2)); }
void IfcBSplineCurve::setCurveForm(IfcBSplineCurveForm::IfcBSplineCurveForm v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcBSplineCurveForm::ToString(v)); }
bool IfcBSplineCurve::ClosedCurve() { return *entity->getArgument(3); }
void IfcBSplineCurve::setClosedCurve(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBSplineCurve::SelfIntersect() { return *entity->getArgument(4); }
void IfcBSplineCurve::setSelfIntersect(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcBSplineCurve::is(Type::Enum v) const { return v == Type::IfcBSplineCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcBSplineCurve::type() const { return Type::IfcBSplineCurve; }
Type::Enum IfcBSplineCurve::Class() { return Type::IfcBSplineCurve; }
IfcBSplineCurve::IfcBSplineCurve(IfcAbstractEntityPtr e) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBSplineCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBSplineCurve::IfcBSplineCurve(int v1_Degree, SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Degree)); e->setArgument(1,(v2_ControlPointsList)->generalize()); e->setArgument(2,v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm)); e->setArgument(3,(v4_ClosedCurve)); e->setArgument(4,(v5_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBSplineCurveWithKnots
std::vector< int > /*[2:?]*/ IfcBSplineCurveWithKnots::KnotMultiplicities() { return *entity->getArgument(5); }
void IfcBSplineCurveWithKnots::setKnotMultiplicities(std::vector< int > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
std::vector< IfcParameterValue > /*[2:?]*/ IfcBSplineCurveWithKnots::Knots() { return *entity->getArgument(6); }
void IfcBSplineCurveWithKnots::setKnots(std::vector< IfcParameterValue > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcKnotType::IfcKnotType IfcBSplineCurveWithKnots::KnotSpec() { return IfcKnotType::FromString(*entity->getArgument(7)); }
void IfcBSplineCurveWithKnots::setKnotSpec(IfcKnotType::IfcKnotType v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcKnotType::ToString(v)); }
bool IfcBSplineCurveWithKnots::is(Type::Enum v) const { return v == Type::IfcBSplineCurveWithKnots || IfcBSplineCurve::is(v); }
Type::Enum IfcBSplineCurveWithKnots::type() const { return Type::IfcBSplineCurveWithKnots; }
Type::Enum IfcBSplineCurveWithKnots::Class() { return Type::IfcBSplineCurveWithKnots; }
IfcBSplineCurveWithKnots::IfcBSplineCurveWithKnots(IfcAbstractEntityPtr e) : IfcBSplineCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBSplineCurveWithKnots)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBSplineCurveWithKnots::IfcBSplineCurveWithKnots(int v1_Degree, SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< IfcParameterValue > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec) : IfcBSplineCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Degree)); e->setArgument(1,(v2_ControlPointsList)->generalize()); e->setArgument(2,v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm)); e->setArgument(3,(v4_ClosedCurve)); e->setArgument(4,(v5_SelfIntersect)); e->setArgument(5,(v6_KnotMultiplicities)); e->setArgument(6,(v7_Knots)); e->setArgument(7,v8_KnotSpec,IfcKnotType::ToString(v8_KnotSpec)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBSplineSurface
int IfcBSplineSurface::UDegree() { return *entity->getArgument(0); }
void IfcBSplineSurface::setUDegree(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
int IfcBSplineSurface::VDegree() { return *entity->getArgument(1); }
void IfcBSplineSurface::setVDegree(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcBSplineSurfaceForm::IfcBSplineSurfaceForm IfcBSplineSurface::SurfaceForm() { return IfcBSplineSurfaceForm::FromString(*entity->getArgument(3)); }
void IfcBSplineSurface::setSurfaceForm(IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v,IfcBSplineSurfaceForm::ToString(v)); }
bool IfcBSplineSurface::UClosed() { return *entity->getArgument(4); }
void IfcBSplineSurface::setUClosed(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcBSplineSurface::VClosed() { return *entity->getArgument(5); }
void IfcBSplineSurface::setVClosed(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcBSplineSurface::SelfIntersect() { return *entity->getArgument(6); }
void IfcBSplineSurface::setSelfIntersect(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcBSplineSurface::is(Type::Enum v) const { return v == Type::IfcBSplineSurface || IfcBoundedSurface::is(v); }
Type::Enum IfcBSplineSurface::type() const { return Type::IfcBSplineSurface; }
Type::Enum IfcBSplineSurface::Class() { return Type::IfcBSplineSurface; }
IfcBSplineSurface::IfcBSplineSurface(IfcAbstractEntityPtr e) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBSplineSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBSplineSurface::IfcBSplineSurface(int v1_UDegree, int v2_VDegree, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_UDegree)); e->setArgument(1,(v2_VDegree)); e->setArgument(3,v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm)); e->setArgument(4,(v5_UClosed)); e->setArgument(5,(v6_VClosed)); e->setArgument(6,(v7_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBSplineSurfaceWithKnots
std::vector< int > /*[2:?]*/ IfcBSplineSurfaceWithKnots::UMultiplicities() { return *entity->getArgument(7); }
void IfcBSplineSurfaceWithKnots::setUMultiplicities(std::vector< int > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
std::vector< int > /*[2:?]*/ IfcBSplineSurfaceWithKnots::VMultiplicities() { return *entity->getArgument(8); }
void IfcBSplineSurfaceWithKnots::setVMultiplicities(std::vector< int > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
std::vector< IfcParameterValue > /*[2:?]*/ IfcBSplineSurfaceWithKnots::UKnots() { return *entity->getArgument(9); }
void IfcBSplineSurfaceWithKnots::setUKnots(std::vector< IfcParameterValue > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
std::vector< IfcParameterValue > /*[2:?]*/ IfcBSplineSurfaceWithKnots::VKnots() { return *entity->getArgument(10); }
void IfcBSplineSurfaceWithKnots::setVKnots(std::vector< IfcParameterValue > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
IfcKnotType::IfcKnotType IfcBSplineSurfaceWithKnots::KnotSpec() { return IfcKnotType::FromString(*entity->getArgument(11)); }
void IfcBSplineSurfaceWithKnots::setKnotSpec(IfcKnotType::IfcKnotType v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcKnotType::ToString(v)); }
bool IfcBSplineSurfaceWithKnots::is(Type::Enum v) const { return v == Type::IfcBSplineSurfaceWithKnots || IfcBSplineSurface::is(v); }
Type::Enum IfcBSplineSurfaceWithKnots::type() const { return Type::IfcBSplineSurfaceWithKnots; }
Type::Enum IfcBSplineSurfaceWithKnots::Class() { return Type::IfcBSplineSurfaceWithKnots; }
IfcBSplineSurfaceWithKnots::IfcBSplineSurfaceWithKnots(IfcAbstractEntityPtr e) : IfcBSplineSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBSplineSurfaceWithKnots)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBSplineSurfaceWithKnots::IfcBSplineSurfaceWithKnots(int v1_UDegree, int v2_VDegree, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< IfcParameterValue > /*[2:?]*/ v10_UKnots, std::vector< IfcParameterValue > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec) : IfcBSplineSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_UDegree)); e->setArgument(1,(v2_VDegree)); e->setArgument(3,v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm)); e->setArgument(4,(v5_UClosed)); e->setArgument(5,(v6_VClosed)); e->setArgument(6,(v7_SelfIntersect)); e->setArgument(7,(v8_UMultiplicities)); e->setArgument(8,(v9_VMultiplicities)); e->setArgument(9,(v10_UKnots)); e->setArgument(10,(v11_VKnots)); e->setArgument(11,v12_KnotSpec,IfcKnotType::ToString(v12_KnotSpec)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBeam
bool IfcBeam::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeam::PredefinedType() { return IfcBeamTypeEnum::FromString(*entity->getArgument(8)); }
void IfcBeam::setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcBeamTypeEnum::ToString(v)); }
bool IfcBeam::is(Type::Enum v) const { return v == Type::IfcBeam || IfcBuildingElement::is(v); }
Type::Enum IfcBeam::type() const { return Type::IfcBeam; }
Type::Enum IfcBeam::Class() { return Type::IfcBeam; }
IfcBeam::IfcBeam(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBeam)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBeam::IfcBeam(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBeamTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBeamStandardCase
bool IfcBeamStandardCase::is(Type::Enum v) const { return v == Type::IfcBeamStandardCase || IfcBeam::is(v); }
Type::Enum IfcBeamStandardCase::type() const { return Type::IfcBeamStandardCase; }
Type::Enum IfcBeamStandardCase::Class() { return Type::IfcBeamStandardCase; }
IfcBeamStandardCase::IfcBeamStandardCase(IfcAbstractEntityPtr e) : IfcBeam((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBeamStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBeamStandardCase::IfcBeamStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType) : IfcBeam((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBeamTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBeamType
IfcBeamTypeEnum::IfcBeamTypeEnum IfcBeamType::PredefinedType() { return IfcBeamTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBeamType::setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcBeamTypeEnum::ToString(v)); }
bool IfcBeamType::is(Type::Enum v) const { return v == Type::IfcBeamType || IfcBuildingElementType::is(v); }
Type::Enum IfcBeamType::type() const { return Type::IfcBeamType; }
Type::Enum IfcBeamType::Class() { return Type::IfcBeamType; }
IfcBeamType::IfcBeamType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBeamType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBeamType::IfcBeamType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcBeamTypeEnum::IfcBeamTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcBeamTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBlobTexture
IfcIdentifier IfcBlobTexture::RasterFormat() { return *entity->getArgument(5); }
void IfcBlobTexture::setRasterFormat(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcBlobTexture::is(Type::Enum v) const { return v == Type::IfcBlobTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcBlobTexture::type() const { return Type::IfcBlobTexture; }
Type::Enum IfcBlobTexture::Class() { return Type::IfcBlobTexture; }
IfcBlobTexture::IfcBlobTexture(IfcAbstractEntityPtr e) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBlobTexture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBlobTexture::IfcBlobTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< IfcIdentifier > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< IfcIdentifier > /*[1:?]*/ > v5_Parameter, IfcIdentifier v6_RasterFormat) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_RepeatS)); e->setArgument(1,(v2_RepeatT)); if (v3_Mode) { e->setArgument(2,(*v3_Mode)); } else { e->setArgument(2); } e->setArgument(3,(v4_TextureTransform)); if (v5_Parameter) { e->setArgument(4,(*v5_Parameter)); } else { e->setArgument(4); } e->setArgument(5,(v6_RasterFormat)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBlock
IfcPositiveLengthMeasure IfcBlock::XLength() { return *entity->getArgument(1); }
void IfcBlock::setXLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcBlock::YLength() { return *entity->getArgument(2); }
void IfcBlock::setYLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPositiveLengthMeasure IfcBlock::ZLength() { return *entity->getArgument(3); }
void IfcBlock::setZLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBlock::is(Type::Enum v) const { return v == Type::IfcBlock || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcBlock::type() const { return Type::IfcBlock; }
Type::Enum IfcBlock::Class() { return Type::IfcBlock; }
IfcBlock::IfcBlock(IfcAbstractEntityPtr e) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBlock)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBlock::IfcBlock(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_XLength, IfcPositiveLengthMeasure v3_YLength, IfcPositiveLengthMeasure v4_ZLength) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_XLength)); e->setArgument(2,(v3_YLength)); e->setArgument(3,(v4_ZLength)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoiler
bool IfcBoiler::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoiler::PredefinedType() { return IfcBoilerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcBoiler::setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcBoilerTypeEnum::ToString(v)); }
bool IfcBoiler::is(Type::Enum v) const { return v == Type::IfcBoiler || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcBoiler::type() const { return Type::IfcBoiler; }
Type::Enum IfcBoiler::Class() { return Type::IfcBoiler; }
IfcBoiler::IfcBoiler(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoiler)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoiler::IfcBoiler(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBoilerTypeEnum::IfcBoilerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBoilerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoilerType
IfcBoilerTypeEnum::IfcBoilerTypeEnum IfcBoilerType::PredefinedType() { return IfcBoilerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBoilerType::setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcBoilerTypeEnum::ToString(v)); }
bool IfcBoilerType::is(Type::Enum v) const { return v == Type::IfcBoilerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcBoilerType::type() const { return Type::IfcBoilerType; }
Type::Enum IfcBoilerType::Class() { return Type::IfcBoilerType; }
IfcBoilerType::IfcBoilerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoilerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoilerType::IfcBoilerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcBoilerTypeEnum::IfcBoilerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcBoilerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBooleanClippingResult
bool IfcBooleanClippingResult::is(Type::Enum v) const { return v == Type::IfcBooleanClippingResult || IfcBooleanResult::is(v); }
Type::Enum IfcBooleanClippingResult::type() const { return Type::IfcBooleanClippingResult; }
Type::Enum IfcBooleanClippingResult::Class() { return Type::IfcBooleanClippingResult; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcAbstractEntityPtr e) : IfcBooleanResult((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBooleanClippingResult)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBooleanClippingResult::IfcBooleanClippingResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand v2_FirstOperand, IfcBooleanOperand v3_SecondOperand) : IfcBooleanResult((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_Operator,IfcBooleanOperator::ToString(v1_Operator)); e->setArgument(1,(v2_FirstOperand)); e->setArgument(2,(v3_SecondOperand)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBooleanResult
IfcBooleanOperator::IfcBooleanOperator IfcBooleanResult::Operator() { return IfcBooleanOperator::FromString(*entity->getArgument(0)); }
void IfcBooleanResult::setOperator(IfcBooleanOperator::IfcBooleanOperator v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcBooleanOperator::ToString(v)); }
IfcBooleanOperand IfcBooleanResult::FirstOperand() { return *entity->getArgument(1); }
void IfcBooleanResult::setFirstOperand(IfcBooleanOperand v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcBooleanOperand IfcBooleanResult::SecondOperand() { return *entity->getArgument(2); }
void IfcBooleanResult::setSecondOperand(IfcBooleanOperand v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcBooleanResult::is(Type::Enum v) const { return v == Type::IfcBooleanResult || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcBooleanResult::type() const { return Type::IfcBooleanResult; }
Type::Enum IfcBooleanResult::Class() { return Type::IfcBooleanResult; }
IfcBooleanResult::IfcBooleanResult(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBooleanResult)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBooleanResult::IfcBooleanResult(IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand v2_FirstOperand, IfcBooleanOperand v3_SecondOperand) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_Operator,IfcBooleanOperator::ToString(v1_Operator)); e->setArgument(1,(v2_FirstOperand)); e->setArgument(2,(v3_SecondOperand)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryCondition
bool IfcBoundaryCondition::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcBoundaryCondition::Name() { return *entity->getArgument(0); }
void IfcBoundaryCondition::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcBoundaryCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryCondition; }
Type::Enum IfcBoundaryCondition::type() const { return Type::IfcBoundaryCondition; }
Type::Enum IfcBoundaryCondition::Class() { return Type::IfcBoundaryCondition; }
IfcBoundaryCondition::IfcBoundaryCondition(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcBoundaryCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryCondition::IfcBoundaryCondition(boost::optional< IfcLabel > v1_Name) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryCurve
bool IfcBoundaryCurve::is(Type::Enum v) const { return v == Type::IfcBoundaryCurve || IfcCompositeCurveOnSurface::is(v); }
Type::Enum IfcBoundaryCurve::type() const { return Type::IfcBoundaryCurve; }
Type::Enum IfcBoundaryCurve::Class() { return Type::IfcBoundaryCurve; }
IfcBoundaryCurve::IfcBoundaryCurve(IfcAbstractEntityPtr e) : IfcCompositeCurveOnSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundaryCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryCurve::IfcBoundaryCurve(SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > v1_Segments, bool v2_SelfIntersect) : IfcCompositeCurveOnSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Segments)->generalize()); e->setArgument(1,(v2_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryEdgeCondition
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthX() { return !entity->getArgument(1)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthX() { return *entity->getArgument(1); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthX(IfcModulusOfTranslationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthY() { return !entity->getArgument(2)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthY() { return *entity->getArgument(2); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthY(IfcModulusOfTranslationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcBoundaryEdgeCondition::hasTranslationalStiffnessByLengthZ() { return !entity->getArgument(3)->isNull(); }
IfcModulusOfTranslationalSubgradeReactionSelect IfcBoundaryEdgeCondition::TranslationalStiffnessByLengthZ() { return *entity->getArgument(3); }
void IfcBoundaryEdgeCondition::setTranslationalStiffnessByLengthZ(IfcModulusOfTranslationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthX() { return !entity->getArgument(4)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect IfcBoundaryEdgeCondition::RotationalStiffnessByLengthX() { return *entity->getArgument(4); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthX(IfcModulusOfRotationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthY() { return !entity->getArgument(5)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect IfcBoundaryEdgeCondition::RotationalStiffnessByLengthY() { return *entity->getArgument(5); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthY(IfcModulusOfRotationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcBoundaryEdgeCondition::hasRotationalStiffnessByLengthZ() { return !entity->getArgument(6)->isNull(); }
IfcModulusOfRotationalSubgradeReactionSelect IfcBoundaryEdgeCondition::RotationalStiffnessByLengthZ() { return *entity->getArgument(6); }
void IfcBoundaryEdgeCondition::setRotationalStiffnessByLengthZ(IfcModulusOfRotationalSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcBoundaryEdgeCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryEdgeCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryEdgeCondition::type() const { return Type::IfcBoundaryEdgeCondition; }
Type::Enum IfcBoundaryEdgeCondition::Class() { return Type::IfcBoundaryEdgeCondition; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(IfcAbstractEntityPtr e) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundaryEdgeCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryEdgeCondition::IfcBoundaryEdgeCondition(boost::optional< IfcLabel > v1_Name, boost::optional< IfcModulusOfTranslationalSubgradeReactionSelect > v2_TranslationalStiffnessByLengthX, boost::optional< IfcModulusOfTranslationalSubgradeReactionSelect > v3_TranslationalStiffnessByLengthY, boost::optional< IfcModulusOfTranslationalSubgradeReactionSelect > v4_TranslationalStiffnessByLengthZ, boost::optional< IfcModulusOfRotationalSubgradeReactionSelect > v5_RotationalStiffnessByLengthX, boost::optional< IfcModulusOfRotationalSubgradeReactionSelect > v6_RotationalStiffnessByLengthY, boost::optional< IfcModulusOfRotationalSubgradeReactionSelect > v7_RotationalStiffnessByLengthZ) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_TranslationalStiffnessByLengthX) { e->setArgument(1,(*v2_TranslationalStiffnessByLengthX)); } else { e->setArgument(1); } if (v3_TranslationalStiffnessByLengthY) { e->setArgument(2,(*v3_TranslationalStiffnessByLengthY)); } else { e->setArgument(2); } if (v4_TranslationalStiffnessByLengthZ) { e->setArgument(3,(*v4_TranslationalStiffnessByLengthZ)); } else { e->setArgument(3); } if (v5_RotationalStiffnessByLengthX) { e->setArgument(4,(*v5_RotationalStiffnessByLengthX)); } else { e->setArgument(4); } if (v6_RotationalStiffnessByLengthY) { e->setArgument(5,(*v6_RotationalStiffnessByLengthY)); } else { e->setArgument(5); } if (v7_RotationalStiffnessByLengthZ) { e->setArgument(6,(*v7_RotationalStiffnessByLengthZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryFaceCondition
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaX() { return !entity->getArgument(1)->isNull(); }
IfcModulusOfSubgradeReactionSelect IfcBoundaryFaceCondition::TranslationalStiffnessByAreaX() { return *entity->getArgument(1); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaX(IfcModulusOfSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaY() { return !entity->getArgument(2)->isNull(); }
IfcModulusOfSubgradeReactionSelect IfcBoundaryFaceCondition::TranslationalStiffnessByAreaY() { return *entity->getArgument(2); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaY(IfcModulusOfSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcBoundaryFaceCondition::hasTranslationalStiffnessByAreaZ() { return !entity->getArgument(3)->isNull(); }
IfcModulusOfSubgradeReactionSelect IfcBoundaryFaceCondition::TranslationalStiffnessByAreaZ() { return *entity->getArgument(3); }
void IfcBoundaryFaceCondition::setTranslationalStiffnessByAreaZ(IfcModulusOfSubgradeReactionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBoundaryFaceCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryFaceCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryFaceCondition::type() const { return Type::IfcBoundaryFaceCondition; }
Type::Enum IfcBoundaryFaceCondition::Class() { return Type::IfcBoundaryFaceCondition; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(IfcAbstractEntityPtr e) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundaryFaceCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryFaceCondition::IfcBoundaryFaceCondition(boost::optional< IfcLabel > v1_Name, boost::optional< IfcModulusOfSubgradeReactionSelect > v2_TranslationalStiffnessByAreaX, boost::optional< IfcModulusOfSubgradeReactionSelect > v3_TranslationalStiffnessByAreaY, boost::optional< IfcModulusOfSubgradeReactionSelect > v4_TranslationalStiffnessByAreaZ) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_TranslationalStiffnessByAreaX) { e->setArgument(1,(*v2_TranslationalStiffnessByAreaX)); } else { e->setArgument(1); } if (v3_TranslationalStiffnessByAreaY) { e->setArgument(2,(*v3_TranslationalStiffnessByAreaY)); } else { e->setArgument(2); } if (v4_TranslationalStiffnessByAreaZ) { e->setArgument(3,(*v4_TranslationalStiffnessByAreaZ)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryNodeCondition
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessX() { return !entity->getArgument(1)->isNull(); }
IfcTranslationalStiffnessSelect IfcBoundaryNodeCondition::TranslationalStiffnessX() { return *entity->getArgument(1); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessX(IfcTranslationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessY() { return !entity->getArgument(2)->isNull(); }
IfcTranslationalStiffnessSelect IfcBoundaryNodeCondition::TranslationalStiffnessY() { return *entity->getArgument(2); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessY(IfcTranslationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcBoundaryNodeCondition::hasTranslationalStiffnessZ() { return !entity->getArgument(3)->isNull(); }
IfcTranslationalStiffnessSelect IfcBoundaryNodeCondition::TranslationalStiffnessZ() { return *entity->getArgument(3); }
void IfcBoundaryNodeCondition::setTranslationalStiffnessZ(IfcTranslationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessX() { return !entity->getArgument(4)->isNull(); }
IfcRotationalStiffnessSelect IfcBoundaryNodeCondition::RotationalStiffnessX() { return *entity->getArgument(4); }
void IfcBoundaryNodeCondition::setRotationalStiffnessX(IfcRotationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessY() { return !entity->getArgument(5)->isNull(); }
IfcRotationalStiffnessSelect IfcBoundaryNodeCondition::RotationalStiffnessY() { return *entity->getArgument(5); }
void IfcBoundaryNodeCondition::setRotationalStiffnessY(IfcRotationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcBoundaryNodeCondition::hasRotationalStiffnessZ() { return !entity->getArgument(6)->isNull(); }
IfcRotationalStiffnessSelect IfcBoundaryNodeCondition::RotationalStiffnessZ() { return *entity->getArgument(6); }
void IfcBoundaryNodeCondition::setRotationalStiffnessZ(IfcRotationalStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcBoundaryNodeCondition::is(Type::Enum v) const { return v == Type::IfcBoundaryNodeCondition || IfcBoundaryCondition::is(v); }
Type::Enum IfcBoundaryNodeCondition::type() const { return Type::IfcBoundaryNodeCondition; }
Type::Enum IfcBoundaryNodeCondition::Class() { return Type::IfcBoundaryNodeCondition; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(IfcAbstractEntityPtr e) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundaryNodeCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryNodeCondition::IfcBoundaryNodeCondition(boost::optional< IfcLabel > v1_Name, boost::optional< IfcTranslationalStiffnessSelect > v2_TranslationalStiffnessX, boost::optional< IfcTranslationalStiffnessSelect > v3_TranslationalStiffnessY, boost::optional< IfcTranslationalStiffnessSelect > v4_TranslationalStiffnessZ, boost::optional< IfcRotationalStiffnessSelect > v5_RotationalStiffnessX, boost::optional< IfcRotationalStiffnessSelect > v6_RotationalStiffnessY, boost::optional< IfcRotationalStiffnessSelect > v7_RotationalStiffnessZ) : IfcBoundaryCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_TranslationalStiffnessX) { e->setArgument(1,(*v2_TranslationalStiffnessX)); } else { e->setArgument(1); } if (v3_TranslationalStiffnessY) { e->setArgument(2,(*v3_TranslationalStiffnessY)); } else { e->setArgument(2); } if (v4_TranslationalStiffnessZ) { e->setArgument(3,(*v4_TranslationalStiffnessZ)); } else { e->setArgument(3); } if (v5_RotationalStiffnessX) { e->setArgument(4,(*v5_RotationalStiffnessX)); } else { e->setArgument(4); } if (v6_RotationalStiffnessY) { e->setArgument(5,(*v6_RotationalStiffnessY)); } else { e->setArgument(5); } if (v7_RotationalStiffnessZ) { e->setArgument(6,(*v7_RotationalStiffnessZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundaryNodeConditionWarping
bool IfcBoundaryNodeConditionWarping::hasWarpingStiffness() { return !entity->getArgument(7)->isNull(); }
IfcWarpingStiffnessSelect IfcBoundaryNodeConditionWarping::WarpingStiffness() { return *entity->getArgument(7); }
void IfcBoundaryNodeConditionWarping::setWarpingStiffness(IfcWarpingStiffnessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcBoundaryNodeConditionWarping::is(Type::Enum v) const { return v == Type::IfcBoundaryNodeConditionWarping || IfcBoundaryNodeCondition::is(v); }
Type::Enum IfcBoundaryNodeConditionWarping::type() const { return Type::IfcBoundaryNodeConditionWarping; }
Type::Enum IfcBoundaryNodeConditionWarping::Class() { return Type::IfcBoundaryNodeConditionWarping; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(IfcAbstractEntityPtr e) : IfcBoundaryNodeCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundaryNodeConditionWarping)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundaryNodeConditionWarping::IfcBoundaryNodeConditionWarping(boost::optional< IfcLabel > v1_Name, boost::optional< IfcTranslationalStiffnessSelect > v2_TranslationalStiffnessX, boost::optional< IfcTranslationalStiffnessSelect > v3_TranslationalStiffnessY, boost::optional< IfcTranslationalStiffnessSelect > v4_TranslationalStiffnessZ, boost::optional< IfcRotationalStiffnessSelect > v5_RotationalStiffnessX, boost::optional< IfcRotationalStiffnessSelect > v6_RotationalStiffnessY, boost::optional< IfcRotationalStiffnessSelect > v7_RotationalStiffnessZ, boost::optional< IfcWarpingStiffnessSelect > v8_WarpingStiffness) : IfcBoundaryNodeCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_TranslationalStiffnessX) { e->setArgument(1,(*v2_TranslationalStiffnessX)); } else { e->setArgument(1); } if (v3_TranslationalStiffnessY) { e->setArgument(2,(*v3_TranslationalStiffnessY)); } else { e->setArgument(2); } if (v4_TranslationalStiffnessZ) { e->setArgument(3,(*v4_TranslationalStiffnessZ)); } else { e->setArgument(3); } if (v5_RotationalStiffnessX) { e->setArgument(4,(*v5_RotationalStiffnessX)); } else { e->setArgument(4); } if (v6_RotationalStiffnessY) { e->setArgument(5,(*v6_RotationalStiffnessY)); } else { e->setArgument(5); } if (v7_RotationalStiffnessZ) { e->setArgument(6,(*v7_RotationalStiffnessZ)); } else { e->setArgument(6); } if (v8_WarpingStiffness) { e->setArgument(7,(*v8_WarpingStiffness)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundedCurve
bool IfcBoundedCurve::is(Type::Enum v) const { return v == Type::IfcBoundedCurve || IfcCurve::is(v); }
Type::Enum IfcBoundedCurve::type() const { return Type::IfcBoundedCurve; }
Type::Enum IfcBoundedCurve::Class() { return Type::IfcBoundedCurve; }
IfcBoundedCurve::IfcBoundedCurve(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundedCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundedCurve::IfcBoundedCurve() : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundedSurface
bool IfcBoundedSurface::is(Type::Enum v) const { return v == Type::IfcBoundedSurface || IfcSurface::is(v); }
Type::Enum IfcBoundedSurface::type() const { return Type::IfcBoundedSurface; }
Type::Enum IfcBoundedSurface::Class() { return Type::IfcBoundedSurface; }
IfcBoundedSurface::IfcBoundedSurface(IfcAbstractEntityPtr e) : IfcSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundedSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundedSurface::IfcBoundedSurface() : IfcSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoundingBox
IfcCartesianPoint* IfcBoundingBox::Corner() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcBoundingBox::setCorner(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcPositiveLengthMeasure IfcBoundingBox::XDim() { return *entity->getArgument(1); }
void IfcBoundingBox::setXDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcBoundingBox::YDim() { return *entity->getArgument(2); }
void IfcBoundingBox::setYDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPositiveLengthMeasure IfcBoundingBox::ZDim() { return *entity->getArgument(3); }
void IfcBoundingBox::setZDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcBoundingBox::is(Type::Enum v) const { return v == Type::IfcBoundingBox || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcBoundingBox::type() const { return Type::IfcBoundingBox; }
Type::Enum IfcBoundingBox::Class() { return Type::IfcBoundingBox; }
IfcBoundingBox::IfcBoundingBox(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoundingBox)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoundingBox::IfcBoundingBox(IfcCartesianPoint* v1_Corner, IfcPositiveLengthMeasure v2_XDim, IfcPositiveLengthMeasure v3_YDim, IfcPositiveLengthMeasure v4_ZDim) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Corner)); e->setArgument(1,(v2_XDim)); e->setArgument(2,(v3_YDim)); e->setArgument(3,(v4_ZDim)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBoxedHalfSpace
IfcBoundingBox* IfcBoxedHalfSpace::Enclosure() { return (IfcBoundingBox*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcBoxedHalfSpace::setEnclosure(IfcBoundingBox* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcBoxedHalfSpace::is(Type::Enum v) const { return v == Type::IfcBoxedHalfSpace || IfcHalfSpaceSolid::is(v); }
Type::Enum IfcBoxedHalfSpace::type() const { return Type::IfcBoxedHalfSpace; }
Type::Enum IfcBoxedHalfSpace::Class() { return Type::IfcBoxedHalfSpace; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcAbstractEntityPtr e) : IfcHalfSpaceSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBoxedHalfSpace)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBoxedHalfSpace::IfcBoxedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcBoundingBox* v3_Enclosure) : IfcHalfSpaceSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BaseSurface)); e->setArgument(1,(v2_AgreementFlag)); e->setArgument(2,(v3_Enclosure)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuilding
bool IfcBuilding::hasElevationOfRefHeight() { return !entity->getArgument(9)->isNull(); }
IfcLengthMeasure IfcBuilding::ElevationOfRefHeight() { return *entity->getArgument(9); }
void IfcBuilding::setElevationOfRefHeight(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcBuilding::hasElevationOfTerrain() { return !entity->getArgument(10)->isNull(); }
IfcLengthMeasure IfcBuilding::ElevationOfTerrain() { return *entity->getArgument(10); }
void IfcBuilding::setElevationOfTerrain(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcBuilding::hasBuildingAddress() { return !entity->getArgument(11)->isNull(); }
IfcPostalAddress* IfcBuilding::BuildingAddress() { return (IfcPostalAddress*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(11))); }
void IfcBuilding::setBuildingAddress(IfcPostalAddress* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcBuilding::is(Type::Enum v) const { return v == Type::IfcBuilding || IfcSpatialStructureElement::is(v); }
Type::Enum IfcBuilding::type() const { return Type::IfcBuilding; }
Type::Enum IfcBuilding::Class() { return Type::IfcBuilding; }
IfcBuilding::IfcBuilding(IfcAbstractEntityPtr e) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuilding)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuilding::IfcBuilding(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcLengthMeasure > v10_ElevationOfRefHeight, boost::optional< IfcLengthMeasure > v11_ElevationOfTerrain, IfcPostalAddress* v12_BuildingAddress) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_CompositionType) { e->setArgument(8,*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType)); } else { e->setArgument(8); } if (v10_ElevationOfRefHeight) { e->setArgument(9,(*v10_ElevationOfRefHeight)); } else { e->setArgument(9); } if (v11_ElevationOfTerrain) { e->setArgument(10,(*v11_ElevationOfTerrain)); } else { e->setArgument(10); } e->setArgument(11,(v12_BuildingAddress)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElement
IfcRelCoversBldgElements::list IfcBuildingElement::HasCoverings() { RETURN_INVERSE(IfcRelCoversBldgElements) }
bool IfcBuildingElement::is(Type::Enum v) const { return v == Type::IfcBuildingElement || IfcElement::is(v); }
Type::Enum IfcBuildingElement::type() const { return Type::IfcBuildingElement; }
Type::Enum IfcBuildingElement::Class() { return Type::IfcBuildingElement; }
IfcBuildingElement::IfcBuildingElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElement::IfcBuildingElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElementPart
bool IfcBuildingElementPart::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPart::PredefinedType() { return IfcBuildingElementPartTypeEnum::FromString(*entity->getArgument(8)); }
void IfcBuildingElementPart::setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcBuildingElementPartTypeEnum::ToString(v)); }
bool IfcBuildingElementPart::is(Type::Enum v) const { return v == Type::IfcBuildingElementPart || IfcElementComponent::is(v); }
Type::Enum IfcBuildingElementPart::type() const { return Type::IfcBuildingElementPart; }
Type::Enum IfcBuildingElementPart::Class() { return Type::IfcBuildingElementPart; }
IfcBuildingElementPart::IfcBuildingElementPart(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElementPart)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementPart::IfcBuildingElementPart(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBuildingElementPartTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElementPartType
IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum IfcBuildingElementPartType::PredefinedType() { return IfcBuildingElementPartTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBuildingElementPartType::setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcBuildingElementPartTypeEnum::ToString(v)); }
bool IfcBuildingElementPartType::is(Type::Enum v) const { return v == Type::IfcBuildingElementPartType || IfcElementComponentType::is(v); }
Type::Enum IfcBuildingElementPartType::type() const { return Type::IfcBuildingElementPartType; }
Type::Enum IfcBuildingElementPartType::Class() { return Type::IfcBuildingElementPartType; }
IfcBuildingElementPartType::IfcBuildingElementPartType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElementPartType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementPartType::IfcBuildingElementPartType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcBuildingElementPartTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElementProxy
bool IfcBuildingElementProxy::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxy::PredefinedType() { return IfcBuildingElementProxyTypeEnum::FromString(*entity->getArgument(8)); }
void IfcBuildingElementProxy::setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcBuildingElementProxyTypeEnum::ToString(v)); }
bool IfcBuildingElementProxy::is(Type::Enum v) const { return v == Type::IfcBuildingElementProxy || IfcBuildingElement::is(v); }
Type::Enum IfcBuildingElementProxy::type() const { return Type::IfcBuildingElementProxy; }
Type::Enum IfcBuildingElementProxy::Class() { return Type::IfcBuildingElementProxy; }
IfcBuildingElementProxy::IfcBuildingElementProxy(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElementProxy)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementProxy::IfcBuildingElementProxy(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBuildingElementProxyTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElementProxyType
IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum IfcBuildingElementProxyType::PredefinedType() { return IfcBuildingElementProxyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBuildingElementProxyType::setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcBuildingElementProxyTypeEnum::ToString(v)); }
bool IfcBuildingElementProxyType::is(Type::Enum v) const { return v == Type::IfcBuildingElementProxyType || IfcBuildingElementType::is(v); }
Type::Enum IfcBuildingElementProxyType::type() const { return Type::IfcBuildingElementProxyType; }
Type::Enum IfcBuildingElementProxyType::Class() { return Type::IfcBuildingElementProxyType; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElementProxyType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementProxyType::IfcBuildingElementProxyType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcBuildingElementProxyTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingElementType
bool IfcBuildingElementType::is(Type::Enum v) const { return v == Type::IfcBuildingElementType || IfcElementType::is(v); }
Type::Enum IfcBuildingElementType::type() const { return Type::IfcBuildingElementType; }
Type::Enum IfcBuildingElementType::Class() { return Type::IfcBuildingElementType; }
IfcBuildingElementType::IfcBuildingElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingElementType::IfcBuildingElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingStorey
bool IfcBuildingStorey::hasElevation() { return !entity->getArgument(9)->isNull(); }
IfcLengthMeasure IfcBuildingStorey::Elevation() { return *entity->getArgument(9); }
void IfcBuildingStorey::setElevation(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcBuildingStorey::is(Type::Enum v) const { return v == Type::IfcBuildingStorey || IfcSpatialStructureElement::is(v); }
Type::Enum IfcBuildingStorey::type() const { return Type::IfcBuildingStorey; }
Type::Enum IfcBuildingStorey::Class() { return Type::IfcBuildingStorey; }
IfcBuildingStorey::IfcBuildingStorey(IfcAbstractEntityPtr e) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingStorey)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingStorey::IfcBuildingStorey(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcLengthMeasure > v10_Elevation) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_CompositionType) { e->setArgument(8,*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType)); } else { e->setArgument(8); } if (v10_Elevation) { e->setArgument(9,(*v10_Elevation)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBuildingSystem
bool IfcBuildingSystem::hasPredefinedType() { return !entity->getArgument(5)->isNull(); }
IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum IfcBuildingSystem::PredefinedType() { return IfcBuildingSystemTypeEnum::FromString(*entity->getArgument(5)); }
void IfcBuildingSystem::setPredefinedType(IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcBuildingSystemTypeEnum::ToString(v)); }
bool IfcBuildingSystem::is(Type::Enum v) const { return v == Type::IfcBuildingSystem || IfcSystem::is(v); }
Type::Enum IfcBuildingSystem::type() const { return Type::IfcBuildingSystem; }
Type::Enum IfcBuildingSystem::Class() { return Type::IfcBuildingSystem; }
IfcBuildingSystem::IfcBuildingSystem(IfcAbstractEntityPtr e) : IfcSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBuildingSystem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBuildingSystem::IfcBuildingSystem(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum > v6_PredefinedType) : IfcSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_PredefinedType) { e->setArgument(5,*v6_PredefinedType,IfcBuildingSystemTypeEnum::ToString(*v6_PredefinedType)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBurner
bool IfcBurner::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurner::PredefinedType() { return IfcBurnerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcBurner::setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcBurnerTypeEnum::ToString(v)); }
bool IfcBurner::is(Type::Enum v) const { return v == Type::IfcBurner || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcBurner::type() const { return Type::IfcBurner; }
Type::Enum IfcBurner::Class() { return Type::IfcBurner; }
IfcBurner::IfcBurner(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBurner)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBurner::IfcBurner(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcBurnerTypeEnum::IfcBurnerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcBurnerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcBurnerType
IfcBurnerTypeEnum::IfcBurnerTypeEnum IfcBurnerType::PredefinedType() { return IfcBurnerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcBurnerType::setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcBurnerTypeEnum::ToString(v)); }
bool IfcBurnerType::is(Type::Enum v) const { return v == Type::IfcBurnerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcBurnerType::type() const { return Type::IfcBurnerType; }
Type::Enum IfcBurnerType::Class() { return Type::IfcBurnerType; }
IfcBurnerType::IfcBurnerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcBurnerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcBurnerType::IfcBurnerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcBurnerTypeEnum::IfcBurnerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcBurnerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCShapeProfileDef
IfcPositiveLengthMeasure IfcCShapeProfileDef::Depth() { return *entity->getArgument(3); }
void IfcCShapeProfileDef::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcCShapeProfileDef::Width() { return *entity->getArgument(4); }
void IfcCShapeProfileDef::setWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcCShapeProfileDef::WallThickness() { return *entity->getArgument(5); }
void IfcCShapeProfileDef::setWallThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcCShapeProfileDef::Girth() { return *entity->getArgument(6); }
void IfcCShapeProfileDef::setGirth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcCShapeProfileDef::hasInternalFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcCShapeProfileDef::InternalFilletRadius() { return *entity->getArgument(7); }
void IfcCShapeProfileDef::setInternalFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcCShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcCShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCShapeProfileDef::type() const { return Type::IfcCShapeProfileDef; }
Type::Enum IfcCShapeProfileDef::Class() { return Type::IfcCShapeProfileDef; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCShapeProfileDef::IfcCShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Depth, IfcPositiveLengthMeasure v5_Width, IfcPositiveLengthMeasure v6_WallThickness, IfcPositiveLengthMeasure v7_Girth, boost::optional< IfcNonNegativeLengthMeasure > v8_InternalFilletRadius) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Depth)); e->setArgument(4,(v5_Width)); e->setArgument(5,(v6_WallThickness)); e->setArgument(6,(v7_Girth)); if (v8_InternalFilletRadius) { e->setArgument(7,(*v8_InternalFilletRadius)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableCarrierFitting
bool IfcCableCarrierFitting::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFitting::PredefinedType() { return IfcCableCarrierFittingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCableCarrierFitting::setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCableCarrierFittingTypeEnum::ToString(v)); }
bool IfcCableCarrierFitting::is(Type::Enum v) const { return v == Type::IfcCableCarrierFitting || IfcFlowFitting::is(v); }
Type::Enum IfcCableCarrierFitting::type() const { return Type::IfcCableCarrierFitting; }
Type::Enum IfcCableCarrierFitting::Class() { return Type::IfcCableCarrierFitting; }
IfcCableCarrierFitting::IfcCableCarrierFitting(IfcAbstractEntityPtr e) : IfcFlowFitting((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableCarrierFitting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierFitting::IfcCableCarrierFitting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCableCarrierFittingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableCarrierFittingType
IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum IfcCableCarrierFittingType::PredefinedType() { return IfcCableCarrierFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableCarrierFittingType::setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCableCarrierFittingTypeEnum::ToString(v)); }
bool IfcCableCarrierFittingType::is(Type::Enum v) const { return v == Type::IfcCableCarrierFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcCableCarrierFittingType::type() const { return Type::IfcCableCarrierFittingType; }
Type::Enum IfcCableCarrierFittingType::Class() { return Type::IfcCableCarrierFittingType; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(IfcAbstractEntityPtr e) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableCarrierFittingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierFittingType::IfcCableCarrierFittingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCableCarrierFittingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableCarrierSegment
bool IfcCableCarrierSegment::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegment::PredefinedType() { return IfcCableCarrierSegmentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCableCarrierSegment::setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCableCarrierSegmentTypeEnum::ToString(v)); }
bool IfcCableCarrierSegment::is(Type::Enum v) const { return v == Type::IfcCableCarrierSegment || IfcFlowSegment::is(v); }
Type::Enum IfcCableCarrierSegment::type() const { return Type::IfcCableCarrierSegment; }
Type::Enum IfcCableCarrierSegment::Class() { return Type::IfcCableCarrierSegment; }
IfcCableCarrierSegment::IfcCableCarrierSegment(IfcAbstractEntityPtr e) : IfcFlowSegment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableCarrierSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierSegment::IfcCableCarrierSegment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCableCarrierSegmentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableCarrierSegmentType
IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum IfcCableCarrierSegmentType::PredefinedType() { return IfcCableCarrierSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableCarrierSegmentType::setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCableCarrierSegmentTypeEnum::ToString(v)); }
bool IfcCableCarrierSegmentType::is(Type::Enum v) const { return v == Type::IfcCableCarrierSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcCableCarrierSegmentType::type() const { return Type::IfcCableCarrierSegmentType; }
Type::Enum IfcCableCarrierSegmentType::Class() { return Type::IfcCableCarrierSegmentType; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(IfcAbstractEntityPtr e) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableCarrierSegmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableCarrierSegmentType::IfcCableCarrierSegmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCableCarrierSegmentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableFitting
bool IfcCableFitting::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFitting::PredefinedType() { return IfcCableFittingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCableFitting::setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCableFittingTypeEnum::ToString(v)); }
bool IfcCableFitting::is(Type::Enum v) const { return v == Type::IfcCableFitting || IfcFlowFitting::is(v); }
Type::Enum IfcCableFitting::type() const { return Type::IfcCableFitting; }
Type::Enum IfcCableFitting::Class() { return Type::IfcCableFitting; }
IfcCableFitting::IfcCableFitting(IfcAbstractEntityPtr e) : IfcFlowFitting((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableFitting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableFitting::IfcCableFitting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCableFittingTypeEnum::IfcCableFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCableFittingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableFittingType
IfcCableFittingTypeEnum::IfcCableFittingTypeEnum IfcCableFittingType::PredefinedType() { return IfcCableFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableFittingType::setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCableFittingTypeEnum::ToString(v)); }
bool IfcCableFittingType::is(Type::Enum v) const { return v == Type::IfcCableFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcCableFittingType::type() const { return Type::IfcCableFittingType; }
Type::Enum IfcCableFittingType::Class() { return Type::IfcCableFittingType; }
IfcCableFittingType::IfcCableFittingType(IfcAbstractEntityPtr e) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableFittingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableFittingType::IfcCableFittingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCableFittingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableSegment
bool IfcCableSegment::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegment::PredefinedType() { return IfcCableSegmentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCableSegment::setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCableSegmentTypeEnum::ToString(v)); }
bool IfcCableSegment::is(Type::Enum v) const { return v == Type::IfcCableSegment || IfcFlowSegment::is(v); }
Type::Enum IfcCableSegment::type() const { return Type::IfcCableSegment; }
Type::Enum IfcCableSegment::Class() { return Type::IfcCableSegment; }
IfcCableSegment::IfcCableSegment(IfcAbstractEntityPtr e) : IfcFlowSegment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableSegment::IfcCableSegment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCableSegmentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCableSegmentType
IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum IfcCableSegmentType::PredefinedType() { return IfcCableSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCableSegmentType::setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCableSegmentTypeEnum::ToString(v)); }
bool IfcCableSegmentType::is(Type::Enum v) const { return v == Type::IfcCableSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcCableSegmentType::type() const { return Type::IfcCableSegmentType; }
Type::Enum IfcCableSegmentType::Class() { return Type::IfcCableSegmentType; }
IfcCableSegmentType::IfcCableSegmentType(IfcAbstractEntityPtr e) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCableSegmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCableSegmentType::IfcCableSegmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCableSegmentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianPoint
std::vector< IfcLengthMeasure > /*[1:3]*/ IfcCartesianPoint::Coordinates() { return *entity->getArgument(0); }
void IfcCartesianPoint::setCoordinates(std::vector< IfcLengthMeasure > /*[1:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcCartesianPoint::is(Type::Enum v) const { return v == Type::IfcCartesianPoint || IfcPoint::is(v); }
Type::Enum IfcCartesianPoint::type() const { return Type::IfcCartesianPoint; }
Type::Enum IfcCartesianPoint::Class() { return Type::IfcCartesianPoint; }
IfcCartesianPoint::IfcCartesianPoint(IfcAbstractEntityPtr e) : IfcPoint((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianPoint)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianPoint::IfcCartesianPoint(std::vector< IfcLengthMeasure > /*[1:3]*/ v1_Coordinates) : IfcPoint((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Coordinates)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianPointList
bool IfcCartesianPointList::is(Type::Enum v) const { return v == Type::IfcCartesianPointList || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCartesianPointList::type() const { return Type::IfcCartesianPointList; }
Type::Enum IfcCartesianPointList::Class() { return Type::IfcCartesianPointList; }
IfcCartesianPointList::IfcCartesianPointList(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianPointList)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianPointList::IfcCartesianPointList() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianPointList3D
bool IfcCartesianPointList3D::is(Type::Enum v) const { return v == Type::IfcCartesianPointList3D || IfcCartesianPointList::is(v); }
Type::Enum IfcCartesianPointList3D::type() const { return Type::IfcCartesianPointList3D; }
Type::Enum IfcCartesianPointList3D::Class() { return Type::IfcCartesianPointList3D; }
IfcCartesianPointList3D::IfcCartesianPointList3D(IfcAbstractEntityPtr e) : IfcCartesianPointList((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianPointList3D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianPointList3D::IfcCartesianPointList3D() : IfcCartesianPointList((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianTransformationOperator
bool IfcCartesianTransformationOperator::hasAxis1() { return !entity->getArgument(0)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis1() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcCartesianTransformationOperator::setAxis1(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcCartesianTransformationOperator::hasAxis2() { return !entity->getArgument(1)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator::Axis2() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcCartesianTransformationOperator::setAxis2(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcCartesianPoint* IfcCartesianTransformationOperator::LocalOrigin() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcCartesianTransformationOperator::setLocalOrigin(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcCartesianTransformationOperator::hasScale() { return !entity->getArgument(3)->isNull(); }
double IfcCartesianTransformationOperator::Scale() { return *entity->getArgument(3); }
void IfcCartesianTransformationOperator::setScale(double v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCartesianTransformationOperator::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCartesianTransformationOperator::type() const { return Type::IfcCartesianTransformationOperator; }
Type::Enum IfcCartesianTransformationOperator::Class() { return Type::IfcCartesianTransformationOperator; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianTransformationOperator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator::IfcCartesianTransformationOperator(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Axis1)); e->setArgument(1,(v2_Axis2)); e->setArgument(2,(v3_LocalOrigin)); if (v4_Scale) { e->setArgument(3,(*v4_Scale)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianTransformationOperator2D
bool IfcCartesianTransformationOperator2D::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator2D || IfcCartesianTransformationOperator::is(v); }
Type::Enum IfcCartesianTransformationOperator2D::type() const { return Type::IfcCartesianTransformationOperator2D; }
Type::Enum IfcCartesianTransformationOperator2D::Class() { return Type::IfcCartesianTransformationOperator2D; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcAbstractEntityPtr e) : IfcCartesianTransformationOperator((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianTransformationOperator2D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator2D::IfcCartesianTransformationOperator2D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale) : IfcCartesianTransformationOperator((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Axis1)); e->setArgument(1,(v2_Axis2)); e->setArgument(2,(v3_LocalOrigin)); if (v4_Scale) { e->setArgument(3,(*v4_Scale)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianTransformationOperator2DnonUniform
bool IfcCartesianTransformationOperator2DnonUniform::hasScale2() { return !entity->getArgument(4)->isNull(); }
double IfcCartesianTransformationOperator2DnonUniform::Scale2() { return *entity->getArgument(4); }
void IfcCartesianTransformationOperator2DnonUniform::setScale2(double v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcCartesianTransformationOperator2DnonUniform::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator2DnonUniform || IfcCartesianTransformationOperator2D::is(v); }
Type::Enum IfcCartesianTransformationOperator2DnonUniform::type() const { return Type::IfcCartesianTransformationOperator2DnonUniform; }
Type::Enum IfcCartesianTransformationOperator2DnonUniform::Class() { return Type::IfcCartesianTransformationOperator2DnonUniform; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcAbstractEntityPtr e) : IfcCartesianTransformationOperator2D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianTransformationOperator2DnonUniform)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator2DnonUniform::IfcCartesianTransformationOperator2DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2) : IfcCartesianTransformationOperator2D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Axis1)); e->setArgument(1,(v2_Axis2)); e->setArgument(2,(v3_LocalOrigin)); if (v4_Scale) { e->setArgument(3,(*v4_Scale)); } else { e->setArgument(3); } if (v5_Scale2) { e->setArgument(4,(*v5_Scale2)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianTransformationOperator3D
bool IfcCartesianTransformationOperator3D::hasAxis3() { return !entity->getArgument(4)->isNull(); }
IfcDirection* IfcCartesianTransformationOperator3D::Axis3() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcCartesianTransformationOperator3D::setAxis3(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcCartesianTransformationOperator3D::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator3D || IfcCartesianTransformationOperator::is(v); }
Type::Enum IfcCartesianTransformationOperator3D::type() const { return Type::IfcCartesianTransformationOperator3D; }
Type::Enum IfcCartesianTransformationOperator3D::Class() { return Type::IfcCartesianTransformationOperator3D; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcAbstractEntityPtr e) : IfcCartesianTransformationOperator((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianTransformationOperator3D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator3D::IfcCartesianTransformationOperator3D(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3) : IfcCartesianTransformationOperator((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Axis1)); e->setArgument(1,(v2_Axis2)); e->setArgument(2,(v3_LocalOrigin)); if (v4_Scale) { e->setArgument(3,(*v4_Scale)); } else { e->setArgument(3); } e->setArgument(4,(v5_Axis3)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCartesianTransformationOperator3DnonUniform
bool IfcCartesianTransformationOperator3DnonUniform::hasScale2() { return !entity->getArgument(5)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale2() { return *entity->getArgument(5); }
void IfcCartesianTransformationOperator3DnonUniform::setScale2(double v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcCartesianTransformationOperator3DnonUniform::hasScale3() { return !entity->getArgument(6)->isNull(); }
double IfcCartesianTransformationOperator3DnonUniform::Scale3() { return *entity->getArgument(6); }
void IfcCartesianTransformationOperator3DnonUniform::setScale3(double v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcCartesianTransformationOperator3DnonUniform::is(Type::Enum v) const { return v == Type::IfcCartesianTransformationOperator3DnonUniform || IfcCartesianTransformationOperator3D::is(v); }
Type::Enum IfcCartesianTransformationOperator3DnonUniform::type() const { return Type::IfcCartesianTransformationOperator3DnonUniform; }
Type::Enum IfcCartesianTransformationOperator3DnonUniform::Class() { return Type::IfcCartesianTransformationOperator3DnonUniform; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcAbstractEntityPtr e) : IfcCartesianTransformationOperator3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCartesianTransformationOperator3DnonUniform)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCartesianTransformationOperator3DnonUniform::IfcCartesianTransformationOperator3DnonUniform(IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3) : IfcCartesianTransformationOperator3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Axis1)); e->setArgument(1,(v2_Axis2)); e->setArgument(2,(v3_LocalOrigin)); if (v4_Scale) { e->setArgument(3,(*v4_Scale)); } else { e->setArgument(3); } e->setArgument(4,(v5_Axis3)); if (v6_Scale2) { e->setArgument(5,(*v6_Scale2)); } else { e->setArgument(5); } if (v7_Scale3) { e->setArgument(6,(*v7_Scale3)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCenterLineProfileDef
IfcPositiveLengthMeasure IfcCenterLineProfileDef::Thickness() { return *entity->getArgument(3); }
void IfcCenterLineProfileDef::setThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCenterLineProfileDef::is(Type::Enum v) const { return v == Type::IfcCenterLineProfileDef || IfcArbitraryOpenProfileDef::is(v); }
Type::Enum IfcCenterLineProfileDef::type() const { return Type::IfcCenterLineProfileDef; }
Type::Enum IfcCenterLineProfileDef::Class() { return Type::IfcCenterLineProfileDef; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcAbstractEntityPtr e) : IfcArbitraryOpenProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCenterLineProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCenterLineProfileDef::IfcCenterLineProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcBoundedCurve* v3_Curve, IfcPositiveLengthMeasure v4_Thickness) : IfcArbitraryOpenProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Curve)); e->setArgument(3,(v4_Thickness)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcChiller
bool IfcChiller::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcChillerTypeEnum::IfcChillerTypeEnum IfcChiller::PredefinedType() { return IfcChillerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcChiller::setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcChillerTypeEnum::ToString(v)); }
bool IfcChiller::is(Type::Enum v) const { return v == Type::IfcChiller || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcChiller::type() const { return Type::IfcChiller; }
Type::Enum IfcChiller::Class() { return Type::IfcChiller; }
IfcChiller::IfcChiller(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcChiller)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChiller::IfcChiller(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcChillerTypeEnum::IfcChillerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcChillerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcChillerType
IfcChillerTypeEnum::IfcChillerTypeEnum IfcChillerType::PredefinedType() { return IfcChillerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcChillerType::setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcChillerTypeEnum::ToString(v)); }
bool IfcChillerType::is(Type::Enum v) const { return v == Type::IfcChillerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcChillerType::type() const { return Type::IfcChillerType; }
Type::Enum IfcChillerType::Class() { return Type::IfcChillerType; }
IfcChillerType::IfcChillerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcChillerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChillerType::IfcChillerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcChillerTypeEnum::IfcChillerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcChillerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcChimney
bool IfcChimney::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimney::PredefinedType() { return IfcChimneyTypeEnum::FromString(*entity->getArgument(8)); }
void IfcChimney::setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcChimneyTypeEnum::ToString(v)); }
bool IfcChimney::is(Type::Enum v) const { return v == Type::IfcChimney || IfcBuildingElement::is(v); }
Type::Enum IfcChimney::type() const { return Type::IfcChimney; }
Type::Enum IfcChimney::Class() { return Type::IfcChimney; }
IfcChimney::IfcChimney(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcChimney)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChimney::IfcChimney(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcChimneyTypeEnum::IfcChimneyTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcChimneyTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcChimneyType
IfcChimneyTypeEnum::IfcChimneyTypeEnum IfcChimneyType::PredefinedType() { return IfcChimneyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcChimneyType::setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcChimneyTypeEnum::ToString(v)); }
bool IfcChimneyType::is(Type::Enum v) const { return v == Type::IfcChimneyType || IfcBuildingElementType::is(v); }
Type::Enum IfcChimneyType::type() const { return Type::IfcChimneyType; }
Type::Enum IfcChimneyType::Class() { return Type::IfcChimneyType; }
IfcChimneyType::IfcChimneyType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcChimneyType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcChimneyType::IfcChimneyType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcChimneyTypeEnum::IfcChimneyTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcChimneyTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCircle
IfcPositiveLengthMeasure IfcCircle::Radius() { return *entity->getArgument(1); }
void IfcCircle::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCircle::is(Type::Enum v) const { return v == Type::IfcCircle || IfcConic::is(v); }
Type::Enum IfcCircle::type() const { return Type::IfcCircle; }
Type::Enum IfcCircle::Class() { return Type::IfcCircle; }
IfcCircle::IfcCircle(IfcAbstractEntityPtr e) : IfcConic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCircle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircle::IfcCircle(IfcAxis2Placement v1_Position, IfcPositiveLengthMeasure v2_Radius) : IfcConic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_Radius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCircleHollowProfileDef
IfcPositiveLengthMeasure IfcCircleHollowProfileDef::WallThickness() { return *entity->getArgument(4); }
void IfcCircleHollowProfileDef::setWallThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcCircleHollowProfileDef::is(Type::Enum v) const { return v == Type::IfcCircleHollowProfileDef || IfcCircleProfileDef::is(v); }
Type::Enum IfcCircleHollowProfileDef::type() const { return Type::IfcCircleHollowProfileDef; }
Type::Enum IfcCircleHollowProfileDef::Class() { return Type::IfcCircleHollowProfileDef; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcAbstractEntityPtr e) : IfcCircleProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCircleHollowProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircleHollowProfileDef::IfcCircleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Radius, IfcPositiveLengthMeasure v5_WallThickness) : IfcCircleProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Radius)); e->setArgument(4,(v5_WallThickness)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCircleProfileDef
IfcPositiveLengthMeasure IfcCircleProfileDef::Radius() { return *entity->getArgument(3); }
void IfcCircleProfileDef::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCircleProfileDef::is(Type::Enum v) const { return v == Type::IfcCircleProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcCircleProfileDef::type() const { return Type::IfcCircleProfileDef; }
Type::Enum IfcCircleProfileDef::Class() { return Type::IfcCircleProfileDef; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCircleProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCircleProfileDef::IfcCircleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Radius) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Radius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCivilElement
bool IfcCivilElement::is(Type::Enum v) const { return v == Type::IfcCivilElement || IfcElement::is(v); }
Type::Enum IfcCivilElement::type() const { return Type::IfcCivilElement; }
Type::Enum IfcCivilElement::Class() { return Type::IfcCivilElement; }
IfcCivilElement::IfcCivilElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCivilElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCivilElement::IfcCivilElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCivilElementType
bool IfcCivilElementType::is(Type::Enum v) const { return v == Type::IfcCivilElementType || IfcElementType::is(v); }
Type::Enum IfcCivilElementType::type() const { return Type::IfcCivilElementType; }
Type::Enum IfcCivilElementType::Class() { return Type::IfcCivilElementType; }
IfcCivilElementType::IfcCivilElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCivilElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCivilElementType::IfcCivilElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcClassification
bool IfcClassification::hasSource() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcClassification::Source() { return *entity->getArgument(0); }
void IfcClassification::setSource(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcClassification::hasEdition() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcClassification::Edition() { return *entity->getArgument(1); }
void IfcClassification::setEdition(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcClassification::hasEditionDate() { return !entity->getArgument(2)->isNull(); }
IfcDate IfcClassification::EditionDate() { return *entity->getArgument(2); }
void IfcClassification::setEditionDate(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcLabel IfcClassification::Name() { return *entity->getArgument(3); }
void IfcClassification::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcClassification::hasDescription() { return !entity->getArgument(4)->isNull(); }
IfcText IfcClassification::Description() { return *entity->getArgument(4); }
void IfcClassification::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcClassification::hasLocation() { return !entity->getArgument(5)->isNull(); }
IfcURIReference IfcClassification::Location() { return *entity->getArgument(5); }
void IfcClassification::setLocation(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcClassification::hasReferenceTokens() { return !entity->getArgument(6)->isNull(); }
std::vector< IfcIdentifier > /*[1:?]*/ IfcClassification::ReferenceTokens() { return *entity->getArgument(6); }
void IfcClassification::setReferenceTokens(std::vector< IfcIdentifier > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcRelAssociatesClassification::list IfcClassification::ClassificationForObjects() { RETURN_INVERSE(IfcRelAssociatesClassification) }
IfcClassificationReference::list IfcClassification::HasReferences() { RETURN_INVERSE(IfcClassificationReference) }
bool IfcClassification::is(Type::Enum v) const { return v == Type::IfcClassification || IfcExternalInformation::is(v); }
Type::Enum IfcClassification::type() const { return Type::IfcClassification; }
Type::Enum IfcClassification::Class() { return Type::IfcClassification; }
IfcClassification::IfcClassification(IfcAbstractEntityPtr e) : IfcExternalInformation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcClassification)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassification::IfcClassification(boost::optional< IfcLabel > v1_Source, boost::optional< IfcLabel > v2_Edition, boost::optional< IfcDate > v3_EditionDate, IfcLabel v4_Name, boost::optional< IfcText > v5_Description, boost::optional< IfcURIReference > v6_Location, boost::optional< std::vector< IfcIdentifier > /*[1:?]*/ > v7_ReferenceTokens) : IfcExternalInformation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Source) { e->setArgument(0,(*v1_Source)); } else { e->setArgument(0); } if (v2_Edition) { e->setArgument(1,(*v2_Edition)); } else { e->setArgument(1); } if (v3_EditionDate) { e->setArgument(2,(*v3_EditionDate)); } else { e->setArgument(2); } e->setArgument(3,(v4_Name)); if (v5_Description) { e->setArgument(4,(*v5_Description)); } else { e->setArgument(4); } if (v6_Location) { e->setArgument(5,(*v6_Location)); } else { e->setArgument(5); } if (v7_ReferenceTokens) { e->setArgument(6,(*v7_ReferenceTokens)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcClassificationReference
bool IfcClassificationReference::hasReferencedSource() { return !entity->getArgument(3)->isNull(); }
IfcClassificationReferenceSelect IfcClassificationReference::ReferencedSource() { return *entity->getArgument(3); }
void IfcClassificationReference::setReferencedSource(IfcClassificationReferenceSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcClassificationReference::hasDescription() { return !entity->getArgument(4)->isNull(); }
IfcText IfcClassificationReference::Description() { return *entity->getArgument(4); }
void IfcClassificationReference::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcClassificationReference::hasSort() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcClassificationReference::Sort() { return *entity->getArgument(5); }
void IfcClassificationReference::setSort(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcRelAssociatesClassification::list IfcClassificationReference::ClassificationRefForObjects() { RETURN_INVERSE(IfcRelAssociatesClassification) }
IfcClassificationReference::list IfcClassificationReference::HasReferences() { RETURN_INVERSE(IfcClassificationReference) }
bool IfcClassificationReference::is(Type::Enum v) const { return v == Type::IfcClassificationReference || IfcExternalReference::is(v); }
Type::Enum IfcClassificationReference::type() const { return Type::IfcClassificationReference; }
Type::Enum IfcClassificationReference::Class() { return Type::IfcClassificationReference; }
IfcClassificationReference::IfcClassificationReference(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcClassificationReference)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClassificationReference::IfcClassificationReference(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name, boost::optional< IfcClassificationReferenceSelect > v4_ReferencedSource, boost::optional< IfcText > v5_Description, boost::optional< IfcIdentifier > v6_Sort) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_ReferencedSource) { e->setArgument(3,(*v4_ReferencedSource)); } else { e->setArgument(3); } if (v5_Description) { e->setArgument(4,(*v5_Description)); } else { e->setArgument(4); } if (v6_Sort) { e->setArgument(5,(*v6_Sort)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcClosedShell
bool IfcClosedShell::is(Type::Enum v) const { return v == Type::IfcClosedShell || IfcConnectedFaceSet::is(v); }
Type::Enum IfcClosedShell::type() const { return Type::IfcClosedShell; }
Type::Enum IfcClosedShell::Class() { return Type::IfcClosedShell; }
IfcClosedShell::IfcClosedShell(IfcAbstractEntityPtr e) : IfcConnectedFaceSet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcClosedShell)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcClosedShell::IfcClosedShell(SHARED_PTR< IfcTemplatedEntityList< IfcFace > > v1_CfsFaces) : IfcConnectedFaceSet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_CfsFaces)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoil
bool IfcCoil::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoil::PredefinedType() { return IfcCoilTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCoil::setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCoilTypeEnum::ToString(v)); }
bool IfcCoil::is(Type::Enum v) const { return v == Type::IfcCoil || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcCoil::type() const { return Type::IfcCoil; }
Type::Enum IfcCoil::Class() { return Type::IfcCoil; }
IfcCoil::IfcCoil(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCoil)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoil::IfcCoil(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCoilTypeEnum::IfcCoilTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCoilTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoilType
IfcCoilTypeEnum::IfcCoilTypeEnum IfcCoilType::PredefinedType() { return IfcCoilTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoilType::setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCoilTypeEnum::ToString(v)); }
bool IfcCoilType::is(Type::Enum v) const { return v == Type::IfcCoilType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCoilType::type() const { return Type::IfcCoilType; }
Type::Enum IfcCoilType::Class() { return Type::IfcCoilType; }
IfcCoilType::IfcCoilType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCoilType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoilType::IfcCoilType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCoilTypeEnum::IfcCoilTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCoilTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColourRgb
IfcNormalisedRatioMeasure IfcColourRgb::Red() { return *entity->getArgument(1); }
void IfcColourRgb::setRed(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcNormalisedRatioMeasure IfcColourRgb::Green() { return *entity->getArgument(2); }
void IfcColourRgb::setGreen(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcNormalisedRatioMeasure IfcColourRgb::Blue() { return *entity->getArgument(3); }
void IfcColourRgb::setBlue(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcColourRgb::is(Type::Enum v) const { return v == Type::IfcColourRgb || IfcColourSpecification::is(v); }
Type::Enum IfcColourRgb::type() const { return Type::IfcColourRgb; }
Type::Enum IfcColourRgb::Class() { return Type::IfcColourRgb; }
IfcColourRgb::IfcColourRgb(IfcAbstractEntityPtr e) : IfcColourSpecification((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColourRgb)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColourRgb::IfcColourRgb(boost::optional< IfcLabel > v1_Name, IfcNormalisedRatioMeasure v2_Red, IfcNormalisedRatioMeasure v3_Green, IfcNormalisedRatioMeasure v4_Blue) : IfcColourSpecification((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_Red)); e->setArgument(2,(v3_Green)); e->setArgument(3,(v4_Blue)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColourRgbList
bool IfcColourRgbList::is(Type::Enum v) const { return v == Type::IfcColourRgbList || IfcPresentationItem::is(v); }
Type::Enum IfcColourRgbList::type() const { return Type::IfcColourRgbList; }
Type::Enum IfcColourRgbList::Class() { return Type::IfcColourRgbList; }
IfcColourRgbList::IfcColourRgbList(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColourRgbList)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColourRgbList::IfcColourRgbList() : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColourSpecification
bool IfcColourSpecification::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcColourSpecification::Name() { return *entity->getArgument(0); }
void IfcColourSpecification::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcColourSpecification::is(Type::Enum v) const { return v == Type::IfcColourSpecification || IfcPresentationItem::is(v); }
Type::Enum IfcColourSpecification::type() const { return Type::IfcColourSpecification; }
Type::Enum IfcColourSpecification::Class() { return Type::IfcColourSpecification; }
IfcColourSpecification::IfcColourSpecification(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColourSpecification)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColourSpecification::IfcColourSpecification(boost::optional< IfcLabel > v1_Name) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColumn
bool IfcColumn::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumn::PredefinedType() { return IfcColumnTypeEnum::FromString(*entity->getArgument(8)); }
void IfcColumn::setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcColumnTypeEnum::ToString(v)); }
bool IfcColumn::is(Type::Enum v) const { return v == Type::IfcColumn || IfcBuildingElement::is(v); }
Type::Enum IfcColumn::type() const { return Type::IfcColumn; }
Type::Enum IfcColumn::Class() { return Type::IfcColumn; }
IfcColumn::IfcColumn(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColumn)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColumn::IfcColumn(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcColumnTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColumnStandardCase
bool IfcColumnStandardCase::is(Type::Enum v) const { return v == Type::IfcColumnStandardCase || IfcColumn::is(v); }
Type::Enum IfcColumnStandardCase::type() const { return Type::IfcColumnStandardCase; }
Type::Enum IfcColumnStandardCase::Class() { return Type::IfcColumnStandardCase; }
IfcColumnStandardCase::IfcColumnStandardCase(IfcAbstractEntityPtr e) : IfcColumn((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColumnStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColumnStandardCase::IfcColumnStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType) : IfcColumn((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcColumnTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcColumnType
IfcColumnTypeEnum::IfcColumnTypeEnum IfcColumnType::PredefinedType() { return IfcColumnTypeEnum::FromString(*entity->getArgument(9)); }
void IfcColumnType::setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcColumnTypeEnum::ToString(v)); }
bool IfcColumnType::is(Type::Enum v) const { return v == Type::IfcColumnType || IfcBuildingElementType::is(v); }
Type::Enum IfcColumnType::type() const { return Type::IfcColumnType; }
Type::Enum IfcColumnType::Class() { return Type::IfcColumnType; }
IfcColumnType::IfcColumnType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcColumnType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcColumnType::IfcColumnType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcColumnTypeEnum::IfcColumnTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcColumnTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCommunicationsAppliance
bool IfcCommunicationsAppliance::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsAppliance::PredefinedType() { return IfcCommunicationsApplianceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCommunicationsAppliance::setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCommunicationsApplianceTypeEnum::ToString(v)); }
bool IfcCommunicationsAppliance::is(Type::Enum v) const { return v == Type::IfcCommunicationsAppliance || IfcFlowTerminal::is(v); }
Type::Enum IfcCommunicationsAppliance::type() const { return Type::IfcCommunicationsAppliance; }
Type::Enum IfcCommunicationsAppliance::Class() { return Type::IfcCommunicationsAppliance; }
IfcCommunicationsAppliance::IfcCommunicationsAppliance(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCommunicationsAppliance)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCommunicationsAppliance::IfcCommunicationsAppliance(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCommunicationsApplianceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCommunicationsApplianceType
IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum IfcCommunicationsApplianceType::PredefinedType() { return IfcCommunicationsApplianceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCommunicationsApplianceType::setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCommunicationsApplianceTypeEnum::ToString(v)); }
bool IfcCommunicationsApplianceType::is(Type::Enum v) const { return v == Type::IfcCommunicationsApplianceType || IfcFlowTerminalType::is(v); }
Type::Enum IfcCommunicationsApplianceType::type() const { return Type::IfcCommunicationsApplianceType; }
Type::Enum IfcCommunicationsApplianceType::Class() { return Type::IfcCommunicationsApplianceType; }
IfcCommunicationsApplianceType::IfcCommunicationsApplianceType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCommunicationsApplianceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCommunicationsApplianceType::IfcCommunicationsApplianceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCommunicationsApplianceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcComplexProperty
IfcIdentifier IfcComplexProperty::UsageName() { return *entity->getArgument(2); }
void IfcComplexProperty::setUsageName(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > IfcComplexProperty::HasProperties() { RETURN_AS_LIST(IfcProperty,3) }
void IfcComplexProperty::setHasProperties(SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcComplexProperty::is(Type::Enum v) const { return v == Type::IfcComplexProperty || IfcProperty::is(v); }
Type::Enum IfcComplexProperty::type() const { return Type::IfcComplexProperty; }
Type::Enum IfcComplexProperty::Class() { return Type::IfcComplexProperty; }
IfcComplexProperty::IfcComplexProperty(IfcAbstractEntityPtr e) : IfcProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcComplexProperty)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcComplexProperty::IfcComplexProperty(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, IfcIdentifier v3_UsageName, SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v4_HasProperties) : IfcProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_UsageName)); e->setArgument(3,(v4_HasProperties)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcComplexPropertyTemplate
bool IfcComplexPropertyTemplate::hasUsageName() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcComplexPropertyTemplate::UsageName() { return *entity->getArgument(4); }
void IfcComplexPropertyTemplate::setUsageName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcComplexPropertyTemplate::hasTemplateType() { return !entity->getArgument(5)->isNull(); }
IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum IfcComplexPropertyTemplate::TemplateType() { return IfcComplexPropertyTemplateTypeEnum::FromString(*entity->getArgument(5)); }
void IfcComplexPropertyTemplate::setTemplateType(IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcComplexPropertyTemplateTypeEnum::ToString(v)); }
bool IfcComplexPropertyTemplate::hasHasPropertyTemplates() { return !entity->getArgument(6)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > IfcComplexPropertyTemplate::HasPropertyTemplates() { RETURN_AS_LIST(IfcPropertyTemplate,6) }
void IfcComplexPropertyTemplate::setHasPropertyTemplates(SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v->generalize()); }
bool IfcComplexPropertyTemplate::is(Type::Enum v) const { return v == Type::IfcComplexPropertyTemplate || IfcPropertyTemplate::is(v); }
Type::Enum IfcComplexPropertyTemplate::type() const { return Type::IfcComplexPropertyTemplate; }
Type::Enum IfcComplexPropertyTemplate::Class() { return Type::IfcComplexPropertyTemplate; }
IfcComplexPropertyTemplate::IfcComplexPropertyTemplate(IfcAbstractEntityPtr e) : IfcPropertyTemplate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcComplexPropertyTemplate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcComplexPropertyTemplate::IfcComplexPropertyTemplate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_UsageName, boost::optional< IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum > v6_TemplateType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > > v7_HasPropertyTemplates) : IfcPropertyTemplate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_UsageName) { e->setArgument(4,(*v5_UsageName)); } else { e->setArgument(4); } if (v6_TemplateType) { e->setArgument(5,*v6_TemplateType,IfcComplexPropertyTemplateTypeEnum::ToString(*v6_TemplateType)); } else { e->setArgument(5); } if (v7_HasPropertyTemplates) { e->setArgument(6,(*v7_HasPropertyTemplates)->generalize()); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompositeCurve
SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > IfcCompositeCurve::Segments() { RETURN_AS_LIST(IfcCompositeCurveSegment,0) }
void IfcCompositeCurve::setSegments(SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcCompositeCurve::SelfIntersect() { return *entity->getArgument(1); }
void IfcCompositeCurve::setSelfIntersect(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCompositeCurve::is(Type::Enum v) const { return v == Type::IfcCompositeCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcCompositeCurve::type() const { return Type::IfcCompositeCurve; }
Type::Enum IfcCompositeCurve::Class() { return Type::IfcCompositeCurve; }
IfcCompositeCurve::IfcCompositeCurve(IfcAbstractEntityPtr e) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompositeCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeCurve::IfcCompositeCurve(SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > v1_Segments, bool v2_SelfIntersect) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Segments)->generalize()); e->setArgument(1,(v2_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompositeCurveOnSurface
bool IfcCompositeCurveOnSurface::is(Type::Enum v) const { return v == Type::IfcCompositeCurveOnSurface || IfcCompositeCurve::is(v); }
Type::Enum IfcCompositeCurveOnSurface::type() const { return Type::IfcCompositeCurveOnSurface; }
Type::Enum IfcCompositeCurveOnSurface::Class() { return Type::IfcCompositeCurveOnSurface; }
IfcCompositeCurveOnSurface::IfcCompositeCurveOnSurface(IfcAbstractEntityPtr e) : IfcCompositeCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompositeCurveOnSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeCurveOnSurface::IfcCompositeCurveOnSurface(SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > v1_Segments, bool v2_SelfIntersect) : IfcCompositeCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Segments)->generalize()); e->setArgument(1,(v2_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompositeCurveSegment
IfcTransitionCode::IfcTransitionCode IfcCompositeCurveSegment::Transition() { return IfcTransitionCode::FromString(*entity->getArgument(0)); }
void IfcCompositeCurveSegment::setTransition(IfcTransitionCode::IfcTransitionCode v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcTransitionCode::ToString(v)); }
bool IfcCompositeCurveSegment::SameSense() { return *entity->getArgument(1); }
void IfcCompositeCurveSegment::setSameSense(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcCurve* IfcCompositeCurveSegment::ParentCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcCompositeCurveSegment::setParentCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcCompositeCurve::list IfcCompositeCurveSegment::UsingCurves() { RETURN_INVERSE(IfcCompositeCurve) }
bool IfcCompositeCurveSegment::is(Type::Enum v) const { return v == Type::IfcCompositeCurveSegment || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCompositeCurveSegment::type() const { return Type::IfcCompositeCurveSegment; }
Type::Enum IfcCompositeCurveSegment::Class() { return Type::IfcCompositeCurveSegment; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompositeCurveSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeCurveSegment::IfcCompositeCurveSegment(IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_Transition,IfcTransitionCode::ToString(v1_Transition)); e->setArgument(1,(v2_SameSense)); e->setArgument(2,(v3_ParentCurve)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompositeProfileDef
SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > IfcCompositeProfileDef::Profiles() { RETURN_AS_LIST(IfcProfileDef,2) }
void IfcCompositeProfileDef::setProfiles(SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcCompositeProfileDef::hasLabel() { return !entity->getArgument(3)->isNull(); }
IfcLabel IfcCompositeProfileDef::Label() { return *entity->getArgument(3); }
void IfcCompositeProfileDef::setLabel(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCompositeProfileDef::is(Type::Enum v) const { return v == Type::IfcCompositeProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcCompositeProfileDef::type() const { return Type::IfcCompositeProfileDef; }
Type::Enum IfcCompositeProfileDef::Class() { return Type::IfcCompositeProfileDef; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcAbstractEntityPtr e) : IfcProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompositeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompositeProfileDef::IfcCompositeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > v3_Profiles, boost::optional< IfcLabel > v4_Label) : IfcProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Profiles)->generalize()); if (v4_Label) { e->setArgument(3,(*v4_Label)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompressor
bool IfcCompressor::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressor::PredefinedType() { return IfcCompressorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCompressor::setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCompressorTypeEnum::ToString(v)); }
bool IfcCompressor::is(Type::Enum v) const { return v == Type::IfcCompressor || IfcFlowMovingDevice::is(v); }
Type::Enum IfcCompressor::type() const { return Type::IfcCompressor; }
Type::Enum IfcCompressor::Class() { return Type::IfcCompressor; }
IfcCompressor::IfcCompressor(IfcAbstractEntityPtr e) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompressor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompressor::IfcCompressor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCompressorTypeEnum::IfcCompressorTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCompressorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCompressorType
IfcCompressorTypeEnum::IfcCompressorTypeEnum IfcCompressorType::PredefinedType() { return IfcCompressorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCompressorType::setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCompressorTypeEnum::ToString(v)); }
bool IfcCompressorType::is(Type::Enum v) const { return v == Type::IfcCompressorType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcCompressorType::type() const { return Type::IfcCompressorType; }
Type::Enum IfcCompressorType::Class() { return Type::IfcCompressorType; }
IfcCompressorType::IfcCompressorType(IfcAbstractEntityPtr e) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCompressorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCompressorType::IfcCompressorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCompressorTypeEnum::IfcCompressorTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCompressorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCondenser
bool IfcCondenser::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenser::PredefinedType() { return IfcCondenserTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCondenser::setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCondenserTypeEnum::ToString(v)); }
bool IfcCondenser::is(Type::Enum v) const { return v == Type::IfcCondenser || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcCondenser::type() const { return Type::IfcCondenser; }
Type::Enum IfcCondenser::Class() { return Type::IfcCondenser; }
IfcCondenser::IfcCondenser(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCondenser)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCondenser::IfcCondenser(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCondenserTypeEnum::IfcCondenserTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCondenserTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCondenserType
IfcCondenserTypeEnum::IfcCondenserTypeEnum IfcCondenserType::PredefinedType() { return IfcCondenserTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCondenserType::setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCondenserTypeEnum::ToString(v)); }
bool IfcCondenserType::is(Type::Enum v) const { return v == Type::IfcCondenserType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCondenserType::type() const { return Type::IfcCondenserType; }
Type::Enum IfcCondenserType::Class() { return Type::IfcCondenserType; }
IfcCondenserType::IfcCondenserType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCondenserType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCondenserType::IfcCondenserType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCondenserTypeEnum::IfcCondenserTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCondenserTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConic
IfcAxis2Placement IfcConic::Position() { return *entity->getArgument(0); }
void IfcConic::setPosition(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConic::is(Type::Enum v) const { return v == Type::IfcConic || IfcCurve::is(v); }
Type::Enum IfcConic::type() const { return Type::IfcConic; }
Type::Enum IfcConic::Class() { return Type::IfcConic; }
IfcConic::IfcConic(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConic)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConic::IfcConic(IfcAxis2Placement v1_Position) : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectedFaceSet
SHARED_PTR< IfcTemplatedEntityList< IfcFace > > IfcConnectedFaceSet::CfsFaces() { RETURN_AS_LIST(IfcFace,0) }
void IfcConnectedFaceSet::setCfsFaces(SHARED_PTR< IfcTemplatedEntityList< IfcFace > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcConnectedFaceSet::is(Type::Enum v) const { return v == Type::IfcConnectedFaceSet || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcConnectedFaceSet::type() const { return Type::IfcConnectedFaceSet; }
Type::Enum IfcConnectedFaceSet::Class() { return Type::IfcConnectedFaceSet; }
IfcConnectedFaceSet::IfcConnectedFaceSet(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectedFaceSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectedFaceSet::IfcConnectedFaceSet(SHARED_PTR< IfcTemplatedEntityList< IfcFace > > v1_CfsFaces) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_CfsFaces)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionCurveGeometry
IfcCurveOrEdgeCurve IfcConnectionCurveGeometry::CurveOnRelatingElement() { return *entity->getArgument(0); }
void IfcConnectionCurveGeometry::setCurveOnRelatingElement(IfcCurveOrEdgeCurve v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConnectionCurveGeometry::hasCurveOnRelatedElement() { return !entity->getArgument(1)->isNull(); }
IfcCurveOrEdgeCurve IfcConnectionCurveGeometry::CurveOnRelatedElement() { return *entity->getArgument(1); }
void IfcConnectionCurveGeometry::setCurveOnRelatedElement(IfcCurveOrEdgeCurve v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcConnectionCurveGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionCurveGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionCurveGeometry::type() const { return Type::IfcConnectionCurveGeometry; }
Type::Enum IfcConnectionCurveGeometry::Class() { return Type::IfcConnectionCurveGeometry; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcAbstractEntityPtr e) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectionCurveGeometry)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionCurveGeometry::IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve v1_CurveOnRelatingElement, boost::optional< IfcCurveOrEdgeCurve > v2_CurveOnRelatedElement) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_CurveOnRelatingElement)); if (v2_CurveOnRelatedElement) { e->setArgument(1,(*v2_CurveOnRelatedElement)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionGeometry
bool IfcConnectionGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionGeometry; }
Type::Enum IfcConnectionGeometry::type() const { return Type::IfcConnectionGeometry; }
Type::Enum IfcConnectionGeometry::Class() { return Type::IfcConnectionGeometry; }
IfcConnectionGeometry::IfcConnectionGeometry(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcConnectionGeometry)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionGeometry::IfcConnectionGeometry() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionPointEccentricity
bool IfcConnectionPointEccentricity::hasEccentricityInX() { return !entity->getArgument(2)->isNull(); }
IfcLengthMeasure IfcConnectionPointEccentricity::EccentricityInX() { return *entity->getArgument(2); }
void IfcConnectionPointEccentricity::setEccentricityInX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcConnectionPointEccentricity::hasEccentricityInY() { return !entity->getArgument(3)->isNull(); }
IfcLengthMeasure IfcConnectionPointEccentricity::EccentricityInY() { return *entity->getArgument(3); }
void IfcConnectionPointEccentricity::setEccentricityInY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcConnectionPointEccentricity::hasEccentricityInZ() { return !entity->getArgument(4)->isNull(); }
IfcLengthMeasure IfcConnectionPointEccentricity::EccentricityInZ() { return *entity->getArgument(4); }
void IfcConnectionPointEccentricity::setEccentricityInZ(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcConnectionPointEccentricity::is(Type::Enum v) const { return v == Type::IfcConnectionPointEccentricity || IfcConnectionPointGeometry::is(v); }
Type::Enum IfcConnectionPointEccentricity::type() const { return Type::IfcConnectionPointEccentricity; }
Type::Enum IfcConnectionPointEccentricity::Class() { return Type::IfcConnectionPointEccentricity; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcAbstractEntityPtr e) : IfcConnectionPointGeometry((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectionPointEccentricity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionPointEccentricity::IfcConnectionPointEccentricity(IfcPointOrVertexPoint v1_PointOnRelatingElement, boost::optional< IfcPointOrVertexPoint > v2_PointOnRelatedElement, boost::optional< IfcLengthMeasure > v3_EccentricityInX, boost::optional< IfcLengthMeasure > v4_EccentricityInY, boost::optional< IfcLengthMeasure > v5_EccentricityInZ) : IfcConnectionPointGeometry((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_PointOnRelatingElement)); if (v2_PointOnRelatedElement) { e->setArgument(1,(*v2_PointOnRelatedElement)); } else { e->setArgument(1); } if (v3_EccentricityInX) { e->setArgument(2,(*v3_EccentricityInX)); } else { e->setArgument(2); } if (v4_EccentricityInY) { e->setArgument(3,(*v4_EccentricityInY)); } else { e->setArgument(3); } if (v5_EccentricityInZ) { e->setArgument(4,(*v5_EccentricityInZ)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionPointGeometry
IfcPointOrVertexPoint IfcConnectionPointGeometry::PointOnRelatingElement() { return *entity->getArgument(0); }
void IfcConnectionPointGeometry::setPointOnRelatingElement(IfcPointOrVertexPoint v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConnectionPointGeometry::hasPointOnRelatedElement() { return !entity->getArgument(1)->isNull(); }
IfcPointOrVertexPoint IfcConnectionPointGeometry::PointOnRelatedElement() { return *entity->getArgument(1); }
void IfcConnectionPointGeometry::setPointOnRelatedElement(IfcPointOrVertexPoint v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcConnectionPointGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionPointGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionPointGeometry::type() const { return Type::IfcConnectionPointGeometry; }
Type::Enum IfcConnectionPointGeometry::Class() { return Type::IfcConnectionPointGeometry; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcAbstractEntityPtr e) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectionPointGeometry)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionPointGeometry::IfcConnectionPointGeometry(IfcPointOrVertexPoint v1_PointOnRelatingElement, boost::optional< IfcPointOrVertexPoint > v2_PointOnRelatedElement) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_PointOnRelatingElement)); if (v2_PointOnRelatedElement) { e->setArgument(1,(*v2_PointOnRelatedElement)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionSurfaceGeometry
IfcSurfaceOrFaceSurface IfcConnectionSurfaceGeometry::SurfaceOnRelatingElement() { return *entity->getArgument(0); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatingElement(IfcSurfaceOrFaceSurface v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConnectionSurfaceGeometry::hasSurfaceOnRelatedElement() { return !entity->getArgument(1)->isNull(); }
IfcSurfaceOrFaceSurface IfcConnectionSurfaceGeometry::SurfaceOnRelatedElement() { return *entity->getArgument(1); }
void IfcConnectionSurfaceGeometry::setSurfaceOnRelatedElement(IfcSurfaceOrFaceSurface v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcConnectionSurfaceGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionSurfaceGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionSurfaceGeometry::type() const { return Type::IfcConnectionSurfaceGeometry; }
Type::Enum IfcConnectionSurfaceGeometry::Class() { return Type::IfcConnectionSurfaceGeometry; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcAbstractEntityPtr e) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectionSurfaceGeometry)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionSurfaceGeometry::IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface v1_SurfaceOnRelatingElement, boost::optional< IfcSurfaceOrFaceSurface > v2_SurfaceOnRelatedElement) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SurfaceOnRelatingElement)); if (v2_SurfaceOnRelatedElement) { e->setArgument(1,(*v2_SurfaceOnRelatedElement)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConnectionVolumeGeometry
IfcSolidOrShell IfcConnectionVolumeGeometry::VolumeOnRelatingElement() { return *entity->getArgument(0); }
void IfcConnectionVolumeGeometry::setVolumeOnRelatingElement(IfcSolidOrShell v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConnectionVolumeGeometry::hasVolumeOnRelatedElement() { return !entity->getArgument(1)->isNull(); }
IfcSolidOrShell IfcConnectionVolumeGeometry::VolumeOnRelatedElement() { return *entity->getArgument(1); }
void IfcConnectionVolumeGeometry::setVolumeOnRelatedElement(IfcSolidOrShell v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcConnectionVolumeGeometry::is(Type::Enum v) const { return v == Type::IfcConnectionVolumeGeometry || IfcConnectionGeometry::is(v); }
Type::Enum IfcConnectionVolumeGeometry::type() const { return Type::IfcConnectionVolumeGeometry; }
Type::Enum IfcConnectionVolumeGeometry::Class() { return Type::IfcConnectionVolumeGeometry; }
IfcConnectionVolumeGeometry::IfcConnectionVolumeGeometry(IfcAbstractEntityPtr e) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConnectionVolumeGeometry)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConnectionVolumeGeometry::IfcConnectionVolumeGeometry(IfcSolidOrShell v1_VolumeOnRelatingElement, boost::optional< IfcSolidOrShell > v2_VolumeOnRelatedElement) : IfcConnectionGeometry((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_VolumeOnRelatingElement)); if (v2_VolumeOnRelatedElement) { e->setArgument(1,(*v2_VolumeOnRelatedElement)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstraint
IfcLabel IfcConstraint::Name() { return *entity->getArgument(0); }
void IfcConstraint::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcConstraint::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcConstraint::Description() { return *entity->getArgument(1); }
void IfcConstraint::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcConstraintEnum::IfcConstraintEnum IfcConstraint::ConstraintGrade() { return IfcConstraintEnum::FromString(*entity->getArgument(2)); }
void IfcConstraint::setConstraintGrade(IfcConstraintEnum::IfcConstraintEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcConstraintEnum::ToString(v)); }
bool IfcConstraint::hasConstraintSource() { return !entity->getArgument(3)->isNull(); }
IfcLabel IfcConstraint::ConstraintSource() { return *entity->getArgument(3); }
void IfcConstraint::setConstraintSource(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcConstraint::hasCreatingActor() { return !entity->getArgument(4)->isNull(); }
IfcActorSelect IfcConstraint::CreatingActor() { return *entity->getArgument(4); }
void IfcConstraint::setCreatingActor(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcConstraint::hasCreationTime() { return !entity->getArgument(5)->isNull(); }
IfcDateTime IfcConstraint::CreationTime() { return *entity->getArgument(5); }
void IfcConstraint::setCreationTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcConstraint::hasUserDefinedGrade() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcConstraint::UserDefinedGrade() { return *entity->getArgument(6); }
void IfcConstraint::setUserDefinedGrade(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcExternalReferenceRelationship::list IfcConstraint::HasExternalReferences() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
IfcResourceConstraintRelationship::list IfcConstraint::PropertiesForConstraint() { RETURN_INVERSE(IfcResourceConstraintRelationship) }
bool IfcConstraint::is(Type::Enum v) const { return v == Type::IfcConstraint; }
Type::Enum IfcConstraint::type() const { return Type::IfcConstraint; }
Type::Enum IfcConstraint::Class() { return Type::IfcConstraint; }
IfcConstraint::IfcConstraint(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcConstraint)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstraint::IfcConstraint(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< IfcLabel > v4_ConstraintSource, boost::optional< IfcActorSelect > v5_CreatingActor, boost::optional< IfcDateTime > v6_CreationTime, boost::optional< IfcLabel > v7_UserDefinedGrade) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade)); if (v4_ConstraintSource) { e->setArgument(3,(*v4_ConstraintSource)); } else { e->setArgument(3); } if (v5_CreatingActor) { e->setArgument(4,(*v5_CreatingActor)); } else { e->setArgument(4); } if (v6_CreationTime) { e->setArgument(5,(*v6_CreationTime)); } else { e->setArgument(5); } if (v7_UserDefinedGrade) { e->setArgument(6,(*v7_UserDefinedGrade)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionEquipmentResource
bool IfcConstructionEquipmentResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResource::PredefinedType() { return IfcConstructionEquipmentResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcConstructionEquipmentResource::setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcConstructionEquipmentResourceTypeEnum::ToString(v)); }
bool IfcConstructionEquipmentResource::is(Type::Enum v) const { return v == Type::IfcConstructionEquipmentResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionEquipmentResource::type() const { return Type::IfcConstructionEquipmentResource; }
Type::Enum IfcConstructionEquipmentResource::Class() { return Type::IfcConstructionEquipmentResource; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionEquipmentResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionEquipmentResource::IfcConstructionEquipmentResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcConstructionEquipmentResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionEquipmentResourceType
IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum IfcConstructionEquipmentResourceType::PredefinedType() { return IfcConstructionEquipmentResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcConstructionEquipmentResourceType::setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcConstructionEquipmentResourceTypeEnum::ToString(v)); }
bool IfcConstructionEquipmentResourceType::is(Type::Enum v) const { return v == Type::IfcConstructionEquipmentResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcConstructionEquipmentResourceType::type() const { return Type::IfcConstructionEquipmentResourceType; }
Type::Enum IfcConstructionEquipmentResourceType::Class() { return Type::IfcConstructionEquipmentResourceType; }
IfcConstructionEquipmentResourceType::IfcConstructionEquipmentResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionEquipmentResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionEquipmentResourceType::IfcConstructionEquipmentResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcConstructionEquipmentResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionMaterialResource
bool IfcConstructionMaterialResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResource::PredefinedType() { return IfcConstructionMaterialResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcConstructionMaterialResource::setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcConstructionMaterialResourceTypeEnum::ToString(v)); }
bool IfcConstructionMaterialResource::is(Type::Enum v) const { return v == Type::IfcConstructionMaterialResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionMaterialResource::type() const { return Type::IfcConstructionMaterialResource; }
Type::Enum IfcConstructionMaterialResource::Class() { return Type::IfcConstructionMaterialResource; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionMaterialResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionMaterialResource::IfcConstructionMaterialResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcConstructionMaterialResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionMaterialResourceType
IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum IfcConstructionMaterialResourceType::PredefinedType() { return IfcConstructionMaterialResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcConstructionMaterialResourceType::setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcConstructionMaterialResourceTypeEnum::ToString(v)); }
bool IfcConstructionMaterialResourceType::is(Type::Enum v) const { return v == Type::IfcConstructionMaterialResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcConstructionMaterialResourceType::type() const { return Type::IfcConstructionMaterialResourceType; }
Type::Enum IfcConstructionMaterialResourceType::Class() { return Type::IfcConstructionMaterialResourceType; }
IfcConstructionMaterialResourceType::IfcConstructionMaterialResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionMaterialResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionMaterialResourceType::IfcConstructionMaterialResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcConstructionMaterialResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionProductResource
bool IfcConstructionProductResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResource::PredefinedType() { return IfcConstructionProductResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcConstructionProductResource::setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcConstructionProductResourceTypeEnum::ToString(v)); }
bool IfcConstructionProductResource::is(Type::Enum v) const { return v == Type::IfcConstructionProductResource || IfcConstructionResource::is(v); }
Type::Enum IfcConstructionProductResource::type() const { return Type::IfcConstructionProductResource; }
Type::Enum IfcConstructionProductResource::Class() { return Type::IfcConstructionProductResource; }
IfcConstructionProductResource::IfcConstructionProductResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionProductResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionProductResource::IfcConstructionProductResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcConstructionProductResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionProductResourceType
IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum IfcConstructionProductResourceType::PredefinedType() { return IfcConstructionProductResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcConstructionProductResourceType::setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcConstructionProductResourceTypeEnum::ToString(v)); }
bool IfcConstructionProductResourceType::is(Type::Enum v) const { return v == Type::IfcConstructionProductResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcConstructionProductResourceType::type() const { return Type::IfcConstructionProductResourceType; }
Type::Enum IfcConstructionProductResourceType::Class() { return Type::IfcConstructionProductResourceType; }
IfcConstructionProductResourceType::IfcConstructionProductResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionProductResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionProductResourceType::IfcConstructionProductResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcConstructionProductResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionResource
bool IfcConstructionResource::hasUsage() { return !entity->getArgument(7)->isNull(); }
IfcResourceTime* IfcConstructionResource::Usage() { return (IfcResourceTime*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcConstructionResource::setUsage(IfcResourceTime* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcConstructionResource::hasBaseCosts() { return !entity->getArgument(8)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > IfcConstructionResource::BaseCosts() { RETURN_AS_LIST(IfcAppliedValue,8) }
void IfcConstructionResource::setBaseCosts(SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v->generalize()); }
bool IfcConstructionResource::hasBaseQuantity() { return !entity->getArgument(9)->isNull(); }
IfcPhysicalQuantity* IfcConstructionResource::BaseQuantity() { return (IfcPhysicalQuantity*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcConstructionResource::setBaseQuantity(IfcPhysicalQuantity* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcConstructionResource::is(Type::Enum v) const { return v == Type::IfcConstructionResource || IfcResource::is(v); }
Type::Enum IfcConstructionResource::type() const { return Type::IfcConstructionResource; }
Type::Enum IfcConstructionResource::Class() { return Type::IfcConstructionResource; }
IfcConstructionResource::IfcConstructionResource(IfcAbstractEntityPtr e) : IfcResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionResource::IfcConstructionResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity) : IfcResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConstructionResourceType
bool IfcConstructionResourceType::hasBaseCosts() { return !entity->getArgument(9)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > IfcConstructionResourceType::BaseCosts() { RETURN_AS_LIST(IfcAppliedValue,9) }
void IfcConstructionResourceType::setBaseCosts(SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v->generalize()); }
bool IfcConstructionResourceType::hasBaseQuantity() { return !entity->getArgument(10)->isNull(); }
IfcPhysicalQuantity* IfcConstructionResourceType::BaseQuantity() { return (IfcPhysicalQuantity*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcConstructionResourceType::setBaseQuantity(IfcPhysicalQuantity* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcConstructionResourceType::is(Type::Enum v) const { return v == Type::IfcConstructionResourceType || IfcTypeResource::is(v); }
Type::Enum IfcConstructionResourceType::type() const { return Type::IfcConstructionResourceType; }
Type::Enum IfcConstructionResourceType::Class() { return Type::IfcConstructionResourceType; }
IfcConstructionResourceType::IfcConstructionResourceType(IfcAbstractEntityPtr e) : IfcTypeResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConstructionResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConstructionResourceType::IfcConstructionResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity) : IfcTypeResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcContext
bool IfcContext::hasObjectType() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcContext::ObjectType() { return *entity->getArgument(4); }
void IfcContext::setObjectType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcContext::hasLongName() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcContext::LongName() { return *entity->getArgument(5); }
void IfcContext::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcContext::hasPhase() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcContext::Phase() { return *entity->getArgument(6); }
void IfcContext::setPhase(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcContext::hasRepresentationContexts() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationContext > > IfcContext::RepresentationContexts() { RETURN_AS_LIST(IfcRepresentationContext,7) }
void IfcContext::setRepresentationContexts(SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationContext > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcContext::hasUnitsInContext() { return !entity->getArgument(8)->isNull(); }
IfcUnitAssignment* IfcContext::UnitsInContext() { return (IfcUnitAssignment*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcContext::setUnitsInContext(IfcUnitAssignment* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcRelDefinesByProperties::list IfcContext::IsDefinedBy() { RETURN_INVERSE(IfcRelDefinesByProperties) }
IfcRelDeclares::list IfcContext::Declares() { RETURN_INVERSE(IfcRelDeclares) }
bool IfcContext::is(Type::Enum v) const { return v == Type::IfcContext || IfcObjectDefinition::is(v); }
Type::Enum IfcContext::type() const { return Type::IfcContext; }
Type::Enum IfcContext::Class() { return Type::IfcContext; }
IfcContext::IfcContext(IfcAbstractEntityPtr e) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcContext)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcContext::IfcContext(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName, boost::optional< IfcLabel > v7_Phase, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationContext > > > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } if (v7_Phase) { e->setArgument(6,(*v7_Phase)); } else { e->setArgument(6); } if (v8_RepresentationContexts) { e->setArgument(7,(*v8_RepresentationContexts)->generalize()); } else { e->setArgument(7); } e->setArgument(8,(v9_UnitsInContext)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcContextDependentUnit
IfcLabel IfcContextDependentUnit::Name() { return *entity->getArgument(2); }
void IfcContextDependentUnit::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcExternalReferenceRelationship::list IfcContextDependentUnit::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcContextDependentUnit::is(Type::Enum v) const { return v == Type::IfcContextDependentUnit || IfcNamedUnit::is(v); }
Type::Enum IfcContextDependentUnit::type() const { return Type::IfcContextDependentUnit; }
Type::Enum IfcContextDependentUnit::Class() { return Type::IfcContextDependentUnit; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcAbstractEntityPtr e) : IfcNamedUnit((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcContextDependentUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcContextDependentUnit::IfcContextDependentUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, IfcLabel v3_Name) : IfcNamedUnit((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Dimensions)); e->setArgument(1,v2_UnitType,IfcUnitEnum::ToString(v2_UnitType)); e->setArgument(2,(v3_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcControl
bool IfcControl::hasIdentification() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcControl::Identification() { return *entity->getArgument(5); }
void IfcControl::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcRelAssignsToControl::list IfcControl::Controls() { RETURN_INVERSE(IfcRelAssignsToControl) }
bool IfcControl::is(Type::Enum v) const { return v == Type::IfcControl || IfcObject::is(v); }
Type::Enum IfcControl::type() const { return Type::IfcControl; }
Type::Enum IfcControl::Class() { return Type::IfcControl; }
IfcControl::IfcControl(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcControl)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcControl::IfcControl(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcController
bool IfcController::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcControllerTypeEnum::IfcControllerTypeEnum IfcController::PredefinedType() { return IfcControllerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcController::setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcControllerTypeEnum::ToString(v)); }
bool IfcController::is(Type::Enum v) const { return v == Type::IfcController || IfcDistributionControlElement::is(v); }
Type::Enum IfcController::type() const { return Type::IfcController; }
Type::Enum IfcController::Class() { return Type::IfcController; }
IfcController::IfcController(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcController)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcController::IfcController(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcControllerTypeEnum::IfcControllerTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcControllerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcControllerType
IfcControllerTypeEnum::IfcControllerTypeEnum IfcControllerType::PredefinedType() { return IfcControllerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcControllerType::setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcControllerTypeEnum::ToString(v)); }
bool IfcControllerType::is(Type::Enum v) const { return v == Type::IfcControllerType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcControllerType::type() const { return Type::IfcControllerType; }
Type::Enum IfcControllerType::Class() { return Type::IfcControllerType; }
IfcControllerType::IfcControllerType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcControllerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcControllerType::IfcControllerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcControllerTypeEnum::IfcControllerTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcControllerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConversionBasedUnit
IfcLabel IfcConversionBasedUnit::Name() { return *entity->getArgument(2); }
void IfcConversionBasedUnit::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcMeasureWithUnit* IfcConversionBasedUnit::ConversionFactor() { return (IfcMeasureWithUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcConversionBasedUnit::setConversionFactor(IfcMeasureWithUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcExternalReferenceRelationship::list IfcConversionBasedUnit::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcConversionBasedUnit::is(Type::Enum v) const { return v == Type::IfcConversionBasedUnit || IfcNamedUnit::is(v); }
Type::Enum IfcConversionBasedUnit::type() const { return Type::IfcConversionBasedUnit; }
Type::Enum IfcConversionBasedUnit::Class() { return Type::IfcConversionBasedUnit; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcAbstractEntityPtr e) : IfcNamedUnit((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConversionBasedUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConversionBasedUnit::IfcConversionBasedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, IfcLabel v3_Name, IfcMeasureWithUnit* v4_ConversionFactor) : IfcNamedUnit((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Dimensions)); e->setArgument(1,v2_UnitType,IfcUnitEnum::ToString(v2_UnitType)); e->setArgument(2,(v3_Name)); e->setArgument(3,(v4_ConversionFactor)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcConversionBasedUnitWithOffset
IfcReal IfcConversionBasedUnitWithOffset::ConversionOffset() { return *entity->getArgument(4); }
void IfcConversionBasedUnitWithOffset::setConversionOffset(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcConversionBasedUnitWithOffset::is(Type::Enum v) const { return v == Type::IfcConversionBasedUnitWithOffset || IfcConversionBasedUnit::is(v); }
Type::Enum IfcConversionBasedUnitWithOffset::type() const { return Type::IfcConversionBasedUnitWithOffset; }
Type::Enum IfcConversionBasedUnitWithOffset::Class() { return Type::IfcConversionBasedUnitWithOffset; }
IfcConversionBasedUnitWithOffset::IfcConversionBasedUnitWithOffset(IfcAbstractEntityPtr e) : IfcConversionBasedUnit((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcConversionBasedUnitWithOffset)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcConversionBasedUnitWithOffset::IfcConversionBasedUnitWithOffset(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, IfcLabel v3_Name, IfcMeasureWithUnit* v4_ConversionFactor, IfcReal v5_ConversionOffset) : IfcConversionBasedUnit((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Dimensions)); e->setArgument(1,v2_UnitType,IfcUnitEnum::ToString(v2_UnitType)); e->setArgument(2,(v3_Name)); e->setArgument(3,(v4_ConversionFactor)); e->setArgument(4,(v5_ConversionOffset)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCooledBeam
bool IfcCooledBeam::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeam::PredefinedType() { return IfcCooledBeamTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCooledBeam::setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCooledBeamTypeEnum::ToString(v)); }
bool IfcCooledBeam::is(Type::Enum v) const { return v == Type::IfcCooledBeam || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcCooledBeam::type() const { return Type::IfcCooledBeam; }
Type::Enum IfcCooledBeam::Class() { return Type::IfcCooledBeam; }
IfcCooledBeam::IfcCooledBeam(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCooledBeam)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCooledBeam::IfcCooledBeam(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCooledBeamTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCooledBeamType
IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum IfcCooledBeamType::PredefinedType() { return IfcCooledBeamTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCooledBeamType::setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCooledBeamTypeEnum::ToString(v)); }
bool IfcCooledBeamType::is(Type::Enum v) const { return v == Type::IfcCooledBeamType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCooledBeamType::type() const { return Type::IfcCooledBeamType; }
Type::Enum IfcCooledBeamType::Class() { return Type::IfcCooledBeamType; }
IfcCooledBeamType::IfcCooledBeamType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCooledBeamType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCooledBeamType::IfcCooledBeamType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCooledBeamTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoolingTower
bool IfcCoolingTower::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTower::PredefinedType() { return IfcCoolingTowerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCoolingTower::setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCoolingTowerTypeEnum::ToString(v)); }
bool IfcCoolingTower::is(Type::Enum v) const { return v == Type::IfcCoolingTower || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcCoolingTower::type() const { return Type::IfcCoolingTower; }
Type::Enum IfcCoolingTower::Class() { return Type::IfcCoolingTower; }
IfcCoolingTower::IfcCoolingTower(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCoolingTower)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoolingTower::IfcCoolingTower(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCoolingTowerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoolingTowerType
IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum IfcCoolingTowerType::PredefinedType() { return IfcCoolingTowerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoolingTowerType::setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCoolingTowerTypeEnum::ToString(v)); }
bool IfcCoolingTowerType::is(Type::Enum v) const { return v == Type::IfcCoolingTowerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcCoolingTowerType::type() const { return Type::IfcCoolingTowerType; }
Type::Enum IfcCoolingTowerType::Class() { return Type::IfcCoolingTowerType; }
IfcCoolingTowerType::IfcCoolingTowerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCoolingTowerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoolingTowerType::IfcCoolingTowerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCoolingTowerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoordinateOperation
IfcCoordinateReferenceSystemSelect IfcCoordinateOperation::SourceCRS() { return *entity->getArgument(0); }
void IfcCoordinateOperation::setSourceCRS(IfcCoordinateReferenceSystemSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCoordinateReferenceSystem* IfcCoordinateOperation::TargetCRS() { return (IfcCoordinateReferenceSystem*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcCoordinateOperation::setTargetCRS(IfcCoordinateReferenceSystem* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCoordinateOperation::is(Type::Enum v) const { return v == Type::IfcCoordinateOperation; }
Type::Enum IfcCoordinateOperation::type() const { return Type::IfcCoordinateOperation; }
Type::Enum IfcCoordinateOperation::Class() { return Type::IfcCoordinateOperation; }
IfcCoordinateOperation::IfcCoordinateOperation(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcCoordinateOperation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoordinateOperation::IfcCoordinateOperation(IfcCoordinateReferenceSystemSelect v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SourceCRS)); e->setArgument(1,(v2_TargetCRS)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoordinateReferenceSystem
bool IfcCoordinateReferenceSystem::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcCoordinateReferenceSystem::Name() { return *entity->getArgument(0); }
void IfcCoordinateReferenceSystem::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcCoordinateReferenceSystem::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcCoordinateReferenceSystem::Description() { return *entity->getArgument(1); }
void IfcCoordinateReferenceSystem::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcIdentifier IfcCoordinateReferenceSystem::GeodeticDatum() { return *entity->getArgument(2); }
void IfcCoordinateReferenceSystem::setGeodeticDatum(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcCoordinateReferenceSystem::hasVerticalDatum() { return !entity->getArgument(3)->isNull(); }
IfcIdentifier IfcCoordinateReferenceSystem::VerticalDatum() { return *entity->getArgument(3); }
void IfcCoordinateReferenceSystem::setVerticalDatum(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCoordinateReferenceSystem::is(Type::Enum v) const { return v == Type::IfcCoordinateReferenceSystem; }
Type::Enum IfcCoordinateReferenceSystem::type() const { return Type::IfcCoordinateReferenceSystem; }
Type::Enum IfcCoordinateReferenceSystem::Class() { return Type::IfcCoordinateReferenceSystem; }
IfcCoordinateReferenceSystem::IfcCoordinateReferenceSystem(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcCoordinateReferenceSystem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoordinateReferenceSystem::IfcCoordinateReferenceSystem(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcIdentifier v3_GeodeticDatum, boost::optional< IfcIdentifier > v4_VerticalDatum) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_GeodeticDatum)); if (v4_VerticalDatum) { e->setArgument(3,(*v4_VerticalDatum)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCostItem
bool IfcCostItem::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcCostItemTypeEnum::IfcCostItemTypeEnum IfcCostItem::PredefinedType() { return IfcCostItemTypeEnum::FromString(*entity->getArgument(6)); }
void IfcCostItem::setPredefinedType(IfcCostItemTypeEnum::IfcCostItemTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcCostItemTypeEnum::ToString(v)); }
bool IfcCostItem::hasCostValues() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcCostValue > > IfcCostItem::CostValues() { RETURN_AS_LIST(IfcCostValue,7) }
void IfcCostItem::setCostValues(SHARED_PTR< IfcTemplatedEntityList< IfcCostValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcCostItem::hasCostQuantities() { return !entity->getArgument(8)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > IfcCostItem::CostQuantities() { RETURN_AS_LIST(IfcPhysicalQuantity,8) }
void IfcCostItem::setCostQuantities(SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v->generalize()); }
bool IfcCostItem::is(Type::Enum v) const { return v == Type::IfcCostItem || IfcControl::is(v); }
Type::Enum IfcCostItem::type() const { return Type::IfcCostItem; }
Type::Enum IfcCostItem::Class() { return Type::IfcCostItem; }
IfcCostItem::IfcCostItem(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCostItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostItem::IfcCostItem(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcCostItemTypeEnum::IfcCostItemTypeEnum > v7_PredefinedType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcCostValue > > > v8_CostValues, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > > v9_CostQuantities) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcCostItemTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } if (v8_CostValues) { e->setArgument(7,(*v8_CostValues)->generalize()); } else { e->setArgument(7); } if (v9_CostQuantities) { e->setArgument(8,(*v9_CostQuantities)->generalize()); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCostSchedule
bool IfcCostSchedule::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum IfcCostSchedule::PredefinedType() { return IfcCostScheduleTypeEnum::FromString(*entity->getArgument(6)); }
void IfcCostSchedule::setPredefinedType(IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcCostScheduleTypeEnum::ToString(v)); }
bool IfcCostSchedule::hasStatus() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcCostSchedule::Status() { return *entity->getArgument(7); }
void IfcCostSchedule::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcCostSchedule::hasSubmittedOn() { return !entity->getArgument(8)->isNull(); }
IfcDateTime IfcCostSchedule::SubmittedOn() { return *entity->getArgument(8); }
void IfcCostSchedule::setSubmittedOn(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcCostSchedule::hasUpdateDate() { return !entity->getArgument(9)->isNull(); }
IfcDateTime IfcCostSchedule::UpdateDate() { return *entity->getArgument(9); }
void IfcCostSchedule::setUpdateDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcCostSchedule::is(Type::Enum v) const { return v == Type::IfcCostSchedule || IfcControl::is(v); }
Type::Enum IfcCostSchedule::type() const { return Type::IfcCostSchedule; }
Type::Enum IfcCostSchedule::Class() { return Type::IfcCostSchedule; }
IfcCostSchedule::IfcCostSchedule(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCostSchedule)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostSchedule::IfcCostSchedule(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum > v7_PredefinedType, boost::optional< IfcLabel > v8_Status, boost::optional< IfcDateTime > v9_SubmittedOn, boost::optional< IfcDateTime > v10_UpdateDate) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcCostScheduleTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } if (v8_Status) { e->setArgument(7,(*v8_Status)); } else { e->setArgument(7); } if (v9_SubmittedOn) { e->setArgument(8,(*v9_SubmittedOn)); } else { e->setArgument(8); } if (v10_UpdateDate) { e->setArgument(9,(*v10_UpdateDate)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCostValue
bool IfcCostValue::is(Type::Enum v) const { return v == Type::IfcCostValue || IfcAppliedValue::is(v); }
Type::Enum IfcCostValue::type() const { return Type::IfcCostValue; }
Type::Enum IfcCostValue::Class() { return Type::IfcCostValue; }
IfcCostValue::IfcCostValue(IfcAbstractEntityPtr e) : IfcAppliedValue((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCostValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCostValue::IfcCostValue(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcAppliedValueSelect > v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< IfcDate > v5_ApplicableDate, boost::optional< IfcDate > v6_FixedUntilDate, boost::optional< IfcLabel > v7_Category, boost::optional< IfcLabel > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_Components) : IfcAppliedValue((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_AppliedValue) { e->setArgument(2,(*v3_AppliedValue)); } else { e->setArgument(2); } e->setArgument(3,(v4_UnitBasis)); if (v5_ApplicableDate) { e->setArgument(4,(*v5_ApplicableDate)); } else { e->setArgument(4); } if (v6_FixedUntilDate) { e->setArgument(5,(*v6_FixedUntilDate)); } else { e->setArgument(5); } if (v7_Category) { e->setArgument(6,(*v7_Category)); } else { e->setArgument(6); } if (v8_Condition) { e->setArgument(7,(*v8_Condition)); } else { e->setArgument(7); } if (v9_ArithmeticOperator) { e->setArgument(8,*v9_ArithmeticOperator,IfcArithmeticOperatorEnum::ToString(*v9_ArithmeticOperator)); } else { e->setArgument(8); } if (v10_Components) { e->setArgument(9,(*v10_Components)->generalize()); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCovering
bool IfcCovering::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCovering::PredefinedType() { return IfcCoveringTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCovering::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCoveringTypeEnum::ToString(v)); }
IfcRelCoversSpaces::list IfcCovering::CoversSpaces() { RETURN_INVERSE(IfcRelCoversSpaces) }
IfcRelCoversBldgElements::list IfcCovering::CoversElements() { RETURN_INVERSE(IfcRelCoversBldgElements) }
bool IfcCovering::is(Type::Enum v) const { return v == Type::IfcCovering || IfcBuildingElement::is(v); }
Type::Enum IfcCovering::type() const { return Type::IfcCovering; }
Type::Enum IfcCovering::Class() { return Type::IfcCovering; }
IfcCovering::IfcCovering(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCovering)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCovering::IfcCovering(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCoveringTypeEnum::IfcCoveringTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCoveringTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCoveringType
IfcCoveringTypeEnum::IfcCoveringTypeEnum IfcCoveringType::PredefinedType() { return IfcCoveringTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCoveringType::setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCoveringTypeEnum::ToString(v)); }
bool IfcCoveringType::is(Type::Enum v) const { return v == Type::IfcCoveringType || IfcBuildingElementType::is(v); }
Type::Enum IfcCoveringType::type() const { return Type::IfcCoveringType; }
Type::Enum IfcCoveringType::Class() { return Type::IfcCoveringType; }
IfcCoveringType::IfcCoveringType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCoveringType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCoveringType::IfcCoveringType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCoveringTypeEnum::IfcCoveringTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCoveringTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCrewResource
bool IfcCrewResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResource::PredefinedType() { return IfcCrewResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcCrewResource::setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcCrewResourceTypeEnum::ToString(v)); }
bool IfcCrewResource::is(Type::Enum v) const { return v == Type::IfcCrewResource || IfcConstructionResource::is(v); }
Type::Enum IfcCrewResource::type() const { return Type::IfcCrewResource; }
Type::Enum IfcCrewResource::Class() { return Type::IfcCrewResource; }
IfcCrewResource::IfcCrewResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCrewResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCrewResource::IfcCrewResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcCrewResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCrewResourceType
IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum IfcCrewResourceType::PredefinedType() { return IfcCrewResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcCrewResourceType::setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcCrewResourceTypeEnum::ToString(v)); }
bool IfcCrewResourceType::is(Type::Enum v) const { return v == Type::IfcCrewResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcCrewResourceType::type() const { return Type::IfcCrewResourceType; }
Type::Enum IfcCrewResourceType::Class() { return Type::IfcCrewResourceType; }
IfcCrewResourceType::IfcCrewResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCrewResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCrewResourceType::IfcCrewResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcCrewResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCsgPrimitive3D
IfcAxis2Placement3D* IfcCsgPrimitive3D::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcCsgPrimitive3D::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcCsgPrimitive3D::is(Type::Enum v) const { return v == Type::IfcCsgPrimitive3D || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCsgPrimitive3D::type() const { return Type::IfcCsgPrimitive3D; }
Type::Enum IfcCsgPrimitive3D::Class() { return Type::IfcCsgPrimitive3D; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCsgPrimitive3D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCsgPrimitive3D::IfcCsgPrimitive3D(IfcAxis2Placement3D* v1_Position) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCsgSolid
IfcCsgSelect IfcCsgSolid::TreeRootExpression() { return *entity->getArgument(0); }
void IfcCsgSolid::setTreeRootExpression(IfcCsgSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcCsgSolid::is(Type::Enum v) const { return v == Type::IfcCsgSolid || IfcSolidModel::is(v); }
Type::Enum IfcCsgSolid::type() const { return Type::IfcCsgSolid; }
Type::Enum IfcCsgSolid::Class() { return Type::IfcCsgSolid; }
IfcCsgSolid::IfcCsgSolid(IfcAbstractEntityPtr e) : IfcSolidModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCsgSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCsgSolid::IfcCsgSolid(IfcCsgSelect v1_TreeRootExpression) : IfcSolidModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_TreeRootExpression)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurrencyRelationship
IfcMonetaryUnit* IfcCurrencyRelationship::RelatingMonetaryUnit() { return (IfcMonetaryUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcCurrencyRelationship::setRelatingMonetaryUnit(IfcMonetaryUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcMonetaryUnit* IfcCurrencyRelationship::RelatedMonetaryUnit() { return (IfcMonetaryUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcCurrencyRelationship::setRelatedMonetaryUnit(IfcMonetaryUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveRatioMeasure IfcCurrencyRelationship::ExchangeRate() { return *entity->getArgument(4); }
void IfcCurrencyRelationship::setExchangeRate(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcCurrencyRelationship::hasRateDateTime() { return !entity->getArgument(5)->isNull(); }
IfcDateTime IfcCurrencyRelationship::RateDateTime() { return *entity->getArgument(5); }
void IfcCurrencyRelationship::setRateDateTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcCurrencyRelationship::hasRateSource() { return !entity->getArgument(6)->isNull(); }
IfcLibraryInformation* IfcCurrencyRelationship::RateSource() { return (IfcLibraryInformation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcCurrencyRelationship::setRateSource(IfcLibraryInformation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcCurrencyRelationship::is(Type::Enum v) const { return v == Type::IfcCurrencyRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcCurrencyRelationship::type() const { return Type::IfcCurrencyRelationship; }
Type::Enum IfcCurrencyRelationship::Class() { return Type::IfcCurrencyRelationship; }
IfcCurrencyRelationship::IfcCurrencyRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurrencyRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurrencyRelationship::IfcCurrencyRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcMonetaryUnit* v3_RelatingMonetaryUnit, IfcMonetaryUnit* v4_RelatedMonetaryUnit, IfcPositiveRatioMeasure v5_ExchangeRate, boost::optional< IfcDateTime > v6_RateDateTime, IfcLibraryInformation* v7_RateSource) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingMonetaryUnit)); e->setArgument(3,(v4_RelatedMonetaryUnit)); e->setArgument(4,(v5_ExchangeRate)); if (v6_RateDateTime) { e->setArgument(5,(*v6_RateDateTime)); } else { e->setArgument(5); } e->setArgument(6,(v7_RateSource)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurtainWall
bool IfcCurtainWall::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWall::PredefinedType() { return IfcCurtainWallTypeEnum::FromString(*entity->getArgument(8)); }
void IfcCurtainWall::setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcCurtainWallTypeEnum::ToString(v)); }
bool IfcCurtainWall::is(Type::Enum v) const { return v == Type::IfcCurtainWall || IfcBuildingElement::is(v); }
Type::Enum IfcCurtainWall::type() const { return Type::IfcCurtainWall; }
Type::Enum IfcCurtainWall::Class() { return Type::IfcCurtainWall; }
IfcCurtainWall::IfcCurtainWall(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurtainWall)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurtainWall::IfcCurtainWall(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcCurtainWallTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurtainWallType
IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum IfcCurtainWallType::PredefinedType() { return IfcCurtainWallTypeEnum::FromString(*entity->getArgument(9)); }
void IfcCurtainWallType::setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcCurtainWallTypeEnum::ToString(v)); }
bool IfcCurtainWallType::is(Type::Enum v) const { return v == Type::IfcCurtainWallType || IfcBuildingElementType::is(v); }
Type::Enum IfcCurtainWallType::type() const { return Type::IfcCurtainWallType; }
Type::Enum IfcCurtainWallType::Class() { return Type::IfcCurtainWallType; }
IfcCurtainWallType::IfcCurtainWallType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurtainWallType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurtainWallType::IfcCurtainWallType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcCurtainWallTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurve
bool IfcCurve::is(Type::Enum v) const { return v == Type::IfcCurve || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcCurve::type() const { return Type::IfcCurve; }
Type::Enum IfcCurve::Class() { return Type::IfcCurve; }
IfcCurve::IfcCurve(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurve::IfcCurve() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveBoundedPlane
IfcPlane* IfcCurveBoundedPlane::BasisSurface() { return (IfcPlane*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcCurveBoundedPlane::setBasisSurface(IfcPlane* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCurve* IfcCurveBoundedPlane::OuterBoundary() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcCurveBoundedPlane::setOuterBoundary(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > IfcCurveBoundedPlane::InnerBoundaries() { RETURN_AS_LIST(IfcCurve,2) }
void IfcCurveBoundedPlane::setInnerBoundaries(SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcCurveBoundedPlane::is(Type::Enum v) const { return v == Type::IfcCurveBoundedPlane || IfcBoundedSurface::is(v); }
Type::Enum IfcCurveBoundedPlane::type() const { return Type::IfcCurveBoundedPlane; }
Type::Enum IfcCurveBoundedPlane::Class() { return Type::IfcCurveBoundedPlane; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcAbstractEntityPtr e) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveBoundedPlane)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveBoundedPlane::IfcCurveBoundedPlane(IfcPlane* v1_BasisSurface, IfcCurve* v2_OuterBoundary, SHARED_PTR< IfcTemplatedEntityList< IfcCurve > > v3_InnerBoundaries) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisSurface)); e->setArgument(1,(v2_OuterBoundary)); e->setArgument(2,(v3_InnerBoundaries)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveBoundedSurface
IfcSurface* IfcCurveBoundedSurface::BasisSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcCurveBoundedSurface::setBasisSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcBoundaryCurve > > IfcCurveBoundedSurface::Boundaries() { RETURN_AS_LIST(IfcBoundaryCurve,1) }
void IfcCurveBoundedSurface::setBoundaries(SHARED_PTR< IfcTemplatedEntityList< IfcBoundaryCurve > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcCurveBoundedSurface::ImplicitOuter() { return *entity->getArgument(2); }
void IfcCurveBoundedSurface::setImplicitOuter(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcCurveBoundedSurface::is(Type::Enum v) const { return v == Type::IfcCurveBoundedSurface || IfcBoundedSurface::is(v); }
Type::Enum IfcCurveBoundedSurface::type() const { return Type::IfcCurveBoundedSurface; }
Type::Enum IfcCurveBoundedSurface::Class() { return Type::IfcCurveBoundedSurface; }
IfcCurveBoundedSurface::IfcCurveBoundedSurface(IfcAbstractEntityPtr e) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveBoundedSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveBoundedSurface::IfcCurveBoundedSurface(IfcSurface* v1_BasisSurface, SHARED_PTR< IfcTemplatedEntityList< IfcBoundaryCurve > > v2_Boundaries, bool v3_ImplicitOuter) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisSurface)); e->setArgument(1,(v2_Boundaries)->generalize()); e->setArgument(2,(v3_ImplicitOuter)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveStyle
bool IfcCurveStyle::hasCurveFont() { return !entity->getArgument(1)->isNull(); }
IfcCurveFontOrScaledCurveFontSelect IfcCurveStyle::CurveFont() { return *entity->getArgument(1); }
void IfcCurveStyle::setCurveFont(IfcCurveFontOrScaledCurveFontSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCurveStyle::hasCurveWidth() { return !entity->getArgument(2)->isNull(); }
IfcSizeSelect IfcCurveStyle::CurveWidth() { return *entity->getArgument(2); }
void IfcCurveStyle::setCurveWidth(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcCurveStyle::hasCurveColour() { return !entity->getArgument(3)->isNull(); }
IfcColour IfcCurveStyle::CurveColour() { return *entity->getArgument(3); }
void IfcCurveStyle::setCurveColour(IfcColour v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcCurveStyle::hasModelOrDraughting() { return !entity->getArgument(4)->isNull(); }
bool IfcCurveStyle::ModelOrDraughting() { return *entity->getArgument(4); }
void IfcCurveStyle::setModelOrDraughting(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcCurveStyle::is(Type::Enum v) const { return v == Type::IfcCurveStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcCurveStyle::type() const { return Type::IfcCurveStyle; }
Type::Enum IfcCurveStyle::Class() { return Type::IfcCurveStyle; }
IfcCurveStyle::IfcCurveStyle(IfcAbstractEntityPtr e) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyle::IfcCurveStyle(boost::optional< IfcLabel > v1_Name, boost::optional< IfcCurveFontOrScaledCurveFontSelect > v2_CurveFont, boost::optional< IfcSizeSelect > v3_CurveWidth, boost::optional< IfcColour > v4_CurveColour, boost::optional< bool > v5_ModelOrDraughting) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_CurveFont) { e->setArgument(1,(*v2_CurveFont)); } else { e->setArgument(1); } if (v3_CurveWidth) { e->setArgument(2,(*v3_CurveWidth)); } else { e->setArgument(2); } if (v4_CurveColour) { e->setArgument(3,(*v4_CurveColour)); } else { e->setArgument(3); } if (v5_ModelOrDraughting) { e->setArgument(4,(*v5_ModelOrDraughting)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveStyleFont
bool IfcCurveStyleFont::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcCurveStyleFont::Name() { return *entity->getArgument(0); }
void IfcCurveStyleFont::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcCurveStyleFontPattern > > IfcCurveStyleFont::PatternList() { RETURN_AS_LIST(IfcCurveStyleFontPattern,1) }
void IfcCurveStyleFont::setPatternList(SHARED_PTR< IfcTemplatedEntityList< IfcCurveStyleFontPattern > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcCurveStyleFont::is(Type::Enum v) const { return v == Type::IfcCurveStyleFont || IfcPresentationItem::is(v); }
Type::Enum IfcCurveStyleFont::type() const { return Type::IfcCurveStyleFont; }
Type::Enum IfcCurveStyleFont::Class() { return Type::IfcCurveStyleFont; }
IfcCurveStyleFont::IfcCurveStyleFont(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveStyleFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFont::IfcCurveStyleFont(boost::optional< IfcLabel > v1_Name, SHARED_PTR< IfcTemplatedEntityList< IfcCurveStyleFontPattern > > v2_PatternList) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_PatternList)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveStyleFontAndScaling
bool IfcCurveStyleFontAndScaling::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcCurveStyleFontAndScaling::Name() { return *entity->getArgument(0); }
void IfcCurveStyleFontAndScaling::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCurveStyleFontSelect IfcCurveStyleFontAndScaling::CurveFont() { return *entity->getArgument(1); }
void IfcCurveStyleFontAndScaling::setCurveFont(IfcCurveStyleFontSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveRatioMeasure IfcCurveStyleFontAndScaling::CurveFontScaling() { return *entity->getArgument(2); }
void IfcCurveStyleFontAndScaling::setCurveFontScaling(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcCurveStyleFontAndScaling::is(Type::Enum v) const { return v == Type::IfcCurveStyleFontAndScaling || IfcPresentationItem::is(v); }
Type::Enum IfcCurveStyleFontAndScaling::type() const { return Type::IfcCurveStyleFontAndScaling; }
Type::Enum IfcCurveStyleFontAndScaling::Class() { return Type::IfcCurveStyleFontAndScaling; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveStyleFontAndScaling)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFontAndScaling::IfcCurveStyleFontAndScaling(boost::optional< IfcLabel > v1_Name, IfcCurveStyleFontSelect v2_CurveFont, IfcPositiveRatioMeasure v3_CurveFontScaling) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_CurveFont)); e->setArgument(2,(v3_CurveFontScaling)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCurveStyleFontPattern
IfcLengthMeasure IfcCurveStyleFontPattern::VisibleSegmentLength() { return *entity->getArgument(0); }
void IfcCurveStyleFontPattern::setVisibleSegmentLength(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcPositiveLengthMeasure IfcCurveStyleFontPattern::InvisibleSegmentLength() { return *entity->getArgument(1); }
void IfcCurveStyleFontPattern::setInvisibleSegmentLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCurveStyleFontPattern::is(Type::Enum v) const { return v == Type::IfcCurveStyleFontPattern || IfcPresentationItem::is(v); }
Type::Enum IfcCurveStyleFontPattern::type() const { return Type::IfcCurveStyleFontPattern; }
Type::Enum IfcCurveStyleFontPattern::Class() { return Type::IfcCurveStyleFontPattern; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCurveStyleFontPattern)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCurveStyleFontPattern::IfcCurveStyleFontPattern(IfcLengthMeasure v1_VisibleSegmentLength, IfcPositiveLengthMeasure v2_InvisibleSegmentLength) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_VisibleSegmentLength)); e->setArgument(1,(v2_InvisibleSegmentLength)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcCylindricalSurface
IfcPositiveLengthMeasure IfcCylindricalSurface::Radius() { return *entity->getArgument(1); }
void IfcCylindricalSurface::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcCylindricalSurface::is(Type::Enum v) const { return v == Type::IfcCylindricalSurface || IfcElementarySurface::is(v); }
Type::Enum IfcCylindricalSurface::type() const { return Type::IfcCylindricalSurface; }
Type::Enum IfcCylindricalSurface::Class() { return Type::IfcCylindricalSurface; }
IfcCylindricalSurface::IfcCylindricalSurface(IfcAbstractEntityPtr e) : IfcElementarySurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcCylindricalSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcCylindricalSurface::IfcCylindricalSurface(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_Radius) : IfcElementarySurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_Radius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDamper
bool IfcDamper::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamper::PredefinedType() { return IfcDamperTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDamper::setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDamperTypeEnum::ToString(v)); }
bool IfcDamper::is(Type::Enum v) const { return v == Type::IfcDamper || IfcFlowController::is(v); }
Type::Enum IfcDamper::type() const { return Type::IfcDamper; }
Type::Enum IfcDamper::Class() { return Type::IfcDamper; }
IfcDamper::IfcDamper(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDamper)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDamper::IfcDamper(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDamperTypeEnum::IfcDamperTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDamperTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDamperType
IfcDamperTypeEnum::IfcDamperTypeEnum IfcDamperType::PredefinedType() { return IfcDamperTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDamperType::setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDamperTypeEnum::ToString(v)); }
bool IfcDamperType::is(Type::Enum v) const { return v == Type::IfcDamperType || IfcFlowControllerType::is(v); }
Type::Enum IfcDamperType::type() const { return Type::IfcDamperType; }
Type::Enum IfcDamperType::Class() { return Type::IfcDamperType; }
IfcDamperType::IfcDamperType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDamperType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDamperType::IfcDamperType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDamperTypeEnum::IfcDamperTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDamperTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDerivedProfileDef
IfcProfileDef* IfcDerivedProfileDef::ParentProfile() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcDerivedProfileDef::setParentProfile(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcCartesianTransformationOperator2D* IfcDerivedProfileDef::Operator() { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcDerivedProfileDef::setOperator(IfcCartesianTransformationOperator2D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcDerivedProfileDef::hasLabel() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcDerivedProfileDef::Label() { return *entity->getArgument(4); }
void IfcDerivedProfileDef::setLabel(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcDerivedProfileDef::is(Type::Enum v) const { return v == Type::IfcDerivedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcDerivedProfileDef::type() const { return Type::IfcDerivedProfileDef; }
Type::Enum IfcDerivedProfileDef::Class() { return Type::IfcDerivedProfileDef; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcAbstractEntityPtr e) : IfcProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDerivedProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedProfileDef::IfcDerivedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcProfileDef* v3_ParentProfile, IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< IfcLabel > v5_Label) : IfcProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_ParentProfile)); e->setArgument(3,(v4_Operator)); if (v5_Label) { e->setArgument(4,(*v5_Label)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDerivedUnit
SHARED_PTR< IfcTemplatedEntityList< IfcDerivedUnitElement > > IfcDerivedUnit::Elements() { RETURN_AS_LIST(IfcDerivedUnitElement,0) }
void IfcDerivedUnit::setElements(SHARED_PTR< IfcTemplatedEntityList< IfcDerivedUnitElement > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
IfcDerivedUnitEnum::IfcDerivedUnitEnum IfcDerivedUnit::UnitType() { return IfcDerivedUnitEnum::FromString(*entity->getArgument(1)); }
void IfcDerivedUnit::setUnitType(IfcDerivedUnitEnum::IfcDerivedUnitEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v,IfcDerivedUnitEnum::ToString(v)); }
bool IfcDerivedUnit::hasUserDefinedType() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcDerivedUnit::UserDefinedType() { return *entity->getArgument(2); }
void IfcDerivedUnit::setUserDefinedType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcDerivedUnit::is(Type::Enum v) const { return v == Type::IfcDerivedUnit; }
Type::Enum IfcDerivedUnit::type() const { return Type::IfcDerivedUnit; }
Type::Enum IfcDerivedUnit::Class() { return Type::IfcDerivedUnit; }
IfcDerivedUnit::IfcDerivedUnit(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcDerivedUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedUnit::IfcDerivedUnit(SHARED_PTR< IfcTemplatedEntityList< IfcDerivedUnitElement > > v1_Elements, IfcDerivedUnitEnum::IfcDerivedUnitEnum v2_UnitType, boost::optional< IfcLabel > v3_UserDefinedType) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Elements)->generalize()); e->setArgument(1,v2_UnitType,IfcDerivedUnitEnum::ToString(v2_UnitType)); if (v3_UserDefinedType) { e->setArgument(2,(*v3_UserDefinedType)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDerivedUnitElement
IfcNamedUnit* IfcDerivedUnitElement::Unit() { return (IfcNamedUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcDerivedUnitElement::setUnit(IfcNamedUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
int IfcDerivedUnitElement::Exponent() { return *entity->getArgument(1); }
void IfcDerivedUnitElement::setExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcDerivedUnitElement::is(Type::Enum v) const { return v == Type::IfcDerivedUnitElement; }
Type::Enum IfcDerivedUnitElement::type() const { return Type::IfcDerivedUnitElement; }
Type::Enum IfcDerivedUnitElement::Class() { return Type::IfcDerivedUnitElement; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcDerivedUnitElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDerivedUnitElement::IfcDerivedUnitElement(IfcNamedUnit* v1_Unit, int v2_Exponent) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Unit)); e->setArgument(1,(v2_Exponent)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDimensionalExponents
int IfcDimensionalExponents::LengthExponent() { return *entity->getArgument(0); }
void IfcDimensionalExponents::setLengthExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
int IfcDimensionalExponents::MassExponent() { return *entity->getArgument(1); }
void IfcDimensionalExponents::setMassExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
int IfcDimensionalExponents::TimeExponent() { return *entity->getArgument(2); }
void IfcDimensionalExponents::setTimeExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
int IfcDimensionalExponents::ElectricCurrentExponent() { return *entity->getArgument(3); }
void IfcDimensionalExponents::setElectricCurrentExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
int IfcDimensionalExponents::ThermodynamicTemperatureExponent() { return *entity->getArgument(4); }
void IfcDimensionalExponents::setThermodynamicTemperatureExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
int IfcDimensionalExponents::AmountOfSubstanceExponent() { return *entity->getArgument(5); }
void IfcDimensionalExponents::setAmountOfSubstanceExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
int IfcDimensionalExponents::LuminousIntensityExponent() { return *entity->getArgument(6); }
void IfcDimensionalExponents::setLuminousIntensityExponent(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcDimensionalExponents::is(Type::Enum v) const { return v == Type::IfcDimensionalExponents; }
Type::Enum IfcDimensionalExponents::type() const { return Type::IfcDimensionalExponents; }
Type::Enum IfcDimensionalExponents::Class() { return Type::IfcDimensionalExponents; }
IfcDimensionalExponents::IfcDimensionalExponents(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcDimensionalExponents)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDimensionalExponents::IfcDimensionalExponents(int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_LengthExponent)); e->setArgument(1,(v2_MassExponent)); e->setArgument(2,(v3_TimeExponent)); e->setArgument(3,(v4_ElectricCurrentExponent)); e->setArgument(4,(v5_ThermodynamicTemperatureExponent)); e->setArgument(5,(v6_AmountOfSubstanceExponent)); e->setArgument(6,(v7_LuminousIntensityExponent)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDirection
std::vector< double > /*[2:3]*/ IfcDirection::DirectionRatios() { return *entity->getArgument(0); }
void IfcDirection::setDirectionRatios(std::vector< double > /*[2:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcDirection::is(Type::Enum v) const { return v == Type::IfcDirection || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcDirection::type() const { return Type::IfcDirection; }
Type::Enum IfcDirection::Class() { return Type::IfcDirection; }
IfcDirection::IfcDirection(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDirection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDirection::IfcDirection(std::vector< double > /*[2:3]*/ v1_DirectionRatios) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_DirectionRatios)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDiscreteAccessory
bool IfcDiscreteAccessory::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessory::PredefinedType() { return IfcDiscreteAccessoryTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDiscreteAccessory::setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDiscreteAccessoryTypeEnum::ToString(v)); }
bool IfcDiscreteAccessory::is(Type::Enum v) const { return v == Type::IfcDiscreteAccessory || IfcElementComponent::is(v); }
Type::Enum IfcDiscreteAccessory::type() const { return Type::IfcDiscreteAccessory; }
Type::Enum IfcDiscreteAccessory::Class() { return Type::IfcDiscreteAccessory; }
IfcDiscreteAccessory::IfcDiscreteAccessory(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDiscreteAccessory)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDiscreteAccessory::IfcDiscreteAccessory(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDiscreteAccessoryTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDiscreteAccessoryType
IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum IfcDiscreteAccessoryType::PredefinedType() { return IfcDiscreteAccessoryTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDiscreteAccessoryType::setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDiscreteAccessoryTypeEnum::ToString(v)); }
bool IfcDiscreteAccessoryType::is(Type::Enum v) const { return v == Type::IfcDiscreteAccessoryType || IfcElementComponentType::is(v); }
Type::Enum IfcDiscreteAccessoryType::type() const { return Type::IfcDiscreteAccessoryType; }
Type::Enum IfcDiscreteAccessoryType::Class() { return Type::IfcDiscreteAccessoryType; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDiscreteAccessoryType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDiscreteAccessoryType::IfcDiscreteAccessoryType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDiscreteAccessoryTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionChamberElement
bool IfcDistributionChamberElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElement::PredefinedType() { return IfcDistributionChamberElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDistributionChamberElement::setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDistributionChamberElementTypeEnum::ToString(v)); }
bool IfcDistributionChamberElement::is(Type::Enum v) const { return v == Type::IfcDistributionChamberElement || IfcDistributionFlowElement::is(v); }
Type::Enum IfcDistributionChamberElement::type() const { return Type::IfcDistributionChamberElement; }
Type::Enum IfcDistributionChamberElement::Class() { return Type::IfcDistributionChamberElement; }
IfcDistributionChamberElement::IfcDistributionChamberElement(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionChamberElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionChamberElement::IfcDistributionChamberElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum > v9_PredefinedType) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDistributionChamberElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionChamberElementType
IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum IfcDistributionChamberElementType::PredefinedType() { return IfcDistributionChamberElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDistributionChamberElementType::setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDistributionChamberElementTypeEnum::ToString(v)); }
bool IfcDistributionChamberElementType::is(Type::Enum v) const { return v == Type::IfcDistributionChamberElementType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcDistributionChamberElementType::type() const { return Type::IfcDistributionChamberElementType; }
Type::Enum IfcDistributionChamberElementType::Class() { return Type::IfcDistributionChamberElementType; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionChamberElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionChamberElementType::IfcDistributionChamberElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v10_PredefinedType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDistributionChamberElementTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionCircuit
bool IfcDistributionCircuit::is(Type::Enum v) const { return v == Type::IfcDistributionCircuit || IfcDistributionSystem::is(v); }
Type::Enum IfcDistributionCircuit::type() const { return Type::IfcDistributionCircuit; }
Type::Enum IfcDistributionCircuit::Class() { return Type::IfcDistributionCircuit; }
IfcDistributionCircuit::IfcDistributionCircuit(IfcAbstractEntityPtr e) : IfcDistributionSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionCircuit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionCircuit::IfcDistributionCircuit(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType) : IfcDistributionSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcDistributionSystemEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionControlElement
IfcRelFlowControlElements::list IfcDistributionControlElement::AssignedToFlowElement() { RETURN_INVERSE(IfcRelFlowControlElements) }
bool IfcDistributionControlElement::is(Type::Enum v) const { return v == Type::IfcDistributionControlElement || IfcDistributionElement::is(v); }
Type::Enum IfcDistributionControlElement::type() const { return Type::IfcDistributionControlElement; }
Type::Enum IfcDistributionControlElement::Class() { return Type::IfcDistributionControlElement; }
IfcDistributionControlElement::IfcDistributionControlElement(IfcAbstractEntityPtr e) : IfcDistributionElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionControlElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionControlElement::IfcDistributionControlElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionControlElementType
bool IfcDistributionControlElementType::is(Type::Enum v) const { return v == Type::IfcDistributionControlElementType || IfcDistributionElementType::is(v); }
Type::Enum IfcDistributionControlElementType::type() const { return Type::IfcDistributionControlElementType; }
Type::Enum IfcDistributionControlElementType::Class() { return Type::IfcDistributionControlElementType; }
IfcDistributionControlElementType::IfcDistributionControlElementType(IfcAbstractEntityPtr e) : IfcDistributionElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionControlElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionControlElementType::IfcDistributionControlElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionElement
IfcRelConnectsPortToElement::list IfcDistributionElement::HasPorts() { RETURN_INVERSE(IfcRelConnectsPortToElement) }
bool IfcDistributionElement::is(Type::Enum v) const { return v == Type::IfcDistributionElement || IfcElement::is(v); }
Type::Enum IfcDistributionElement::type() const { return Type::IfcDistributionElement; }
Type::Enum IfcDistributionElement::Class() { return Type::IfcDistributionElement; }
IfcDistributionElement::IfcDistributionElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionElement::IfcDistributionElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionElementType
bool IfcDistributionElementType::is(Type::Enum v) const { return v == Type::IfcDistributionElementType || IfcElementType::is(v); }
Type::Enum IfcDistributionElementType::type() const { return Type::IfcDistributionElementType; }
Type::Enum IfcDistributionElementType::Class() { return Type::IfcDistributionElementType; }
IfcDistributionElementType::IfcDistributionElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionElementType::IfcDistributionElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionFlowElement
IfcRelFlowControlElements::list IfcDistributionFlowElement::HasControlElements() { RETURN_INVERSE(IfcRelFlowControlElements) }
bool IfcDistributionFlowElement::is(Type::Enum v) const { return v == Type::IfcDistributionFlowElement || IfcDistributionElement::is(v); }
Type::Enum IfcDistributionFlowElement::type() const { return Type::IfcDistributionFlowElement; }
Type::Enum IfcDistributionFlowElement::Class() { return Type::IfcDistributionFlowElement; }
IfcDistributionFlowElement::IfcDistributionFlowElement(IfcAbstractEntityPtr e) : IfcDistributionElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionFlowElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionFlowElement::IfcDistributionFlowElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionFlowElementType
bool IfcDistributionFlowElementType::is(Type::Enum v) const { return v == Type::IfcDistributionFlowElementType || IfcDistributionElementType::is(v); }
Type::Enum IfcDistributionFlowElementType::type() const { return Type::IfcDistributionFlowElementType; }
Type::Enum IfcDistributionFlowElementType::Class() { return Type::IfcDistributionFlowElementType; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(IfcAbstractEntityPtr e) : IfcDistributionElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionFlowElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionFlowElementType::IfcDistributionFlowElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionPort
bool IfcDistributionPort::hasFlowDirection() { return !entity->getArgument(7)->isNull(); }
IfcFlowDirectionEnum::IfcFlowDirectionEnum IfcDistributionPort::FlowDirection() { return IfcFlowDirectionEnum::FromString(*entity->getArgument(7)); }
void IfcDistributionPort::setFlowDirection(IfcFlowDirectionEnum::IfcFlowDirectionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcFlowDirectionEnum::ToString(v)); }
bool IfcDistributionPort::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum IfcDistributionPort::PredefinedType() { return IfcDistributionPortTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDistributionPort::setPredefinedType(IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDistributionPortTypeEnum::ToString(v)); }
bool IfcDistributionPort::hasSystemType() { return !entity->getArgument(9)->isNull(); }
IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionPort::SystemType() { return IfcDistributionSystemEnum::FromString(*entity->getArgument(9)); }
void IfcDistributionPort::setSystemType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDistributionSystemEnum::ToString(v)); }
bool IfcDistributionPort::is(Type::Enum v) const { return v == Type::IfcDistributionPort || IfcPort::is(v); }
Type::Enum IfcDistributionPort::type() const { return Type::IfcDistributionPort; }
Type::Enum IfcDistributionPort::Class() { return Type::IfcDistributionPort; }
IfcDistributionPort::IfcDistributionPort(IfcAbstractEntityPtr e) : IfcPort((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionPort)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionPort::IfcDistributionPort(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcFlowDirectionEnum::IfcFlowDirectionEnum > v8_FlowDirection, boost::optional< IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum > v9_PredefinedType, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v10_SystemType) : IfcPort((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_FlowDirection) { e->setArgument(7,*v8_FlowDirection,IfcFlowDirectionEnum::ToString(*v8_FlowDirection)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDistributionPortTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } if (v10_SystemType) { e->setArgument(9,*v10_SystemType,IfcDistributionSystemEnum::ToString(*v10_SystemType)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDistributionSystem
bool IfcDistributionSystem::hasLongName() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcDistributionSystem::LongName() { return *entity->getArgument(5); }
void IfcDistributionSystem::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcDistributionSystem::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcDistributionSystemEnum::IfcDistributionSystemEnum IfcDistributionSystem::PredefinedType() { return IfcDistributionSystemEnum::FromString(*entity->getArgument(6)); }
void IfcDistributionSystem::setPredefinedType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcDistributionSystemEnum::ToString(v)); }
bool IfcDistributionSystem::is(Type::Enum v) const { return v == Type::IfcDistributionSystem || IfcSystem::is(v); }
Type::Enum IfcDistributionSystem::type() const { return Type::IfcDistributionSystem; }
Type::Enum IfcDistributionSystem::Class() { return Type::IfcDistributionSystem; }
IfcDistributionSystem::IfcDistributionSystem(IfcAbstractEntityPtr e) : IfcSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDistributionSystem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDistributionSystem::IfcDistributionSystem(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType) : IfcSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcDistributionSystemEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDocumentInformation
IfcIdentifier IfcDocumentInformation::Identification() { return *entity->getArgument(0); }
void IfcDocumentInformation::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLabel IfcDocumentInformation::Name() { return *entity->getArgument(1); }
void IfcDocumentInformation::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcDocumentInformation::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcDocumentInformation::Description() { return *entity->getArgument(2); }
void IfcDocumentInformation::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcDocumentInformation::hasLocation() { return !entity->getArgument(3)->isNull(); }
IfcURIReference IfcDocumentInformation::Location() { return *entity->getArgument(3); }
void IfcDocumentInformation::setLocation(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcDocumentInformation::hasPurpose() { return !entity->getArgument(4)->isNull(); }
IfcText IfcDocumentInformation::Purpose() { return *entity->getArgument(4); }
void IfcDocumentInformation::setPurpose(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcDocumentInformation::hasIntendedUse() { return !entity->getArgument(5)->isNull(); }
IfcText IfcDocumentInformation::IntendedUse() { return *entity->getArgument(5); }
void IfcDocumentInformation::setIntendedUse(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcDocumentInformation::hasScope() { return !entity->getArgument(6)->isNull(); }
IfcText IfcDocumentInformation::Scope() { return *entity->getArgument(6); }
void IfcDocumentInformation::setScope(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcDocumentInformation::hasRevision() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcDocumentInformation::Revision() { return *entity->getArgument(7); }
void IfcDocumentInformation::setRevision(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcDocumentInformation::hasDocumentOwner() { return !entity->getArgument(8)->isNull(); }
IfcActorSelect IfcDocumentInformation::DocumentOwner() { return *entity->getArgument(8); }
void IfcDocumentInformation::setDocumentOwner(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcDocumentInformation::hasEditors() { return !entity->getArgument(9)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcDocumentInformation::Editors() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,9) }
void IfcDocumentInformation::setEditors(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v->generalize()); }
bool IfcDocumentInformation::hasCreationTime() { return !entity->getArgument(10)->isNull(); }
IfcDateTime IfcDocumentInformation::CreationTime() { return *entity->getArgument(10); }
void IfcDocumentInformation::setCreationTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcDocumentInformation::hasLastRevisionTime() { return !entity->getArgument(11)->isNull(); }
IfcDateTime IfcDocumentInformation::LastRevisionTime() { return *entity->getArgument(11); }
void IfcDocumentInformation::setLastRevisionTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcDocumentInformation::hasElectronicFormat() { return !entity->getArgument(12)->isNull(); }
IfcIdentifier IfcDocumentInformation::ElectronicFormat() { return *entity->getArgument(12); }
void IfcDocumentInformation::setElectronicFormat(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcDocumentInformation::hasValidFrom() { return !entity->getArgument(13)->isNull(); }
IfcDate IfcDocumentInformation::ValidFrom() { return *entity->getArgument(13); }
void IfcDocumentInformation::setValidFrom(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcDocumentInformation::hasValidUntil() { return !entity->getArgument(14)->isNull(); }
IfcDate IfcDocumentInformation::ValidUntil() { return *entity->getArgument(14); }
void IfcDocumentInformation::setValidUntil(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcDocumentInformation::hasConfidentiality() { return !entity->getArgument(15)->isNull(); }
IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum IfcDocumentInformation::Confidentiality() { return IfcDocumentConfidentialityEnum::FromString(*entity->getArgument(15)); }
void IfcDocumentInformation::setConfidentiality(IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v,IfcDocumentConfidentialityEnum::ToString(v)); }
bool IfcDocumentInformation::hasStatus() { return !entity->getArgument(16)->isNull(); }
IfcDocumentStatusEnum::IfcDocumentStatusEnum IfcDocumentInformation::Status() { return IfcDocumentStatusEnum::FromString(*entity->getArgument(16)); }
void IfcDocumentInformation::setStatus(IfcDocumentStatusEnum::IfcDocumentStatusEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v,IfcDocumentStatusEnum::ToString(v)); }
IfcRelAssociatesDocument::list IfcDocumentInformation::DocumentInfoForObjects() { RETURN_INVERSE(IfcRelAssociatesDocument) }
IfcDocumentReference::list IfcDocumentInformation::HasDocumentReferences() { RETURN_INVERSE(IfcDocumentReference) }
IfcDocumentInformationRelationship::list IfcDocumentInformation::IsPointedTo() { RETURN_INVERSE(IfcDocumentInformationRelationship) }
IfcDocumentInformationRelationship::list IfcDocumentInformation::IsPointer() { RETURN_INVERSE(IfcDocumentInformationRelationship) }
bool IfcDocumentInformation::is(Type::Enum v) const { return v == Type::IfcDocumentInformation || IfcExternalInformation::is(v); }
Type::Enum IfcDocumentInformation::type() const { return Type::IfcDocumentInformation; }
Type::Enum IfcDocumentInformation::Class() { return Type::IfcDocumentInformation; }
IfcDocumentInformation::IfcDocumentInformation(IfcAbstractEntityPtr e) : IfcExternalInformation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDocumentInformation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentInformation::IfcDocumentInformation(IfcIdentifier v1_Identification, IfcLabel v2_Name, boost::optional< IfcText > v3_Description, boost::optional< IfcURIReference > v4_Location, boost::optional< IfcText > v5_Purpose, boost::optional< IfcText > v6_IntendedUse, boost::optional< IfcText > v7_Scope, boost::optional< IfcLabel > v8_Revision, boost::optional< IfcActorSelect > v9_DocumentOwner, boost::optional< IfcEntities > v10_Editors, boost::optional< IfcDateTime > v11_CreationTime, boost::optional< IfcDateTime > v12_LastRevisionTime, boost::optional< IfcIdentifier > v13_ElectronicFormat, boost::optional< IfcDate > v14_ValidFrom, boost::optional< IfcDate > v15_ValidUntil, boost::optional< IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum > v16_Confidentiality, boost::optional< IfcDocumentStatusEnum::IfcDocumentStatusEnum > v17_Status) : IfcExternalInformation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Identification)); e->setArgument(1,(v2_Name)); if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } if (v4_Location) { e->setArgument(3,(*v4_Location)); } else { e->setArgument(3); } if (v5_Purpose) { e->setArgument(4,(*v5_Purpose)); } else { e->setArgument(4); } if (v6_IntendedUse) { e->setArgument(5,(*v6_IntendedUse)); } else { e->setArgument(5); } if (v7_Scope) { e->setArgument(6,(*v7_Scope)); } else { e->setArgument(6); } if (v8_Revision) { e->setArgument(7,(*v8_Revision)); } else { e->setArgument(7); } if (v9_DocumentOwner) { e->setArgument(8,(*v9_DocumentOwner)); } else { e->setArgument(8); } if (v10_Editors) { e->setArgument(9,(*v10_Editors)); } else { e->setArgument(9); } if (v11_CreationTime) { e->setArgument(10,(*v11_CreationTime)); } else { e->setArgument(10); } if (v12_LastRevisionTime) { e->setArgument(11,(*v12_LastRevisionTime)); } else { e->setArgument(11); } if (v13_ElectronicFormat) { e->setArgument(12,(*v13_ElectronicFormat)); } else { e->setArgument(12); } if (v14_ValidFrom) { e->setArgument(13,(*v14_ValidFrom)); } else { e->setArgument(13); } if (v15_ValidUntil) { e->setArgument(14,(*v15_ValidUntil)); } else { e->setArgument(14); } if (v16_Confidentiality) { e->setArgument(15,*v16_Confidentiality,IfcDocumentConfidentialityEnum::ToString(*v16_Confidentiality)); } else { e->setArgument(15); } if (v17_Status) { e->setArgument(16,*v17_Status,IfcDocumentStatusEnum::ToString(*v17_Status)); } else { e->setArgument(16); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDocumentInformationRelationship
IfcDocumentInformation* IfcDocumentInformationRelationship::RelatingDocument() { return (IfcDocumentInformation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcDocumentInformationRelationship::setRelatingDocument(IfcDocumentInformation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcDocumentInformation > > IfcDocumentInformationRelationship::RelatedDocuments() { RETURN_AS_LIST(IfcDocumentInformation,3) }
void IfcDocumentInformationRelationship::setRelatedDocuments(SHARED_PTR< IfcTemplatedEntityList< IfcDocumentInformation > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcDocumentInformationRelationship::hasRelationshipType() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcDocumentInformationRelationship::RelationshipType() { return *entity->getArgument(4); }
void IfcDocumentInformationRelationship::setRelationshipType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcDocumentInformationRelationship::is(Type::Enum v) const { return v == Type::IfcDocumentInformationRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcDocumentInformationRelationship::type() const { return Type::IfcDocumentInformationRelationship; }
Type::Enum IfcDocumentInformationRelationship::Class() { return Type::IfcDocumentInformationRelationship; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDocumentInformationRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentInformationRelationship::IfcDocumentInformationRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcDocumentInformation* v3_RelatingDocument, SHARED_PTR< IfcTemplatedEntityList< IfcDocumentInformation > > v4_RelatedDocuments, boost::optional< IfcLabel > v5_RelationshipType) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingDocument)); e->setArgument(3,(v4_RelatedDocuments)->generalize()); if (v5_RelationshipType) { e->setArgument(4,(*v5_RelationshipType)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDocumentReference
bool IfcDocumentReference::hasDescription() { return !entity->getArgument(3)->isNull(); }
IfcText IfcDocumentReference::Description() { return *entity->getArgument(3); }
void IfcDocumentReference::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcDocumentReference::hasReferencedDocument() { return !entity->getArgument(4)->isNull(); }
IfcDocumentInformation* IfcDocumentReference::ReferencedDocument() { return (IfcDocumentInformation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcDocumentReference::setReferencedDocument(IfcDocumentInformation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcRelAssociatesDocument::list IfcDocumentReference::DocumentRefForObjects() { RETURN_INVERSE(IfcRelAssociatesDocument) }
bool IfcDocumentReference::is(Type::Enum v) const { return v == Type::IfcDocumentReference || IfcExternalReference::is(v); }
Type::Enum IfcDocumentReference::type() const { return Type::IfcDocumentReference; }
Type::Enum IfcDocumentReference::Class() { return Type::IfcDocumentReference; }
IfcDocumentReference::IfcDocumentReference(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDocumentReference)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDocumentReference::IfcDocumentReference(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcDocumentInformation* v5_ReferencedDocument) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_ReferencedDocument)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoor
bool IfcDoor::hasOverallHeight() { return !entity->getArgument(8)->isNull(); }
IfcPositiveLengthMeasure IfcDoor::OverallHeight() { return *entity->getArgument(8); }
void IfcDoor::setOverallHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcDoor::hasOverallWidth() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcDoor::OverallWidth() { return *entity->getArgument(9); }
void IfcDoor::setOverallWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcDoor::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoor::PredefinedType() { return IfcDoorTypeEnum::FromString(*entity->getArgument(10)); }
void IfcDoor::setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcDoorTypeEnum::ToString(v)); }
bool IfcDoor::hasOperationType() { return !entity->getArgument(11)->isNull(); }
IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoor::OperationType() { return IfcDoorTypeOperationEnum::FromString(*entity->getArgument(11)); }
void IfcDoor::setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcDoorTypeOperationEnum::ToString(v)); }
bool IfcDoor::hasUserDefinedOperationType() { return !entity->getArgument(12)->isNull(); }
IfcLabel IfcDoor::UserDefinedOperationType() { return *entity->getArgument(12); }
void IfcDoor::setUserDefinedOperationType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcDoor::is(Type::Enum v) const { return v == Type::IfcDoor || IfcBuildingElement::is(v); }
Type::Enum IfcDoor::type() const { return Type::IfcDoor; }
Type::Enum IfcDoor::Class() { return Type::IfcDoor; }
IfcDoor::IfcDoor(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoor::IfcDoor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPositiveLengthMeasure > v9_OverallHeight, boost::optional< IfcPositiveLengthMeasure > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< IfcLabel > v13_UserDefinedOperationType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_OverallHeight) { e->setArgument(8,(*v9_OverallHeight)); } else { e->setArgument(8); } if (v10_OverallWidth) { e->setArgument(9,(*v10_OverallWidth)); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcDoorTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } if (v12_OperationType) { e->setArgument(11,*v12_OperationType,IfcDoorTypeOperationEnum::ToString(*v12_OperationType)); } else { e->setArgument(11); } if (v13_UserDefinedOperationType) { e->setArgument(12,(*v13_UserDefinedOperationType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoorLiningProperties
bool IfcDoorLiningProperties::hasLiningDepth() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcDoorLiningProperties::LiningDepth() { return *entity->getArgument(4); }
void IfcDoorLiningProperties::setLiningDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcDoorLiningProperties::hasLiningThickness() { return !entity->getArgument(5)->isNull(); }
IfcNonNegativeLengthMeasure IfcDoorLiningProperties::LiningThickness() { return *entity->getArgument(5); }
void IfcDoorLiningProperties::setLiningThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcDoorLiningProperties::hasThresholdDepth() { return !entity->getArgument(6)->isNull(); }
IfcPositiveLengthMeasure IfcDoorLiningProperties::ThresholdDepth() { return *entity->getArgument(6); }
void IfcDoorLiningProperties::setThresholdDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcDoorLiningProperties::hasThresholdThickness() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcDoorLiningProperties::ThresholdThickness() { return *entity->getArgument(7); }
void IfcDoorLiningProperties::setThresholdThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcDoorLiningProperties::hasTransomThickness() { return !entity->getArgument(8)->isNull(); }
IfcNonNegativeLengthMeasure IfcDoorLiningProperties::TransomThickness() { return *entity->getArgument(8); }
void IfcDoorLiningProperties::setTransomThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcDoorLiningProperties::hasTransomOffset() { return !entity->getArgument(9)->isNull(); }
IfcLengthMeasure IfcDoorLiningProperties::TransomOffset() { return *entity->getArgument(9); }
void IfcDoorLiningProperties::setTransomOffset(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcDoorLiningProperties::hasLiningOffset() { return !entity->getArgument(10)->isNull(); }
IfcLengthMeasure IfcDoorLiningProperties::LiningOffset() { return *entity->getArgument(10); }
void IfcDoorLiningProperties::setLiningOffset(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcDoorLiningProperties::hasThresholdOffset() { return !entity->getArgument(11)->isNull(); }
IfcLengthMeasure IfcDoorLiningProperties::ThresholdOffset() { return *entity->getArgument(11); }
void IfcDoorLiningProperties::setThresholdOffset(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcDoorLiningProperties::hasCasingThickness() { return !entity->getArgument(12)->isNull(); }
IfcPositiveLengthMeasure IfcDoorLiningProperties::CasingThickness() { return *entity->getArgument(12); }
void IfcDoorLiningProperties::setCasingThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcDoorLiningProperties::hasCasingDepth() { return !entity->getArgument(13)->isNull(); }
IfcPositiveLengthMeasure IfcDoorLiningProperties::CasingDepth() { return *entity->getArgument(13); }
void IfcDoorLiningProperties::setCasingDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcDoorLiningProperties::hasShapeAspectStyle() { return !entity->getArgument(14)->isNull(); }
IfcShapeAspect* IfcDoorLiningProperties::ShapeAspectStyle() { return (IfcShapeAspect*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(14))); }
void IfcDoorLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcDoorLiningProperties::hasLiningToPanelOffsetX() { return !entity->getArgument(15)->isNull(); }
IfcLengthMeasure IfcDoorLiningProperties::LiningToPanelOffsetX() { return *entity->getArgument(15); }
void IfcDoorLiningProperties::setLiningToPanelOffsetX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcDoorLiningProperties::hasLiningToPanelOffsetY() { return !entity->getArgument(16)->isNull(); }
IfcLengthMeasure IfcDoorLiningProperties::LiningToPanelOffsetY() { return *entity->getArgument(16); }
void IfcDoorLiningProperties::setLiningToPanelOffsetY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcDoorLiningProperties::is(Type::Enum v) const { return v == Type::IfcDoorLiningProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcDoorLiningProperties::type() const { return Type::IfcDoorLiningProperties; }
Type::Enum IfcDoorLiningProperties::Class() { return Type::IfcDoorLiningProperties; }
IfcDoorLiningProperties::IfcDoorLiningProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoorLiningProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorLiningProperties::IfcDoorLiningProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcPositiveLengthMeasure > v5_LiningDepth, boost::optional< IfcNonNegativeLengthMeasure > v6_LiningThickness, boost::optional< IfcPositiveLengthMeasure > v7_ThresholdDepth, boost::optional< IfcNonNegativeLengthMeasure > v8_ThresholdThickness, boost::optional< IfcNonNegativeLengthMeasure > v9_TransomThickness, boost::optional< IfcLengthMeasure > v10_TransomOffset, boost::optional< IfcLengthMeasure > v11_LiningOffset, boost::optional< IfcLengthMeasure > v12_ThresholdOffset, boost::optional< IfcPositiveLengthMeasure > v13_CasingThickness, boost::optional< IfcPositiveLengthMeasure > v14_CasingDepth, IfcShapeAspect* v15_ShapeAspectStyle, boost::optional< IfcLengthMeasure > v16_LiningToPanelOffsetX, boost::optional< IfcLengthMeasure > v17_LiningToPanelOffsetY) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_LiningDepth) { e->setArgument(4,(*v5_LiningDepth)); } else { e->setArgument(4); } if (v6_LiningThickness) { e->setArgument(5,(*v6_LiningThickness)); } else { e->setArgument(5); } if (v7_ThresholdDepth) { e->setArgument(6,(*v7_ThresholdDepth)); } else { e->setArgument(6); } if (v8_ThresholdThickness) { e->setArgument(7,(*v8_ThresholdThickness)); } else { e->setArgument(7); } if (v9_TransomThickness) { e->setArgument(8,(*v9_TransomThickness)); } else { e->setArgument(8); } if (v10_TransomOffset) { e->setArgument(9,(*v10_TransomOffset)); } else { e->setArgument(9); } if (v11_LiningOffset) { e->setArgument(10,(*v11_LiningOffset)); } else { e->setArgument(10); } if (v12_ThresholdOffset) { e->setArgument(11,(*v12_ThresholdOffset)); } else { e->setArgument(11); } if (v13_CasingThickness) { e->setArgument(12,(*v13_CasingThickness)); } else { e->setArgument(12); } if (v14_CasingDepth) { e->setArgument(13,(*v14_CasingDepth)); } else { e->setArgument(13); } e->setArgument(14,(v15_ShapeAspectStyle)); if (v16_LiningToPanelOffsetX) { e->setArgument(15,(*v16_LiningToPanelOffsetX)); } else { e->setArgument(15); } if (v17_LiningToPanelOffsetY) { e->setArgument(16,(*v17_LiningToPanelOffsetY)); } else { e->setArgument(16); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoorPanelProperties
bool IfcDoorPanelProperties::hasPanelDepth() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcDoorPanelProperties::PanelDepth() { return *entity->getArgument(4); }
void IfcDoorPanelProperties::setPanelDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum IfcDoorPanelProperties::PanelOperation() { return IfcDoorPanelOperationEnum::FromString(*entity->getArgument(5)); }
void IfcDoorPanelProperties::setPanelOperation(IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcDoorPanelOperationEnum::ToString(v)); }
bool IfcDoorPanelProperties::hasPanelWidth() { return !entity->getArgument(6)->isNull(); }
IfcNormalisedRatioMeasure IfcDoorPanelProperties::PanelWidth() { return *entity->getArgument(6); }
void IfcDoorPanelProperties::setPanelWidth(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum IfcDoorPanelProperties::PanelPosition() { return IfcDoorPanelPositionEnum::FromString(*entity->getArgument(7)); }
void IfcDoorPanelProperties::setPanelPosition(IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcDoorPanelPositionEnum::ToString(v)); }
bool IfcDoorPanelProperties::hasShapeAspectStyle() { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcDoorPanelProperties::ShapeAspectStyle() { return (IfcShapeAspect*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcDoorPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcDoorPanelProperties::is(Type::Enum v) const { return v == Type::IfcDoorPanelProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcDoorPanelProperties::type() const { return Type::IfcDoorPanelProperties; }
Type::Enum IfcDoorPanelProperties::Class() { return Type::IfcDoorPanelProperties; }
IfcDoorPanelProperties::IfcDoorPanelProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoorPanelProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorPanelProperties::IfcDoorPanelProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcPositiveLengthMeasure > v5_PanelDepth, IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v6_PanelOperation, boost::optional< IfcNormalisedRatioMeasure > v7_PanelWidth, IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v8_PanelPosition, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_PanelDepth) { e->setArgument(4,(*v5_PanelDepth)); } else { e->setArgument(4); } e->setArgument(5,v6_PanelOperation,IfcDoorPanelOperationEnum::ToString(v6_PanelOperation)); if (v7_PanelWidth) { e->setArgument(6,(*v7_PanelWidth)); } else { e->setArgument(6); } e->setArgument(7,v8_PanelPosition,IfcDoorPanelPositionEnum::ToString(v8_PanelPosition)); e->setArgument(8,(v9_ShapeAspectStyle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoorStandardCase
bool IfcDoorStandardCase::is(Type::Enum v) const { return v == Type::IfcDoorStandardCase || IfcDoor::is(v); }
Type::Enum IfcDoorStandardCase::type() const { return Type::IfcDoorStandardCase; }
Type::Enum IfcDoorStandardCase::Class() { return Type::IfcDoorStandardCase; }
IfcDoorStandardCase::IfcDoorStandardCase(IfcAbstractEntityPtr e) : IfcDoor((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoorStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorStandardCase::IfcDoorStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPositiveLengthMeasure > v9_OverallHeight, boost::optional< IfcPositiveLengthMeasure > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< IfcLabel > v13_UserDefinedOperationType) : IfcDoor((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_OverallHeight) { e->setArgument(8,(*v9_OverallHeight)); } else { e->setArgument(8); } if (v10_OverallWidth) { e->setArgument(9,(*v10_OverallWidth)); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcDoorTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } if (v12_OperationType) { e->setArgument(11,*v12_OperationType,IfcDoorTypeOperationEnum::ToString(*v12_OperationType)); } else { e->setArgument(11); } if (v13_UserDefinedOperationType) { e->setArgument(12,(*v13_UserDefinedOperationType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoorStyle
IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum IfcDoorStyle::OperationType() { return IfcDoorStyleOperationEnum::FromString(*entity->getArgument(8)); }
void IfcDoorStyle::setOperationType(IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDoorStyleOperationEnum::ToString(v)); }
IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum IfcDoorStyle::ConstructionType() { return IfcDoorStyleConstructionEnum::FromString(*entity->getArgument(9)); }
void IfcDoorStyle::setConstructionType(IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDoorStyleConstructionEnum::ToString(v)); }
bool IfcDoorStyle::ParameterTakesPrecedence() { return *entity->getArgument(10); }
void IfcDoorStyle::setParameterTakesPrecedence(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcDoorStyle::Sizeable() { return *entity->getArgument(11); }
void IfcDoorStyle::setSizeable(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcDoorStyle::is(Type::Enum v) const { return v == Type::IfcDoorStyle || IfcTypeProduct::is(v); }
Type::Enum IfcDoorStyle::type() const { return Type::IfcDoorStyle; }
Type::Enum IfcDoorStyle::Class() { return Type::IfcDoorStyle; }
IfcDoorStyle::IfcDoorStyle(IfcAbstractEntityPtr e) : IfcTypeProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoorStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorStyle::IfcDoorStyle(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v9_OperationType, IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } e->setArgument(8,v9_OperationType,IfcDoorStyleOperationEnum::ToString(v9_OperationType)); e->setArgument(9,v10_ConstructionType,IfcDoorStyleConstructionEnum::ToString(v10_ConstructionType)); e->setArgument(10,(v11_ParameterTakesPrecedence)); e->setArgument(11,(v12_Sizeable)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDoorType
IfcDoorTypeEnum::IfcDoorTypeEnum IfcDoorType::PredefinedType() { return IfcDoorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDoorType::setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDoorTypeEnum::ToString(v)); }
IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum IfcDoorType::OperationType() { return IfcDoorTypeOperationEnum::FromString(*entity->getArgument(10)); }
void IfcDoorType::setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcDoorTypeOperationEnum::ToString(v)); }
bool IfcDoorType::hasParameterTakesPrecedence() { return !entity->getArgument(11)->isNull(); }
bool IfcDoorType::ParameterTakesPrecedence() { return *entity->getArgument(11); }
void IfcDoorType::setParameterTakesPrecedence(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcDoorType::hasUserDefinedOperationType() { return !entity->getArgument(12)->isNull(); }
IfcLabel IfcDoorType::UserDefinedOperationType() { return *entity->getArgument(12); }
void IfcDoorType::setUserDefinedOperationType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcDoorType::is(Type::Enum v) const { return v == Type::IfcDoorType || IfcBuildingElementType::is(v); }
Type::Enum IfcDoorType::type() const { return Type::IfcDoorType; }
Type::Enum IfcDoorType::Class() { return Type::IfcDoorType; }
IfcDoorType::IfcDoorType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDoorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDoorType::IfcDoorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDoorTypeEnum::IfcDoorTypeEnum v10_PredefinedType, IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v11_OperationType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< IfcLabel > v13_UserDefinedOperationType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDoorTypeEnum::ToString(v10_PredefinedType)); e->setArgument(10,v11_OperationType,IfcDoorTypeOperationEnum::ToString(v11_OperationType)); if (v12_ParameterTakesPrecedence) { e->setArgument(11,(*v12_ParameterTakesPrecedence)); } else { e->setArgument(11); } if (v13_UserDefinedOperationType) { e->setArgument(12,(*v13_UserDefinedOperationType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDraughtingPreDefinedColour
bool IfcDraughtingPreDefinedColour::is(Type::Enum v) const { return v == Type::IfcDraughtingPreDefinedColour || IfcPreDefinedColour::is(v); }
Type::Enum IfcDraughtingPreDefinedColour::type() const { return Type::IfcDraughtingPreDefinedColour; }
Type::Enum IfcDraughtingPreDefinedColour::Class() { return Type::IfcDraughtingPreDefinedColour; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(IfcAbstractEntityPtr e) : IfcPreDefinedColour((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDraughtingPreDefinedColour)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingPreDefinedColour::IfcDraughtingPreDefinedColour(IfcLabel v1_Name) : IfcPreDefinedColour((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDraughtingPreDefinedCurveFont
bool IfcDraughtingPreDefinedCurveFont::is(Type::Enum v) const { return v == Type::IfcDraughtingPreDefinedCurveFont || IfcPreDefinedCurveFont::is(v); }
Type::Enum IfcDraughtingPreDefinedCurveFont::type() const { return Type::IfcDraughtingPreDefinedCurveFont; }
Type::Enum IfcDraughtingPreDefinedCurveFont::Class() { return Type::IfcDraughtingPreDefinedCurveFont; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(IfcAbstractEntityPtr e) : IfcPreDefinedCurveFont((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDraughtingPreDefinedCurveFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDraughtingPreDefinedCurveFont::IfcDraughtingPreDefinedCurveFont(IfcLabel v1_Name) : IfcPreDefinedCurveFont((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctFitting
bool IfcDuctFitting::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFitting::PredefinedType() { return IfcDuctFittingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDuctFitting::setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDuctFittingTypeEnum::ToString(v)); }
bool IfcDuctFitting::is(Type::Enum v) const { return v == Type::IfcDuctFitting || IfcFlowFitting::is(v); }
Type::Enum IfcDuctFitting::type() const { return Type::IfcDuctFitting; }
Type::Enum IfcDuctFitting::Class() { return Type::IfcDuctFitting; }
IfcDuctFitting::IfcDuctFitting(IfcAbstractEntityPtr e) : IfcFlowFitting((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctFitting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctFitting::IfcDuctFitting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDuctFittingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctFittingType
IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum IfcDuctFittingType::PredefinedType() { return IfcDuctFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctFittingType::setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDuctFittingTypeEnum::ToString(v)); }
bool IfcDuctFittingType::is(Type::Enum v) const { return v == Type::IfcDuctFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcDuctFittingType::type() const { return Type::IfcDuctFittingType; }
Type::Enum IfcDuctFittingType::Class() { return Type::IfcDuctFittingType; }
IfcDuctFittingType::IfcDuctFittingType(IfcAbstractEntityPtr e) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctFittingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctFittingType::IfcDuctFittingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDuctFittingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctSegment
bool IfcDuctSegment::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegment::PredefinedType() { return IfcDuctSegmentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDuctSegment::setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDuctSegmentTypeEnum::ToString(v)); }
bool IfcDuctSegment::is(Type::Enum v) const { return v == Type::IfcDuctSegment || IfcFlowSegment::is(v); }
Type::Enum IfcDuctSegment::type() const { return Type::IfcDuctSegment; }
Type::Enum IfcDuctSegment::Class() { return Type::IfcDuctSegment; }
IfcDuctSegment::IfcDuctSegment(IfcAbstractEntityPtr e) : IfcFlowSegment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSegment::IfcDuctSegment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDuctSegmentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctSegmentType
IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum IfcDuctSegmentType::PredefinedType() { return IfcDuctSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctSegmentType::setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDuctSegmentTypeEnum::ToString(v)); }
bool IfcDuctSegmentType::is(Type::Enum v) const { return v == Type::IfcDuctSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcDuctSegmentType::type() const { return Type::IfcDuctSegmentType; }
Type::Enum IfcDuctSegmentType::Class() { return Type::IfcDuctSegmentType; }
IfcDuctSegmentType::IfcDuctSegmentType(IfcAbstractEntityPtr e) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctSegmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSegmentType::IfcDuctSegmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDuctSegmentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctSilencer
bool IfcDuctSilencer::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencer::PredefinedType() { return IfcDuctSilencerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcDuctSilencer::setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcDuctSilencerTypeEnum::ToString(v)); }
bool IfcDuctSilencer::is(Type::Enum v) const { return v == Type::IfcDuctSilencer || IfcFlowTreatmentDevice::is(v); }
Type::Enum IfcDuctSilencer::type() const { return Type::IfcDuctSilencer; }
Type::Enum IfcDuctSilencer::Class() { return Type::IfcDuctSilencer; }
IfcDuctSilencer::IfcDuctSilencer(IfcAbstractEntityPtr e) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctSilencer)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSilencer::IfcDuctSilencer(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcDuctSilencerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcDuctSilencerType
IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum IfcDuctSilencerType::PredefinedType() { return IfcDuctSilencerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcDuctSilencerType::setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcDuctSilencerTypeEnum::ToString(v)); }
bool IfcDuctSilencerType::is(Type::Enum v) const { return v == Type::IfcDuctSilencerType || IfcFlowTreatmentDeviceType::is(v); }
Type::Enum IfcDuctSilencerType::type() const { return Type::IfcDuctSilencerType; }
Type::Enum IfcDuctSilencerType::Class() { return Type::IfcDuctSilencerType; }
IfcDuctSilencerType::IfcDuctSilencerType(IfcAbstractEntityPtr e) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcDuctSilencerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcDuctSilencerType::IfcDuctSilencerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcDuctSilencerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEdge
IfcVertex* IfcEdge::EdgeStart() { return (IfcVertex*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcEdge::setEdgeStart(IfcVertex* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcVertex* IfcEdge::EdgeEnd() { return (IfcVertex*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcEdge::setEdgeEnd(IfcVertex* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcEdge::is(Type::Enum v) const { return v == Type::IfcEdge || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcEdge::type() const { return Type::IfcEdge; }
Type::Enum IfcEdge::Class() { return Type::IfcEdge; }
IfcEdge::IfcEdge(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEdge)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdge::IfcEdge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_EdgeStart)); e->setArgument(1,(v2_EdgeEnd)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEdgeCurve
IfcCurve* IfcEdgeCurve::EdgeGeometry() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcEdgeCurve::setEdgeGeometry(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcEdgeCurve::SameSense() { return *entity->getArgument(3); }
void IfcEdgeCurve::setSameSense(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcEdgeCurve::is(Type::Enum v) const { return v == Type::IfcEdgeCurve || IfcEdge::is(v); }
Type::Enum IfcEdgeCurve::type() const { return Type::IfcEdgeCurve; }
Type::Enum IfcEdgeCurve::Class() { return Type::IfcEdgeCurve; }
IfcEdgeCurve::IfcEdgeCurve(IfcAbstractEntityPtr e) : IfcEdge((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEdgeCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdgeCurve::IfcEdgeCurve(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcCurve* v3_EdgeGeometry, bool v4_SameSense) : IfcEdge((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_EdgeStart)); e->setArgument(1,(v2_EdgeEnd)); e->setArgument(2,(v3_EdgeGeometry)); e->setArgument(3,(v4_SameSense)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEdgeLoop
SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > IfcEdgeLoop::EdgeList() { RETURN_AS_LIST(IfcOrientedEdge,0) }
void IfcEdgeLoop::setEdgeList(SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcEdgeLoop::is(Type::Enum v) const { return v == Type::IfcEdgeLoop || IfcLoop::is(v); }
Type::Enum IfcEdgeLoop::type() const { return Type::IfcEdgeLoop; }
Type::Enum IfcEdgeLoop::Class() { return Type::IfcEdgeLoop; }
IfcEdgeLoop::IfcEdgeLoop(IfcAbstractEntityPtr e) : IfcLoop((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEdgeLoop)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEdgeLoop::IfcEdgeLoop(SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > v1_EdgeList) : IfcLoop((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_EdgeList)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricAppliance
bool IfcElectricAppliance::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricAppliance::PredefinedType() { return IfcElectricApplianceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricAppliance::setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricApplianceTypeEnum::ToString(v)); }
bool IfcElectricAppliance::is(Type::Enum v) const { return v == Type::IfcElectricAppliance || IfcFlowTerminal::is(v); }
Type::Enum IfcElectricAppliance::type() const { return Type::IfcElectricAppliance; }
Type::Enum IfcElectricAppliance::Class() { return Type::IfcElectricAppliance; }
IfcElectricAppliance::IfcElectricAppliance(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricAppliance)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricAppliance::IfcElectricAppliance(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricApplianceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricApplianceType
IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum IfcElectricApplianceType::PredefinedType() { return IfcElectricApplianceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricApplianceType::setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricApplianceTypeEnum::ToString(v)); }
bool IfcElectricApplianceType::is(Type::Enum v) const { return v == Type::IfcElectricApplianceType || IfcFlowTerminalType::is(v); }
Type::Enum IfcElectricApplianceType::type() const { return Type::IfcElectricApplianceType; }
Type::Enum IfcElectricApplianceType::Class() { return Type::IfcElectricApplianceType; }
IfcElectricApplianceType::IfcElectricApplianceType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricApplianceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricApplianceType::IfcElectricApplianceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricApplianceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricDistributionBoard
bool IfcElectricDistributionBoard::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoard::PredefinedType() { return IfcElectricDistributionBoardTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricDistributionBoard::setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricDistributionBoardTypeEnum::ToString(v)); }
bool IfcElectricDistributionBoard::is(Type::Enum v) const { return v == Type::IfcElectricDistributionBoard || IfcFlowController::is(v); }
Type::Enum IfcElectricDistributionBoard::type() const { return Type::IfcElectricDistributionBoard; }
Type::Enum IfcElectricDistributionBoard::Class() { return Type::IfcElectricDistributionBoard; }
IfcElectricDistributionBoard::IfcElectricDistributionBoard(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricDistributionBoard)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricDistributionBoard::IfcElectricDistributionBoard(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricDistributionBoardTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricDistributionBoardType
IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum IfcElectricDistributionBoardType::PredefinedType() { return IfcElectricDistributionBoardTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricDistributionBoardType::setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricDistributionBoardTypeEnum::ToString(v)); }
bool IfcElectricDistributionBoardType::is(Type::Enum v) const { return v == Type::IfcElectricDistributionBoardType || IfcFlowControllerType::is(v); }
Type::Enum IfcElectricDistributionBoardType::type() const { return Type::IfcElectricDistributionBoardType; }
Type::Enum IfcElectricDistributionBoardType::Class() { return Type::IfcElectricDistributionBoardType; }
IfcElectricDistributionBoardType::IfcElectricDistributionBoardType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricDistributionBoardType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricDistributionBoardType::IfcElectricDistributionBoardType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricDistributionBoardTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricFlowStorageDevice
bool IfcElectricFlowStorageDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDevice::PredefinedType() { return IfcElectricFlowStorageDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricFlowStorageDevice::setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricFlowStorageDeviceTypeEnum::ToString(v)); }
bool IfcElectricFlowStorageDevice::is(Type::Enum v) const { return v == Type::IfcElectricFlowStorageDevice || IfcFlowStorageDevice::is(v); }
Type::Enum IfcElectricFlowStorageDevice::type() const { return Type::IfcElectricFlowStorageDevice; }
Type::Enum IfcElectricFlowStorageDevice::Class() { return Type::IfcElectricFlowStorageDevice; }
IfcElectricFlowStorageDevice::IfcElectricFlowStorageDevice(IfcAbstractEntityPtr e) : IfcFlowStorageDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricFlowStorageDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricFlowStorageDevice::IfcElectricFlowStorageDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum > v9_PredefinedType) : IfcFlowStorageDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricFlowStorageDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricFlowStorageDeviceType
IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum IfcElectricFlowStorageDeviceType::PredefinedType() { return IfcElectricFlowStorageDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricFlowStorageDeviceType::setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricFlowStorageDeviceTypeEnum::ToString(v)); }
bool IfcElectricFlowStorageDeviceType::is(Type::Enum v) const { return v == Type::IfcElectricFlowStorageDeviceType || IfcFlowStorageDeviceType::is(v); }
Type::Enum IfcElectricFlowStorageDeviceType::type() const { return Type::IfcElectricFlowStorageDeviceType; }
Type::Enum IfcElectricFlowStorageDeviceType::Class() { return Type::IfcElectricFlowStorageDeviceType; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(IfcAbstractEntityPtr e) : IfcFlowStorageDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricFlowStorageDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricFlowStorageDeviceType::IfcElectricFlowStorageDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricFlowStorageDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricGenerator
bool IfcElectricGenerator::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGenerator::PredefinedType() { return IfcElectricGeneratorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricGenerator::setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricGeneratorTypeEnum::ToString(v)); }
bool IfcElectricGenerator::is(Type::Enum v) const { return v == Type::IfcElectricGenerator || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcElectricGenerator::type() const { return Type::IfcElectricGenerator; }
Type::Enum IfcElectricGenerator::Class() { return Type::IfcElectricGenerator; }
IfcElectricGenerator::IfcElectricGenerator(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricGenerator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricGenerator::IfcElectricGenerator(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricGeneratorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricGeneratorType
IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum IfcElectricGeneratorType::PredefinedType() { return IfcElectricGeneratorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricGeneratorType::setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricGeneratorTypeEnum::ToString(v)); }
bool IfcElectricGeneratorType::is(Type::Enum v) const { return v == Type::IfcElectricGeneratorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcElectricGeneratorType::type() const { return Type::IfcElectricGeneratorType; }
Type::Enum IfcElectricGeneratorType::Class() { return Type::IfcElectricGeneratorType; }
IfcElectricGeneratorType::IfcElectricGeneratorType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricGeneratorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricGeneratorType::IfcElectricGeneratorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricGeneratorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricMotor
bool IfcElectricMotor::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotor::PredefinedType() { return IfcElectricMotorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricMotor::setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricMotorTypeEnum::ToString(v)); }
bool IfcElectricMotor::is(Type::Enum v) const { return v == Type::IfcElectricMotor || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcElectricMotor::type() const { return Type::IfcElectricMotor; }
Type::Enum IfcElectricMotor::Class() { return Type::IfcElectricMotor; }
IfcElectricMotor::IfcElectricMotor(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricMotor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricMotor::IfcElectricMotor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricMotorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricMotorType
IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum IfcElectricMotorType::PredefinedType() { return IfcElectricMotorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricMotorType::setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricMotorTypeEnum::ToString(v)); }
bool IfcElectricMotorType::is(Type::Enum v) const { return v == Type::IfcElectricMotorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcElectricMotorType::type() const { return Type::IfcElectricMotorType; }
Type::Enum IfcElectricMotorType::Class() { return Type::IfcElectricMotorType; }
IfcElectricMotorType::IfcElectricMotorType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricMotorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricMotorType::IfcElectricMotorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricMotorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricTimeControl
bool IfcElectricTimeControl::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControl::PredefinedType() { return IfcElectricTimeControlTypeEnum::FromString(*entity->getArgument(8)); }
void IfcElectricTimeControl::setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElectricTimeControlTypeEnum::ToString(v)); }
bool IfcElectricTimeControl::is(Type::Enum v) const { return v == Type::IfcElectricTimeControl || IfcFlowController::is(v); }
Type::Enum IfcElectricTimeControl::type() const { return Type::IfcElectricTimeControl; }
Type::Enum IfcElectricTimeControl::Class() { return Type::IfcElectricTimeControl; }
IfcElectricTimeControl::IfcElectricTimeControl(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricTimeControl)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricTimeControl::IfcElectricTimeControl(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcElectricTimeControlTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElectricTimeControlType
IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum IfcElectricTimeControlType::PredefinedType() { return IfcElectricTimeControlTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElectricTimeControlType::setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElectricTimeControlTypeEnum::ToString(v)); }
bool IfcElectricTimeControlType::is(Type::Enum v) const { return v == Type::IfcElectricTimeControlType || IfcFlowControllerType::is(v); }
Type::Enum IfcElectricTimeControlType::type() const { return Type::IfcElectricTimeControlType; }
Type::Enum IfcElectricTimeControlType::Class() { return Type::IfcElectricTimeControlType; }
IfcElectricTimeControlType::IfcElectricTimeControlType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElectricTimeControlType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElectricTimeControlType::IfcElectricTimeControlType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElectricTimeControlTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElement
bool IfcElement::hasTag() { return !entity->getArgument(7)->isNull(); }
IfcIdentifier IfcElement::Tag() { return *entity->getArgument(7); }
void IfcElement::setTag(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcRelFillsElement::list IfcElement::FillsVoids() { RETURN_INVERSE(IfcRelFillsElement) }
IfcRelConnectsElements::list IfcElement::ConnectedTo() { RETURN_INVERSE(IfcRelConnectsElements) }
IfcRelInterferesElements::list IfcElement::IsInterferedByElements() { RETURN_INVERSE(IfcRelInterferesElements) }
IfcRelInterferesElements::list IfcElement::InterferesElements() { RETURN_INVERSE(IfcRelInterferesElements) }
IfcRelProjectsElement::list IfcElement::HasProjections() { RETURN_INVERSE(IfcRelProjectsElement) }
IfcRelReferencedInSpatialStructure::list IfcElement::ReferencedInStructures() { RETURN_INVERSE(IfcRelReferencedInSpatialStructure) }
IfcRelVoidsElement::list IfcElement::HasOpenings() { RETURN_INVERSE(IfcRelVoidsElement) }
IfcRelConnectsWithRealizingElements::list IfcElement::IsConnectionRealization() { RETURN_INVERSE(IfcRelConnectsWithRealizingElements) }
IfcRelSpaceBoundary::list IfcElement::ProvidesBoundaries() { RETURN_INVERSE(IfcRelSpaceBoundary) }
IfcRelConnectsElements::list IfcElement::ConnectedFrom() { RETURN_INVERSE(IfcRelConnectsElements) }
IfcRelContainedInSpatialStructure::list IfcElement::ContainedInStructure() { RETURN_INVERSE(IfcRelContainedInSpatialStructure) }
bool IfcElement::is(Type::Enum v) const { return v == Type::IfcElement || IfcProduct::is(v); }
Type::Enum IfcElement::type() const { return Type::IfcElement; }
Type::Enum IfcElement::Class() { return Type::IfcElement; }
IfcElement::IfcElement(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElement::IfcElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementAssembly
bool IfcElementAssembly::hasAssemblyPlace() { return !entity->getArgument(8)->isNull(); }
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcElementAssembly::AssemblyPlace() { return IfcAssemblyPlaceEnum::FromString(*entity->getArgument(8)); }
void IfcElementAssembly::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcAssemblyPlaceEnum::ToString(v)); }
bool IfcElementAssembly::hasPredefinedType() { return !entity->getArgument(9)->isNull(); }
IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssembly::PredefinedType() { return IfcElementAssemblyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElementAssembly::setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElementAssemblyTypeEnum::ToString(v)); }
bool IfcElementAssembly::is(Type::Enum v) const { return v == Type::IfcElementAssembly || IfcElement::is(v); }
Type::Enum IfcElementAssembly::type() const { return Type::IfcElementAssembly; }
Type::Enum IfcElementAssembly::Class() { return Type::IfcElementAssembly; }
IfcElementAssembly::IfcElementAssembly(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementAssembly)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementAssembly::IfcElementAssembly(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum > v9_AssemblyPlace, boost::optional< IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum > v10_PredefinedType) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_AssemblyPlace) { e->setArgument(8,*v9_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(*v9_AssemblyPlace)); } else { e->setArgument(8); } if (v10_PredefinedType) { e->setArgument(9,*v10_PredefinedType,IfcElementAssemblyTypeEnum::ToString(*v10_PredefinedType)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementAssemblyType
IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum IfcElementAssemblyType::PredefinedType() { return IfcElementAssemblyTypeEnum::FromString(*entity->getArgument(9)); }
void IfcElementAssemblyType::setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcElementAssemblyTypeEnum::ToString(v)); }
bool IfcElementAssemblyType::is(Type::Enum v) const { return v == Type::IfcElementAssemblyType || IfcElementType::is(v); }
Type::Enum IfcElementAssemblyType::type() const { return Type::IfcElementAssemblyType; }
Type::Enum IfcElementAssemblyType::Class() { return Type::IfcElementAssemblyType; }
IfcElementAssemblyType::IfcElementAssemblyType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementAssemblyType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementAssemblyType::IfcElementAssemblyType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v10_PredefinedType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcElementAssemblyTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementComponent
bool IfcElementComponent::is(Type::Enum v) const { return v == Type::IfcElementComponent || IfcElement::is(v); }
Type::Enum IfcElementComponent::type() const { return Type::IfcElementComponent; }
Type::Enum IfcElementComponent::Class() { return Type::IfcElementComponent; }
IfcElementComponent::IfcElementComponent(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementComponent)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementComponent::IfcElementComponent(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementComponentType
bool IfcElementComponentType::is(Type::Enum v) const { return v == Type::IfcElementComponentType || IfcElementType::is(v); }
Type::Enum IfcElementComponentType::type() const { return Type::IfcElementComponentType; }
Type::Enum IfcElementComponentType::Class() { return Type::IfcElementComponentType; }
IfcElementComponentType::IfcElementComponentType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementComponentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementComponentType::IfcElementComponentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementQuantity
bool IfcElementQuantity::hasMethodOfMeasurement() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcElementQuantity::MethodOfMeasurement() { return *entity->getArgument(4); }
void IfcElementQuantity::setMethodOfMeasurement(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > IfcElementQuantity::Quantities() { RETURN_AS_LIST(IfcPhysicalQuantity,5) }
void IfcElementQuantity::setQuantities(SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcElementQuantity::is(Type::Enum v) const { return v == Type::IfcElementQuantity || IfcQuantitySet::is(v); }
Type::Enum IfcElementQuantity::type() const { return Type::IfcElementQuantity; }
Type::Enum IfcElementQuantity::Class() { return Type::IfcElementQuantity; }
IfcElementQuantity::IfcElementQuantity(IfcAbstractEntityPtr e) : IfcQuantitySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementQuantity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementQuantity::IfcElementQuantity(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_MethodOfMeasurement, SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > v6_Quantities) : IfcQuantitySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_MethodOfMeasurement) { e->setArgument(4,(*v5_MethodOfMeasurement)); } else { e->setArgument(4); } e->setArgument(5,(v6_Quantities)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementType
bool IfcElementType::hasElementType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcElementType::ElementType() { return *entity->getArgument(8); }
void IfcElementType::setElementType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcElementType::is(Type::Enum v) const { return v == Type::IfcElementType || IfcTypeProduct::is(v); }
Type::Enum IfcElementType::type() const { return Type::IfcElementType; }
Type::Enum IfcElementType::Class() { return Type::IfcElementType; }
IfcElementType::IfcElementType(IfcAbstractEntityPtr e) : IfcTypeProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementType::IfcElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcTypeProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcElementarySurface
IfcAxis2Placement3D* IfcElementarySurface::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcElementarySurface::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcElementarySurface::is(Type::Enum v) const { return v == Type::IfcElementarySurface || IfcSurface::is(v); }
Type::Enum IfcElementarySurface::type() const { return Type::IfcElementarySurface; }
Type::Enum IfcElementarySurface::Class() { return Type::IfcElementarySurface; }
IfcElementarySurface::IfcElementarySurface(IfcAbstractEntityPtr e) : IfcSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcElementarySurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcElementarySurface::IfcElementarySurface(IfcAxis2Placement3D* v1_Position) : IfcSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEllipse
IfcPositiveLengthMeasure IfcEllipse::SemiAxis1() { return *entity->getArgument(1); }
void IfcEllipse::setSemiAxis1(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcEllipse::SemiAxis2() { return *entity->getArgument(2); }
void IfcEllipse::setSemiAxis2(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcEllipse::is(Type::Enum v) const { return v == Type::IfcEllipse || IfcConic::is(v); }
Type::Enum IfcEllipse::type() const { return Type::IfcEllipse; }
Type::Enum IfcEllipse::Class() { return Type::IfcEllipse; }
IfcEllipse::IfcEllipse(IfcAbstractEntityPtr e) : IfcConic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEllipse)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEllipse::IfcEllipse(IfcAxis2Placement v1_Position, IfcPositiveLengthMeasure v2_SemiAxis1, IfcPositiveLengthMeasure v3_SemiAxis2) : IfcConic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_SemiAxis1)); e->setArgument(2,(v3_SemiAxis2)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEllipseProfileDef
IfcPositiveLengthMeasure IfcEllipseProfileDef::SemiAxis1() { return *entity->getArgument(3); }
void IfcEllipseProfileDef::setSemiAxis1(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcEllipseProfileDef::SemiAxis2() { return *entity->getArgument(4); }
void IfcEllipseProfileDef::setSemiAxis2(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcEllipseProfileDef::is(Type::Enum v) const { return v == Type::IfcEllipseProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcEllipseProfileDef::type() const { return Type::IfcEllipseProfileDef; }
Type::Enum IfcEllipseProfileDef::Class() { return Type::IfcEllipseProfileDef; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEllipseProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEllipseProfileDef::IfcEllipseProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_SemiAxis1, IfcPositiveLengthMeasure v5_SemiAxis2) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_SemiAxis1)); e->setArgument(4,(v5_SemiAxis2)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEnergyConversionDevice
bool IfcEnergyConversionDevice::is(Type::Enum v) const { return v == Type::IfcEnergyConversionDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcEnergyConversionDevice::type() const { return Type::IfcEnergyConversionDevice; }
Type::Enum IfcEnergyConversionDevice::Class() { return Type::IfcEnergyConversionDevice; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEnergyConversionDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnergyConversionDevice::IfcEnergyConversionDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEnergyConversionDeviceType
bool IfcEnergyConversionDeviceType::is(Type::Enum v) const { return v == Type::IfcEnergyConversionDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcEnergyConversionDeviceType::type() const { return Type::IfcEnergyConversionDeviceType; }
Type::Enum IfcEnergyConversionDeviceType::Class() { return Type::IfcEnergyConversionDeviceType; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEnergyConversionDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEnergyConversionDeviceType::IfcEnergyConversionDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEngine
bool IfcEngine::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngine::PredefinedType() { return IfcEngineTypeEnum::FromString(*entity->getArgument(8)); }
void IfcEngine::setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcEngineTypeEnum::ToString(v)); }
bool IfcEngine::is(Type::Enum v) const { return v == Type::IfcEngine || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcEngine::type() const { return Type::IfcEngine; }
Type::Enum IfcEngine::Class() { return Type::IfcEngine; }
IfcEngine::IfcEngine(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEngine)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEngine::IfcEngine(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcEngineTypeEnum::IfcEngineTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcEngineTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEngineType
IfcEngineTypeEnum::IfcEngineTypeEnum IfcEngineType::PredefinedType() { return IfcEngineTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEngineType::setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcEngineTypeEnum::ToString(v)); }
bool IfcEngineType::is(Type::Enum v) const { return v == Type::IfcEngineType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcEngineType::type() const { return Type::IfcEngineType; }
Type::Enum IfcEngineType::Class() { return Type::IfcEngineType; }
IfcEngineType::IfcEngineType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEngineType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEngineType::IfcEngineType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcEngineTypeEnum::IfcEngineTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcEngineTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEvaporativeCooler
bool IfcEvaporativeCooler::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCooler::PredefinedType() { return IfcEvaporativeCoolerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcEvaporativeCooler::setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcEvaporativeCoolerTypeEnum::ToString(v)); }
bool IfcEvaporativeCooler::is(Type::Enum v) const { return v == Type::IfcEvaporativeCooler || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcEvaporativeCooler::type() const { return Type::IfcEvaporativeCooler; }
Type::Enum IfcEvaporativeCooler::Class() { return Type::IfcEvaporativeCooler; }
IfcEvaporativeCooler::IfcEvaporativeCooler(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEvaporativeCooler)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporativeCooler::IfcEvaporativeCooler(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcEvaporativeCoolerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEvaporativeCoolerType
IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum IfcEvaporativeCoolerType::PredefinedType() { return IfcEvaporativeCoolerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEvaporativeCoolerType::setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcEvaporativeCoolerTypeEnum::ToString(v)); }
bool IfcEvaporativeCoolerType::is(Type::Enum v) const { return v == Type::IfcEvaporativeCoolerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcEvaporativeCoolerType::type() const { return Type::IfcEvaporativeCoolerType; }
Type::Enum IfcEvaporativeCoolerType::Class() { return Type::IfcEvaporativeCoolerType; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEvaporativeCoolerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporativeCoolerType::IfcEvaporativeCoolerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcEvaporativeCoolerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEvaporator
bool IfcEvaporator::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporator::PredefinedType() { return IfcEvaporatorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcEvaporator::setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcEvaporatorTypeEnum::ToString(v)); }
bool IfcEvaporator::is(Type::Enum v) const { return v == Type::IfcEvaporator || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcEvaporator::type() const { return Type::IfcEvaporator; }
Type::Enum IfcEvaporator::Class() { return Type::IfcEvaporator; }
IfcEvaporator::IfcEvaporator(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEvaporator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporator::IfcEvaporator(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcEvaporatorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEvaporatorType
IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum IfcEvaporatorType::PredefinedType() { return IfcEvaporatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEvaporatorType::setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcEvaporatorTypeEnum::ToString(v)); }
bool IfcEvaporatorType::is(Type::Enum v) const { return v == Type::IfcEvaporatorType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcEvaporatorType::type() const { return Type::IfcEvaporatorType; }
Type::Enum IfcEvaporatorType::Class() { return Type::IfcEvaporatorType; }
IfcEvaporatorType::IfcEvaporatorType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEvaporatorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvaporatorType::IfcEvaporatorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcEvaporatorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEvent
bool IfcEvent::hasPredefinedType() { return !entity->getArgument(7)->isNull(); }
IfcEventTypeEnum::IfcEventTypeEnum IfcEvent::PredefinedType() { return IfcEventTypeEnum::FromString(*entity->getArgument(7)); }
void IfcEvent::setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcEventTypeEnum::ToString(v)); }
bool IfcEvent::hasEventTriggerType() { return !entity->getArgument(8)->isNull(); }
IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEvent::EventTriggerType() { return IfcEventTriggerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcEvent::setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcEventTriggerTypeEnum::ToString(v)); }
bool IfcEvent::hasUserDefinedEventTriggerType() { return !entity->getArgument(9)->isNull(); }
IfcLabel IfcEvent::UserDefinedEventTriggerType() { return *entity->getArgument(9); }
void IfcEvent::setUserDefinedEventTriggerType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcEvent::hasEventOccurenceTime() { return !entity->getArgument(10)->isNull(); }
IfcEventTime* IfcEvent::EventOccurenceTime() { return (IfcEventTime*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcEvent::setEventOccurenceTime(IfcEventTime* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcEvent::is(Type::Enum v) const { return v == Type::IfcEvent || IfcProcess::is(v); }
Type::Enum IfcEvent::type() const { return Type::IfcEvent; }
Type::Enum IfcEvent::Class() { return Type::IfcEvent; }
IfcEvent::IfcEvent(IfcAbstractEntityPtr e) : IfcProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEvent)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEvent::IfcEvent(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, boost::optional< IfcEventTypeEnum::IfcEventTypeEnum > v8_PredefinedType, boost::optional< IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum > v9_EventTriggerType, boost::optional< IfcLabel > v10_UserDefinedEventTriggerType, IfcEventTime* v11_EventOccurenceTime) : IfcProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } if (v8_PredefinedType) { e->setArgument(7,*v8_PredefinedType,IfcEventTypeEnum::ToString(*v8_PredefinedType)); } else { e->setArgument(7); } if (v9_EventTriggerType) { e->setArgument(8,*v9_EventTriggerType,IfcEventTriggerTypeEnum::ToString(*v9_EventTriggerType)); } else { e->setArgument(8); } if (v10_UserDefinedEventTriggerType) { e->setArgument(9,(*v10_UserDefinedEventTriggerType)); } else { e->setArgument(9); } e->setArgument(10,(v11_EventOccurenceTime)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEventTime
bool IfcEventTime::hasActualDate() { return !entity->getArgument(3)->isNull(); }
IfcDateTime IfcEventTime::ActualDate() { return *entity->getArgument(3); }
void IfcEventTime::setActualDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcEventTime::hasEarlyDate() { return !entity->getArgument(4)->isNull(); }
IfcDateTime IfcEventTime::EarlyDate() { return *entity->getArgument(4); }
void IfcEventTime::setEarlyDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcEventTime::hasLateDate() { return !entity->getArgument(5)->isNull(); }
IfcDateTime IfcEventTime::LateDate() { return *entity->getArgument(5); }
void IfcEventTime::setLateDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcEventTime::hasScheduleDate() { return !entity->getArgument(6)->isNull(); }
IfcDateTime IfcEventTime::ScheduleDate() { return *entity->getArgument(6); }
void IfcEventTime::setScheduleDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcEventTime::is(Type::Enum v) const { return v == Type::IfcEventTime || IfcSchedulingTime::is(v); }
Type::Enum IfcEventTime::type() const { return Type::IfcEventTime; }
Type::Enum IfcEventTime::Class() { return Type::IfcEventTime; }
IfcEventTime::IfcEventTime(IfcAbstractEntityPtr e) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEventTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEventTime::IfcEventTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, boost::optional< IfcDateTime > v4_ActualDate, boost::optional< IfcDateTime > v5_EarlyDate, boost::optional< IfcDateTime > v6_LateDate, boost::optional< IfcDateTime > v7_ScheduleDate) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } if (v4_ActualDate) { e->setArgument(3,(*v4_ActualDate)); } else { e->setArgument(3); } if (v5_EarlyDate) { e->setArgument(4,(*v5_EarlyDate)); } else { e->setArgument(4); } if (v6_LateDate) { e->setArgument(5,(*v6_LateDate)); } else { e->setArgument(5); } if (v7_ScheduleDate) { e->setArgument(6,(*v7_ScheduleDate)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcEventType
IfcEventTypeEnum::IfcEventTypeEnum IfcEventType::PredefinedType() { return IfcEventTypeEnum::FromString(*entity->getArgument(9)); }
void IfcEventType::setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcEventTypeEnum::ToString(v)); }
IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum IfcEventType::EventTriggerType() { return IfcEventTriggerTypeEnum::FromString(*entity->getArgument(10)); }
void IfcEventType::setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcEventTriggerTypeEnum::ToString(v)); }
bool IfcEventType::hasUserDefinedEventTriggerType() { return !entity->getArgument(11)->isNull(); }
IfcLabel IfcEventType::UserDefinedEventTriggerType() { return *entity->getArgument(11); }
void IfcEventType::setUserDefinedEventTriggerType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcEventType::is(Type::Enum v) const { return v == Type::IfcEventType || IfcTypeProcess::is(v); }
Type::Enum IfcEventType::type() const { return Type::IfcEventType; }
Type::Enum IfcEventType::Class() { return Type::IfcEventType; }
IfcEventType::IfcEventType(IfcAbstractEntityPtr e) : IfcTypeProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcEventType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcEventType::IfcEventType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ProcessType, IfcEventTypeEnum::IfcEventTypeEnum v10_PredefinedType, IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v11_EventTriggerType, boost::optional< IfcLabel > v12_UserDefinedEventTriggerType) : IfcTypeProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ProcessType) { e->setArgument(8,(*v9_ProcessType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcEventTypeEnum::ToString(v10_PredefinedType)); e->setArgument(10,v11_EventTriggerType,IfcEventTriggerTypeEnum::ToString(v11_EventTriggerType)); if (v12_UserDefinedEventTriggerType) { e->setArgument(11,(*v12_UserDefinedEventTriggerType)); } else { e->setArgument(11); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExtendedProperties
bool IfcExtendedProperties::hasName() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcExtendedProperties::Name() { return *entity->getArgument(0); }
void IfcExtendedProperties::setName(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcExtendedProperties::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcExtendedProperties::Description() { return *entity->getArgument(1); }
void IfcExtendedProperties::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > IfcExtendedProperties::Properties() { RETURN_AS_LIST(IfcProperty,2) }
void IfcExtendedProperties::setProperties(SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcExtendedProperties::is(Type::Enum v) const { return v == Type::IfcExtendedProperties || IfcPropertyAbstraction::is(v); }
Type::Enum IfcExtendedProperties::type() const { return Type::IfcExtendedProperties; }
Type::Enum IfcExtendedProperties::Class() { return Type::IfcExtendedProperties; }
IfcExtendedProperties::IfcExtendedProperties(IfcAbstractEntityPtr e) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExtendedProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExtendedProperties::IfcExtendedProperties(boost::optional< IfcIdentifier > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v3_Properties) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Properties)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternalInformation
bool IfcExternalInformation::is(Type::Enum v) const { return v == Type::IfcExternalInformation; }
Type::Enum IfcExternalInformation::type() const { return Type::IfcExternalInformation; }
Type::Enum IfcExternalInformation::Class() { return Type::IfcExternalInformation; }
IfcExternalInformation::IfcExternalInformation(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcExternalInformation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalInformation::IfcExternalInformation() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternalReference
bool IfcExternalReference::hasLocation() { return !entity->getArgument(0)->isNull(); }
IfcURIReference IfcExternalReference::Location() { return *entity->getArgument(0); }
void IfcExternalReference::setLocation(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcExternalReference::hasIdentification() { return !entity->getArgument(1)->isNull(); }
IfcIdentifier IfcExternalReference::Identification() { return *entity->getArgument(1); }
void IfcExternalReference::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcExternalReference::hasName() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcExternalReference::Name() { return *entity->getArgument(2); }
void IfcExternalReference::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcExternalReferenceRelationship::list IfcExternalReference::ExternalReferenceForResources() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcExternalReference::is(Type::Enum v) const { return v == Type::IfcExternalReference; }
Type::Enum IfcExternalReference::type() const { return Type::IfcExternalReference; }
Type::Enum IfcExternalReference::Class() { return Type::IfcExternalReference; }
IfcExternalReference::IfcExternalReference(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcExternalReference)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalReference::IfcExternalReference(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternalReferenceRelationship
IfcExternalReference* IfcExternalReferenceRelationship::RelatingReference() { return (IfcExternalReference*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcExternalReferenceRelationship::setRelatingReference(IfcExternalReference* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcExternalReferenceRelationship::RelatedResourceObjects() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,3) }
void IfcExternalReferenceRelationship::setRelatedResourceObjects(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcExternalReferenceRelationship::is(Type::Enum v) const { return v == Type::IfcExternalReferenceRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcExternalReferenceRelationship::type() const { return Type::IfcExternalReferenceRelationship; }
Type::Enum IfcExternalReferenceRelationship::Class() { return Type::IfcExternalReferenceRelationship; }
IfcExternalReferenceRelationship::IfcExternalReferenceRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternalReferenceRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalReferenceRelationship::IfcExternalReferenceRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcExternalReference* v3_RelatingReference, IfcEntities v4_RelatedResourceObjects) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingReference)); e->setArgument(3,(v4_RelatedResourceObjects)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternalSpatialElement
bool IfcExternalSpatialElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum IfcExternalSpatialElement::PredefinedType() { return IfcExternalSpatialElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcExternalSpatialElement::setPredefinedType(IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcExternalSpatialElementTypeEnum::ToString(v)); }
IfcRelSpaceBoundary::list IfcExternalSpatialElement::BoundedBy() { RETURN_INVERSE(IfcRelSpaceBoundary) }
bool IfcExternalSpatialElement::is(Type::Enum v) const { return v == Type::IfcExternalSpatialElement || IfcExternalSpatialStructureElement::is(v); }
Type::Enum IfcExternalSpatialElement::type() const { return Type::IfcExternalSpatialElement; }
Type::Enum IfcExternalSpatialElement::Class() { return Type::IfcExternalSpatialElement; }
IfcExternalSpatialElement::IfcExternalSpatialElement(IfcAbstractEntityPtr e) : IfcExternalSpatialStructureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternalSpatialElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalSpatialElement::IfcExternalSpatialElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum > v9_PredefinedType) : IfcExternalSpatialStructureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcExternalSpatialElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternalSpatialStructureElement
bool IfcExternalSpatialStructureElement::is(Type::Enum v) const { return v == Type::IfcExternalSpatialStructureElement || IfcSpatialElement::is(v); }
Type::Enum IfcExternalSpatialStructureElement::type() const { return Type::IfcExternalSpatialStructureElement; }
Type::Enum IfcExternalSpatialStructureElement::Class() { return Type::IfcExternalSpatialStructureElement; }
IfcExternalSpatialStructureElement::IfcExternalSpatialStructureElement(IfcAbstractEntityPtr e) : IfcSpatialElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternalSpatialStructureElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternalSpatialStructureElement::IfcExternalSpatialStructureElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName) : IfcSpatialElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternallyDefinedHatchStyle
bool IfcExternallyDefinedHatchStyle::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedHatchStyle || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedHatchStyle::type() const { return Type::IfcExternallyDefinedHatchStyle; }
Type::Enum IfcExternallyDefinedHatchStyle::Class() { return Type::IfcExternallyDefinedHatchStyle; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternallyDefinedHatchStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedHatchStyle::IfcExternallyDefinedHatchStyle(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternallyDefinedSurfaceStyle
bool IfcExternallyDefinedSurfaceStyle::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedSurfaceStyle || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedSurfaceStyle::type() const { return Type::IfcExternallyDefinedSurfaceStyle; }
Type::Enum IfcExternallyDefinedSurfaceStyle::Class() { return Type::IfcExternallyDefinedSurfaceStyle; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternallyDefinedSurfaceStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedSurfaceStyle::IfcExternallyDefinedSurfaceStyle(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExternallyDefinedTextFont
bool IfcExternallyDefinedTextFont::is(Type::Enum v) const { return v == Type::IfcExternallyDefinedTextFont || IfcExternalReference::is(v); }
Type::Enum IfcExternallyDefinedTextFont::type() const { return Type::IfcExternallyDefinedTextFont; }
Type::Enum IfcExternallyDefinedTextFont::Class() { return Type::IfcExternallyDefinedTextFont; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExternallyDefinedTextFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExternallyDefinedTextFont::IfcExternallyDefinedTextFont(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExtrudedAreaSolid
IfcDirection* IfcExtrudedAreaSolid::ExtrudedDirection() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcExtrudedAreaSolid::setExtrudedDirection(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPositiveLengthMeasure IfcExtrudedAreaSolid::Depth() { return *entity->getArgument(3); }
void IfcExtrudedAreaSolid::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcExtrudedAreaSolid::is(Type::Enum v) const { return v == Type::IfcExtrudedAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcExtrudedAreaSolid::type() const { return Type::IfcExtrudedAreaSolid; }
Type::Enum IfcExtrudedAreaSolid::Class() { return Type::IfcExtrudedAreaSolid; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcAbstractEntityPtr e) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExtrudedAreaSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExtrudedAreaSolid::IfcExtrudedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, IfcPositiveLengthMeasure v4_Depth) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_ExtrudedDirection)); e->setArgument(3,(v4_Depth)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcExtrudedAreaSolidTapered
IfcProfileDef* IfcExtrudedAreaSolidTapered::EndSweptArea() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcExtrudedAreaSolidTapered::setEndSweptArea(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcExtrudedAreaSolidTapered::is(Type::Enum v) const { return v == Type::IfcExtrudedAreaSolidTapered || IfcExtrudedAreaSolid::is(v); }
Type::Enum IfcExtrudedAreaSolidTapered::type() const { return Type::IfcExtrudedAreaSolidTapered; }
Type::Enum IfcExtrudedAreaSolidTapered::Class() { return Type::IfcExtrudedAreaSolidTapered; }
IfcExtrudedAreaSolidTapered::IfcExtrudedAreaSolidTapered(IfcAbstractEntityPtr e) : IfcExtrudedAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcExtrudedAreaSolidTapered)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcExtrudedAreaSolidTapered::IfcExtrudedAreaSolidTapered(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, IfcPositiveLengthMeasure v4_Depth, IfcProfileDef* v5_EndSweptArea) : IfcExtrudedAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_ExtrudedDirection)); e->setArgument(3,(v4_Depth)); e->setArgument(4,(v5_EndSweptArea)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFace
SHARED_PTR< IfcTemplatedEntityList< IfcFaceBound > > IfcFace::Bounds() { RETURN_AS_LIST(IfcFaceBound,0) }
void IfcFace::setBounds(SHARED_PTR< IfcTemplatedEntityList< IfcFaceBound > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
IfcTextureMap::list IfcFace::HasTextureMaps() { RETURN_INVERSE(IfcTextureMap) }
bool IfcFace::is(Type::Enum v) const { return v == Type::IfcFace || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcFace::type() const { return Type::IfcFace; }
Type::Enum IfcFace::Class() { return Type::IfcFace; }
IfcFace::IfcFace(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFace)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFace::IfcFace(SHARED_PTR< IfcTemplatedEntityList< IfcFaceBound > > v1_Bounds) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Bounds)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFaceBasedSurfaceModel
SHARED_PTR< IfcTemplatedEntityList< IfcConnectedFaceSet > > IfcFaceBasedSurfaceModel::FbsmFaces() { RETURN_AS_LIST(IfcConnectedFaceSet,0) }
void IfcFaceBasedSurfaceModel::setFbsmFaces(SHARED_PTR< IfcTemplatedEntityList< IfcConnectedFaceSet > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcFaceBasedSurfaceModel::is(Type::Enum v) const { return v == Type::IfcFaceBasedSurfaceModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFaceBasedSurfaceModel::type() const { return Type::IfcFaceBasedSurfaceModel; }
Type::Enum IfcFaceBasedSurfaceModel::Class() { return Type::IfcFaceBasedSurfaceModel; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFaceBasedSurfaceModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceBasedSurfaceModel::IfcFaceBasedSurfaceModel(SHARED_PTR< IfcTemplatedEntityList< IfcConnectedFaceSet > > v1_FbsmFaces) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_FbsmFaces)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFaceBound
IfcLoop* IfcFaceBound::Bound() { return (IfcLoop*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcFaceBound::setBound(IfcLoop* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcFaceBound::Orientation() { return *entity->getArgument(1); }
void IfcFaceBound::setOrientation(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcFaceBound::is(Type::Enum v) const { return v == Type::IfcFaceBound || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcFaceBound::type() const { return Type::IfcFaceBound; }
Type::Enum IfcFaceBound::Class() { return Type::IfcFaceBound; }
IfcFaceBound::IfcFaceBound(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFaceBound)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceBound::IfcFaceBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Bound)); e->setArgument(1,(v2_Orientation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFaceOuterBound
bool IfcFaceOuterBound::is(Type::Enum v) const { return v == Type::IfcFaceOuterBound || IfcFaceBound::is(v); }
Type::Enum IfcFaceOuterBound::type() const { return Type::IfcFaceOuterBound; }
Type::Enum IfcFaceOuterBound::Class() { return Type::IfcFaceOuterBound; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcAbstractEntityPtr e) : IfcFaceBound((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFaceOuterBound)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceOuterBound::IfcFaceOuterBound(IfcLoop* v1_Bound, bool v2_Orientation) : IfcFaceBound((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Bound)); e->setArgument(1,(v2_Orientation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFaceSurface
IfcSurface* IfcFaceSurface::FaceSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcFaceSurface::setFaceSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcFaceSurface::SameSense() { return *entity->getArgument(2); }
void IfcFaceSurface::setSameSense(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFaceSurface::is(Type::Enum v) const { return v == Type::IfcFaceSurface || IfcFace::is(v); }
Type::Enum IfcFaceSurface::type() const { return Type::IfcFaceSurface; }
Type::Enum IfcFaceSurface::Class() { return Type::IfcFaceSurface; }
IfcFaceSurface::IfcFaceSurface(IfcAbstractEntityPtr e) : IfcFace((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFaceSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFaceSurface::IfcFaceSurface(SHARED_PTR< IfcTemplatedEntityList< IfcFaceBound > > v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense) : IfcFace((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Bounds)->generalize()); e->setArgument(1,(v2_FaceSurface)); e->setArgument(2,(v3_SameSense)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFacetedBrep
bool IfcFacetedBrep::is(Type::Enum v) const { return v == Type::IfcFacetedBrep || IfcManifoldSolidBrep::is(v); }
Type::Enum IfcFacetedBrep::type() const { return Type::IfcFacetedBrep; }
Type::Enum IfcFacetedBrep::Class() { return Type::IfcFacetedBrep; }
IfcFacetedBrep::IfcFacetedBrep(IfcAbstractEntityPtr e) : IfcManifoldSolidBrep((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFacetedBrep)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFacetedBrep::IfcFacetedBrep(IfcClosedShell* v1_Outer) : IfcManifoldSolidBrep((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Outer)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFacetedBrepWithVoids
SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > IfcFacetedBrepWithVoids::Voids() { RETURN_AS_LIST(IfcClosedShell,1) }
void IfcFacetedBrepWithVoids::setVoids(SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcFacetedBrepWithVoids::is(Type::Enum v) const { return v == Type::IfcFacetedBrepWithVoids || IfcFacetedBrep::is(v); }
Type::Enum IfcFacetedBrepWithVoids::type() const { return Type::IfcFacetedBrepWithVoids; }
Type::Enum IfcFacetedBrepWithVoids::Class() { return Type::IfcFacetedBrepWithVoids; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcAbstractEntityPtr e) : IfcFacetedBrep((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFacetedBrepWithVoids)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFacetedBrepWithVoids::IfcFacetedBrepWithVoids(IfcClosedShell* v1_Outer, SHARED_PTR< IfcTemplatedEntityList< IfcClosedShell > > v2_Voids) : IfcFacetedBrep((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Outer)); e->setArgument(1,(v2_Voids)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFailureConnectionCondition
bool IfcFailureConnectionCondition::hasTensionFailureX() { return !entity->getArgument(1)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::TensionFailureX() { return *entity->getArgument(1); }
void IfcFailureConnectionCondition::setTensionFailureX(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcFailureConnectionCondition::hasTensionFailureY() { return !entity->getArgument(2)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::TensionFailureY() { return *entity->getArgument(2); }
void IfcFailureConnectionCondition::setTensionFailureY(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFailureConnectionCondition::hasTensionFailureZ() { return !entity->getArgument(3)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::TensionFailureZ() { return *entity->getArgument(3); }
void IfcFailureConnectionCondition::setTensionFailureZ(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcFailureConnectionCondition::hasCompressionFailureX() { return !entity->getArgument(4)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::CompressionFailureX() { return *entity->getArgument(4); }
void IfcFailureConnectionCondition::setCompressionFailureX(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcFailureConnectionCondition::hasCompressionFailureY() { return !entity->getArgument(5)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::CompressionFailureY() { return *entity->getArgument(5); }
void IfcFailureConnectionCondition::setCompressionFailureY(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcFailureConnectionCondition::hasCompressionFailureZ() { return !entity->getArgument(6)->isNull(); }
IfcForceMeasure IfcFailureConnectionCondition::CompressionFailureZ() { return *entity->getArgument(6); }
void IfcFailureConnectionCondition::setCompressionFailureZ(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcFailureConnectionCondition::is(Type::Enum v) const { return v == Type::IfcFailureConnectionCondition || IfcStructuralConnectionCondition::is(v); }
Type::Enum IfcFailureConnectionCondition::type() const { return Type::IfcFailureConnectionCondition; }
Type::Enum IfcFailureConnectionCondition::Class() { return Type::IfcFailureConnectionCondition; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(IfcAbstractEntityPtr e) : IfcStructuralConnectionCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFailureConnectionCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFailureConnectionCondition::IfcFailureConnectionCondition(boost::optional< IfcLabel > v1_Name, boost::optional< IfcForceMeasure > v2_TensionFailureX, boost::optional< IfcForceMeasure > v3_TensionFailureY, boost::optional< IfcForceMeasure > v4_TensionFailureZ, boost::optional< IfcForceMeasure > v5_CompressionFailureX, boost::optional< IfcForceMeasure > v6_CompressionFailureY, boost::optional< IfcForceMeasure > v7_CompressionFailureZ) : IfcStructuralConnectionCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_TensionFailureX) { e->setArgument(1,(*v2_TensionFailureX)); } else { e->setArgument(1); } if (v3_TensionFailureY) { e->setArgument(2,(*v3_TensionFailureY)); } else { e->setArgument(2); } if (v4_TensionFailureZ) { e->setArgument(3,(*v4_TensionFailureZ)); } else { e->setArgument(3); } if (v5_CompressionFailureX) { e->setArgument(4,(*v5_CompressionFailureX)); } else { e->setArgument(4); } if (v6_CompressionFailureY) { e->setArgument(5,(*v6_CompressionFailureY)); } else { e->setArgument(5); } if (v7_CompressionFailureZ) { e->setArgument(6,(*v7_CompressionFailureZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFan
bool IfcFan::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFanTypeEnum::IfcFanTypeEnum IfcFan::PredefinedType() { return IfcFanTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFan::setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFanTypeEnum::ToString(v)); }
bool IfcFan::is(Type::Enum v) const { return v == Type::IfcFan || IfcFlowMovingDevice::is(v); }
Type::Enum IfcFan::type() const { return Type::IfcFan; }
Type::Enum IfcFan::Class() { return Type::IfcFan; }
IfcFan::IfcFan(IfcAbstractEntityPtr e) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFan)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFan::IfcFan(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFanTypeEnum::IfcFanTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFanTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFanType
IfcFanTypeEnum::IfcFanTypeEnum IfcFanType::PredefinedType() { return IfcFanTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFanType::setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFanTypeEnum::ToString(v)); }
bool IfcFanType::is(Type::Enum v) const { return v == Type::IfcFanType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcFanType::type() const { return Type::IfcFanType; }
Type::Enum IfcFanType::Class() { return Type::IfcFanType; }
IfcFanType::IfcFanType(IfcAbstractEntityPtr e) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFanType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFanType::IfcFanType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFanTypeEnum::IfcFanTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFanTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFastener
bool IfcFastener::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastener::PredefinedType() { return IfcFastenerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFastener::setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFastenerTypeEnum::ToString(v)); }
bool IfcFastener::is(Type::Enum v) const { return v == Type::IfcFastener || IfcElementComponent::is(v); }
Type::Enum IfcFastener::type() const { return Type::IfcFastener; }
Type::Enum IfcFastener::Class() { return Type::IfcFastener; }
IfcFastener::IfcFastener(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFastener)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFastener::IfcFastener(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFastenerTypeEnum::IfcFastenerTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFastenerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFastenerType
IfcFastenerTypeEnum::IfcFastenerTypeEnum IfcFastenerType::PredefinedType() { return IfcFastenerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFastenerType::setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFastenerTypeEnum::ToString(v)); }
bool IfcFastenerType::is(Type::Enum v) const { return v == Type::IfcFastenerType || IfcElementComponentType::is(v); }
Type::Enum IfcFastenerType::type() const { return Type::IfcFastenerType; }
Type::Enum IfcFastenerType::Class() { return Type::IfcFastenerType; }
IfcFastenerType::IfcFastenerType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFastenerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFastenerType::IfcFastenerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFastenerTypeEnum::IfcFastenerTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFastenerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFeatureElement
bool IfcFeatureElement::is(Type::Enum v) const { return v == Type::IfcFeatureElement || IfcElement::is(v); }
Type::Enum IfcFeatureElement::type() const { return Type::IfcFeatureElement; }
Type::Enum IfcFeatureElement::Class() { return Type::IfcFeatureElement; }
IfcFeatureElement::IfcFeatureElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFeatureElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElement::IfcFeatureElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFeatureElementAddition
IfcRelProjectsElement::list IfcFeatureElementAddition::ProjectsElements() { RETURN_INVERSE(IfcRelProjectsElement) }
bool IfcFeatureElementAddition::is(Type::Enum v) const { return v == Type::IfcFeatureElementAddition || IfcFeatureElement::is(v); }
Type::Enum IfcFeatureElementAddition::type() const { return Type::IfcFeatureElementAddition; }
Type::Enum IfcFeatureElementAddition::Class() { return Type::IfcFeatureElementAddition; }
IfcFeatureElementAddition::IfcFeatureElementAddition(IfcAbstractEntityPtr e) : IfcFeatureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFeatureElementAddition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElementAddition::IfcFeatureElementAddition(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcFeatureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFeatureElementSubtraction
IfcRelVoidsElement::list IfcFeatureElementSubtraction::VoidsElements() { RETURN_INVERSE(IfcRelVoidsElement) }
bool IfcFeatureElementSubtraction::is(Type::Enum v) const { return v == Type::IfcFeatureElementSubtraction || IfcFeatureElement::is(v); }
Type::Enum IfcFeatureElementSubtraction::type() const { return Type::IfcFeatureElementSubtraction; }
Type::Enum IfcFeatureElementSubtraction::Class() { return Type::IfcFeatureElementSubtraction; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(IfcAbstractEntityPtr e) : IfcFeatureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFeatureElementSubtraction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFeatureElementSubtraction::IfcFeatureElementSubtraction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcFeatureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFillAreaStyle
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcFillAreaStyle::FillStyles() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,1) }
void IfcFillAreaStyle::setFillStyles(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcFillAreaStyle::hasModelorDraughting() { return !entity->getArgument(2)->isNull(); }
bool IfcFillAreaStyle::ModelorDraughting() { return *entity->getArgument(2); }
void IfcFillAreaStyle::setModelorDraughting(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFillAreaStyle::is(Type::Enum v) const { return v == Type::IfcFillAreaStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcFillAreaStyle::type() const { return Type::IfcFillAreaStyle; }
Type::Enum IfcFillAreaStyle::Class() { return Type::IfcFillAreaStyle; }
IfcFillAreaStyle::IfcFillAreaStyle(IfcAbstractEntityPtr e) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFillAreaStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyle::IfcFillAreaStyle(boost::optional< IfcLabel > v1_Name, IfcEntities v2_FillStyles, boost::optional< bool > v3_ModelorDraughting) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_FillStyles)); if (v3_ModelorDraughting) { e->setArgument(2,(*v3_ModelorDraughting)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFillAreaStyleHatching
IfcCurveStyle* IfcFillAreaStyleHatching::HatchLineAppearance() { return (IfcCurveStyle*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcFillAreaStyleHatching::setHatchLineAppearance(IfcCurveStyle* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcHatchLineDistanceSelect IfcFillAreaStyleHatching::StartOfNextHatchLine() { return *entity->getArgument(1); }
void IfcFillAreaStyleHatching::setStartOfNextHatchLine(IfcHatchLineDistanceSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcFillAreaStyleHatching::hasPointOfReferenceHatchLine() { return !entity->getArgument(2)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PointOfReferenceHatchLine() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcFillAreaStyleHatching::setPointOfReferenceHatchLine(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFillAreaStyleHatching::hasPatternStart() { return !entity->getArgument(3)->isNull(); }
IfcCartesianPoint* IfcFillAreaStyleHatching::PatternStart() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcFillAreaStyleHatching::setPatternStart(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPlaneAngleMeasure IfcFillAreaStyleHatching::HatchLineAngle() { return *entity->getArgument(4); }
void IfcFillAreaStyleHatching::setHatchLineAngle(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcFillAreaStyleHatching::is(Type::Enum v) const { return v == Type::IfcFillAreaStyleHatching || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFillAreaStyleHatching::type() const { return Type::IfcFillAreaStyleHatching; }
Type::Enum IfcFillAreaStyleHatching::Class() { return Type::IfcFillAreaStyleHatching; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFillAreaStyleHatching)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyleHatching::IfcFillAreaStyleHatching(IfcCurveStyle* v1_HatchLineAppearance, IfcHatchLineDistanceSelect v2_StartOfNextHatchLine, IfcCartesianPoint* v3_PointOfReferenceHatchLine, IfcCartesianPoint* v4_PatternStart, IfcPlaneAngleMeasure v5_HatchLineAngle) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_HatchLineAppearance)); e->setArgument(1,(v2_StartOfNextHatchLine)); e->setArgument(2,(v3_PointOfReferenceHatchLine)); e->setArgument(3,(v4_PatternStart)); e->setArgument(4,(v5_HatchLineAngle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFillAreaStyleTiles
SHARED_PTR< IfcTemplatedEntityList< IfcVector > > IfcFillAreaStyleTiles::TilingPattern() { RETURN_AS_LIST(IfcVector,0) }
void IfcFillAreaStyleTiles::setTilingPattern(SHARED_PTR< IfcTemplatedEntityList< IfcVector > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
SHARED_PTR< IfcTemplatedEntityList< IfcStyledItem > > IfcFillAreaStyleTiles::Tiles() { RETURN_AS_LIST(IfcStyledItem,1) }
void IfcFillAreaStyleTiles::setTiles(SHARED_PTR< IfcTemplatedEntityList< IfcStyledItem > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
IfcPositiveRatioMeasure IfcFillAreaStyleTiles::TilingScale() { return *entity->getArgument(2); }
void IfcFillAreaStyleTiles::setTilingScale(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFillAreaStyleTiles::is(Type::Enum v) const { return v == Type::IfcFillAreaStyleTiles || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcFillAreaStyleTiles::type() const { return Type::IfcFillAreaStyleTiles; }
Type::Enum IfcFillAreaStyleTiles::Class() { return Type::IfcFillAreaStyleTiles; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFillAreaStyleTiles)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFillAreaStyleTiles::IfcFillAreaStyleTiles(SHARED_PTR< IfcTemplatedEntityList< IfcVector > > v1_TilingPattern, SHARED_PTR< IfcTemplatedEntityList< IfcStyledItem > > v2_Tiles, IfcPositiveRatioMeasure v3_TilingScale) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_TilingPattern)->generalize()); e->setArgument(1,(v2_Tiles)->generalize()); e->setArgument(2,(v3_TilingScale)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFilter
bool IfcFilter::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilter::PredefinedType() { return IfcFilterTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFilter::setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFilterTypeEnum::ToString(v)); }
bool IfcFilter::is(Type::Enum v) const { return v == Type::IfcFilter || IfcFlowTreatmentDevice::is(v); }
Type::Enum IfcFilter::type() const { return Type::IfcFilter; }
Type::Enum IfcFilter::Class() { return Type::IfcFilter; }
IfcFilter::IfcFilter(IfcAbstractEntityPtr e) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFilter)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFilter::IfcFilter(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFilterTypeEnum::IfcFilterTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFilterTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFilterType
IfcFilterTypeEnum::IfcFilterTypeEnum IfcFilterType::PredefinedType() { return IfcFilterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFilterType::setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFilterTypeEnum::ToString(v)); }
bool IfcFilterType::is(Type::Enum v) const { return v == Type::IfcFilterType || IfcFlowTreatmentDeviceType::is(v); }
Type::Enum IfcFilterType::type() const { return Type::IfcFilterType; }
Type::Enum IfcFilterType::Class() { return Type::IfcFilterType; }
IfcFilterType::IfcFilterType(IfcAbstractEntityPtr e) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFilterType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFilterType::IfcFilterType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFilterTypeEnum::IfcFilterTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFilterTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFireSuppressionTerminal
bool IfcFireSuppressionTerminal::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminal::PredefinedType() { return IfcFireSuppressionTerminalTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFireSuppressionTerminal::setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFireSuppressionTerminalTypeEnum::ToString(v)); }
bool IfcFireSuppressionTerminal::is(Type::Enum v) const { return v == Type::IfcFireSuppressionTerminal || IfcFlowTerminal::is(v); }
Type::Enum IfcFireSuppressionTerminal::type() const { return Type::IfcFireSuppressionTerminal; }
Type::Enum IfcFireSuppressionTerminal::Class() { return Type::IfcFireSuppressionTerminal; }
IfcFireSuppressionTerminal::IfcFireSuppressionTerminal(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFireSuppressionTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFireSuppressionTerminal::IfcFireSuppressionTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFireSuppressionTerminalTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFireSuppressionTerminalType
IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum IfcFireSuppressionTerminalType::PredefinedType() { return IfcFireSuppressionTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFireSuppressionTerminalType::setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFireSuppressionTerminalTypeEnum::ToString(v)); }
bool IfcFireSuppressionTerminalType::is(Type::Enum v) const { return v == Type::IfcFireSuppressionTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcFireSuppressionTerminalType::type() const { return Type::IfcFireSuppressionTerminalType; }
Type::Enum IfcFireSuppressionTerminalType::Class() { return Type::IfcFireSuppressionTerminalType; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFireSuppressionTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFireSuppressionTerminalType::IfcFireSuppressionTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFireSuppressionTerminalTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFixedReferenceSweptAreaSolid
IfcCurve* IfcFixedReferenceSweptAreaSolid::Directrix() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcFixedReferenceSweptAreaSolid::setDirectrix(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcFixedReferenceSweptAreaSolid::hasStartParam() { return !entity->getArgument(3)->isNull(); }
IfcParameterValue IfcFixedReferenceSweptAreaSolid::StartParam() { return *entity->getArgument(3); }
void IfcFixedReferenceSweptAreaSolid::setStartParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcFixedReferenceSweptAreaSolid::hasEndParam() { return !entity->getArgument(4)->isNull(); }
IfcParameterValue IfcFixedReferenceSweptAreaSolid::EndParam() { return *entity->getArgument(4); }
void IfcFixedReferenceSweptAreaSolid::setEndParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcDirection* IfcFixedReferenceSweptAreaSolid::FixedReference() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcFixedReferenceSweptAreaSolid::setFixedReference(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcFixedReferenceSweptAreaSolid::is(Type::Enum v) const { return v == Type::IfcFixedReferenceSweptAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcFixedReferenceSweptAreaSolid::type() const { return Type::IfcFixedReferenceSweptAreaSolid; }
Type::Enum IfcFixedReferenceSweptAreaSolid::Class() { return Type::IfcFixedReferenceSweptAreaSolid; }
IfcFixedReferenceSweptAreaSolid::IfcFixedReferenceSweptAreaSolid(IfcAbstractEntityPtr e) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFixedReferenceSweptAreaSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFixedReferenceSweptAreaSolid::IfcFixedReferenceSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< IfcParameterValue > v4_StartParam, boost::optional< IfcParameterValue > v5_EndParam, IfcDirection* v6_FixedReference) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_Directrix)); if (v4_StartParam) { e->setArgument(3,(*v4_StartParam)); } else { e->setArgument(3); } if (v5_EndParam) { e->setArgument(4,(*v5_EndParam)); } else { e->setArgument(4); } e->setArgument(5,(v6_FixedReference)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowController
bool IfcFlowController::is(Type::Enum v) const { return v == Type::IfcFlowController || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowController::type() const { return Type::IfcFlowController; }
Type::Enum IfcFlowController::Class() { return Type::IfcFlowController; }
IfcFlowController::IfcFlowController(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowController)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowController::IfcFlowController(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowControllerType
bool IfcFlowControllerType::is(Type::Enum v) const { return v == Type::IfcFlowControllerType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowControllerType::type() const { return Type::IfcFlowControllerType; }
Type::Enum IfcFlowControllerType::Class() { return Type::IfcFlowControllerType; }
IfcFlowControllerType::IfcFlowControllerType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowControllerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowControllerType::IfcFlowControllerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowFitting
bool IfcFlowFitting::is(Type::Enum v) const { return v == Type::IfcFlowFitting || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowFitting::type() const { return Type::IfcFlowFitting; }
Type::Enum IfcFlowFitting::Class() { return Type::IfcFlowFitting; }
IfcFlowFitting::IfcFlowFitting(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowFitting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowFitting::IfcFlowFitting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowFittingType
bool IfcFlowFittingType::is(Type::Enum v) const { return v == Type::IfcFlowFittingType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowFittingType::type() const { return Type::IfcFlowFittingType; }
Type::Enum IfcFlowFittingType::Class() { return Type::IfcFlowFittingType; }
IfcFlowFittingType::IfcFlowFittingType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowFittingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowFittingType::IfcFlowFittingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowInstrument
bool IfcFlowInstrument::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrument::PredefinedType() { return IfcFlowInstrumentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFlowInstrument::setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFlowInstrumentTypeEnum::ToString(v)); }
bool IfcFlowInstrument::is(Type::Enum v) const { return v == Type::IfcFlowInstrument || IfcDistributionControlElement::is(v); }
Type::Enum IfcFlowInstrument::type() const { return Type::IfcFlowInstrument; }
Type::Enum IfcFlowInstrument::Class() { return Type::IfcFlowInstrument; }
IfcFlowInstrument::IfcFlowInstrument(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowInstrument)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowInstrument::IfcFlowInstrument(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFlowInstrumentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowInstrumentType
IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum IfcFlowInstrumentType::PredefinedType() { return IfcFlowInstrumentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFlowInstrumentType::setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFlowInstrumentTypeEnum::ToString(v)); }
bool IfcFlowInstrumentType::is(Type::Enum v) const { return v == Type::IfcFlowInstrumentType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcFlowInstrumentType::type() const { return Type::IfcFlowInstrumentType; }
Type::Enum IfcFlowInstrumentType::Class() { return Type::IfcFlowInstrumentType; }
IfcFlowInstrumentType::IfcFlowInstrumentType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowInstrumentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowInstrumentType::IfcFlowInstrumentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFlowInstrumentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowMeter
bool IfcFlowMeter::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeter::PredefinedType() { return IfcFlowMeterTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFlowMeter::setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFlowMeterTypeEnum::ToString(v)); }
bool IfcFlowMeter::is(Type::Enum v) const { return v == Type::IfcFlowMeter || IfcFlowController::is(v); }
Type::Enum IfcFlowMeter::type() const { return Type::IfcFlowMeter; }
Type::Enum IfcFlowMeter::Class() { return Type::IfcFlowMeter; }
IfcFlowMeter::IfcFlowMeter(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowMeter)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMeter::IfcFlowMeter(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFlowMeterTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowMeterType
IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum IfcFlowMeterType::PredefinedType() { return IfcFlowMeterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFlowMeterType::setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFlowMeterTypeEnum::ToString(v)); }
bool IfcFlowMeterType::is(Type::Enum v) const { return v == Type::IfcFlowMeterType || IfcFlowControllerType::is(v); }
Type::Enum IfcFlowMeterType::type() const { return Type::IfcFlowMeterType; }
Type::Enum IfcFlowMeterType::Class() { return Type::IfcFlowMeterType; }
IfcFlowMeterType::IfcFlowMeterType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowMeterType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMeterType::IfcFlowMeterType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFlowMeterTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowMovingDevice
bool IfcFlowMovingDevice::is(Type::Enum v) const { return v == Type::IfcFlowMovingDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowMovingDevice::type() const { return Type::IfcFlowMovingDevice; }
Type::Enum IfcFlowMovingDevice::Class() { return Type::IfcFlowMovingDevice; }
IfcFlowMovingDevice::IfcFlowMovingDevice(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowMovingDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMovingDevice::IfcFlowMovingDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowMovingDeviceType
bool IfcFlowMovingDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowMovingDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowMovingDeviceType::type() const { return Type::IfcFlowMovingDeviceType; }
Type::Enum IfcFlowMovingDeviceType::Class() { return Type::IfcFlowMovingDeviceType; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowMovingDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowMovingDeviceType::IfcFlowMovingDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowSegment
bool IfcFlowSegment::is(Type::Enum v) const { return v == Type::IfcFlowSegment || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowSegment::type() const { return Type::IfcFlowSegment; }
Type::Enum IfcFlowSegment::Class() { return Type::IfcFlowSegment; }
IfcFlowSegment::IfcFlowSegment(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowSegment::IfcFlowSegment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowSegmentType
bool IfcFlowSegmentType::is(Type::Enum v) const { return v == Type::IfcFlowSegmentType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowSegmentType::type() const { return Type::IfcFlowSegmentType; }
Type::Enum IfcFlowSegmentType::Class() { return Type::IfcFlowSegmentType; }
IfcFlowSegmentType::IfcFlowSegmentType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowSegmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowSegmentType::IfcFlowSegmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowStorageDevice
bool IfcFlowStorageDevice::is(Type::Enum v) const { return v == Type::IfcFlowStorageDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowStorageDevice::type() const { return Type::IfcFlowStorageDevice; }
Type::Enum IfcFlowStorageDevice::Class() { return Type::IfcFlowStorageDevice; }
IfcFlowStorageDevice::IfcFlowStorageDevice(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowStorageDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowStorageDevice::IfcFlowStorageDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowStorageDeviceType
bool IfcFlowStorageDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowStorageDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowStorageDeviceType::type() const { return Type::IfcFlowStorageDeviceType; }
Type::Enum IfcFlowStorageDeviceType::Class() { return Type::IfcFlowStorageDeviceType; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowStorageDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowStorageDeviceType::IfcFlowStorageDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowTerminal
bool IfcFlowTerminal::is(Type::Enum v) const { return v == Type::IfcFlowTerminal || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowTerminal::type() const { return Type::IfcFlowTerminal; }
Type::Enum IfcFlowTerminal::Class() { return Type::IfcFlowTerminal; }
IfcFlowTerminal::IfcFlowTerminal(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTerminal::IfcFlowTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowTerminalType
bool IfcFlowTerminalType::is(Type::Enum v) const { return v == Type::IfcFlowTerminalType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowTerminalType::type() const { return Type::IfcFlowTerminalType; }
Type::Enum IfcFlowTerminalType::Class() { return Type::IfcFlowTerminalType; }
IfcFlowTerminalType::IfcFlowTerminalType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTerminalType::IfcFlowTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowTreatmentDevice
bool IfcFlowTreatmentDevice::is(Type::Enum v) const { return v == Type::IfcFlowTreatmentDevice || IfcDistributionFlowElement::is(v); }
Type::Enum IfcFlowTreatmentDevice::type() const { return Type::IfcFlowTreatmentDevice; }
Type::Enum IfcFlowTreatmentDevice::Class() { return Type::IfcFlowTreatmentDevice; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(IfcAbstractEntityPtr e) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowTreatmentDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTreatmentDevice::IfcFlowTreatmentDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcDistributionFlowElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFlowTreatmentDeviceType
bool IfcFlowTreatmentDeviceType::is(Type::Enum v) const { return v == Type::IfcFlowTreatmentDeviceType || IfcDistributionFlowElementType::is(v); }
Type::Enum IfcFlowTreatmentDeviceType::type() const { return Type::IfcFlowTreatmentDeviceType; }
Type::Enum IfcFlowTreatmentDeviceType::Class() { return Type::IfcFlowTreatmentDeviceType; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(IfcAbstractEntityPtr e) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFlowTreatmentDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFlowTreatmentDeviceType::IfcFlowTreatmentDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcDistributionFlowElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFooting
bool IfcFooting::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFootingTypeEnum::IfcFootingTypeEnum IfcFooting::PredefinedType() { return IfcFootingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFooting::setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFootingTypeEnum::ToString(v)); }
bool IfcFooting::is(Type::Enum v) const { return v == Type::IfcFooting || IfcBuildingElement::is(v); }
Type::Enum IfcFooting::type() const { return Type::IfcFooting; }
Type::Enum IfcFooting::Class() { return Type::IfcFooting; }
IfcFooting::IfcFooting(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFooting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFooting::IfcFooting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFootingTypeEnum::IfcFootingTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFootingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFootingType
IfcFootingTypeEnum::IfcFootingTypeEnum IfcFootingType::PredefinedType() { return IfcFootingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcFootingType::setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcFootingTypeEnum::ToString(v)); }
bool IfcFootingType::is(Type::Enum v) const { return v == Type::IfcFootingType || IfcBuildingElementType::is(v); }
Type::Enum IfcFootingType::type() const { return Type::IfcFootingType; }
Type::Enum IfcFootingType::Class() { return Type::IfcFootingType; }
IfcFootingType::IfcFootingType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFootingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFootingType::IfcFootingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcFootingTypeEnum::IfcFootingTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcFootingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFurnishingElement
bool IfcFurnishingElement::is(Type::Enum v) const { return v == Type::IfcFurnishingElement || IfcElement::is(v); }
Type::Enum IfcFurnishingElement::type() const { return Type::IfcFurnishingElement; }
Type::Enum IfcFurnishingElement::Class() { return Type::IfcFurnishingElement; }
IfcFurnishingElement::IfcFurnishingElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFurnishingElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnishingElement::IfcFurnishingElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFurnishingElementType
bool IfcFurnishingElementType::is(Type::Enum v) const { return v == Type::IfcFurnishingElementType || IfcElementType::is(v); }
Type::Enum IfcFurnishingElementType::type() const { return Type::IfcFurnishingElementType; }
Type::Enum IfcFurnishingElementType::Class() { return Type::IfcFurnishingElementType; }
IfcFurnishingElementType::IfcFurnishingElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFurnishingElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnishingElementType::IfcFurnishingElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFurniture
bool IfcFurniture::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurniture::PredefinedType() { return IfcFurnitureTypeEnum::FromString(*entity->getArgument(8)); }
void IfcFurniture::setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcFurnitureTypeEnum::ToString(v)); }
bool IfcFurniture::is(Type::Enum v) const { return v == Type::IfcFurniture || IfcFurnishingElement::is(v); }
Type::Enum IfcFurniture::type() const { return Type::IfcFurniture; }
Type::Enum IfcFurniture::Class() { return Type::IfcFurniture; }
IfcFurniture::IfcFurniture(IfcAbstractEntityPtr e) : IfcFurnishingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFurniture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurniture::IfcFurniture(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v9_PredefinedType) : IfcFurnishingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcFurnitureTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcFurnitureType
IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum IfcFurnitureType::AssemblyPlace() { return IfcAssemblyPlaceEnum::FromString(*entity->getArgument(9)); }
void IfcFurnitureType::setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcAssemblyPlaceEnum::ToString(v)); }
bool IfcFurnitureType::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcFurnitureTypeEnum::IfcFurnitureTypeEnum IfcFurnitureType::PredefinedType() { return IfcFurnitureTypeEnum::FromString(*entity->getArgument(10)); }
void IfcFurnitureType::setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcFurnitureTypeEnum::ToString(v)); }
bool IfcFurnitureType::is(Type::Enum v) const { return v == Type::IfcFurnitureType || IfcFurnishingElementType::is(v); }
Type::Enum IfcFurnitureType::type() const { return Type::IfcFurnitureType; }
Type::Enum IfcFurnitureType::Class() { return Type::IfcFurnitureType; }
IfcFurnitureType::IfcFurnitureType(IfcAbstractEntityPtr e) : IfcFurnishingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcFurnitureType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcFurnitureType::IfcFurnitureType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v10_AssemblyPlace, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v11_PredefinedType) : IfcFurnishingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_AssemblyPlace,IfcAssemblyPlaceEnum::ToString(v10_AssemblyPlace)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcFurnitureTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeographicElement
bool IfcGeographicElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElement::PredefinedType() { return IfcGeographicElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcGeographicElement::setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcGeographicElementTypeEnum::ToString(v)); }
bool IfcGeographicElement::is(Type::Enum v) const { return v == Type::IfcGeographicElement || IfcElement::is(v); }
Type::Enum IfcGeographicElement::type() const { return Type::IfcGeographicElement; }
Type::Enum IfcGeographicElement::Class() { return Type::IfcGeographicElement; }
IfcGeographicElement::IfcGeographicElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeographicElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeographicElement::IfcGeographicElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum > v9_PredefinedType) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcGeographicElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeographicElementType
IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum IfcGeographicElementType::PredefinedType() { return IfcGeographicElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcGeographicElementType::setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcGeographicElementTypeEnum::ToString(v)); }
bool IfcGeographicElementType::is(Type::Enum v) const { return v == Type::IfcGeographicElementType || IfcElementType::is(v); }
Type::Enum IfcGeographicElementType::type() const { return Type::IfcGeographicElementType; }
Type::Enum IfcGeographicElementType::Class() { return Type::IfcGeographicElementType; }
IfcGeographicElementType::IfcGeographicElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeographicElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeographicElementType::IfcGeographicElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v10_PredefinedType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcGeographicElementTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeometricCurveSet
bool IfcGeometricCurveSet::is(Type::Enum v) const { return v == Type::IfcGeometricCurveSet || IfcGeometricSet::is(v); }
Type::Enum IfcGeometricCurveSet::type() const { return Type::IfcGeometricCurveSet; }
Type::Enum IfcGeometricCurveSet::Class() { return Type::IfcGeometricCurveSet; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcAbstractEntityPtr e) : IfcGeometricSet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeometricCurveSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricCurveSet::IfcGeometricCurveSet(IfcEntities v1_Elements) : IfcGeometricSet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Elements)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeometricRepresentationContext
IfcDimensionCount IfcGeometricRepresentationContext::CoordinateSpaceDimension() { return *entity->getArgument(2); }
void IfcGeometricRepresentationContext::setCoordinateSpaceDimension(IfcDimensionCount v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcGeometricRepresentationContext::hasPrecision() { return !entity->getArgument(3)->isNull(); }
double IfcGeometricRepresentationContext::Precision() { return *entity->getArgument(3); }
void IfcGeometricRepresentationContext::setPrecision(double v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcAxis2Placement IfcGeometricRepresentationContext::WorldCoordinateSystem() { return *entity->getArgument(4); }
void IfcGeometricRepresentationContext::setWorldCoordinateSystem(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcGeometricRepresentationContext::hasTrueNorth() { return !entity->getArgument(5)->isNull(); }
IfcDirection* IfcGeometricRepresentationContext::TrueNorth() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcGeometricRepresentationContext::setTrueNorth(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcGeometricRepresentationSubContext::list IfcGeometricRepresentationContext::HasSubContexts() { RETURN_INVERSE(IfcGeometricRepresentationSubContext) }
bool IfcGeometricRepresentationContext::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationContext || IfcRepresentationContext::is(v); }
Type::Enum IfcGeometricRepresentationContext::type() const { return Type::IfcGeometricRepresentationContext; }
Type::Enum IfcGeometricRepresentationContext::Class() { return Type::IfcGeometricRepresentationContext; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(IfcAbstractEntityPtr e) : IfcRepresentationContext((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeometricRepresentationContext)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationContext::IfcGeometricRepresentationContext(boost::optional< IfcLabel > v1_ContextIdentifier, boost::optional< IfcLabel > v2_ContextType, IfcDimensionCount v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, IfcAxis2Placement v5_WorldCoordinateSystem, IfcDirection* v6_TrueNorth) : IfcRepresentationContext((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_ContextIdentifier) { e->setArgument(0,(*v1_ContextIdentifier)); } else { e->setArgument(0); } if (v2_ContextType) { e->setArgument(1,(*v2_ContextType)); } else { e->setArgument(1); } e->setArgument(2,(v3_CoordinateSpaceDimension)); if (v4_Precision) { e->setArgument(3,(*v4_Precision)); } else { e->setArgument(3); } e->setArgument(4,(v5_WorldCoordinateSystem)); e->setArgument(5,(v6_TrueNorth)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeometricRepresentationItem
bool IfcGeometricRepresentationItem::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationItem || IfcRepresentationItem::is(v); }
Type::Enum IfcGeometricRepresentationItem::type() const { return Type::IfcGeometricRepresentationItem; }
Type::Enum IfcGeometricRepresentationItem::Class() { return Type::IfcGeometricRepresentationItem; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem(IfcAbstractEntityPtr e) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeometricRepresentationItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationItem::IfcGeometricRepresentationItem() : IfcRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeometricRepresentationSubContext
IfcGeometricRepresentationContext* IfcGeometricRepresentationSubContext::ParentContext() { return (IfcGeometricRepresentationContext*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcGeometricRepresentationSubContext::setParentContext(IfcGeometricRepresentationContext* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcGeometricRepresentationSubContext::hasTargetScale() { return !entity->getArgument(7)->isNull(); }
IfcPositiveRatioMeasure IfcGeometricRepresentationSubContext::TargetScale() { return *entity->getArgument(7); }
void IfcGeometricRepresentationSubContext::setTargetScale(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcGeometricProjectionEnum::IfcGeometricProjectionEnum IfcGeometricRepresentationSubContext::TargetView() { return IfcGeometricProjectionEnum::FromString(*entity->getArgument(8)); }
void IfcGeometricRepresentationSubContext::setTargetView(IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcGeometricProjectionEnum::ToString(v)); }
bool IfcGeometricRepresentationSubContext::hasUserDefinedTargetView() { return !entity->getArgument(9)->isNull(); }
IfcLabel IfcGeometricRepresentationSubContext::UserDefinedTargetView() { return *entity->getArgument(9); }
void IfcGeometricRepresentationSubContext::setUserDefinedTargetView(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcGeometricRepresentationSubContext::is(Type::Enum v) const { return v == Type::IfcGeometricRepresentationSubContext || IfcGeometricRepresentationContext::is(v); }
Type::Enum IfcGeometricRepresentationSubContext::type() const { return Type::IfcGeometricRepresentationSubContext; }
Type::Enum IfcGeometricRepresentationSubContext::Class() { return Type::IfcGeometricRepresentationSubContext; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(IfcAbstractEntityPtr e) : IfcGeometricRepresentationContext((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeometricRepresentationSubContext)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricRepresentationSubContext::IfcGeometricRepresentationSubContext(boost::optional< IfcLabel > v1_ContextIdentifier, boost::optional< IfcLabel > v2_ContextType, IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< IfcPositiveRatioMeasure > v8_TargetScale, IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v9_TargetView, boost::optional< IfcLabel > v10_UserDefinedTargetView) : IfcGeometricRepresentationContext((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_ContextIdentifier) { e->setArgument(0,(*v1_ContextIdentifier)); } else { e->setArgument(0); } if (v2_ContextType) { e->setArgument(1,(*v2_ContextType)); } else { e->setArgument(1); } e->setArgumentDerived(2); e->setArgumentDerived(3); e->setArgumentDerived(4); e->setArgumentDerived(5); e->setArgument(6,(v7_ParentContext)); if (v8_TargetScale) { e->setArgument(7,(*v8_TargetScale)); } else { e->setArgument(7); } e->setArgument(8,v9_TargetView,IfcGeometricProjectionEnum::ToString(v9_TargetView)); if (v10_UserDefinedTargetView) { e->setArgument(9,(*v10_UserDefinedTargetView)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGeometricSet
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcGeometricSet::Elements() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcGeometricSet::setElements(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcGeometricSet::is(Type::Enum v) const { return v == Type::IfcGeometricSet || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcGeometricSet::type() const { return Type::IfcGeometricSet; }
Type::Enum IfcGeometricSet::Class() { return Type::IfcGeometricSet; }
IfcGeometricSet::IfcGeometricSet(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGeometricSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGeometricSet::IfcGeometricSet(IfcEntities v1_Elements) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Elements)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGrid
SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > IfcGrid::UAxes() { RETURN_AS_LIST(IfcGridAxis,7) }
void IfcGrid::setUAxes(SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > IfcGrid::VAxes() { RETURN_AS_LIST(IfcGridAxis,8) }
void IfcGrid::setVAxes(SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v->generalize()); }
bool IfcGrid::hasWAxes() { return !entity->getArgument(9)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > IfcGrid::WAxes() { RETURN_AS_LIST(IfcGridAxis,9) }
void IfcGrid::setWAxes(SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v->generalize()); }
bool IfcGrid::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcGridTypeEnum::IfcGridTypeEnum IfcGrid::PredefinedType() { return IfcGridTypeEnum::FromString(*entity->getArgument(10)); }
void IfcGrid::setPredefinedType(IfcGridTypeEnum::IfcGridTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcGridTypeEnum::ToString(v)); }
IfcRelContainedInSpatialStructure::list IfcGrid::ContainedInStructure() { RETURN_INVERSE(IfcRelContainedInSpatialStructure) }
bool IfcGrid::is(Type::Enum v) const { return v == Type::IfcGrid || IfcProduct::is(v); }
Type::Enum IfcGrid::type() const { return Type::IfcGrid; }
Type::Enum IfcGrid::Class() { return Type::IfcGrid; }
IfcGrid::IfcGrid(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGrid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGrid::IfcGrid(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v8_UAxes, SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v9_VAxes, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > > v10_WAxes, boost::optional< IfcGridTypeEnum::IfcGridTypeEnum > v11_PredefinedType) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_UAxes)->generalize()); e->setArgument(8,(v9_VAxes)->generalize()); if (v10_WAxes) { e->setArgument(9,(*v10_WAxes)->generalize()); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcGridTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGridAxis
bool IfcGridAxis::hasAxisTag() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcGridAxis::AxisTag() { return *entity->getArgument(0); }
void IfcGridAxis::setAxisTag(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCurve* IfcGridAxis::AxisCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcGridAxis::setAxisCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcBoolean IfcGridAxis::SameSense() { return *entity->getArgument(2); }
void IfcGridAxis::setSameSense(IfcBoolean v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcGrid::list IfcGridAxis::PartOfW() { RETURN_INVERSE(IfcGrid) }
IfcGrid::list IfcGridAxis::PartOfV() { RETURN_INVERSE(IfcGrid) }
IfcGrid::list IfcGridAxis::PartOfU() { RETURN_INVERSE(IfcGrid) }
IfcVirtualGridIntersection::list IfcGridAxis::HasIntersections() { RETURN_INVERSE(IfcVirtualGridIntersection) }
bool IfcGridAxis::is(Type::Enum v) const { return v == Type::IfcGridAxis; }
Type::Enum IfcGridAxis::type() const { return Type::IfcGridAxis; }
Type::Enum IfcGridAxis::Class() { return Type::IfcGridAxis; }
IfcGridAxis::IfcGridAxis(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcGridAxis)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGridAxis::IfcGridAxis(boost::optional< IfcLabel > v1_AxisTag, IfcCurve* v2_AxisCurve, IfcBoolean v3_SameSense) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_AxisTag) { e->setArgument(0,(*v1_AxisTag)); } else { e->setArgument(0); } e->setArgument(1,(v2_AxisCurve)); e->setArgument(2,(v3_SameSense)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGridPlacement
IfcVirtualGridIntersection* IfcGridPlacement::PlacementLocation() { return (IfcVirtualGridIntersection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcGridPlacement::setPlacementLocation(IfcVirtualGridIntersection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcGridPlacement::hasPlacementRefDirection() { return !entity->getArgument(1)->isNull(); }
IfcGridPlacementDirectionSelect IfcGridPlacement::PlacementRefDirection() { return *entity->getArgument(1); }
void IfcGridPlacement::setPlacementRefDirection(IfcGridPlacementDirectionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcGridPlacement::is(Type::Enum v) const { return v == Type::IfcGridPlacement || IfcObjectPlacement::is(v); }
Type::Enum IfcGridPlacement::type() const { return Type::IfcGridPlacement; }
Type::Enum IfcGridPlacement::Class() { return Type::IfcGridPlacement; }
IfcGridPlacement::IfcGridPlacement(IfcAbstractEntityPtr e) : IfcObjectPlacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGridPlacement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGridPlacement::IfcGridPlacement(IfcVirtualGridIntersection* v1_PlacementLocation, boost::optional< IfcGridPlacementDirectionSelect > v2_PlacementRefDirection) : IfcObjectPlacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_PlacementLocation)); if (v2_PlacementRefDirection) { e->setArgument(1,(*v2_PlacementRefDirection)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcGroup
IfcRelAssignsToGroup::list IfcGroup::IsGroupedBy() { RETURN_INVERSE(IfcRelAssignsToGroup) }
bool IfcGroup::is(Type::Enum v) const { return v == Type::IfcGroup || IfcObject::is(v); }
Type::Enum IfcGroup::type() const { return Type::IfcGroup; }
Type::Enum IfcGroup::Class() { return Type::IfcGroup; }
IfcGroup::IfcGroup(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcGroup)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcGroup::IfcGroup(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcHalfSpaceSolid
IfcSurface* IfcHalfSpaceSolid::BaseSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcHalfSpaceSolid::setBaseSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcHalfSpaceSolid::AgreementFlag() { return *entity->getArgument(1); }
void IfcHalfSpaceSolid::setAgreementFlag(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcHalfSpaceSolid::is(Type::Enum v) const { return v == Type::IfcHalfSpaceSolid || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcHalfSpaceSolid::type() const { return Type::IfcHalfSpaceSolid; }
Type::Enum IfcHalfSpaceSolid::Class() { return Type::IfcHalfSpaceSolid; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcHalfSpaceSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHalfSpaceSolid::IfcHalfSpaceSolid(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BaseSurface)); e->setArgument(1,(v2_AgreementFlag)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcHeatExchanger
bool IfcHeatExchanger::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchanger::PredefinedType() { return IfcHeatExchangerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcHeatExchanger::setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcHeatExchangerTypeEnum::ToString(v)); }
bool IfcHeatExchanger::is(Type::Enum v) const { return v == Type::IfcHeatExchanger || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcHeatExchanger::type() const { return Type::IfcHeatExchanger; }
Type::Enum IfcHeatExchanger::Class() { return Type::IfcHeatExchanger; }
IfcHeatExchanger::IfcHeatExchanger(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcHeatExchanger)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHeatExchanger::IfcHeatExchanger(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcHeatExchangerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcHeatExchangerType
IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum IfcHeatExchangerType::PredefinedType() { return IfcHeatExchangerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcHeatExchangerType::setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcHeatExchangerTypeEnum::ToString(v)); }
bool IfcHeatExchangerType::is(Type::Enum v) const { return v == Type::IfcHeatExchangerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcHeatExchangerType::type() const { return Type::IfcHeatExchangerType; }
Type::Enum IfcHeatExchangerType::Class() { return Type::IfcHeatExchangerType; }
IfcHeatExchangerType::IfcHeatExchangerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcHeatExchangerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHeatExchangerType::IfcHeatExchangerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcHeatExchangerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcHumidifier
bool IfcHumidifier::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifier::PredefinedType() { return IfcHumidifierTypeEnum::FromString(*entity->getArgument(8)); }
void IfcHumidifier::setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcHumidifierTypeEnum::ToString(v)); }
bool IfcHumidifier::is(Type::Enum v) const { return v == Type::IfcHumidifier || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcHumidifier::type() const { return Type::IfcHumidifier; }
Type::Enum IfcHumidifier::Class() { return Type::IfcHumidifier; }
IfcHumidifier::IfcHumidifier(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcHumidifier)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHumidifier::IfcHumidifier(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcHumidifierTypeEnum::IfcHumidifierTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcHumidifierTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcHumidifierType
IfcHumidifierTypeEnum::IfcHumidifierTypeEnum IfcHumidifierType::PredefinedType() { return IfcHumidifierTypeEnum::FromString(*entity->getArgument(9)); }
void IfcHumidifierType::setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcHumidifierTypeEnum::ToString(v)); }
bool IfcHumidifierType::is(Type::Enum v) const { return v == Type::IfcHumidifierType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcHumidifierType::type() const { return Type::IfcHumidifierType; }
Type::Enum IfcHumidifierType::Class() { return Type::IfcHumidifierType; }
IfcHumidifierType::IfcHumidifierType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcHumidifierType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcHumidifierType::IfcHumidifierType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcHumidifierTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIShapeProfileDef
IfcPositiveLengthMeasure IfcIShapeProfileDef::OverallWidth() { return *entity->getArgument(3); }
void IfcIShapeProfileDef::setOverallWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcIShapeProfileDef::OverallDepth() { return *entity->getArgument(4); }
void IfcIShapeProfileDef::setOverallDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcIShapeProfileDef::WebThickness() { return *entity->getArgument(5); }
void IfcIShapeProfileDef::setWebThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcIShapeProfileDef::FlangeThickness() { return *entity->getArgument(6); }
void IfcIShapeProfileDef::setFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcIShapeProfileDef::hasFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcIShapeProfileDef::FilletRadius() { return *entity->getArgument(7); }
void IfcIShapeProfileDef::setFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcIShapeProfileDef::hasFlangeEdgeRadius() { return !entity->getArgument(8)->isNull(); }
IfcNonNegativeLengthMeasure IfcIShapeProfileDef::FlangeEdgeRadius() { return *entity->getArgument(8); }
void IfcIShapeProfileDef::setFlangeEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcIShapeProfileDef::hasFlangeSlope() { return !entity->getArgument(9)->isNull(); }
IfcPlaneAngleMeasure IfcIShapeProfileDef::FlangeSlope() { return *entity->getArgument(9); }
void IfcIShapeProfileDef::setFlangeSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcIShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcIShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcIShapeProfileDef::type() const { return Type::IfcIShapeProfileDef; }
Type::Enum IfcIShapeProfileDef::Class() { return Type::IfcIShapeProfileDef; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcIShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIShapeProfileDef::IfcIShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_OverallWidth, IfcPositiveLengthMeasure v5_OverallDepth, IfcPositiveLengthMeasure v6_WebThickness, IfcPositiveLengthMeasure v7_FlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_FilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v9_FlangeEdgeRadius, boost::optional< IfcPlaneAngleMeasure > v10_FlangeSlope) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_OverallWidth)); e->setArgument(4,(v5_OverallDepth)); e->setArgument(5,(v6_WebThickness)); e->setArgument(6,(v7_FlangeThickness)); if (v8_FilletRadius) { e->setArgument(7,(*v8_FilletRadius)); } else { e->setArgument(7); } if (v9_FlangeEdgeRadius) { e->setArgument(8,(*v9_FlangeEdgeRadius)); } else { e->setArgument(8); } if (v10_FlangeSlope) { e->setArgument(9,(*v10_FlangeSlope)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcImageTexture
IfcURIReference IfcImageTexture::URLReference() { return *entity->getArgument(5); }
void IfcImageTexture::setURLReference(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcImageTexture::is(Type::Enum v) const { return v == Type::IfcImageTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcImageTexture::type() const { return Type::IfcImageTexture; }
Type::Enum IfcImageTexture::Class() { return Type::IfcImageTexture; }
IfcImageTexture::IfcImageTexture(IfcAbstractEntityPtr e) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcImageTexture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcImageTexture::IfcImageTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< IfcIdentifier > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< IfcIdentifier > /*[1:?]*/ > v5_Parameter, IfcURIReference v6_URLReference) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_RepeatS)); e->setArgument(1,(v2_RepeatT)); if (v3_Mode) { e->setArgument(2,(*v3_Mode)); } else { e->setArgument(2); } e->setArgument(3,(v4_TextureTransform)); if (v5_Parameter) { e->setArgument(4,(*v5_Parameter)); } else { e->setArgument(4); } e->setArgument(5,(v6_URLReference)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIndexedColourMap
IfcTessellatedFaceSet* IfcIndexedColourMap::MappedTo() { return (IfcTessellatedFaceSet*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcIndexedColourMap::setMappedTo(IfcTessellatedFaceSet* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcIndexedColourMap::hasOverrides() { return !entity->getArgument(1)->isNull(); }
IfcSurfaceStyleShading* IfcIndexedColourMap::Overrides() { return (IfcSurfaceStyleShading*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcIndexedColourMap::setOverrides(IfcSurfaceStyleShading* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcColourRgbList* IfcIndexedColourMap::Colours() { return (IfcColourRgbList*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcIndexedColourMap::setColours(IfcColourRgbList* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
std::vector< int > /*[1:?]*/ IfcIndexedColourMap::ColourIndex() { return *entity->getArgument(3); }
void IfcIndexedColourMap::setColourIndex(std::vector< int > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcIndexedColourMap::is(Type::Enum v) const { return v == Type::IfcIndexedColourMap || IfcPresentationItem::is(v); }
Type::Enum IfcIndexedColourMap::type() const { return Type::IfcIndexedColourMap; }
Type::Enum IfcIndexedColourMap::Class() { return Type::IfcIndexedColourMap; }
IfcIndexedColourMap::IfcIndexedColourMap(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcIndexedColourMap)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIndexedColourMap::IfcIndexedColourMap(IfcTessellatedFaceSet* v1_MappedTo, IfcSurfaceStyleShading* v2_Overrides, IfcColourRgbList* v3_Colours, std::vector< int > /*[1:?]*/ v4_ColourIndex) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MappedTo)); e->setArgument(1,(v2_Overrides)); e->setArgument(2,(v3_Colours)); e->setArgument(3,(v4_ColourIndex)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIndexedTextureMap
IfcTessellatedFaceSet* IfcIndexedTextureMap::MappedTo() { return (IfcTessellatedFaceSet*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcIndexedTextureMap::setMappedTo(IfcTessellatedFaceSet* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcTextureVertexList* IfcIndexedTextureMap::TexCoords() { return (IfcTextureVertexList*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcIndexedTextureMap::setTexCoords(IfcTextureVertexList* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcIndexedTextureMap::is(Type::Enum v) const { return v == Type::IfcIndexedTextureMap || IfcTextureCoordinate::is(v); }
Type::Enum IfcIndexedTextureMap::type() const { return Type::IfcIndexedTextureMap; }
Type::Enum IfcIndexedTextureMap::Class() { return Type::IfcIndexedTextureMap; }
IfcIndexedTextureMap::IfcIndexedTextureMap(IfcAbstractEntityPtr e) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcIndexedTextureMap)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIndexedTextureMap::IfcIndexedTextureMap(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Maps)->generalize()); e->setArgument(1,(v2_MappedTo)); e->setArgument(2,(v3_TexCoords)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIndexedTriangleTextureMap
bool IfcIndexedTriangleTextureMap::is(Type::Enum v) const { return v == Type::IfcIndexedTriangleTextureMap || IfcIndexedTextureMap::is(v); }
Type::Enum IfcIndexedTriangleTextureMap::type() const { return Type::IfcIndexedTriangleTextureMap; }
Type::Enum IfcIndexedTriangleTextureMap::Class() { return Type::IfcIndexedTriangleTextureMap; }
IfcIndexedTriangleTextureMap::IfcIndexedTriangleTextureMap(IfcAbstractEntityPtr e) : IfcIndexedTextureMap((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcIndexedTriangleTextureMap)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIndexedTriangleTextureMap::IfcIndexedTriangleTextureMap(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords) : IfcIndexedTextureMap((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Maps)->generalize()); e->setArgument(1,(v2_MappedTo)); e->setArgument(2,(v3_TexCoords)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcInterceptor
bool IfcInterceptor::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptor::PredefinedType() { return IfcInterceptorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcInterceptor::setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcInterceptorTypeEnum::ToString(v)); }
bool IfcInterceptor::is(Type::Enum v) const { return v == Type::IfcInterceptor || IfcFlowTreatmentDevice::is(v); }
Type::Enum IfcInterceptor::type() const { return Type::IfcInterceptor; }
Type::Enum IfcInterceptor::Class() { return Type::IfcInterceptor; }
IfcInterceptor::IfcInterceptor(IfcAbstractEntityPtr e) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcInterceptor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcInterceptor::IfcInterceptor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcInterceptorTypeEnum::IfcInterceptorTypeEnum > v9_PredefinedType) : IfcFlowTreatmentDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcInterceptorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcInterceptorType
IfcInterceptorTypeEnum::IfcInterceptorTypeEnum IfcInterceptorType::PredefinedType() { return IfcInterceptorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcInterceptorType::setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcInterceptorTypeEnum::ToString(v)); }
bool IfcInterceptorType::is(Type::Enum v) const { return v == Type::IfcInterceptorType || IfcFlowTreatmentDeviceType::is(v); }
Type::Enum IfcInterceptorType::type() const { return Type::IfcInterceptorType; }
Type::Enum IfcInterceptorType::Class() { return Type::IfcInterceptorType; }
IfcInterceptorType::IfcInterceptorType(IfcAbstractEntityPtr e) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcInterceptorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcInterceptorType::IfcInterceptorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v10_PredefinedType) : IfcFlowTreatmentDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcInterceptorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcInventory
bool IfcInventory::hasPredefinedType() { return !entity->getArgument(5)->isNull(); }
IfcInventoryTypeEnum::IfcInventoryTypeEnum IfcInventory::PredefinedType() { return IfcInventoryTypeEnum::FromString(*entity->getArgument(5)); }
void IfcInventory::setPredefinedType(IfcInventoryTypeEnum::IfcInventoryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcInventoryTypeEnum::ToString(v)); }
bool IfcInventory::hasJurisdiction() { return !entity->getArgument(6)->isNull(); }
IfcActorSelect IfcInventory::Jurisdiction() { return *entity->getArgument(6); }
void IfcInventory::setJurisdiction(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcInventory::hasResponsiblePersons() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > IfcInventory::ResponsiblePersons() { RETURN_AS_LIST(IfcPerson,7) }
void IfcInventory::setResponsiblePersons(SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcInventory::hasLastUpdateDate() { return !entity->getArgument(8)->isNull(); }
IfcDate IfcInventory::LastUpdateDate() { return *entity->getArgument(8); }
void IfcInventory::setLastUpdateDate(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcInventory::hasCurrentValue() { return !entity->getArgument(9)->isNull(); }
IfcCostValue* IfcInventory::CurrentValue() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcInventory::setCurrentValue(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcInventory::hasOriginalValue() { return !entity->getArgument(10)->isNull(); }
IfcCostValue* IfcInventory::OriginalValue() { return (IfcCostValue*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcInventory::setOriginalValue(IfcCostValue* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcInventory::is(Type::Enum v) const { return v == Type::IfcInventory || IfcGroup::is(v); }
Type::Enum IfcInventory::type() const { return Type::IfcInventory; }
Type::Enum IfcInventory::Class() { return Type::IfcInventory; }
IfcInventory::IfcInventory(IfcAbstractEntityPtr e) : IfcGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcInventory)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcInventory::IfcInventory(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcInventoryTypeEnum::IfcInventoryTypeEnum > v6_PredefinedType, boost::optional< IfcActorSelect > v7_Jurisdiction, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > > v8_ResponsiblePersons, boost::optional< IfcDate > v9_LastUpdateDate, IfcCostValue* v10_CurrentValue, IfcCostValue* v11_OriginalValue) : IfcGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_PredefinedType) { e->setArgument(5,*v6_PredefinedType,IfcInventoryTypeEnum::ToString(*v6_PredefinedType)); } else { e->setArgument(5); } if (v7_Jurisdiction) { e->setArgument(6,(*v7_Jurisdiction)); } else { e->setArgument(6); } if (v8_ResponsiblePersons) { e->setArgument(7,(*v8_ResponsiblePersons)->generalize()); } else { e->setArgument(7); } if (v9_LastUpdateDate) { e->setArgument(8,(*v9_LastUpdateDate)); } else { e->setArgument(8); } e->setArgument(9,(v10_CurrentValue)); e->setArgument(10,(v11_OriginalValue)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIrregularTimeSeries
SHARED_PTR< IfcTemplatedEntityList< IfcIrregularTimeSeriesValue > > IfcIrregularTimeSeries::Values() { RETURN_AS_LIST(IfcIrregularTimeSeriesValue,8) }
void IfcIrregularTimeSeries::setValues(SHARED_PTR< IfcTemplatedEntityList< IfcIrregularTimeSeriesValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v->generalize()); }
bool IfcIrregularTimeSeries::is(Type::Enum v) const { return v == Type::IfcIrregularTimeSeries || IfcTimeSeries::is(v); }
Type::Enum IfcIrregularTimeSeries::type() const { return Type::IfcIrregularTimeSeries; }
Type::Enum IfcIrregularTimeSeries::Class() { return Type::IfcIrregularTimeSeries; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(IfcAbstractEntityPtr e) : IfcTimeSeries((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcIrregularTimeSeries)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIrregularTimeSeries::IfcIrregularTimeSeries(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcDateTime v3_StartTime, IfcDateTime v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< IfcLabel > v7_UserDefinedDataOrigin, boost::optional< IfcUnit > v8_Unit, SHARED_PTR< IfcTemplatedEntityList< IfcIrregularTimeSeriesValue > > v9_Values) : IfcTimeSeries((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_StartTime)); e->setArgument(3,(v4_EndTime)); e->setArgument(4,v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType)); e->setArgument(5,v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin)); if (v7_UserDefinedDataOrigin) { e->setArgument(6,(*v7_UserDefinedDataOrigin)); } else { e->setArgument(6); } if (v8_Unit) { e->setArgument(7,(*v8_Unit)); } else { e->setArgument(7); } e->setArgument(8,(v9_Values)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcIrregularTimeSeriesValue
IfcDateTime IfcIrregularTimeSeriesValue::TimeStamp() { return *entity->getArgument(0); }
void IfcIrregularTimeSeriesValue::setTimeStamp(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcIrregularTimeSeriesValue::ListValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,1) }
void IfcIrregularTimeSeriesValue::setListValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcIrregularTimeSeriesValue::is(Type::Enum v) const { return v == Type::IfcIrregularTimeSeriesValue; }
Type::Enum IfcIrregularTimeSeriesValue::type() const { return Type::IfcIrregularTimeSeriesValue; }
Type::Enum IfcIrregularTimeSeriesValue::Class() { return Type::IfcIrregularTimeSeriesValue; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcIrregularTimeSeriesValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcIrregularTimeSeriesValue::IfcIrregularTimeSeriesValue(IfcDateTime v1_TimeStamp, IfcEntities v2_ListValues) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_TimeStamp)); e->setArgument(1,(v2_ListValues)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcJunctionBox
bool IfcJunctionBox::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBox::PredefinedType() { return IfcJunctionBoxTypeEnum::FromString(*entity->getArgument(8)); }
void IfcJunctionBox::setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcJunctionBoxTypeEnum::ToString(v)); }
bool IfcJunctionBox::is(Type::Enum v) const { return v == Type::IfcJunctionBox || IfcFlowFitting::is(v); }
Type::Enum IfcJunctionBox::type() const { return Type::IfcJunctionBox; }
Type::Enum IfcJunctionBox::Class() { return Type::IfcJunctionBox; }
IfcJunctionBox::IfcJunctionBox(IfcAbstractEntityPtr e) : IfcFlowFitting((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcJunctionBox)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcJunctionBox::IfcJunctionBox(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcJunctionBoxTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcJunctionBoxType
IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum IfcJunctionBoxType::PredefinedType() { return IfcJunctionBoxTypeEnum::FromString(*entity->getArgument(9)); }
void IfcJunctionBoxType::setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcJunctionBoxTypeEnum::ToString(v)); }
bool IfcJunctionBoxType::is(Type::Enum v) const { return v == Type::IfcJunctionBoxType || IfcFlowFittingType::is(v); }
Type::Enum IfcJunctionBoxType::type() const { return Type::IfcJunctionBoxType; }
Type::Enum IfcJunctionBoxType::Class() { return Type::IfcJunctionBoxType; }
IfcJunctionBoxType::IfcJunctionBoxType(IfcAbstractEntityPtr e) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcJunctionBoxType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcJunctionBoxType::IfcJunctionBoxType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcJunctionBoxTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLShapeProfileDef
IfcPositiveLengthMeasure IfcLShapeProfileDef::Depth() { return *entity->getArgument(3); }
void IfcLShapeProfileDef::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcLShapeProfileDef::hasWidth() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcLShapeProfileDef::Width() { return *entity->getArgument(4); }
void IfcLShapeProfileDef::setWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcLShapeProfileDef::Thickness() { return *entity->getArgument(5); }
void IfcLShapeProfileDef::setThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcLShapeProfileDef::hasFilletRadius() { return !entity->getArgument(6)->isNull(); }
IfcNonNegativeLengthMeasure IfcLShapeProfileDef::FilletRadius() { return *entity->getArgument(6); }
void IfcLShapeProfileDef::setFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcLShapeProfileDef::hasEdgeRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcLShapeProfileDef::EdgeRadius() { return *entity->getArgument(7); }
void IfcLShapeProfileDef::setEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcLShapeProfileDef::hasLegSlope() { return !entity->getArgument(8)->isNull(); }
IfcPlaneAngleMeasure IfcLShapeProfileDef::LegSlope() { return *entity->getArgument(8); }
void IfcLShapeProfileDef::setLegSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcLShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcLShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcLShapeProfileDef::type() const { return Type::IfcLShapeProfileDef; }
Type::Enum IfcLShapeProfileDef::Class() { return Type::IfcLShapeProfileDef; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLShapeProfileDef::IfcLShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Depth, boost::optional< IfcPositiveLengthMeasure > v5_Width, IfcPositiveLengthMeasure v6_Thickness, boost::optional< IfcNonNegativeLengthMeasure > v7_FilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v8_EdgeRadius, boost::optional< IfcPlaneAngleMeasure > v9_LegSlope) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Depth)); if (v5_Width) { e->setArgument(4,(*v5_Width)); } else { e->setArgument(4); } e->setArgument(5,(v6_Thickness)); if (v7_FilletRadius) { e->setArgument(6,(*v7_FilletRadius)); } else { e->setArgument(6); } if (v8_EdgeRadius) { e->setArgument(7,(*v8_EdgeRadius)); } else { e->setArgument(7); } if (v9_LegSlope) { e->setArgument(8,(*v9_LegSlope)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLaborResource
bool IfcLaborResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResource::PredefinedType() { return IfcLaborResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcLaborResource::setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcLaborResourceTypeEnum::ToString(v)); }
bool IfcLaborResource::is(Type::Enum v) const { return v == Type::IfcLaborResource || IfcConstructionResource::is(v); }
Type::Enum IfcLaborResource::type() const { return Type::IfcLaborResource; }
Type::Enum IfcLaborResource::Class() { return Type::IfcLaborResource; }
IfcLaborResource::IfcLaborResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLaborResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLaborResource::IfcLaborResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcLaborResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLaborResourceType
IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum IfcLaborResourceType::PredefinedType() { return IfcLaborResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcLaborResourceType::setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcLaborResourceTypeEnum::ToString(v)); }
bool IfcLaborResourceType::is(Type::Enum v) const { return v == Type::IfcLaborResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcLaborResourceType::type() const { return Type::IfcLaborResourceType; }
Type::Enum IfcLaborResourceType::Class() { return Type::IfcLaborResourceType; }
IfcLaborResourceType::IfcLaborResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLaborResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLaborResourceType::IfcLaborResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcLaborResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLagTime
IfcTimeOrRatioSelect IfcLagTime::LagValue() { return *entity->getArgument(3); }
void IfcLagTime::setLagValue(IfcTimeOrRatioSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcTaskDurationEnum::IfcTaskDurationEnum IfcLagTime::DurationType() { return IfcTaskDurationEnum::FromString(*entity->getArgument(4)); }
void IfcLagTime::setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcTaskDurationEnum::ToString(v)); }
bool IfcLagTime::is(Type::Enum v) const { return v == Type::IfcLagTime || IfcSchedulingTime::is(v); }
Type::Enum IfcLagTime::type() const { return Type::IfcLagTime; }
Type::Enum IfcLagTime::Class() { return Type::IfcLagTime; }
IfcLagTime::IfcLagTime(IfcAbstractEntityPtr e) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLagTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLagTime::IfcLagTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, IfcTimeOrRatioSelect v4_LagValue, IfcTaskDurationEnum::IfcTaskDurationEnum v5_DurationType) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } e->setArgument(3,(v4_LagValue)); e->setArgument(4,v5_DurationType,IfcTaskDurationEnum::ToString(v5_DurationType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLamp
bool IfcLamp::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcLampTypeEnum::IfcLampTypeEnum IfcLamp::PredefinedType() { return IfcLampTypeEnum::FromString(*entity->getArgument(8)); }
void IfcLamp::setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcLampTypeEnum::ToString(v)); }
bool IfcLamp::is(Type::Enum v) const { return v == Type::IfcLamp || IfcFlowTerminal::is(v); }
Type::Enum IfcLamp::type() const { return Type::IfcLamp; }
Type::Enum IfcLamp::Class() { return Type::IfcLamp; }
IfcLamp::IfcLamp(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLamp)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLamp::IfcLamp(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLampTypeEnum::IfcLampTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcLampTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLampType
IfcLampTypeEnum::IfcLampTypeEnum IfcLampType::PredefinedType() { return IfcLampTypeEnum::FromString(*entity->getArgument(9)); }
void IfcLampType::setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcLampTypeEnum::ToString(v)); }
bool IfcLampType::is(Type::Enum v) const { return v == Type::IfcLampType || IfcFlowTerminalType::is(v); }
Type::Enum IfcLampType::type() const { return Type::IfcLampType; }
Type::Enum IfcLampType::Class() { return Type::IfcLampType; }
IfcLampType::IfcLampType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLampType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLampType::IfcLampType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcLampTypeEnum::IfcLampTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcLampTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLibraryInformation
IfcLabel IfcLibraryInformation::Name() { return *entity->getArgument(0); }
void IfcLibraryInformation::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcLibraryInformation::hasVersion() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcLibraryInformation::Version() { return *entity->getArgument(1); }
void IfcLibraryInformation::setVersion(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcLibraryInformation::hasPublisher() { return !entity->getArgument(2)->isNull(); }
IfcActorSelect IfcLibraryInformation::Publisher() { return *entity->getArgument(2); }
void IfcLibraryInformation::setPublisher(IfcActorSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcLibraryInformation::hasVersionDate() { return !entity->getArgument(3)->isNull(); }
IfcDateTime IfcLibraryInformation::VersionDate() { return *entity->getArgument(3); }
void IfcLibraryInformation::setVersionDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcLibraryInformation::hasLocation() { return !entity->getArgument(4)->isNull(); }
IfcURIReference IfcLibraryInformation::Location() { return *entity->getArgument(4); }
void IfcLibraryInformation::setLocation(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcLibraryInformation::hasDescription() { return !entity->getArgument(5)->isNull(); }
IfcText IfcLibraryInformation::Description() { return *entity->getArgument(5); }
void IfcLibraryInformation::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcRelAssociatesLibrary::list IfcLibraryInformation::LibraryInfoForObjects() { RETURN_INVERSE(IfcRelAssociatesLibrary) }
IfcLibraryReference::list IfcLibraryInformation::HasLibraryReferences() { RETURN_INVERSE(IfcLibraryReference) }
bool IfcLibraryInformation::is(Type::Enum v) const { return v == Type::IfcLibraryInformation || IfcExternalInformation::is(v); }
Type::Enum IfcLibraryInformation::type() const { return Type::IfcLibraryInformation; }
Type::Enum IfcLibraryInformation::Class() { return Type::IfcLibraryInformation; }
IfcLibraryInformation::IfcLibraryInformation(IfcAbstractEntityPtr e) : IfcExternalInformation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLibraryInformation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLibraryInformation::IfcLibraryInformation(IfcLabel v1_Name, boost::optional< IfcLabel > v2_Version, boost::optional< IfcActorSelect > v3_Publisher, boost::optional< IfcDateTime > v4_VersionDate, boost::optional< IfcURIReference > v5_Location, boost::optional< IfcText > v6_Description) : IfcExternalInformation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Version) { e->setArgument(1,(*v2_Version)); } else { e->setArgument(1); } if (v3_Publisher) { e->setArgument(2,(*v3_Publisher)); } else { e->setArgument(2); } if (v4_VersionDate) { e->setArgument(3,(*v4_VersionDate)); } else { e->setArgument(3); } if (v5_Location) { e->setArgument(4,(*v5_Location)); } else { e->setArgument(4); } if (v6_Description) { e->setArgument(5,(*v6_Description)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLibraryReference
bool IfcLibraryReference::hasDescription() { return !entity->getArgument(3)->isNull(); }
IfcText IfcLibraryReference::Description() { return *entity->getArgument(3); }
void IfcLibraryReference::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcLibraryReference::hasLanguage() { return !entity->getArgument(4)->isNull(); }
IfcLanguageId IfcLibraryReference::Language() { return *entity->getArgument(4); }
void IfcLibraryReference::setLanguage(IfcLanguageId v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcLibraryReference::hasReferencedLibrary() { return !entity->getArgument(5)->isNull(); }
IfcLibraryInformation* IfcLibraryReference::ReferencedLibrary() { return (IfcLibraryInformation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcLibraryReference::setReferencedLibrary(IfcLibraryInformation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcRelAssociatesLibrary::list IfcLibraryReference::LibraryRefForObjects() { RETURN_INVERSE(IfcRelAssociatesLibrary) }
bool IfcLibraryReference::is(Type::Enum v) const { return v == Type::IfcLibraryReference || IfcExternalReference::is(v); }
Type::Enum IfcLibraryReference::type() const { return Type::IfcLibraryReference; }
Type::Enum IfcLibraryReference::Class() { return Type::IfcLibraryReference; }
IfcLibraryReference::IfcLibraryReference(IfcAbstractEntityPtr e) : IfcExternalReference((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLibraryReference)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLibraryReference::IfcLibraryReference(boost::optional< IfcURIReference > v1_Location, boost::optional< IfcIdentifier > v2_Identification, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLanguageId > v5_Language, IfcLibraryInformation* v6_ReferencedLibrary) : IfcExternalReference((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Location) { e->setArgument(0,(*v1_Location)); } else { e->setArgument(0); } if (v2_Identification) { e->setArgument(1,(*v2_Identification)); } else { e->setArgument(1); } if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_Language) { e->setArgument(4,(*v5_Language)); } else { e->setArgument(4); } e->setArgument(5,(v6_ReferencedLibrary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightDistributionData
IfcPlaneAngleMeasure IfcLightDistributionData::MainPlaneAngle() { return *entity->getArgument(0); }
void IfcLightDistributionData::setMainPlaneAngle(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
std::vector< IfcPlaneAngleMeasure > /*[1:?]*/ IfcLightDistributionData::SecondaryPlaneAngle() { return *entity->getArgument(1); }
void IfcLightDistributionData::setSecondaryPlaneAngle(std::vector< IfcPlaneAngleMeasure > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
std::vector< IfcLuminousIntensityDistributionMeasure > /*[1:?]*/ IfcLightDistributionData::LuminousIntensity() { return *entity->getArgument(2); }
void IfcLightDistributionData::setLuminousIntensity(std::vector< IfcLuminousIntensityDistributionMeasure > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcLightDistributionData::is(Type::Enum v) const { return v == Type::IfcLightDistributionData; }
Type::Enum IfcLightDistributionData::type() const { return Type::IfcLightDistributionData; }
Type::Enum IfcLightDistributionData::Class() { return Type::IfcLightDistributionData; }
IfcLightDistributionData::IfcLightDistributionData(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcLightDistributionData)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightDistributionData::IfcLightDistributionData(IfcPlaneAngleMeasure v1_MainPlaneAngle, std::vector< IfcPlaneAngleMeasure > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< IfcLuminousIntensityDistributionMeasure > /*[1:?]*/ v3_LuminousIntensity) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MainPlaneAngle)); e->setArgument(1,(v2_SecondaryPlaneAngle)); e->setArgument(2,(v3_LuminousIntensity)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightFixture
bool IfcLightFixture::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixture::PredefinedType() { return IfcLightFixtureTypeEnum::FromString(*entity->getArgument(8)); }
void IfcLightFixture::setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcLightFixtureTypeEnum::ToString(v)); }
bool IfcLightFixture::is(Type::Enum v) const { return v == Type::IfcLightFixture || IfcFlowTerminal::is(v); }
Type::Enum IfcLightFixture::type() const { return Type::IfcLightFixture; }
Type::Enum IfcLightFixture::Class() { return Type::IfcLightFixture; }
IfcLightFixture::IfcLightFixture(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightFixture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightFixture::IfcLightFixture(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcLightFixtureTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightFixtureType
IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum IfcLightFixtureType::PredefinedType() { return IfcLightFixtureTypeEnum::FromString(*entity->getArgument(9)); }
void IfcLightFixtureType::setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcLightFixtureTypeEnum::ToString(v)); }
bool IfcLightFixtureType::is(Type::Enum v) const { return v == Type::IfcLightFixtureType || IfcFlowTerminalType::is(v); }
Type::Enum IfcLightFixtureType::type() const { return Type::IfcLightFixtureType; }
Type::Enum IfcLightFixtureType::Class() { return Type::IfcLightFixtureType; }
IfcLightFixtureType::IfcLightFixtureType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightFixtureType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightFixtureType::IfcLightFixtureType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcLightFixtureTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightIntensityDistribution
IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum IfcLightIntensityDistribution::LightDistributionCurve() { return IfcLightDistributionCurveEnum::FromString(*entity->getArgument(0)); }
void IfcLightIntensityDistribution::setLightDistributionCurve(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcLightDistributionCurveEnum::ToString(v)); }
SHARED_PTR< IfcTemplatedEntityList< IfcLightDistributionData > > IfcLightIntensityDistribution::DistributionData() { RETURN_AS_LIST(IfcLightDistributionData,1) }
void IfcLightIntensityDistribution::setDistributionData(SHARED_PTR< IfcTemplatedEntityList< IfcLightDistributionData > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcLightIntensityDistribution::is(Type::Enum v) const { return v == Type::IfcLightIntensityDistribution; }
Type::Enum IfcLightIntensityDistribution::type() const { return Type::IfcLightIntensityDistribution; }
Type::Enum IfcLightIntensityDistribution::Class() { return Type::IfcLightIntensityDistribution; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcLightIntensityDistribution)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightIntensityDistribution::IfcLightIntensityDistribution(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v1_LightDistributionCurve, SHARED_PTR< IfcTemplatedEntityList< IfcLightDistributionData > > v2_DistributionData) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_LightDistributionCurve,IfcLightDistributionCurveEnum::ToString(v1_LightDistributionCurve)); e->setArgument(1,(v2_DistributionData)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSource
bool IfcLightSource::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcLightSource::Name() { return *entity->getArgument(0); }
void IfcLightSource::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcColourRgb* IfcLightSource::LightColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcLightSource::setLightColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcLightSource::hasAmbientIntensity() { return !entity->getArgument(2)->isNull(); }
IfcNormalisedRatioMeasure IfcLightSource::AmbientIntensity() { return *entity->getArgument(2); }
void IfcLightSource::setAmbientIntensity(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcLightSource::hasIntensity() { return !entity->getArgument(3)->isNull(); }
IfcNormalisedRatioMeasure IfcLightSource::Intensity() { return *entity->getArgument(3); }
void IfcLightSource::setIntensity(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcLightSource::is(Type::Enum v) const { return v == Type::IfcLightSource || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcLightSource::type() const { return Type::IfcLightSource; }
Type::Enum IfcLightSource::Class() { return Type::IfcLightSource; }
IfcLightSource::IfcLightSource(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSource::IfcLightSource(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSourceAmbient
bool IfcLightSourceAmbient::is(Type::Enum v) const { return v == Type::IfcLightSourceAmbient || IfcLightSource::is(v); }
Type::Enum IfcLightSourceAmbient::type() const { return Type::IfcLightSourceAmbient; }
Type::Enum IfcLightSourceAmbient::Class() { return Type::IfcLightSourceAmbient; }
IfcLightSourceAmbient::IfcLightSourceAmbient(IfcAbstractEntityPtr e) : IfcLightSource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSourceAmbient)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceAmbient::IfcLightSourceAmbient(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity) : IfcLightSource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSourceDirectional
IfcDirection* IfcLightSourceDirectional::Orientation() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcLightSourceDirectional::setOrientation(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcLightSourceDirectional::is(Type::Enum v) const { return v == Type::IfcLightSourceDirectional || IfcLightSource::is(v); }
Type::Enum IfcLightSourceDirectional::type() const { return Type::IfcLightSourceDirectional; }
Type::Enum IfcLightSourceDirectional::Class() { return Type::IfcLightSourceDirectional; }
IfcLightSourceDirectional::IfcLightSourceDirectional(IfcAbstractEntityPtr e) : IfcLightSource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSourceDirectional)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceDirectional::IfcLightSourceDirectional(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity, IfcDirection* v5_Orientation) : IfcLightSource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } e->setArgument(4,(v5_Orientation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSourceGoniometric
IfcAxis2Placement3D* IfcLightSourceGoniometric::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcLightSourceGoniometric::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcLightSourceGoniometric::hasColourAppearance() { return !entity->getArgument(5)->isNull(); }
IfcColourRgb* IfcLightSourceGoniometric::ColourAppearance() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcLightSourceGoniometric::setColourAppearance(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcThermodynamicTemperatureMeasure IfcLightSourceGoniometric::ColourTemperature() { return *entity->getArgument(6); }
void IfcLightSourceGoniometric::setColourTemperature(IfcThermodynamicTemperatureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcLuminousFluxMeasure IfcLightSourceGoniometric::LuminousFlux() { return *entity->getArgument(7); }
void IfcLightSourceGoniometric::setLuminousFlux(IfcLuminousFluxMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum IfcLightSourceGoniometric::LightEmissionSource() { return IfcLightEmissionSourceEnum::FromString(*entity->getArgument(8)); }
void IfcLightSourceGoniometric::setLightEmissionSource(IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcLightEmissionSourceEnum::ToString(v)); }
IfcLightDistributionDataSourceSelect IfcLightSourceGoniometric::LightDistributionDataSource() { return *entity->getArgument(9); }
void IfcLightSourceGoniometric::setLightDistributionDataSource(IfcLightDistributionDataSourceSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcLightSourceGoniometric::is(Type::Enum v) const { return v == Type::IfcLightSourceGoniometric || IfcLightSource::is(v); }
Type::Enum IfcLightSourceGoniometric::type() const { return Type::IfcLightSourceGoniometric; }
Type::Enum IfcLightSourceGoniometric::Class() { return Type::IfcLightSourceGoniometric; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(IfcAbstractEntityPtr e) : IfcLightSource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSourceGoniometric)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceGoniometric::IfcLightSourceGoniometric(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity, IfcAxis2Placement3D* v5_Position, IfcColourRgb* v6_ColourAppearance, IfcThermodynamicTemperatureMeasure v7_ColourTemperature, IfcLuminousFluxMeasure v8_LuminousFlux, IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v9_LightEmissionSource, IfcLightDistributionDataSourceSelect v10_LightDistributionDataSource) : IfcLightSource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } e->setArgument(4,(v5_Position)); e->setArgument(5,(v6_ColourAppearance)); e->setArgument(6,(v7_ColourTemperature)); e->setArgument(7,(v8_LuminousFlux)); e->setArgument(8,v9_LightEmissionSource,IfcLightEmissionSourceEnum::ToString(v9_LightEmissionSource)); e->setArgument(9,(v10_LightDistributionDataSource)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSourcePositional
IfcCartesianPoint* IfcLightSourcePositional::Position() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcLightSourcePositional::setPosition(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcLightSourcePositional::Radius() { return *entity->getArgument(5); }
void IfcLightSourcePositional::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcReal IfcLightSourcePositional::ConstantAttenuation() { return *entity->getArgument(6); }
void IfcLightSourcePositional::setConstantAttenuation(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcReal IfcLightSourcePositional::DistanceAttenuation() { return *entity->getArgument(7); }
void IfcLightSourcePositional::setDistanceAttenuation(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcReal IfcLightSourcePositional::QuadricAttenuation() { return *entity->getArgument(8); }
void IfcLightSourcePositional::setQuadricAttenuation(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcLightSourcePositional::is(Type::Enum v) const { return v == Type::IfcLightSourcePositional || IfcLightSource::is(v); }
Type::Enum IfcLightSourcePositional::type() const { return Type::IfcLightSourcePositional; }
Type::Enum IfcLightSourcePositional::Class() { return Type::IfcLightSourcePositional; }
IfcLightSourcePositional::IfcLightSourcePositional(IfcAbstractEntityPtr e) : IfcLightSource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSourcePositional)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourcePositional::IfcLightSourcePositional(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity, IfcCartesianPoint* v5_Position, IfcPositiveLengthMeasure v6_Radius, IfcReal v7_ConstantAttenuation, IfcReal v8_DistanceAttenuation, IfcReal v9_QuadricAttenuation) : IfcLightSource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } e->setArgument(4,(v5_Position)); e->setArgument(5,(v6_Radius)); e->setArgument(6,(v7_ConstantAttenuation)); e->setArgument(7,(v8_DistanceAttenuation)); e->setArgument(8,(v9_QuadricAttenuation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLightSourceSpot
IfcDirection* IfcLightSourceSpot::Orientation() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcLightSourceSpot::setOrientation(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcLightSourceSpot::hasConcentrationExponent() { return !entity->getArgument(10)->isNull(); }
IfcReal IfcLightSourceSpot::ConcentrationExponent() { return *entity->getArgument(10); }
void IfcLightSourceSpot::setConcentrationExponent(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
IfcPositivePlaneAngleMeasure IfcLightSourceSpot::SpreadAngle() { return *entity->getArgument(11); }
void IfcLightSourceSpot::setSpreadAngle(IfcPositivePlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
IfcPositivePlaneAngleMeasure IfcLightSourceSpot::BeamWidthAngle() { return *entity->getArgument(12); }
void IfcLightSourceSpot::setBeamWidthAngle(IfcPositivePlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcLightSourceSpot::is(Type::Enum v) const { return v == Type::IfcLightSourceSpot || IfcLightSourcePositional::is(v); }
Type::Enum IfcLightSourceSpot::type() const { return Type::IfcLightSourceSpot; }
Type::Enum IfcLightSourceSpot::Class() { return Type::IfcLightSourceSpot; }
IfcLightSourceSpot::IfcLightSourceSpot(IfcAbstractEntityPtr e) : IfcLightSourcePositional((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLightSourceSpot)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLightSourceSpot::IfcLightSourceSpot(boost::optional< IfcLabel > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< IfcNormalisedRatioMeasure > v3_AmbientIntensity, boost::optional< IfcNormalisedRatioMeasure > v4_Intensity, IfcCartesianPoint* v5_Position, IfcPositiveLengthMeasure v6_Radius, IfcReal v7_ConstantAttenuation, IfcReal v8_DistanceAttenuation, IfcReal v9_QuadricAttenuation, IfcDirection* v10_Orientation, boost::optional< IfcReal > v11_ConcentrationExponent, IfcPositivePlaneAngleMeasure v12_SpreadAngle, IfcPositivePlaneAngleMeasure v13_BeamWidthAngle) : IfcLightSourcePositional((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_LightColour)); if (v3_AmbientIntensity) { e->setArgument(2,(*v3_AmbientIntensity)); } else { e->setArgument(2); } if (v4_Intensity) { e->setArgument(3,(*v4_Intensity)); } else { e->setArgument(3); } e->setArgument(4,(v5_Position)); e->setArgument(5,(v6_Radius)); e->setArgument(6,(v7_ConstantAttenuation)); e->setArgument(7,(v8_DistanceAttenuation)); e->setArgument(8,(v9_QuadricAttenuation)); e->setArgument(9,(v10_Orientation)); if (v11_ConcentrationExponent) { e->setArgument(10,(*v11_ConcentrationExponent)); } else { e->setArgument(10); } e->setArgument(11,(v12_SpreadAngle)); e->setArgument(12,(v13_BeamWidthAngle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLine
IfcCartesianPoint* IfcLine::Pnt() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcLine::setPnt(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcVector* IfcLine::Dir() { return (IfcVector*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcLine::setDir(IfcVector* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcLine::is(Type::Enum v) const { return v == Type::IfcLine || IfcCurve::is(v); }
Type::Enum IfcLine::type() const { return Type::IfcLine; }
Type::Enum IfcLine::Class() { return Type::IfcLine; }
IfcLine::IfcLine(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLine)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLine::IfcLine(IfcCartesianPoint* v1_Pnt, IfcVector* v2_Dir) : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Pnt)); e->setArgument(1,(v2_Dir)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLocalPlacement
bool IfcLocalPlacement::hasPlacementRelTo() { return !entity->getArgument(0)->isNull(); }
IfcObjectPlacement* IfcLocalPlacement::PlacementRelTo() { return (IfcObjectPlacement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcLocalPlacement::setPlacementRelTo(IfcObjectPlacement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcAxis2Placement IfcLocalPlacement::RelativePlacement() { return *entity->getArgument(1); }
void IfcLocalPlacement::setRelativePlacement(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcLocalPlacement::is(Type::Enum v) const { return v == Type::IfcLocalPlacement || IfcObjectPlacement::is(v); }
Type::Enum IfcLocalPlacement::type() const { return Type::IfcLocalPlacement; }
Type::Enum IfcLocalPlacement::Class() { return Type::IfcLocalPlacement; }
IfcLocalPlacement::IfcLocalPlacement(IfcAbstractEntityPtr e) : IfcObjectPlacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLocalPlacement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLocalPlacement::IfcLocalPlacement(IfcObjectPlacement* v1_PlacementRelTo, IfcAxis2Placement v2_RelativePlacement) : IfcObjectPlacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_PlacementRelTo)); e->setArgument(1,(v2_RelativePlacement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcLoop
bool IfcLoop::is(Type::Enum v) const { return v == Type::IfcLoop || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcLoop::type() const { return Type::IfcLoop; }
Type::Enum IfcLoop::Class() { return Type::IfcLoop; }
IfcLoop::IfcLoop(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcLoop)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcLoop::IfcLoop() : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcManifoldSolidBrep
IfcClosedShell* IfcManifoldSolidBrep::Outer() { return (IfcClosedShell*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcManifoldSolidBrep::setOuter(IfcClosedShell* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcManifoldSolidBrep::is(Type::Enum v) const { return v == Type::IfcManifoldSolidBrep || IfcSolidModel::is(v); }
Type::Enum IfcManifoldSolidBrep::type() const { return Type::IfcManifoldSolidBrep; }
Type::Enum IfcManifoldSolidBrep::Class() { return Type::IfcManifoldSolidBrep; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcAbstractEntityPtr e) : IfcSolidModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcManifoldSolidBrep)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcManifoldSolidBrep::IfcManifoldSolidBrep(IfcClosedShell* v1_Outer) : IfcSolidModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Outer)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMapConversion
IfcLengthMeasure IfcMapConversion::Eastings() { return *entity->getArgument(2); }
void IfcMapConversion::setEastings(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcLengthMeasure IfcMapConversion::Northings() { return *entity->getArgument(3); }
void IfcMapConversion::setNorthings(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcLengthMeasure IfcMapConversion::OrthogonalHeight() { return *entity->getArgument(4); }
void IfcMapConversion::setOrthogonalHeight(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMapConversion::hasXAxisAbscissa() { return !entity->getArgument(5)->isNull(); }
IfcReal IfcMapConversion::XAxisAbscissa() { return *entity->getArgument(5); }
void IfcMapConversion::setXAxisAbscissa(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcMapConversion::hasXAxisOrdinate() { return !entity->getArgument(6)->isNull(); }
IfcReal IfcMapConversion::XAxisOrdinate() { return *entity->getArgument(6); }
void IfcMapConversion::setXAxisOrdinate(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcMapConversion::hasScale() { return !entity->getArgument(7)->isNull(); }
IfcReal IfcMapConversion::Scale() { return *entity->getArgument(7); }
void IfcMapConversion::setScale(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcMapConversion::is(Type::Enum v) const { return v == Type::IfcMapConversion || IfcCoordinateOperation::is(v); }
Type::Enum IfcMapConversion::type() const { return Type::IfcMapConversion; }
Type::Enum IfcMapConversion::Class() { return Type::IfcMapConversion; }
IfcMapConversion::IfcMapConversion(IfcAbstractEntityPtr e) : IfcCoordinateOperation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMapConversion)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMapConversion::IfcMapConversion(IfcCoordinateReferenceSystemSelect v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS, IfcLengthMeasure v3_Eastings, IfcLengthMeasure v4_Northings, IfcLengthMeasure v5_OrthogonalHeight, boost::optional< IfcReal > v6_XAxisAbscissa, boost::optional< IfcReal > v7_XAxisOrdinate, boost::optional< IfcReal > v8_Scale) : IfcCoordinateOperation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SourceCRS)); e->setArgument(1,(v2_TargetCRS)); e->setArgument(2,(v3_Eastings)); e->setArgument(3,(v4_Northings)); e->setArgument(4,(v5_OrthogonalHeight)); if (v6_XAxisAbscissa) { e->setArgument(5,(*v6_XAxisAbscissa)); } else { e->setArgument(5); } if (v7_XAxisOrdinate) { e->setArgument(6,(*v7_XAxisOrdinate)); } else { e->setArgument(6); } if (v8_Scale) { e->setArgument(7,(*v8_Scale)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMappedItem
IfcRepresentationMap* IfcMappedItem::MappingSource() { return (IfcRepresentationMap*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcMappedItem::setMappingSource(IfcRepresentationMap* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCartesianTransformationOperator* IfcMappedItem::MappingTarget() { return (IfcCartesianTransformationOperator*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcMappedItem::setMappingTarget(IfcCartesianTransformationOperator* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMappedItem::is(Type::Enum v) const { return v == Type::IfcMappedItem || IfcRepresentationItem::is(v); }
Type::Enum IfcMappedItem::type() const { return Type::IfcMappedItem; }
Type::Enum IfcMappedItem::Class() { return Type::IfcMappedItem; }
IfcMappedItem::IfcMappedItem(IfcAbstractEntityPtr e) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMappedItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMappedItem::IfcMappedItem(IfcRepresentationMap* v1_MappingSource, IfcCartesianTransformationOperator* v2_MappingTarget) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MappingSource)); e->setArgument(1,(v2_MappingTarget)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterial
IfcLabel IfcMaterial::Name() { return *entity->getArgument(0); }
void IfcMaterial::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterial::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcMaterial::Description() { return *entity->getArgument(1); }
void IfcMaterial::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterial::hasCategory() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcMaterial::Category() { return *entity->getArgument(2); }
void IfcMaterial::setCategory(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcMaterialDefinitionRepresentation::list IfcMaterial::HasRepresentation() { RETURN_INVERSE(IfcMaterialDefinitionRepresentation) }
IfcMaterialRelationship::list IfcMaterial::IsRelatedWith() { RETURN_INVERSE(IfcMaterialRelationship) }
IfcMaterialRelationship::list IfcMaterial::RelatesTo() { RETURN_INVERSE(IfcMaterialRelationship) }
bool IfcMaterial::is(Type::Enum v) const { return v == Type::IfcMaterial || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterial::type() const { return Type::IfcMaterial; }
Type::Enum IfcMaterial::Class() { return Type::IfcMaterial; }
IfcMaterial::IfcMaterial(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterial)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterial::IfcMaterial(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcLabel > v3_Category) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_Category) { e->setArgument(2,(*v3_Category)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialClassificationRelationship
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcMaterialClassificationRelationship::MaterialClassifications() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcMaterialClassificationRelationship::setMaterialClassifications(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
IfcMaterial* IfcMaterialClassificationRelationship::ClassifiedMaterial() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcMaterialClassificationRelationship::setClassifiedMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialClassificationRelationship::is(Type::Enum v) const { return v == Type::IfcMaterialClassificationRelationship; }
Type::Enum IfcMaterialClassificationRelationship::type() const { return Type::IfcMaterialClassificationRelationship; }
Type::Enum IfcMaterialClassificationRelationship::Class() { return Type::IfcMaterialClassificationRelationship; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMaterialClassificationRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialClassificationRelationship::IfcMaterialClassificationRelationship(IfcEntities v1_MaterialClassifications, IfcMaterial* v2_ClassifiedMaterial) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MaterialClassifications)); e->setArgument(1,(v2_ClassifiedMaterial)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialConstituent
bool IfcMaterialConstituent::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcMaterialConstituent::Name() { return *entity->getArgument(0); }
void IfcMaterialConstituent::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterialConstituent::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcMaterialConstituent::Description() { return *entity->getArgument(1); }
void IfcMaterialConstituent::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcMaterial* IfcMaterialConstituent::Material() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcMaterialConstituent::setMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcMaterialConstituent::hasFraction() { return !entity->getArgument(3)->isNull(); }
IfcNormalisedRatioMeasure IfcMaterialConstituent::Fraction() { return *entity->getArgument(3); }
void IfcMaterialConstituent::setFraction(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialConstituent::hasCategory() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcMaterialConstituent::Category() { return *entity->getArgument(4); }
void IfcMaterialConstituent::setCategory(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcMaterialConstituentSet::list IfcMaterialConstituent::ToMaterialConstituentSet() { RETURN_INVERSE(IfcMaterialConstituentSet) }
bool IfcMaterialConstituent::is(Type::Enum v) const { return v == Type::IfcMaterialConstituent || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialConstituent::type() const { return Type::IfcMaterialConstituent; }
Type::Enum IfcMaterialConstituent::Class() { return Type::IfcMaterialConstituent; }
IfcMaterialConstituent::IfcMaterialConstituent(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialConstituent)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialConstituent::IfcMaterialConstituent(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcMaterial* v3_Material, boost::optional< IfcNormalisedRatioMeasure > v4_Fraction, boost::optional< IfcLabel > v5_Category) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Material)); if (v4_Fraction) { e->setArgument(3,(*v4_Fraction)); } else { e->setArgument(3); } if (v5_Category) { e->setArgument(4,(*v5_Category)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialConstituentSet
bool IfcMaterialConstituentSet::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcMaterialConstituentSet::Name() { return *entity->getArgument(0); }
void IfcMaterialConstituentSet::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterialConstituentSet::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcMaterialConstituentSet::Description() { return *entity->getArgument(1); }
void IfcMaterialConstituentSet::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialConstituentSet::hasMaterialConstituents() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcMaterialConstituent > > IfcMaterialConstituentSet::MaterialConstituents() { RETURN_AS_LIST(IfcMaterialConstituent,2) }
void IfcMaterialConstituentSet::setMaterialConstituents(SHARED_PTR< IfcTemplatedEntityList< IfcMaterialConstituent > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcMaterialConstituentSet::is(Type::Enum v) const { return v == Type::IfcMaterialConstituentSet || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialConstituentSet::type() const { return Type::IfcMaterialConstituentSet; }
Type::Enum IfcMaterialConstituentSet::Class() { return Type::IfcMaterialConstituentSet; }
IfcMaterialConstituentSet::IfcMaterialConstituentSet(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialConstituentSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialConstituentSet::IfcMaterialConstituentSet(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcMaterialConstituent > > > v3_MaterialConstituents) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_MaterialConstituents) { e->setArgument(2,(*v3_MaterialConstituents)->generalize()); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialDefinition
IfcRelAssociatesMaterial::list IfcMaterialDefinition::AssociatedTo() { RETURN_INVERSE(IfcRelAssociatesMaterial) }
IfcExternalReferenceRelationship::list IfcMaterialDefinition::HasExternalReferences() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
IfcMaterialProperties::list IfcMaterialDefinition::HasProperties() { RETURN_INVERSE(IfcMaterialProperties) }
bool IfcMaterialDefinition::is(Type::Enum v) const { return v == Type::IfcMaterialDefinition; }
Type::Enum IfcMaterialDefinition::type() const { return Type::IfcMaterialDefinition; }
Type::Enum IfcMaterialDefinition::Class() { return Type::IfcMaterialDefinition; }
IfcMaterialDefinition::IfcMaterialDefinition(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMaterialDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialDefinition::IfcMaterialDefinition() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialDefinitionRepresentation
IfcMaterial* IfcMaterialDefinitionRepresentation::RepresentedMaterial() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcMaterialDefinitionRepresentation::setRepresentedMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialDefinitionRepresentation::is(Type::Enum v) const { return v == Type::IfcMaterialDefinitionRepresentation || IfcProductRepresentation::is(v); }
Type::Enum IfcMaterialDefinitionRepresentation::type() const { return Type::IfcMaterialDefinitionRepresentation; }
Type::Enum IfcMaterialDefinitionRepresentation::Class() { return Type::IfcMaterialDefinitionRepresentation; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(IfcAbstractEntityPtr e) : IfcProductRepresentation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialDefinitionRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialDefinitionRepresentation::IfcMaterialDefinitionRepresentation(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentation > > v3_Representations, IfcMaterial* v4_RepresentedMaterial) : IfcProductRepresentation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Representations)->generalize()); e->setArgument(3,(v4_RepresentedMaterial)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialLayer
bool IfcMaterialLayer::hasMaterial() { return !entity->getArgument(0)->isNull(); }
IfcMaterial* IfcMaterialLayer::Material() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcMaterialLayer::setMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcNonNegativeLengthMeasure IfcMaterialLayer::LayerThickness() { return *entity->getArgument(1); }
void IfcMaterialLayer::setLayerThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialLayer::hasIsVentilated() { return !entity->getArgument(2)->isNull(); }
IfcLogical IfcMaterialLayer::IsVentilated() { return *entity->getArgument(2); }
void IfcMaterialLayer::setIsVentilated(IfcLogical v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcMaterialLayer::hasName() { return !entity->getArgument(3)->isNull(); }
IfcLabel IfcMaterialLayer::Name() { return *entity->getArgument(3); }
void IfcMaterialLayer::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialLayer::hasDescription() { return !entity->getArgument(4)->isNull(); }
IfcText IfcMaterialLayer::Description() { return *entity->getArgument(4); }
void IfcMaterialLayer::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMaterialLayer::hasCategory() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcMaterialLayer::Category() { return *entity->getArgument(5); }
void IfcMaterialLayer::setCategory(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcMaterialLayer::hasPriority() { return !entity->getArgument(6)->isNull(); }
IfcNormalisedRatioMeasure IfcMaterialLayer::Priority() { return *entity->getArgument(6); }
void IfcMaterialLayer::setPriority(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcMaterialLayerSet::list IfcMaterialLayer::ToMaterialLayerSet() { RETURN_INVERSE(IfcMaterialLayerSet) }
bool IfcMaterialLayer::is(Type::Enum v) const { return v == Type::IfcMaterialLayer || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialLayer::type() const { return Type::IfcMaterialLayer; }
Type::Enum IfcMaterialLayer::Class() { return Type::IfcMaterialLayer; }
IfcMaterialLayer::IfcMaterialLayer(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialLayer)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayer::IfcMaterialLayer(IfcMaterial* v1_Material, IfcNonNegativeLengthMeasure v2_LayerThickness, boost::optional< IfcLogical > v3_IsVentilated, boost::optional< IfcLabel > v4_Name, boost::optional< IfcText > v5_Description, boost::optional< IfcLabel > v6_Category, boost::optional< IfcNormalisedRatioMeasure > v7_Priority) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Material)); e->setArgument(1,(v2_LayerThickness)); if (v3_IsVentilated) { e->setArgument(2,(*v3_IsVentilated)); } else { e->setArgument(2); } if (v4_Name) { e->setArgument(3,(*v4_Name)); } else { e->setArgument(3); } if (v5_Description) { e->setArgument(4,(*v5_Description)); } else { e->setArgument(4); } if (v6_Category) { e->setArgument(5,(*v6_Category)); } else { e->setArgument(5); } if (v7_Priority) { e->setArgument(6,(*v7_Priority)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialLayerSet
SHARED_PTR< IfcTemplatedEntityList< IfcMaterialLayer > > IfcMaterialLayerSet::MaterialLayers() { RETURN_AS_LIST(IfcMaterialLayer,0) }
void IfcMaterialLayerSet::setMaterialLayers(SHARED_PTR< IfcTemplatedEntityList< IfcMaterialLayer > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcMaterialLayerSet::hasLayerSetName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcMaterialLayerSet::LayerSetName() { return *entity->getArgument(1); }
void IfcMaterialLayerSet::setLayerSetName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialLayerSet::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcMaterialLayerSet::Description() { return *entity->getArgument(2); }
void IfcMaterialLayerSet::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcMaterialLayerSet::is(Type::Enum v) const { return v == Type::IfcMaterialLayerSet || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialLayerSet::type() const { return Type::IfcMaterialLayerSet; }
Type::Enum IfcMaterialLayerSet::Class() { return Type::IfcMaterialLayerSet; }
IfcMaterialLayerSet::IfcMaterialLayerSet(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialLayerSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayerSet::IfcMaterialLayerSet(SHARED_PTR< IfcTemplatedEntityList< IfcMaterialLayer > > v1_MaterialLayers, boost::optional< IfcLabel > v2_LayerSetName, boost::optional< IfcText > v3_Description) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MaterialLayers)->generalize()); if (v2_LayerSetName) { e->setArgument(1,(*v2_LayerSetName)); } else { e->setArgument(1); } if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialLayerSetUsage
IfcMaterialLayerSet* IfcMaterialLayerSetUsage::ForLayerSet() { return (IfcMaterialLayerSet*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcMaterialLayerSetUsage::setForLayerSet(IfcMaterialLayerSet* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcMaterialLayerSetUsage::LayerSetDirection() { return IfcLayerSetDirectionEnum::FromString(*entity->getArgument(1)); }
void IfcMaterialLayerSetUsage::setLayerSetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v,IfcLayerSetDirectionEnum::ToString(v)); }
IfcDirectionSenseEnum::IfcDirectionSenseEnum IfcMaterialLayerSetUsage::DirectionSense() { return IfcDirectionSenseEnum::FromString(*entity->getArgument(2)); }
void IfcMaterialLayerSetUsage::setDirectionSense(IfcDirectionSenseEnum::IfcDirectionSenseEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcDirectionSenseEnum::ToString(v)); }
IfcLengthMeasure IfcMaterialLayerSetUsage::OffsetFromReferenceLine() { return *entity->getArgument(3); }
void IfcMaterialLayerSetUsage::setOffsetFromReferenceLine(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialLayerSetUsage::hasReferenceExtent() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcMaterialLayerSetUsage::ReferenceExtent() { return *entity->getArgument(4); }
void IfcMaterialLayerSetUsage::setReferenceExtent(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMaterialLayerSetUsage::is(Type::Enum v) const { return v == Type::IfcMaterialLayerSetUsage || IfcMaterialUsageDefinition::is(v); }
Type::Enum IfcMaterialLayerSetUsage::type() const { return Type::IfcMaterialLayerSetUsage; }
Type::Enum IfcMaterialLayerSetUsage::Class() { return Type::IfcMaterialLayerSetUsage; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcAbstractEntityPtr e) : IfcMaterialUsageDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialLayerSetUsage)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayerSetUsage::IfcMaterialLayerSetUsage(IfcMaterialLayerSet* v1_ForLayerSet, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v2_LayerSetDirection, IfcDirectionSenseEnum::IfcDirectionSenseEnum v3_DirectionSense, IfcLengthMeasure v4_OffsetFromReferenceLine, boost::optional< IfcPositiveLengthMeasure > v5_ReferenceExtent) : IfcMaterialUsageDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ForLayerSet)); e->setArgument(1,v2_LayerSetDirection,IfcLayerSetDirectionEnum::ToString(v2_LayerSetDirection)); e->setArgument(2,v3_DirectionSense,IfcDirectionSenseEnum::ToString(v3_DirectionSense)); e->setArgument(3,(v4_OffsetFromReferenceLine)); if (v5_ReferenceExtent) { e->setArgument(4,(*v5_ReferenceExtent)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialLayerWithOffsets
IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum IfcMaterialLayerWithOffsets::OffsetDirection() { return IfcLayerSetDirectionEnum::FromString(*entity->getArgument(7)); }
void IfcMaterialLayerWithOffsets::setOffsetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcLayerSetDirectionEnum::ToString(v)); }
std::vector< IfcLengthMeasure > /*[1:2]*/ IfcMaterialLayerWithOffsets::OffsetValues() { return *entity->getArgument(8); }
void IfcMaterialLayerWithOffsets::setOffsetValues(std::vector< IfcLengthMeasure > /*[1:2]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcMaterialLayerWithOffsets::is(Type::Enum v) const { return v == Type::IfcMaterialLayerWithOffsets || IfcMaterialLayer::is(v); }
Type::Enum IfcMaterialLayerWithOffsets::type() const { return Type::IfcMaterialLayerWithOffsets; }
Type::Enum IfcMaterialLayerWithOffsets::Class() { return Type::IfcMaterialLayerWithOffsets; }
IfcMaterialLayerWithOffsets::IfcMaterialLayerWithOffsets(IfcAbstractEntityPtr e) : IfcMaterialLayer((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialLayerWithOffsets)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialLayerWithOffsets::IfcMaterialLayerWithOffsets(IfcMaterial* v1_Material, IfcNonNegativeLengthMeasure v2_LayerThickness, boost::optional< IfcLogical > v3_IsVentilated, boost::optional< IfcLabel > v4_Name, boost::optional< IfcText > v5_Description, boost::optional< IfcLabel > v6_Category, boost::optional< IfcNormalisedRatioMeasure > v7_Priority, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v8_OffsetDirection, std::vector< IfcLengthMeasure > /*[1:2]*/ v9_OffsetValues) : IfcMaterialLayer((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Material)); e->setArgument(1,(v2_LayerThickness)); if (v3_IsVentilated) { e->setArgument(2,(*v3_IsVentilated)); } else { e->setArgument(2); } if (v4_Name) { e->setArgument(3,(*v4_Name)); } else { e->setArgument(3); } if (v5_Description) { e->setArgument(4,(*v5_Description)); } else { e->setArgument(4); } if (v6_Category) { e->setArgument(5,(*v6_Category)); } else { e->setArgument(5); } if (v7_Priority) { e->setArgument(6,(*v7_Priority)); } else { e->setArgument(6); } e->setArgument(7,v8_OffsetDirection,IfcLayerSetDirectionEnum::ToString(v8_OffsetDirection)); e->setArgument(8,(v9_OffsetValues)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialList
SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > IfcMaterialList::Materials() { RETURN_AS_LIST(IfcMaterial,0) }
void IfcMaterialList::setMaterials(SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcMaterialList::is(Type::Enum v) const { return v == Type::IfcMaterialList; }
Type::Enum IfcMaterialList::type() const { return Type::IfcMaterialList; }
Type::Enum IfcMaterialList::Class() { return Type::IfcMaterialList; }
IfcMaterialList::IfcMaterialList(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMaterialList)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialList::IfcMaterialList(SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > v1_Materials) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Materials)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProfile
bool IfcMaterialProfile::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcMaterialProfile::Name() { return *entity->getArgument(0); }
void IfcMaterialProfile::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterialProfile::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcMaterialProfile::Description() { return *entity->getArgument(1); }
void IfcMaterialProfile::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialProfile::hasMaterial() { return !entity->getArgument(2)->isNull(); }
IfcMaterial* IfcMaterialProfile::Material() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcMaterialProfile::setMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcProfileDef* IfcMaterialProfile::Profile() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcMaterialProfile::setProfile(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialProfile::hasPriority() { return !entity->getArgument(4)->isNull(); }
IfcNormalisedRatioMeasure IfcMaterialProfile::Priority() { return *entity->getArgument(4); }
void IfcMaterialProfile::setPriority(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMaterialProfile::hasCategory() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcMaterialProfile::Category() { return *entity->getArgument(5); }
void IfcMaterialProfile::setCategory(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcMaterialProfileSet::list IfcMaterialProfile::ToMaterialProfileSet() { RETURN_INVERSE(IfcMaterialProfileSet) }
bool IfcMaterialProfile::is(Type::Enum v) const { return v == Type::IfcMaterialProfile || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialProfile::type() const { return Type::IfcMaterialProfile; }
Type::Enum IfcMaterialProfile::Class() { return Type::IfcMaterialProfile; }
IfcMaterialProfile::IfcMaterialProfile(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProfile)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProfile::IfcMaterialProfile(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< IfcNormalisedRatioMeasure > v5_Priority, boost::optional< IfcLabel > v6_Category) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Material)); e->setArgument(3,(v4_Profile)); if (v5_Priority) { e->setArgument(4,(*v5_Priority)); } else { e->setArgument(4); } if (v6_Category) { e->setArgument(5,(*v6_Category)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProfileSet
bool IfcMaterialProfileSet::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcMaterialProfileSet::Name() { return *entity->getArgument(0); }
void IfcMaterialProfileSet::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterialProfileSet::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcMaterialProfileSet::Description() { return *entity->getArgument(1); }
void IfcMaterialProfileSet::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcMaterialProfile > > IfcMaterialProfileSet::MaterialProfiles() { RETURN_AS_LIST(IfcMaterialProfile,2) }
void IfcMaterialProfileSet::setMaterialProfiles(SHARED_PTR< IfcTemplatedEntityList< IfcMaterialProfile > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcMaterialProfileSet::hasCompositeProfile() { return !entity->getArgument(3)->isNull(); }
IfcCompositeProfileDef* IfcMaterialProfileSet::CompositeProfile() { return (IfcCompositeProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcMaterialProfileSet::setCompositeProfile(IfcCompositeProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialProfileSet::is(Type::Enum v) const { return v == Type::IfcMaterialProfileSet || IfcMaterialDefinition::is(v); }
Type::Enum IfcMaterialProfileSet::type() const { return Type::IfcMaterialProfileSet; }
Type::Enum IfcMaterialProfileSet::Class() { return Type::IfcMaterialProfileSet; }
IfcMaterialProfileSet::IfcMaterialProfileSet(IfcAbstractEntityPtr e) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProfileSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProfileSet::IfcMaterialProfileSet(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcMaterialProfile > > v3_MaterialProfiles, IfcCompositeProfileDef* v4_CompositeProfile) : IfcMaterialDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_MaterialProfiles)->generalize()); e->setArgument(3,(v4_CompositeProfile)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProfileSetUsage
IfcMaterialProfileSet* IfcMaterialProfileSetUsage::ForProfileSet() { return (IfcMaterialProfileSet*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcMaterialProfileSetUsage::setForProfileSet(IfcMaterialProfileSet* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMaterialProfileSetUsage::hasCardinalPoint() { return !entity->getArgument(1)->isNull(); }
IfcCardinalPointReference IfcMaterialProfileSetUsage::CardinalPoint() { return *entity->getArgument(1); }
void IfcMaterialProfileSetUsage::setCardinalPoint(IfcCardinalPointReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMaterialProfileSetUsage::hasReferenceExtent() { return !entity->getArgument(2)->isNull(); }
IfcPositiveLengthMeasure IfcMaterialProfileSetUsage::ReferenceExtent() { return *entity->getArgument(2); }
void IfcMaterialProfileSetUsage::setReferenceExtent(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcMaterialProfileSetUsage::is(Type::Enum v) const { return v == Type::IfcMaterialProfileSetUsage || IfcMaterialUsageDefinition::is(v); }
Type::Enum IfcMaterialProfileSetUsage::type() const { return Type::IfcMaterialProfileSetUsage; }
Type::Enum IfcMaterialProfileSetUsage::Class() { return Type::IfcMaterialProfileSetUsage; }
IfcMaterialProfileSetUsage::IfcMaterialProfileSetUsage(IfcAbstractEntityPtr e) : IfcMaterialUsageDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProfileSetUsage)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProfileSetUsage::IfcMaterialProfileSetUsage(IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< IfcCardinalPointReference > v2_CardinalPoint, boost::optional< IfcPositiveLengthMeasure > v3_ReferenceExtent) : IfcMaterialUsageDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ForProfileSet)); if (v2_CardinalPoint) { e->setArgument(1,(*v2_CardinalPoint)); } else { e->setArgument(1); } if (v3_ReferenceExtent) { e->setArgument(2,(*v3_ReferenceExtent)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProfileSetUsageTapering
IfcMaterialProfileSet* IfcMaterialProfileSetUsageTapering::ForProfileEndSet() { return (IfcMaterialProfileSet*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcMaterialProfileSetUsageTapering::setForProfileEndSet(IfcMaterialProfileSet* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialProfileSetUsageTapering::hasCardinalEndPoint() { return !entity->getArgument(4)->isNull(); }
IfcCardinalPointReference IfcMaterialProfileSetUsageTapering::CardinalEndPoint() { return *entity->getArgument(4); }
void IfcMaterialProfileSetUsageTapering::setCardinalEndPoint(IfcCardinalPointReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMaterialProfileSetUsageTapering::is(Type::Enum v) const { return v == Type::IfcMaterialProfileSetUsageTapering || IfcMaterialProfileSetUsage::is(v); }
Type::Enum IfcMaterialProfileSetUsageTapering::type() const { return Type::IfcMaterialProfileSetUsageTapering; }
Type::Enum IfcMaterialProfileSetUsageTapering::Class() { return Type::IfcMaterialProfileSetUsageTapering; }
IfcMaterialProfileSetUsageTapering::IfcMaterialProfileSetUsageTapering(IfcAbstractEntityPtr e) : IfcMaterialProfileSetUsage((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProfileSetUsageTapering)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProfileSetUsageTapering::IfcMaterialProfileSetUsageTapering(IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< IfcCardinalPointReference > v2_CardinalPoint, boost::optional< IfcPositiveLengthMeasure > v3_ReferenceExtent, IfcMaterialProfileSet* v4_ForProfileEndSet, boost::optional< IfcCardinalPointReference > v5_CardinalEndPoint) : IfcMaterialProfileSetUsage((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ForProfileSet)); if (v2_CardinalPoint) { e->setArgument(1,(*v2_CardinalPoint)); } else { e->setArgument(1); } if (v3_ReferenceExtent) { e->setArgument(2,(*v3_ReferenceExtent)); } else { e->setArgument(2); } e->setArgument(3,(v4_ForProfileEndSet)); if (v5_CardinalEndPoint) { e->setArgument(4,(*v5_CardinalEndPoint)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProfileWithOffsets
std::vector< IfcLengthMeasure > /*[1:2]*/ IfcMaterialProfileWithOffsets::OffsetValues() { return *entity->getArgument(6); }
void IfcMaterialProfileWithOffsets::setOffsetValues(std::vector< IfcLengthMeasure > /*[1:2]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcMaterialProfileWithOffsets::is(Type::Enum v) const { return v == Type::IfcMaterialProfileWithOffsets || IfcMaterialProfile::is(v); }
Type::Enum IfcMaterialProfileWithOffsets::type() const { return Type::IfcMaterialProfileWithOffsets; }
Type::Enum IfcMaterialProfileWithOffsets::Class() { return Type::IfcMaterialProfileWithOffsets; }
IfcMaterialProfileWithOffsets::IfcMaterialProfileWithOffsets(IfcAbstractEntityPtr e) : IfcMaterialProfile((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProfileWithOffsets)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProfileWithOffsets::IfcMaterialProfileWithOffsets(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< IfcNormalisedRatioMeasure > v5_Priority, boost::optional< IfcLabel > v6_Category, std::vector< IfcLengthMeasure > /*[1:2]*/ v7_OffsetValues) : IfcMaterialProfile((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Material)); e->setArgument(3,(v4_Profile)); if (v5_Priority) { e->setArgument(4,(*v5_Priority)); } else { e->setArgument(4); } if (v6_Category) { e->setArgument(5,(*v6_Category)); } else { e->setArgument(5); } e->setArgument(6,(v7_OffsetValues)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialProperties
IfcMaterialDefinition* IfcMaterialProperties::Material() { return (IfcMaterialDefinition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcMaterialProperties::setMaterial(IfcMaterialDefinition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcMaterialProperties::is(Type::Enum v) const { return v == Type::IfcMaterialProperties || IfcExtendedProperties::is(v); }
Type::Enum IfcMaterialProperties::type() const { return Type::IfcMaterialProperties; }
Type::Enum IfcMaterialProperties::Class() { return Type::IfcMaterialProperties; }
IfcMaterialProperties::IfcMaterialProperties(IfcAbstractEntityPtr e) : IfcExtendedProperties((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialProperties::IfcMaterialProperties(boost::optional< IfcIdentifier > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v3_Properties, IfcMaterialDefinition* v4_Material) : IfcExtendedProperties((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Properties)->generalize()); e->setArgument(3,(v4_Material)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialRelationship
IfcMaterial* IfcMaterialRelationship::RelatingMaterial() { return (IfcMaterial*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcMaterialRelationship::setRelatingMaterial(IfcMaterial* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > IfcMaterialRelationship::RelatedMaterials() { RETURN_AS_LIST(IfcMaterial,3) }
void IfcMaterialRelationship::setRelatedMaterials(SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcMaterialRelationship::hasExpression() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcMaterialRelationship::Expression() { return *entity->getArgument(4); }
void IfcMaterialRelationship::setExpression(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcMaterialRelationship::is(Type::Enum v) const { return v == Type::IfcMaterialRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcMaterialRelationship::type() const { return Type::IfcMaterialRelationship; }
Type::Enum IfcMaterialRelationship::Class() { return Type::IfcMaterialRelationship; }
IfcMaterialRelationship::IfcMaterialRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMaterialRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialRelationship::IfcMaterialRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcMaterial* v3_RelatingMaterial, SHARED_PTR< IfcTemplatedEntityList< IfcMaterial > > v4_RelatedMaterials, boost::optional< IfcLabel > v5_Expression) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingMaterial)); e->setArgument(3,(v4_RelatedMaterials)->generalize()); if (v5_Expression) { e->setArgument(4,(*v5_Expression)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMaterialUsageDefinition
IfcRelAssociatesMaterial::list IfcMaterialUsageDefinition::AssociatedTo() { RETURN_INVERSE(IfcRelAssociatesMaterial) }
bool IfcMaterialUsageDefinition::is(Type::Enum v) const { return v == Type::IfcMaterialUsageDefinition; }
Type::Enum IfcMaterialUsageDefinition::type() const { return Type::IfcMaterialUsageDefinition; }
Type::Enum IfcMaterialUsageDefinition::Class() { return Type::IfcMaterialUsageDefinition; }
IfcMaterialUsageDefinition::IfcMaterialUsageDefinition(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMaterialUsageDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMaterialUsageDefinition::IfcMaterialUsageDefinition() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMeasureWithUnit
IfcValue IfcMeasureWithUnit::ValueComponent() { return *entity->getArgument(0); }
void IfcMeasureWithUnit::setValueComponent(IfcValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcUnit IfcMeasureWithUnit::UnitComponent() { return *entity->getArgument(1); }
void IfcMeasureWithUnit::setUnitComponent(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcMeasureWithUnit::is(Type::Enum v) const { return v == Type::IfcMeasureWithUnit; }
Type::Enum IfcMeasureWithUnit::type() const { return Type::IfcMeasureWithUnit; }
Type::Enum IfcMeasureWithUnit::Class() { return Type::IfcMeasureWithUnit; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMeasureWithUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMeasureWithUnit::IfcMeasureWithUnit(IfcValue v1_ValueComponent, IfcUnit v2_UnitComponent) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ValueComponent)); e->setArgument(1,(v2_UnitComponent)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMechanicalFastener
bool IfcMechanicalFastener::hasNominalDiameter() { return !entity->getArgument(8)->isNull(); }
IfcPositiveLengthMeasure IfcMechanicalFastener::NominalDiameter() { return *entity->getArgument(8); }
void IfcMechanicalFastener::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcMechanicalFastener::hasNominalLength() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcMechanicalFastener::NominalLength() { return *entity->getArgument(9); }
void IfcMechanicalFastener::setNominalLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcMechanicalFastener::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastener::PredefinedType() { return IfcMechanicalFastenerTypeEnum::FromString(*entity->getArgument(10)); }
void IfcMechanicalFastener::setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcMechanicalFastenerTypeEnum::ToString(v)); }
bool IfcMechanicalFastener::is(Type::Enum v) const { return v == Type::IfcMechanicalFastener || IfcElementComponent::is(v); }
Type::Enum IfcMechanicalFastener::type() const { return Type::IfcMechanicalFastener; }
Type::Enum IfcMechanicalFastener::Class() { return Type::IfcMechanicalFastener; }
IfcMechanicalFastener::IfcMechanicalFastener(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMechanicalFastener)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalFastener::IfcMechanicalFastener(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPositiveLengthMeasure > v9_NominalDiameter, boost::optional< IfcPositiveLengthMeasure > v10_NominalLength, boost::optional< IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum > v11_PredefinedType) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_NominalDiameter) { e->setArgument(8,(*v9_NominalDiameter)); } else { e->setArgument(8); } if (v10_NominalLength) { e->setArgument(9,(*v10_NominalLength)); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcMechanicalFastenerTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMechanicalFastenerType
IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum IfcMechanicalFastenerType::PredefinedType() { return IfcMechanicalFastenerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMechanicalFastenerType::setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcMechanicalFastenerTypeEnum::ToString(v)); }
bool IfcMechanicalFastenerType::hasNominalDiameter() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcMechanicalFastenerType::NominalDiameter() { return *entity->getArgument(10); }
void IfcMechanicalFastenerType::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcMechanicalFastenerType::hasNominalLength() { return !entity->getArgument(11)->isNull(); }
IfcPositiveLengthMeasure IfcMechanicalFastenerType::NominalLength() { return *entity->getArgument(11); }
void IfcMechanicalFastenerType::setNominalLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcMechanicalFastenerType::is(Type::Enum v) const { return v == Type::IfcMechanicalFastenerType || IfcElementComponentType::is(v); }
Type::Enum IfcMechanicalFastenerType::type() const { return Type::IfcMechanicalFastenerType; }
Type::Enum IfcMechanicalFastenerType::Class() { return Type::IfcMechanicalFastenerType; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMechanicalFastenerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMechanicalFastenerType::IfcMechanicalFastenerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v10_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v11_NominalDiameter, boost::optional< IfcPositiveLengthMeasure > v12_NominalLength) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcMechanicalFastenerTypeEnum::ToString(v10_PredefinedType)); if (v11_NominalDiameter) { e->setArgument(10,(*v11_NominalDiameter)); } else { e->setArgument(10); } if (v12_NominalLength) { e->setArgument(11,(*v12_NominalLength)); } else { e->setArgument(11); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMedicalDevice
bool IfcMedicalDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDevice::PredefinedType() { return IfcMedicalDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcMedicalDevice::setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcMedicalDeviceTypeEnum::ToString(v)); }
bool IfcMedicalDevice::is(Type::Enum v) const { return v == Type::IfcMedicalDevice || IfcFlowTerminal::is(v); }
Type::Enum IfcMedicalDevice::type() const { return Type::IfcMedicalDevice; }
Type::Enum IfcMedicalDevice::Class() { return Type::IfcMedicalDevice; }
IfcMedicalDevice::IfcMedicalDevice(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMedicalDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMedicalDevice::IfcMedicalDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcMedicalDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMedicalDeviceType
IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum IfcMedicalDeviceType::PredefinedType() { return IfcMedicalDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMedicalDeviceType::setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcMedicalDeviceTypeEnum::ToString(v)); }
bool IfcMedicalDeviceType::is(Type::Enum v) const { return v == Type::IfcMedicalDeviceType || IfcFlowTerminalType::is(v); }
Type::Enum IfcMedicalDeviceType::type() const { return Type::IfcMedicalDeviceType; }
Type::Enum IfcMedicalDeviceType::Class() { return Type::IfcMedicalDeviceType; }
IfcMedicalDeviceType::IfcMedicalDeviceType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMedicalDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMedicalDeviceType::IfcMedicalDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcMedicalDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMember
bool IfcMember::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcMemberTypeEnum::IfcMemberTypeEnum IfcMember::PredefinedType() { return IfcMemberTypeEnum::FromString(*entity->getArgument(8)); }
void IfcMember::setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcMemberTypeEnum::ToString(v)); }
bool IfcMember::is(Type::Enum v) const { return v == Type::IfcMember || IfcBuildingElement::is(v); }
Type::Enum IfcMember::type() const { return Type::IfcMember; }
Type::Enum IfcMember::Class() { return Type::IfcMember; }
IfcMember::IfcMember(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMember)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMember::IfcMember(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcMemberTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMemberStandardCase
bool IfcMemberStandardCase::is(Type::Enum v) const { return v == Type::IfcMemberStandardCase || IfcMember::is(v); }
Type::Enum IfcMemberStandardCase::type() const { return Type::IfcMemberStandardCase; }
Type::Enum IfcMemberStandardCase::Class() { return Type::IfcMemberStandardCase; }
IfcMemberStandardCase::IfcMemberStandardCase(IfcAbstractEntityPtr e) : IfcMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMemberStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMemberStandardCase::IfcMemberStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType) : IfcMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcMemberTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMemberType
IfcMemberTypeEnum::IfcMemberTypeEnum IfcMemberType::PredefinedType() { return IfcMemberTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMemberType::setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcMemberTypeEnum::ToString(v)); }
bool IfcMemberType::is(Type::Enum v) const { return v == Type::IfcMemberType || IfcBuildingElementType::is(v); }
Type::Enum IfcMemberType::type() const { return Type::IfcMemberType; }
Type::Enum IfcMemberType::Class() { return Type::IfcMemberType; }
IfcMemberType::IfcMemberType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMemberType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMemberType::IfcMemberType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcMemberTypeEnum::IfcMemberTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcMemberTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMetric
IfcBenchmarkEnum::IfcBenchmarkEnum IfcMetric::Benchmark() { return IfcBenchmarkEnum::FromString(*entity->getArgument(7)); }
void IfcMetric::setBenchmark(IfcBenchmarkEnum::IfcBenchmarkEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcBenchmarkEnum::ToString(v)); }
bool IfcMetric::hasValueSource() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcMetric::ValueSource() { return *entity->getArgument(8); }
void IfcMetric::setValueSource(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcMetricValueSelect IfcMetric::DataValue() { return *entity->getArgument(9); }
void IfcMetric::setDataValue(IfcMetricValueSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcMetric::hasReferencePath() { return !entity->getArgument(10)->isNull(); }
IfcReference* IfcMetric::ReferencePath() { return (IfcReference*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcMetric::setReferencePath(IfcReference* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcMetric::is(Type::Enum v) const { return v == Type::IfcMetric || IfcConstraint::is(v); }
Type::Enum IfcMetric::type() const { return Type::IfcMetric; }
Type::Enum IfcMetric::Class() { return Type::IfcMetric; }
IfcMetric::IfcMetric(IfcAbstractEntityPtr e) : IfcConstraint((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMetric)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMetric::IfcMetric(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< IfcLabel > v4_ConstraintSource, boost::optional< IfcActorSelect > v5_CreatingActor, boost::optional< IfcDateTime > v6_CreationTime, boost::optional< IfcLabel > v7_UserDefinedGrade, IfcBenchmarkEnum::IfcBenchmarkEnum v8_Benchmark, boost::optional< IfcLabel > v9_ValueSource, IfcMetricValueSelect v10_DataValue, IfcReference* v11_ReferencePath) : IfcConstraint((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade)); if (v4_ConstraintSource) { e->setArgument(3,(*v4_ConstraintSource)); } else { e->setArgument(3); } if (v5_CreatingActor) { e->setArgument(4,(*v5_CreatingActor)); } else { e->setArgument(4); } if (v6_CreationTime) { e->setArgument(5,(*v6_CreationTime)); } else { e->setArgument(5); } if (v7_UserDefinedGrade) { e->setArgument(6,(*v7_UserDefinedGrade)); } else { e->setArgument(6); } e->setArgument(7,v8_Benchmark,IfcBenchmarkEnum::ToString(v8_Benchmark)); if (v9_ValueSource) { e->setArgument(8,(*v9_ValueSource)); } else { e->setArgument(8); } e->setArgument(9,(v10_DataValue)); e->setArgument(10,(v11_ReferencePath)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMirroredProfileDef
bool IfcMirroredProfileDef::is(Type::Enum v) const { return v == Type::IfcMirroredProfileDef || IfcDerivedProfileDef::is(v); }
Type::Enum IfcMirroredProfileDef::type() const { return Type::IfcMirroredProfileDef; }
Type::Enum IfcMirroredProfileDef::Class() { return Type::IfcMirroredProfileDef; }
IfcMirroredProfileDef::IfcMirroredProfileDef(IfcAbstractEntityPtr e) : IfcDerivedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMirroredProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMirroredProfileDef::IfcMirroredProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcProfileDef* v3_ParentProfile, boost::optional< IfcLabel > v5_Label) : IfcDerivedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_ParentProfile)); e->setArgumentDerived(3); if (v5_Label) { e->setArgument(4,(*v5_Label)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMonetaryUnit
IfcLabel IfcMonetaryUnit::Currency() { return *entity->getArgument(0); }
void IfcMonetaryUnit::setCurrency(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcMonetaryUnit::is(Type::Enum v) const { return v == Type::IfcMonetaryUnit; }
Type::Enum IfcMonetaryUnit::type() const { return Type::IfcMonetaryUnit; }
Type::Enum IfcMonetaryUnit::Class() { return Type::IfcMonetaryUnit; }
IfcMonetaryUnit::IfcMonetaryUnit(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcMonetaryUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMonetaryUnit::IfcMonetaryUnit(IfcLabel v1_Currency) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Currency)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMotorConnection
bool IfcMotorConnection::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnection::PredefinedType() { return IfcMotorConnectionTypeEnum::FromString(*entity->getArgument(8)); }
void IfcMotorConnection::setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcMotorConnectionTypeEnum::ToString(v)); }
bool IfcMotorConnection::is(Type::Enum v) const { return v == Type::IfcMotorConnection || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcMotorConnection::type() const { return Type::IfcMotorConnection; }
Type::Enum IfcMotorConnection::Class() { return Type::IfcMotorConnection; }
IfcMotorConnection::IfcMotorConnection(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMotorConnection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMotorConnection::IfcMotorConnection(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcMotorConnectionTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcMotorConnectionType
IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum IfcMotorConnectionType::PredefinedType() { return IfcMotorConnectionTypeEnum::FromString(*entity->getArgument(9)); }
void IfcMotorConnectionType::setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcMotorConnectionTypeEnum::ToString(v)); }
bool IfcMotorConnectionType::is(Type::Enum v) const { return v == Type::IfcMotorConnectionType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcMotorConnectionType::type() const { return Type::IfcMotorConnectionType; }
Type::Enum IfcMotorConnectionType::Class() { return Type::IfcMotorConnectionType; }
IfcMotorConnectionType::IfcMotorConnectionType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcMotorConnectionType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcMotorConnectionType::IfcMotorConnectionType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcMotorConnectionTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcNamedUnit
IfcDimensionalExponents* IfcNamedUnit::Dimensions() { return (IfcDimensionalExponents*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcNamedUnit::setDimensions(IfcDimensionalExponents* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcUnitEnum::IfcUnitEnum IfcNamedUnit::UnitType() { return IfcUnitEnum::FromString(*entity->getArgument(1)); }
void IfcNamedUnit::setUnitType(IfcUnitEnum::IfcUnitEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v,IfcUnitEnum::ToString(v)); }
bool IfcNamedUnit::is(Type::Enum v) const { return v == Type::IfcNamedUnit; }
Type::Enum IfcNamedUnit::type() const { return Type::IfcNamedUnit; }
Type::Enum IfcNamedUnit::Class() { return Type::IfcNamedUnit; }
IfcNamedUnit::IfcNamedUnit(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcNamedUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcNamedUnit::IfcNamedUnit(IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Dimensions)); e->setArgument(1,v2_UnitType,IfcUnitEnum::ToString(v2_UnitType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcObject
bool IfcObject::hasObjectType() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcObject::ObjectType() { return *entity->getArgument(4); }
void IfcObject::setObjectType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcRelDefinesByObject::list IfcObject::IsDeclaredBy() { RETURN_INVERSE(IfcRelDefinesByObject) }
IfcRelDefinesByObject::list IfcObject::Declares() { RETURN_INVERSE(IfcRelDefinesByObject) }
IfcRelDefinesByType::list IfcObject::IsTypedBy() { RETURN_INVERSE(IfcRelDefinesByType) }
IfcRelDefinesByProperties::list IfcObject::IsDefinedBy() { RETURN_INVERSE(IfcRelDefinesByProperties) }
bool IfcObject::is(Type::Enum v) const { return v == Type::IfcObject || IfcObjectDefinition::is(v); }
Type::Enum IfcObject::type() const { return Type::IfcObject; }
Type::Enum IfcObject::Class() { return Type::IfcObject; }
IfcObject::IfcObject(IfcAbstractEntityPtr e) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcObject)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObject::IfcObject(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcObjectDefinition
IfcRelAssigns::list IfcObjectDefinition::HasAssignments() { RETURN_INVERSE(IfcRelAssigns) }
IfcRelNests::list IfcObjectDefinition::Nests() { RETURN_INVERSE(IfcRelNests) }
IfcRelNests::list IfcObjectDefinition::IsNestedBy() { RETURN_INVERSE(IfcRelNests) }
IfcRelDeclares::list IfcObjectDefinition::HasContext() { RETURN_INVERSE(IfcRelDeclares) }
IfcRelAggregates::list IfcObjectDefinition::IsDecomposedBy() { RETURN_INVERSE(IfcRelAggregates) }
IfcRelAggregates::list IfcObjectDefinition::Decomposes() { RETURN_INVERSE(IfcRelAggregates) }
IfcRelAssociates::list IfcObjectDefinition::HasAssociations() { RETURN_INVERSE(IfcRelAssociates) }
bool IfcObjectDefinition::is(Type::Enum v) const { return v == Type::IfcObjectDefinition || IfcRoot::is(v); }
Type::Enum IfcObjectDefinition::type() const { return Type::IfcObjectDefinition; }
Type::Enum IfcObjectDefinition::Class() { return Type::IfcObjectDefinition; }
IfcObjectDefinition::IfcObjectDefinition(IfcAbstractEntityPtr e) : IfcRoot((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcObjectDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjectDefinition::IfcObjectDefinition(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRoot((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcObjectPlacement
IfcProduct::list IfcObjectPlacement::PlacesObject() { RETURN_INVERSE(IfcProduct) }
IfcLocalPlacement::list IfcObjectPlacement::ReferencedByPlacements() { RETURN_INVERSE(IfcLocalPlacement) }
bool IfcObjectPlacement::is(Type::Enum v) const { return v == Type::IfcObjectPlacement; }
Type::Enum IfcObjectPlacement::type() const { return Type::IfcObjectPlacement; }
Type::Enum IfcObjectPlacement::Class() { return Type::IfcObjectPlacement; }
IfcObjectPlacement::IfcObjectPlacement(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcObjectPlacement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjectPlacement::IfcObjectPlacement() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcObjective
bool IfcObjective::hasBenchmarkValues() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcConstraint > > IfcObjective::BenchmarkValues() { RETURN_AS_LIST(IfcConstraint,7) }
void IfcObjective::setBenchmarkValues(SHARED_PTR< IfcTemplatedEntityList< IfcConstraint > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcObjective::hasLogicalAggregator() { return !entity->getArgument(8)->isNull(); }
IfcLogicalOperatorEnum::IfcLogicalOperatorEnum IfcObjective::LogicalAggregator() { return IfcLogicalOperatorEnum::FromString(*entity->getArgument(8)); }
void IfcObjective::setLogicalAggregator(IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcLogicalOperatorEnum::ToString(v)); }
IfcObjectiveEnum::IfcObjectiveEnum IfcObjective::ObjectiveQualifier() { return IfcObjectiveEnum::FromString(*entity->getArgument(9)); }
void IfcObjective::setObjectiveQualifier(IfcObjectiveEnum::IfcObjectiveEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcObjectiveEnum::ToString(v)); }
bool IfcObjective::hasUserDefinedQualifier() { return !entity->getArgument(10)->isNull(); }
IfcLabel IfcObjective::UserDefinedQualifier() { return *entity->getArgument(10); }
void IfcObjective::setUserDefinedQualifier(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcObjective::is(Type::Enum v) const { return v == Type::IfcObjective || IfcConstraint::is(v); }
Type::Enum IfcObjective::type() const { return Type::IfcObjective; }
Type::Enum IfcObjective::Class() { return Type::IfcObjective; }
IfcObjective::IfcObjective(IfcAbstractEntityPtr e) : IfcConstraint((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcObjective)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcObjective::IfcObjective(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< IfcLabel > v4_ConstraintSource, boost::optional< IfcActorSelect > v5_CreatingActor, boost::optional< IfcDateTime > v6_CreationTime, boost::optional< IfcLabel > v7_UserDefinedGrade, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcConstraint > > > v8_BenchmarkValues, boost::optional< IfcLogicalOperatorEnum::IfcLogicalOperatorEnum > v9_LogicalAggregator, IfcObjectiveEnum::IfcObjectiveEnum v10_ObjectiveQualifier, boost::optional< IfcLabel > v11_UserDefinedQualifier) : IfcConstraint((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,v3_ConstraintGrade,IfcConstraintEnum::ToString(v3_ConstraintGrade)); if (v4_ConstraintSource) { e->setArgument(3,(*v4_ConstraintSource)); } else { e->setArgument(3); } if (v5_CreatingActor) { e->setArgument(4,(*v5_CreatingActor)); } else { e->setArgument(4); } if (v6_CreationTime) { e->setArgument(5,(*v6_CreationTime)); } else { e->setArgument(5); } if (v7_UserDefinedGrade) { e->setArgument(6,(*v7_UserDefinedGrade)); } else { e->setArgument(6); } if (v8_BenchmarkValues) { e->setArgument(7,(*v8_BenchmarkValues)->generalize()); } else { e->setArgument(7); } if (v9_LogicalAggregator) { e->setArgument(8,*v9_LogicalAggregator,IfcLogicalOperatorEnum::ToString(*v9_LogicalAggregator)); } else { e->setArgument(8); } e->setArgument(9,v10_ObjectiveQualifier,IfcObjectiveEnum::ToString(v10_ObjectiveQualifier)); if (v11_UserDefinedQualifier) { e->setArgument(10,(*v11_UserDefinedQualifier)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOccupant
bool IfcOccupant::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcOccupantTypeEnum::IfcOccupantTypeEnum IfcOccupant::PredefinedType() { return IfcOccupantTypeEnum::FromString(*entity->getArgument(6)); }
void IfcOccupant::setPredefinedType(IfcOccupantTypeEnum::IfcOccupantTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcOccupantTypeEnum::ToString(v)); }
bool IfcOccupant::is(Type::Enum v) const { return v == Type::IfcOccupant || IfcActor::is(v); }
Type::Enum IfcOccupant::type() const { return Type::IfcOccupant; }
Type::Enum IfcOccupant::Class() { return Type::IfcOccupant; }
IfcOccupant::IfcOccupant(IfcAbstractEntityPtr e) : IfcActor((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOccupant)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOccupant::IfcOccupant(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcActorSelect v6_TheActor, boost::optional< IfcOccupantTypeEnum::IfcOccupantTypeEnum > v7_PredefinedType) : IfcActor((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_TheActor)); if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcOccupantTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOffsetCurve2D
IfcCurve* IfcOffsetCurve2D::BasisCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcOffsetCurve2D::setBasisCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLengthMeasure IfcOffsetCurve2D::Distance() { return *entity->getArgument(1); }
void IfcOffsetCurve2D::setDistance(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcOffsetCurve2D::SelfIntersect() { return *entity->getArgument(2); }
void IfcOffsetCurve2D::setSelfIntersect(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcOffsetCurve2D::is(Type::Enum v) const { return v == Type::IfcOffsetCurve2D || IfcCurve::is(v); }
Type::Enum IfcOffsetCurve2D::type() const { return Type::IfcOffsetCurve2D; }
Type::Enum IfcOffsetCurve2D::Class() { return Type::IfcOffsetCurve2D; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOffsetCurve2D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOffsetCurve2D::IfcOffsetCurve2D(IfcCurve* v1_BasisCurve, IfcLengthMeasure v2_Distance, bool v3_SelfIntersect) : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisCurve)); e->setArgument(1,(v2_Distance)); e->setArgument(2,(v3_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOffsetCurve3D
IfcCurve* IfcOffsetCurve3D::BasisCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcOffsetCurve3D::setBasisCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLengthMeasure IfcOffsetCurve3D::Distance() { return *entity->getArgument(1); }
void IfcOffsetCurve3D::setDistance(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcOffsetCurve3D::SelfIntersect() { return *entity->getArgument(2); }
void IfcOffsetCurve3D::setSelfIntersect(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcDirection* IfcOffsetCurve3D::RefDirection() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcOffsetCurve3D::setRefDirection(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcOffsetCurve3D::is(Type::Enum v) const { return v == Type::IfcOffsetCurve3D || IfcCurve::is(v); }
Type::Enum IfcOffsetCurve3D::type() const { return Type::IfcOffsetCurve3D; }
Type::Enum IfcOffsetCurve3D::Class() { return Type::IfcOffsetCurve3D; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOffsetCurve3D)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOffsetCurve3D::IfcOffsetCurve3D(IfcCurve* v1_BasisCurve, IfcLengthMeasure v2_Distance, bool v3_SelfIntersect, IfcDirection* v4_RefDirection) : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisCurve)); e->setArgument(1,(v2_Distance)); e->setArgument(2,(v3_SelfIntersect)); e->setArgument(3,(v4_RefDirection)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOpenShell
bool IfcOpenShell::is(Type::Enum v) const { return v == Type::IfcOpenShell || IfcConnectedFaceSet::is(v); }
Type::Enum IfcOpenShell::type() const { return Type::IfcOpenShell; }
Type::Enum IfcOpenShell::Class() { return Type::IfcOpenShell; }
IfcOpenShell::IfcOpenShell(IfcAbstractEntityPtr e) : IfcConnectedFaceSet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOpenShell)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpenShell::IfcOpenShell(SHARED_PTR< IfcTemplatedEntityList< IfcFace > > v1_CfsFaces) : IfcConnectedFaceSet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_CfsFaces)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOpeningElement
bool IfcOpeningElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum IfcOpeningElement::PredefinedType() { return IfcOpeningElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcOpeningElement::setPredefinedType(IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcOpeningElementTypeEnum::ToString(v)); }
IfcRelFillsElement::list IfcOpeningElement::HasFillings() { RETURN_INVERSE(IfcRelFillsElement) }
bool IfcOpeningElement::is(Type::Enum v) const { return v == Type::IfcOpeningElement || IfcFeatureElementSubtraction::is(v); }
Type::Enum IfcOpeningElement::type() const { return Type::IfcOpeningElement; }
Type::Enum IfcOpeningElement::Class() { return Type::IfcOpeningElement; }
IfcOpeningElement::IfcOpeningElement(IfcAbstractEntityPtr e) : IfcFeatureElementSubtraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOpeningElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpeningElement::IfcOpeningElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType) : IfcFeatureElementSubtraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcOpeningElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOpeningStandardCase
bool IfcOpeningStandardCase::is(Type::Enum v) const { return v == Type::IfcOpeningStandardCase || IfcOpeningElement::is(v); }
Type::Enum IfcOpeningStandardCase::type() const { return Type::IfcOpeningStandardCase; }
Type::Enum IfcOpeningStandardCase::Class() { return Type::IfcOpeningStandardCase; }
IfcOpeningStandardCase::IfcOpeningStandardCase(IfcAbstractEntityPtr e) : IfcOpeningElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOpeningStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOpeningStandardCase::IfcOpeningStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType) : IfcOpeningElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcOpeningElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOrganization
bool IfcOrganization::hasIdentification() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcOrganization::Identification() { return *entity->getArgument(0); }
void IfcOrganization::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLabel IfcOrganization::Name() { return *entity->getArgument(1); }
void IfcOrganization::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcOrganization::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcOrganization::Description() { return *entity->getArgument(2); }
void IfcOrganization::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcOrganization::hasRoles() { return !entity->getArgument(3)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > IfcOrganization::Roles() { RETURN_AS_LIST(IfcActorRole,3) }
void IfcOrganization::setRoles(SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcOrganization::hasAddresses() { return !entity->getArgument(4)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > IfcOrganization::Addresses() { RETURN_AS_LIST(IfcAddress,4) }
void IfcOrganization::setAddresses(SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcOrganizationRelationship::list IfcOrganization::IsRelatedBy() { RETURN_INVERSE(IfcOrganizationRelationship) }
IfcOrganizationRelationship::list IfcOrganization::Relates() { RETURN_INVERSE(IfcOrganizationRelationship) }
IfcPersonAndOrganization::list IfcOrganization::Engages() { RETURN_INVERSE(IfcPersonAndOrganization) }
bool IfcOrganization::is(Type::Enum v) const { return v == Type::IfcOrganization; }
Type::Enum IfcOrganization::type() const { return Type::IfcOrganization; }
Type::Enum IfcOrganization::Class() { return Type::IfcOrganization; }
IfcOrganization::IfcOrganization(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcOrganization)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrganization::IfcOrganization(boost::optional< IfcIdentifier > v1_Identification, IfcLabel v2_Name, boost::optional< IfcText > v3_Description, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > > v4_Roles, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > > v5_Addresses) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Identification) { e->setArgument(0,(*v1_Identification)); } else { e->setArgument(0); } e->setArgument(1,(v2_Name)); if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } if (v4_Roles) { e->setArgument(3,(*v4_Roles)->generalize()); } else { e->setArgument(3); } if (v5_Addresses) { e->setArgument(4,(*v5_Addresses)->generalize()); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOrganizationRelationship
IfcOrganization* IfcOrganizationRelationship::RelatingOrganization() { return (IfcOrganization*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcOrganizationRelationship::setRelatingOrganization(IfcOrganization* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcOrganization > > IfcOrganizationRelationship::RelatedOrganizations() { RETURN_AS_LIST(IfcOrganization,3) }
void IfcOrganizationRelationship::setRelatedOrganizations(SHARED_PTR< IfcTemplatedEntityList< IfcOrganization > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcOrganizationRelationship::is(Type::Enum v) const { return v == Type::IfcOrganizationRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcOrganizationRelationship::type() const { return Type::IfcOrganizationRelationship; }
Type::Enum IfcOrganizationRelationship::Class() { return Type::IfcOrganizationRelationship; }
IfcOrganizationRelationship::IfcOrganizationRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOrganizationRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrganizationRelationship::IfcOrganizationRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcOrganization* v3_RelatingOrganization, SHARED_PTR< IfcTemplatedEntityList< IfcOrganization > > v4_RelatedOrganizations) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingOrganization)); e->setArgument(3,(v4_RelatedOrganizations)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOrientedEdge
IfcEdge* IfcOrientedEdge::EdgeElement() { return (IfcEdge*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcOrientedEdge::setEdgeElement(IfcEdge* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcOrientedEdge::Orientation() { return *entity->getArgument(3); }
void IfcOrientedEdge::setOrientation(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcOrientedEdge::is(Type::Enum v) const { return v == Type::IfcOrientedEdge || IfcEdge::is(v); }
Type::Enum IfcOrientedEdge::type() const { return Type::IfcOrientedEdge; }
Type::Enum IfcOrientedEdge::Class() { return Type::IfcOrientedEdge; }
IfcOrientedEdge::IfcOrientedEdge(IfcAbstractEntityPtr e) : IfcEdge((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOrientedEdge)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOrientedEdge::IfcOrientedEdge(IfcEdge* v3_EdgeElement, bool v4_Orientation) : IfcEdge((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgumentDerived(0); e->setArgumentDerived(1); e->setArgument(2,(v3_EdgeElement)); e->setArgument(3,(v4_Orientation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOuterBoundaryCurve
bool IfcOuterBoundaryCurve::is(Type::Enum v) const { return v == Type::IfcOuterBoundaryCurve || IfcBoundaryCurve::is(v); }
Type::Enum IfcOuterBoundaryCurve::type() const { return Type::IfcOuterBoundaryCurve; }
Type::Enum IfcOuterBoundaryCurve::Class() { return Type::IfcOuterBoundaryCurve; }
IfcOuterBoundaryCurve::IfcOuterBoundaryCurve(IfcAbstractEntityPtr e) : IfcBoundaryCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOuterBoundaryCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOuterBoundaryCurve::IfcOuterBoundaryCurve(SHARED_PTR< IfcTemplatedEntityList< IfcCompositeCurveSegment > > v1_Segments, bool v2_SelfIntersect) : IfcBoundaryCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Segments)->generalize()); e->setArgument(1,(v2_SelfIntersect)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOutlet
bool IfcOutlet::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutlet::PredefinedType() { return IfcOutletTypeEnum::FromString(*entity->getArgument(8)); }
void IfcOutlet::setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcOutletTypeEnum::ToString(v)); }
bool IfcOutlet::is(Type::Enum v) const { return v == Type::IfcOutlet || IfcFlowTerminal::is(v); }
Type::Enum IfcOutlet::type() const { return Type::IfcOutlet; }
Type::Enum IfcOutlet::Class() { return Type::IfcOutlet; }
IfcOutlet::IfcOutlet(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOutlet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOutlet::IfcOutlet(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcOutletTypeEnum::IfcOutletTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcOutletTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOutletType
IfcOutletTypeEnum::IfcOutletTypeEnum IfcOutletType::PredefinedType() { return IfcOutletTypeEnum::FromString(*entity->getArgument(9)); }
void IfcOutletType::setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcOutletTypeEnum::ToString(v)); }
bool IfcOutletType::is(Type::Enum v) const { return v == Type::IfcOutletType || IfcFlowTerminalType::is(v); }
Type::Enum IfcOutletType::type() const { return Type::IfcOutletType; }
Type::Enum IfcOutletType::Class() { return Type::IfcOutletType; }
IfcOutletType::IfcOutletType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcOutletType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOutletType::IfcOutletType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcOutletTypeEnum::IfcOutletTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcOutletTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcOwnerHistory
IfcPersonAndOrganization* IfcOwnerHistory::OwningUser() { return (IfcPersonAndOrganization*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcOwnerHistory::setOwningUser(IfcPersonAndOrganization* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcApplication* IfcOwnerHistory::OwningApplication() { return (IfcApplication*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcOwnerHistory::setOwningApplication(IfcApplication* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcOwnerHistory::hasState() { return !entity->getArgument(2)->isNull(); }
IfcStateEnum::IfcStateEnum IfcOwnerHistory::State() { return IfcStateEnum::FromString(*entity->getArgument(2)); }
void IfcOwnerHistory::setState(IfcStateEnum::IfcStateEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcStateEnum::ToString(v)); }
bool IfcOwnerHistory::hasChangeAction() { return !entity->getArgument(3)->isNull(); }
IfcChangeActionEnum::IfcChangeActionEnum IfcOwnerHistory::ChangeAction() { return IfcChangeActionEnum::FromString(*entity->getArgument(3)); }
void IfcOwnerHistory::setChangeAction(IfcChangeActionEnum::IfcChangeActionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v,IfcChangeActionEnum::ToString(v)); }
bool IfcOwnerHistory::hasLastModifiedDate() { return !entity->getArgument(4)->isNull(); }
IfcTimeStamp IfcOwnerHistory::LastModifiedDate() { return *entity->getArgument(4); }
void IfcOwnerHistory::setLastModifiedDate(IfcTimeStamp v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcOwnerHistory::hasLastModifyingUser() { return !entity->getArgument(5)->isNull(); }
IfcPersonAndOrganization* IfcOwnerHistory::LastModifyingUser() { return (IfcPersonAndOrganization*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcOwnerHistory::setLastModifyingUser(IfcPersonAndOrganization* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcOwnerHistory::hasLastModifyingApplication() { return !entity->getArgument(6)->isNull(); }
IfcApplication* IfcOwnerHistory::LastModifyingApplication() { return (IfcApplication*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcOwnerHistory::setLastModifyingApplication(IfcApplication* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcTimeStamp IfcOwnerHistory::CreationDate() { return *entity->getArgument(7); }
void IfcOwnerHistory::setCreationDate(IfcTimeStamp v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcOwnerHistory::is(Type::Enum v) const { return v == Type::IfcOwnerHistory; }
Type::Enum IfcOwnerHistory::type() const { return Type::IfcOwnerHistory; }
Type::Enum IfcOwnerHistory::Class() { return Type::IfcOwnerHistory; }
IfcOwnerHistory::IfcOwnerHistory(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcOwnerHistory)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcOwnerHistory::IfcOwnerHistory(IfcPersonAndOrganization* v1_OwningUser, IfcApplication* v2_OwningApplication, boost::optional< IfcStateEnum::IfcStateEnum > v3_State, boost::optional< IfcChangeActionEnum::IfcChangeActionEnum > v4_ChangeAction, boost::optional< IfcTimeStamp > v5_LastModifiedDate, IfcPersonAndOrganization* v6_LastModifyingUser, IfcApplication* v7_LastModifyingApplication, IfcTimeStamp v8_CreationDate) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_OwningUser)); e->setArgument(1,(v2_OwningApplication)); if (v3_State) { e->setArgument(2,*v3_State,IfcStateEnum::ToString(*v3_State)); } else { e->setArgument(2); } if (v4_ChangeAction) { e->setArgument(3,*v4_ChangeAction,IfcChangeActionEnum::ToString(*v4_ChangeAction)); } else { e->setArgument(3); } if (v5_LastModifiedDate) { e->setArgument(4,(*v5_LastModifiedDate)); } else { e->setArgument(4); } e->setArgument(5,(v6_LastModifyingUser)); e->setArgument(6,(v7_LastModifyingApplication)); e->setArgument(7,(v8_CreationDate)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcParameterizedProfileDef
bool IfcParameterizedProfileDef::hasPosition() { return !entity->getArgument(2)->isNull(); }
IfcAxis2Placement2D* IfcParameterizedProfileDef::Position() { return (IfcAxis2Placement2D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcParameterizedProfileDef::setPosition(IfcAxis2Placement2D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcParameterizedProfileDef::is(Type::Enum v) const { return v == Type::IfcParameterizedProfileDef || IfcProfileDef::is(v); }
Type::Enum IfcParameterizedProfileDef::type() const { return Type::IfcParameterizedProfileDef; }
Type::Enum IfcParameterizedProfileDef::Class() { return Type::IfcParameterizedProfileDef; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcAbstractEntityPtr e) : IfcProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcParameterizedProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcParameterizedProfileDef::IfcParameterizedProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position) : IfcProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPath
SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > IfcPath::EdgeList() { RETURN_AS_LIST(IfcOrientedEdge,0) }
void IfcPath::setEdgeList(SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcPath::is(Type::Enum v) const { return v == Type::IfcPath || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcPath::type() const { return Type::IfcPath; }
Type::Enum IfcPath::Class() { return Type::IfcPath; }
IfcPath::IfcPath(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPath)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPath::IfcPath(SHARED_PTR< IfcTemplatedEntityList< IfcOrientedEdge > > v1_EdgeList) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_EdgeList)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPcurve
IfcSurface* IfcPcurve::BasisSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcPcurve::setBasisSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcCurve* IfcPcurve::ReferenceCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcPcurve::setReferenceCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcPcurve::is(Type::Enum v) const { return v == Type::IfcPcurve || IfcCurve::is(v); }
Type::Enum IfcPcurve::type() const { return Type::IfcPcurve; }
Type::Enum IfcPcurve::Class() { return Type::IfcPcurve; }
IfcPcurve::IfcPcurve(IfcAbstractEntityPtr e) : IfcCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPcurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPcurve::IfcPcurve(IfcSurface* v1_BasisSurface, IfcCurve* v2_ReferenceCurve) : IfcCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisSurface)); e->setArgument(1,(v2_ReferenceCurve)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPerformanceHistory
IfcLabel IfcPerformanceHistory::LifeCyclePhase() { return *entity->getArgument(6); }
void IfcPerformanceHistory::setLifeCyclePhase(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcPerformanceHistory::hasPredefinedType() { return !entity->getArgument(7)->isNull(); }
IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum IfcPerformanceHistory::PredefinedType() { return IfcPerformanceHistoryTypeEnum::FromString(*entity->getArgument(7)); }
void IfcPerformanceHistory::setPredefinedType(IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcPerformanceHistoryTypeEnum::ToString(v)); }
bool IfcPerformanceHistory::is(Type::Enum v) const { return v == Type::IfcPerformanceHistory || IfcControl::is(v); }
Type::Enum IfcPerformanceHistory::type() const { return Type::IfcPerformanceHistory; }
Type::Enum IfcPerformanceHistory::Class() { return Type::IfcPerformanceHistory; }
IfcPerformanceHistory::IfcPerformanceHistory(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPerformanceHistory)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPerformanceHistory::IfcPerformanceHistory(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, IfcLabel v7_LifeCyclePhase, boost::optional< IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum > v8_PredefinedType) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } e->setArgument(6,(v7_LifeCyclePhase)); if (v8_PredefinedType) { e->setArgument(7,*v8_PredefinedType,IfcPerformanceHistoryTypeEnum::ToString(*v8_PredefinedType)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPermeableCoveringProperties
IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum IfcPermeableCoveringProperties::OperationType() { return IfcPermeableCoveringOperationEnum::FromString(*entity->getArgument(4)); }
void IfcPermeableCoveringProperties::setOperationType(IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcPermeableCoveringOperationEnum::ToString(v)); }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcPermeableCoveringProperties::PanelPosition() { return IfcWindowPanelPositionEnum::FromString(*entity->getArgument(5)); }
void IfcPermeableCoveringProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcWindowPanelPositionEnum::ToString(v)); }
bool IfcPermeableCoveringProperties::hasFrameDepth() { return !entity->getArgument(6)->isNull(); }
IfcPositiveLengthMeasure IfcPermeableCoveringProperties::FrameDepth() { return *entity->getArgument(6); }
void IfcPermeableCoveringProperties::setFrameDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcPermeableCoveringProperties::hasFrameThickness() { return !entity->getArgument(7)->isNull(); }
IfcPositiveLengthMeasure IfcPermeableCoveringProperties::FrameThickness() { return *entity->getArgument(7); }
void IfcPermeableCoveringProperties::setFrameThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcPermeableCoveringProperties::hasShapeAspectStyle() { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcPermeableCoveringProperties::ShapeAspectStyle() { return (IfcShapeAspect*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcPermeableCoveringProperties::setShapeAspectStyle(IfcShapeAspect* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcPermeableCoveringProperties::is(Type::Enum v) const { return v == Type::IfcPermeableCoveringProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcPermeableCoveringProperties::type() const { return Type::IfcPermeableCoveringProperties; }
Type::Enum IfcPermeableCoveringProperties::Class() { return Type::IfcPermeableCoveringProperties; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPermeableCoveringProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPermeableCoveringProperties::IfcPermeableCoveringProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< IfcPositiveLengthMeasure > v7_FrameDepth, boost::optional< IfcPositiveLengthMeasure > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,v5_OperationType,IfcPermeableCoveringOperationEnum::ToString(v5_OperationType)); e->setArgument(5,v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition)); if (v7_FrameDepth) { e->setArgument(6,(*v7_FrameDepth)); } else { e->setArgument(6); } if (v8_FrameThickness) { e->setArgument(7,(*v8_FrameThickness)); } else { e->setArgument(7); } e->setArgument(8,(v9_ShapeAspectStyle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPermit
bool IfcPermit::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcPermitTypeEnum::IfcPermitTypeEnum IfcPermit::PredefinedType() { return IfcPermitTypeEnum::FromString(*entity->getArgument(6)); }
void IfcPermit::setPredefinedType(IfcPermitTypeEnum::IfcPermitTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcPermitTypeEnum::ToString(v)); }
bool IfcPermit::hasStatus() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcPermit::Status() { return *entity->getArgument(7); }
void IfcPermit::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcPermit::hasLongDescription() { return !entity->getArgument(8)->isNull(); }
IfcText IfcPermit::LongDescription() { return *entity->getArgument(8); }
void IfcPermit::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcPermit::is(Type::Enum v) const { return v == Type::IfcPermit || IfcControl::is(v); }
Type::Enum IfcPermit::type() const { return Type::IfcPermit; }
Type::Enum IfcPermit::Class() { return Type::IfcPermit; }
IfcPermit::IfcPermit(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPermit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPermit::IfcPermit(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcPermitTypeEnum::IfcPermitTypeEnum > v7_PredefinedType, boost::optional< IfcLabel > v8_Status, boost::optional< IfcText > v9_LongDescription) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcPermitTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } if (v8_Status) { e->setArgument(7,(*v8_Status)); } else { e->setArgument(7); } if (v9_LongDescription) { e->setArgument(8,(*v9_LongDescription)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPerson
bool IfcPerson::hasIdentification() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcPerson::Identification() { return *entity->getArgument(0); }
void IfcPerson::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPerson::hasFamilyName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcPerson::FamilyName() { return *entity->getArgument(1); }
void IfcPerson::setFamilyName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcPerson::hasGivenName() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcPerson::GivenName() { return *entity->getArgument(2); }
void IfcPerson::setGivenName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPerson::hasMiddleNames() { return !entity->getArgument(3)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcPerson::MiddleNames() { return *entity->getArgument(3); }
void IfcPerson::setMiddleNames(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPerson::hasPrefixTitles() { return !entity->getArgument(4)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcPerson::PrefixTitles() { return *entity->getArgument(4); }
void IfcPerson::setPrefixTitles(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPerson::hasSuffixTitles() { return !entity->getArgument(5)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcPerson::SuffixTitles() { return *entity->getArgument(5); }
void IfcPerson::setSuffixTitles(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPerson::hasRoles() { return !entity->getArgument(6)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > IfcPerson::Roles() { RETURN_AS_LIST(IfcActorRole,6) }
void IfcPerson::setRoles(SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v->generalize()); }
bool IfcPerson::hasAddresses() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > IfcPerson::Addresses() { RETURN_AS_LIST(IfcAddress,7) }
void IfcPerson::setAddresses(SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
IfcPersonAndOrganization::list IfcPerson::EngagedIn() { RETURN_INVERSE(IfcPersonAndOrganization) }
bool IfcPerson::is(Type::Enum v) const { return v == Type::IfcPerson; }
Type::Enum IfcPerson::type() const { return Type::IfcPerson; }
Type::Enum IfcPerson::Class() { return Type::IfcPerson; }
IfcPerson::IfcPerson(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPerson)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPerson::IfcPerson(boost::optional< IfcIdentifier > v1_Identification, boost::optional< IfcLabel > v2_FamilyName, boost::optional< IfcLabel > v3_GivenName, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v6_SuffixTitles, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > > v7_Roles, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAddress > > > v8_Addresses) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Identification) { e->setArgument(0,(*v1_Identification)); } else { e->setArgument(0); } if (v2_FamilyName) { e->setArgument(1,(*v2_FamilyName)); } else { e->setArgument(1); } if (v3_GivenName) { e->setArgument(2,(*v3_GivenName)); } else { e->setArgument(2); } if (v4_MiddleNames) { e->setArgument(3,(*v4_MiddleNames)); } else { e->setArgument(3); } if (v5_PrefixTitles) { e->setArgument(4,(*v5_PrefixTitles)); } else { e->setArgument(4); } if (v6_SuffixTitles) { e->setArgument(5,(*v6_SuffixTitles)); } else { e->setArgument(5); } if (v7_Roles) { e->setArgument(6,(*v7_Roles)->generalize()); } else { e->setArgument(6); } if (v8_Addresses) { e->setArgument(7,(*v8_Addresses)->generalize()); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPersonAndOrganization
IfcPerson* IfcPersonAndOrganization::ThePerson() { return (IfcPerson*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcPersonAndOrganization::setThePerson(IfcPerson* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcOrganization* IfcPersonAndOrganization::TheOrganization() { return (IfcOrganization*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcPersonAndOrganization::setTheOrganization(IfcOrganization* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcPersonAndOrganization::hasRoles() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > IfcPersonAndOrganization::Roles() { RETURN_AS_LIST(IfcActorRole,2) }
void IfcPersonAndOrganization::setRoles(SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcPersonAndOrganization::is(Type::Enum v) const { return v == Type::IfcPersonAndOrganization; }
Type::Enum IfcPersonAndOrganization::type() const { return Type::IfcPersonAndOrganization; }
Type::Enum IfcPersonAndOrganization::Class() { return Type::IfcPersonAndOrganization; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPersonAndOrganization)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPersonAndOrganization::IfcPersonAndOrganization(IfcPerson* v1_ThePerson, IfcOrganization* v2_TheOrganization, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcActorRole > > > v3_Roles) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ThePerson)); e->setArgument(1,(v2_TheOrganization)); if (v3_Roles) { e->setArgument(2,(*v3_Roles)->generalize()); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPhysicalComplexQuantity
SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > IfcPhysicalComplexQuantity::HasQuantities() { RETURN_AS_LIST(IfcPhysicalQuantity,2) }
void IfcPhysicalComplexQuantity::setHasQuantities(SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
IfcLabel IfcPhysicalComplexQuantity::Discrimination() { return *entity->getArgument(3); }
void IfcPhysicalComplexQuantity::setDiscrimination(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPhysicalComplexQuantity::hasQuality() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcPhysicalComplexQuantity::Quality() { return *entity->getArgument(4); }
void IfcPhysicalComplexQuantity::setQuality(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPhysicalComplexQuantity::hasUsage() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcPhysicalComplexQuantity::Usage() { return *entity->getArgument(5); }
void IfcPhysicalComplexQuantity::setUsage(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPhysicalComplexQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalComplexQuantity || IfcPhysicalQuantity::is(v); }
Type::Enum IfcPhysicalComplexQuantity::type() const { return Type::IfcPhysicalComplexQuantity; }
Type::Enum IfcPhysicalComplexQuantity::Class() { return Type::IfcPhysicalComplexQuantity; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(IfcAbstractEntityPtr e) : IfcPhysicalQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPhysicalComplexQuantity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalComplexQuantity::IfcPhysicalComplexQuantity(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcPhysicalQuantity > > v3_HasQuantities, IfcLabel v4_Discrimination, boost::optional< IfcLabel > v5_Quality, boost::optional< IfcLabel > v6_Usage) : IfcPhysicalQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_HasQuantities)->generalize()); e->setArgument(3,(v4_Discrimination)); if (v5_Quality) { e->setArgument(4,(*v5_Quality)); } else { e->setArgument(4); } if (v6_Usage) { e->setArgument(5,(*v6_Usage)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPhysicalQuantity
IfcLabel IfcPhysicalQuantity::Name() { return *entity->getArgument(0); }
void IfcPhysicalQuantity::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPhysicalQuantity::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcPhysicalQuantity::Description() { return *entity->getArgument(1); }
void IfcPhysicalQuantity::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcExternalReferenceRelationship::list IfcPhysicalQuantity::HasExternalReferences() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
IfcPhysicalComplexQuantity::list IfcPhysicalQuantity::PartOfComplex() { RETURN_INVERSE(IfcPhysicalComplexQuantity) }
bool IfcPhysicalQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalQuantity; }
Type::Enum IfcPhysicalQuantity::type() const { return Type::IfcPhysicalQuantity; }
Type::Enum IfcPhysicalQuantity::Class() { return Type::IfcPhysicalQuantity; }
IfcPhysicalQuantity::IfcPhysicalQuantity(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPhysicalQuantity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalQuantity::IfcPhysicalQuantity(IfcLabel v1_Name, boost::optional< IfcText > v2_Description) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPhysicalSimpleQuantity
bool IfcPhysicalSimpleQuantity::hasUnit() { return !entity->getArgument(2)->isNull(); }
IfcNamedUnit* IfcPhysicalSimpleQuantity::Unit() { return (IfcNamedUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcPhysicalSimpleQuantity::setUnit(IfcNamedUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPhysicalSimpleQuantity::is(Type::Enum v) const { return v == Type::IfcPhysicalSimpleQuantity || IfcPhysicalQuantity::is(v); }
Type::Enum IfcPhysicalSimpleQuantity::type() const { return Type::IfcPhysicalSimpleQuantity; }
Type::Enum IfcPhysicalSimpleQuantity::Class() { return Type::IfcPhysicalSimpleQuantity; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(IfcAbstractEntityPtr e) : IfcPhysicalQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPhysicalSimpleQuantity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPhysicalSimpleQuantity::IfcPhysicalSimpleQuantity(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit) : IfcPhysicalQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPile
bool IfcPile::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcPileTypeEnum::IfcPileTypeEnum IfcPile::PredefinedType() { return IfcPileTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPile::setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcPileTypeEnum::ToString(v)); }
bool IfcPile::hasConstructionType() { return !entity->getArgument(9)->isNull(); }
IfcPileConstructionEnum::IfcPileConstructionEnum IfcPile::ConstructionType() { return IfcPileConstructionEnum::FromString(*entity->getArgument(9)); }
void IfcPile::setConstructionType(IfcPileConstructionEnum::IfcPileConstructionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPileConstructionEnum::ToString(v)); }
bool IfcPile::is(Type::Enum v) const { return v == Type::IfcPile || IfcBuildingElement::is(v); }
Type::Enum IfcPile::type() const { return Type::IfcPile; }
Type::Enum IfcPile::Class() { return Type::IfcPile; }
IfcPile::IfcPile(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPile)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPile::IfcPile(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPileTypeEnum::IfcPileTypeEnum > v9_PredefinedType, boost::optional< IfcPileConstructionEnum::IfcPileConstructionEnum > v10_ConstructionType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPileTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } if (v10_ConstructionType) { e->setArgument(9,*v10_ConstructionType,IfcPileConstructionEnum::ToString(*v10_ConstructionType)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPileType
IfcPileTypeEnum::IfcPileTypeEnum IfcPileType::PredefinedType() { return IfcPileTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPileType::setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPileTypeEnum::ToString(v)); }
bool IfcPileType::is(Type::Enum v) const { return v == Type::IfcPileType || IfcBuildingElementType::is(v); }
Type::Enum IfcPileType::type() const { return Type::IfcPileType; }
Type::Enum IfcPileType::Class() { return Type::IfcPileType; }
IfcPileType::IfcPileType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPileType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPileType::IfcPileType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcPileTypeEnum::IfcPileTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcPileTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPipeFitting
bool IfcPipeFitting::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFitting::PredefinedType() { return IfcPipeFittingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPipeFitting::setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcPipeFittingTypeEnum::ToString(v)); }
bool IfcPipeFitting::is(Type::Enum v) const { return v == Type::IfcPipeFitting || IfcFlowFitting::is(v); }
Type::Enum IfcPipeFitting::type() const { return Type::IfcPipeFitting; }
Type::Enum IfcPipeFitting::Class() { return Type::IfcPipeFitting; }
IfcPipeFitting::IfcPipeFitting(IfcAbstractEntityPtr e) : IfcFlowFitting((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPipeFitting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeFitting::IfcPipeFitting(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum > v9_PredefinedType) : IfcFlowFitting((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPipeFittingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPipeFittingType
IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum IfcPipeFittingType::PredefinedType() { return IfcPipeFittingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPipeFittingType::setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPipeFittingTypeEnum::ToString(v)); }
bool IfcPipeFittingType::is(Type::Enum v) const { return v == Type::IfcPipeFittingType || IfcFlowFittingType::is(v); }
Type::Enum IfcPipeFittingType::type() const { return Type::IfcPipeFittingType; }
Type::Enum IfcPipeFittingType::Class() { return Type::IfcPipeFittingType; }
IfcPipeFittingType::IfcPipeFittingType(IfcAbstractEntityPtr e) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPipeFittingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeFittingType::IfcPipeFittingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v10_PredefinedType) : IfcFlowFittingType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcPipeFittingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPipeSegment
bool IfcPipeSegment::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegment::PredefinedType() { return IfcPipeSegmentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPipeSegment::setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcPipeSegmentTypeEnum::ToString(v)); }
bool IfcPipeSegment::is(Type::Enum v) const { return v == Type::IfcPipeSegment || IfcFlowSegment::is(v); }
Type::Enum IfcPipeSegment::type() const { return Type::IfcPipeSegment; }
Type::Enum IfcPipeSegment::Class() { return Type::IfcPipeSegment; }
IfcPipeSegment::IfcPipeSegment(IfcAbstractEntityPtr e) : IfcFlowSegment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPipeSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeSegment::IfcPipeSegment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum > v9_PredefinedType) : IfcFlowSegment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPipeSegmentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPipeSegmentType
IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum IfcPipeSegmentType::PredefinedType() { return IfcPipeSegmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPipeSegmentType::setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPipeSegmentTypeEnum::ToString(v)); }
bool IfcPipeSegmentType::is(Type::Enum v) const { return v == Type::IfcPipeSegmentType || IfcFlowSegmentType::is(v); }
Type::Enum IfcPipeSegmentType::type() const { return Type::IfcPipeSegmentType; }
Type::Enum IfcPipeSegmentType::Class() { return Type::IfcPipeSegmentType; }
IfcPipeSegmentType::IfcPipeSegmentType(IfcAbstractEntityPtr e) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPipeSegmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPipeSegmentType::IfcPipeSegmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v10_PredefinedType) : IfcFlowSegmentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcPipeSegmentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPixelTexture
IfcInteger IfcPixelTexture::Width() { return *entity->getArgument(5); }
void IfcPixelTexture::setWidth(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcInteger IfcPixelTexture::Height() { return *entity->getArgument(6); }
void IfcPixelTexture::setHeight(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcInteger IfcPixelTexture::ColourComponents() { return *entity->getArgument(7); }
void IfcPixelTexture::setColourComponents(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcPixelTexture::is(Type::Enum v) const { return v == Type::IfcPixelTexture || IfcSurfaceTexture::is(v); }
Type::Enum IfcPixelTexture::type() const { return Type::IfcPixelTexture; }
Type::Enum IfcPixelTexture::Class() { return Type::IfcPixelTexture; }
IfcPixelTexture::IfcPixelTexture(IfcAbstractEntityPtr e) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPixelTexture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPixelTexture::IfcPixelTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< IfcIdentifier > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< IfcIdentifier > /*[1:?]*/ > v5_Parameter, IfcInteger v6_Width, IfcInteger v7_Height, IfcInteger v8_ColourComponents) : IfcSurfaceTexture((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_RepeatS)); e->setArgument(1,(v2_RepeatT)); if (v3_Mode) { e->setArgument(2,(*v3_Mode)); } else { e->setArgument(2); } e->setArgument(3,(v4_TextureTransform)); if (v5_Parameter) { e->setArgument(4,(*v5_Parameter)); } else { e->setArgument(4); } e->setArgument(5,(v6_Width)); e->setArgument(6,(v7_Height)); e->setArgument(7,(v8_ColourComponents)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlacement
IfcCartesianPoint* IfcPlacement::Location() { return (IfcCartesianPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcPlacement::setLocation(IfcCartesianPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPlacement::is(Type::Enum v) const { return v == Type::IfcPlacement || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPlacement::type() const { return Type::IfcPlacement; }
Type::Enum IfcPlacement::Class() { return Type::IfcPlacement; }
IfcPlacement::IfcPlacement(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlacement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlacement::IfcPlacement(IfcCartesianPoint* v1_Location) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Location)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlanarBox
IfcAxis2Placement IfcPlanarBox::Placement() { return *entity->getArgument(2); }
void IfcPlanarBox::setPlacement(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPlanarBox::is(Type::Enum v) const { return v == Type::IfcPlanarBox || IfcPlanarExtent::is(v); }
Type::Enum IfcPlanarBox::type() const { return Type::IfcPlanarBox; }
Type::Enum IfcPlanarBox::Class() { return Type::IfcPlanarBox; }
IfcPlanarBox::IfcPlanarBox(IfcAbstractEntityPtr e) : IfcPlanarExtent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlanarBox)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlanarBox::IfcPlanarBox(IfcLengthMeasure v1_SizeInX, IfcLengthMeasure v2_SizeInY, IfcAxis2Placement v3_Placement) : IfcPlanarExtent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SizeInX)); e->setArgument(1,(v2_SizeInY)); e->setArgument(2,(v3_Placement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlanarExtent
IfcLengthMeasure IfcPlanarExtent::SizeInX() { return *entity->getArgument(0); }
void IfcPlanarExtent::setSizeInX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLengthMeasure IfcPlanarExtent::SizeInY() { return *entity->getArgument(1); }
void IfcPlanarExtent::setSizeInY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcPlanarExtent::is(Type::Enum v) const { return v == Type::IfcPlanarExtent || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPlanarExtent::type() const { return Type::IfcPlanarExtent; }
Type::Enum IfcPlanarExtent::Class() { return Type::IfcPlanarExtent; }
IfcPlanarExtent::IfcPlanarExtent(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlanarExtent)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlanarExtent::IfcPlanarExtent(IfcLengthMeasure v1_SizeInX, IfcLengthMeasure v2_SizeInY) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SizeInX)); e->setArgument(1,(v2_SizeInY)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlane
bool IfcPlane::is(Type::Enum v) const { return v == Type::IfcPlane || IfcElementarySurface::is(v); }
Type::Enum IfcPlane::type() const { return Type::IfcPlane; }
Type::Enum IfcPlane::Class() { return Type::IfcPlane; }
IfcPlane::IfcPlane(IfcAbstractEntityPtr e) : IfcElementarySurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlane)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlane::IfcPlane(IfcAxis2Placement3D* v1_Position) : IfcElementarySurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlate
bool IfcPlate::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlate::PredefinedType() { return IfcPlateTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPlate::setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcPlateTypeEnum::ToString(v)); }
bool IfcPlate::is(Type::Enum v) const { return v == Type::IfcPlate || IfcBuildingElement::is(v); }
Type::Enum IfcPlate::type() const { return Type::IfcPlate; }
Type::Enum IfcPlate::Class() { return Type::IfcPlate; }
IfcPlate::IfcPlate(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlate::IfcPlate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPlateTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlateStandardCase
bool IfcPlateStandardCase::is(Type::Enum v) const { return v == Type::IfcPlateStandardCase || IfcPlate::is(v); }
Type::Enum IfcPlateStandardCase::type() const { return Type::IfcPlateStandardCase; }
Type::Enum IfcPlateStandardCase::Class() { return Type::IfcPlateStandardCase; }
IfcPlateStandardCase::IfcPlateStandardCase(IfcAbstractEntityPtr e) : IfcPlate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlateStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlateStandardCase::IfcPlateStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType) : IfcPlate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPlateTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPlateType
IfcPlateTypeEnum::IfcPlateTypeEnum IfcPlateType::PredefinedType() { return IfcPlateTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPlateType::setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPlateTypeEnum::ToString(v)); }
bool IfcPlateType::is(Type::Enum v) const { return v == Type::IfcPlateType || IfcBuildingElementType::is(v); }
Type::Enum IfcPlateType::type() const { return Type::IfcPlateType; }
Type::Enum IfcPlateType::Class() { return Type::IfcPlateType; }
IfcPlateType::IfcPlateType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPlateType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPlateType::IfcPlateType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcPlateTypeEnum::IfcPlateTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcPlateTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPoint
bool IfcPoint::is(Type::Enum v) const { return v == Type::IfcPoint || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcPoint::type() const { return Type::IfcPoint; }
Type::Enum IfcPoint::Class() { return Type::IfcPoint; }
IfcPoint::IfcPoint(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPoint)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPoint::IfcPoint() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPointOnCurve
IfcCurve* IfcPointOnCurve::BasisCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcPointOnCurve::setBasisCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcParameterValue IfcPointOnCurve::PointParameter() { return *entity->getArgument(1); }
void IfcPointOnCurve::setPointParameter(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcPointOnCurve::is(Type::Enum v) const { return v == Type::IfcPointOnCurve || IfcPoint::is(v); }
Type::Enum IfcPointOnCurve::type() const { return Type::IfcPointOnCurve; }
Type::Enum IfcPointOnCurve::Class() { return Type::IfcPointOnCurve; }
IfcPointOnCurve::IfcPointOnCurve(IfcAbstractEntityPtr e) : IfcPoint((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPointOnCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPointOnCurve::IfcPointOnCurve(IfcCurve* v1_BasisCurve, IfcParameterValue v2_PointParameter) : IfcPoint((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisCurve)); e->setArgument(1,(v2_PointParameter)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPointOnSurface
IfcSurface* IfcPointOnSurface::BasisSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcPointOnSurface::setBasisSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcParameterValue IfcPointOnSurface::PointParameterU() { return *entity->getArgument(1); }
void IfcPointOnSurface::setPointParameterU(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcParameterValue IfcPointOnSurface::PointParameterV() { return *entity->getArgument(2); }
void IfcPointOnSurface::setPointParameterV(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPointOnSurface::is(Type::Enum v) const { return v == Type::IfcPointOnSurface || IfcPoint::is(v); }
Type::Enum IfcPointOnSurface::type() const { return Type::IfcPointOnSurface; }
Type::Enum IfcPointOnSurface::Class() { return Type::IfcPointOnSurface; }
IfcPointOnSurface::IfcPointOnSurface(IfcAbstractEntityPtr e) : IfcPoint((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPointOnSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPointOnSurface::IfcPointOnSurface(IfcSurface* v1_BasisSurface, IfcParameterValue v2_PointParameterU, IfcParameterValue v3_PointParameterV) : IfcPoint((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisSurface)); e->setArgument(1,(v2_PointParameterU)); e->setArgument(2,(v3_PointParameterV)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPolyLoop
SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > IfcPolyLoop::Polygon() { RETURN_AS_LIST(IfcCartesianPoint,0) }
void IfcPolyLoop::setPolygon(SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcPolyLoop::is(Type::Enum v) const { return v == Type::IfcPolyLoop || IfcLoop::is(v); }
Type::Enum IfcPolyLoop::type() const { return Type::IfcPolyLoop; }
Type::Enum IfcPolyLoop::Class() { return Type::IfcPolyLoop; }
IfcPolyLoop::IfcPolyLoop(IfcAbstractEntityPtr e) : IfcLoop((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPolyLoop)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolyLoop::IfcPolyLoop(SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v1_Polygon) : IfcLoop((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Polygon)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPolygonalBoundedHalfSpace
IfcAxis2Placement3D* IfcPolygonalBoundedHalfSpace::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcPolygonalBoundedHalfSpace::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcBoundedCurve* IfcPolygonalBoundedHalfSpace::PolygonalBoundary() { return (IfcBoundedCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcPolygonalBoundedHalfSpace::setPolygonalBoundary(IfcBoundedCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPolygonalBoundedHalfSpace::is(Type::Enum v) const { return v == Type::IfcPolygonalBoundedHalfSpace || IfcHalfSpaceSolid::is(v); }
Type::Enum IfcPolygonalBoundedHalfSpace::type() const { return Type::IfcPolygonalBoundedHalfSpace; }
Type::Enum IfcPolygonalBoundedHalfSpace::Class() { return Type::IfcPolygonalBoundedHalfSpace; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcAbstractEntityPtr e) : IfcHalfSpaceSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPolygonalBoundedHalfSpace)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolygonalBoundedHalfSpace::IfcPolygonalBoundedHalfSpace(IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcAxis2Placement3D* v3_Position, IfcBoundedCurve* v4_PolygonalBoundary) : IfcHalfSpaceSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BaseSurface)); e->setArgument(1,(v2_AgreementFlag)); e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_PolygonalBoundary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPolyline
SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > IfcPolyline::Points() { RETURN_AS_LIST(IfcCartesianPoint,0) }
void IfcPolyline::setPoints(SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcPolyline::is(Type::Enum v) const { return v == Type::IfcPolyline || IfcBoundedCurve::is(v); }
Type::Enum IfcPolyline::type() const { return Type::IfcPolyline; }
Type::Enum IfcPolyline::Class() { return Type::IfcPolyline; }
IfcPolyline::IfcPolyline(IfcAbstractEntityPtr e) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPolyline)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPolyline::IfcPolyline(SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v1_Points) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Points)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPort
IfcRelConnectsPortToElement::list IfcPort::ContainedIn() { RETURN_INVERSE(IfcRelConnectsPortToElement) }
IfcRelConnectsPorts::list IfcPort::ConnectedFrom() { RETURN_INVERSE(IfcRelConnectsPorts) }
IfcRelConnectsPorts::list IfcPort::ConnectedTo() { RETURN_INVERSE(IfcRelConnectsPorts) }
bool IfcPort::is(Type::Enum v) const { return v == Type::IfcPort || IfcProduct::is(v); }
Type::Enum IfcPort::type() const { return Type::IfcPort; }
Type::Enum IfcPort::Class() { return Type::IfcPort; }
IfcPort::IfcPort(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPort)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPort::IfcPort(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPostalAddress
bool IfcPostalAddress::hasInternalLocation() { return !entity->getArgument(3)->isNull(); }
IfcLabel IfcPostalAddress::InternalLocation() { return *entity->getArgument(3); }
void IfcPostalAddress::setInternalLocation(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPostalAddress::hasAddressLines() { return !entity->getArgument(4)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcPostalAddress::AddressLines() { return *entity->getArgument(4); }
void IfcPostalAddress::setAddressLines(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPostalAddress::hasPostalBox() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcPostalAddress::PostalBox() { return *entity->getArgument(5); }
void IfcPostalAddress::setPostalBox(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPostalAddress::hasTown() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcPostalAddress::Town() { return *entity->getArgument(6); }
void IfcPostalAddress::setTown(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcPostalAddress::hasRegion() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcPostalAddress::Region() { return *entity->getArgument(7); }
void IfcPostalAddress::setRegion(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcPostalAddress::hasPostalCode() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcPostalAddress::PostalCode() { return *entity->getArgument(8); }
void IfcPostalAddress::setPostalCode(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcPostalAddress::hasCountry() { return !entity->getArgument(9)->isNull(); }
IfcLabel IfcPostalAddress::Country() { return *entity->getArgument(9); }
void IfcPostalAddress::setCountry(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcPostalAddress::is(Type::Enum v) const { return v == Type::IfcPostalAddress || IfcAddress::is(v); }
Type::Enum IfcPostalAddress::type() const { return Type::IfcPostalAddress; }
Type::Enum IfcPostalAddress::Class() { return Type::IfcPostalAddress; }
IfcPostalAddress::IfcPostalAddress(IfcAbstractEntityPtr e) : IfcAddress((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPostalAddress)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPostalAddress::IfcPostalAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< IfcText > v2_Description, boost::optional< IfcLabel > v3_UserDefinedPurpose, boost::optional< IfcLabel > v4_InternalLocation, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v5_AddressLines, boost::optional< IfcLabel > v6_PostalBox, boost::optional< IfcLabel > v7_Town, boost::optional< IfcLabel > v8_Region, boost::optional< IfcLabel > v9_PostalCode, boost::optional< IfcLabel > v10_Country) : IfcAddress((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Purpose) { e->setArgument(0,*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_UserDefinedPurpose) { e->setArgument(2,(*v3_UserDefinedPurpose)); } else { e->setArgument(2); } if (v4_InternalLocation) { e->setArgument(3,(*v4_InternalLocation)); } else { e->setArgument(3); } if (v5_AddressLines) { e->setArgument(4,(*v5_AddressLines)); } else { e->setArgument(4); } if (v6_PostalBox) { e->setArgument(5,(*v6_PostalBox)); } else { e->setArgument(5); } if (v7_Town) { e->setArgument(6,(*v7_Town)); } else { e->setArgument(6); } if (v8_Region) { e->setArgument(7,(*v8_Region)); } else { e->setArgument(7); } if (v9_PostalCode) { e->setArgument(8,(*v9_PostalCode)); } else { e->setArgument(8); } if (v10_Country) { e->setArgument(9,(*v10_Country)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedColour
bool IfcPreDefinedColour::is(Type::Enum v) const { return v == Type::IfcPreDefinedColour || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedColour::type() const { return Type::IfcPreDefinedColour; }
Type::Enum IfcPreDefinedColour::Class() { return Type::IfcPreDefinedColour; }
IfcPreDefinedColour::IfcPreDefinedColour(IfcAbstractEntityPtr e) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedColour)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedColour::IfcPreDefinedColour(IfcLabel v1_Name) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedCurveFont
bool IfcPreDefinedCurveFont::is(Type::Enum v) const { return v == Type::IfcPreDefinedCurveFont || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedCurveFont::type() const { return Type::IfcPreDefinedCurveFont; }
Type::Enum IfcPreDefinedCurveFont::Class() { return Type::IfcPreDefinedCurveFont; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(IfcAbstractEntityPtr e) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedCurveFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedCurveFont::IfcPreDefinedCurveFont(IfcLabel v1_Name) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedItem
IfcLabel IfcPreDefinedItem::Name() { return *entity->getArgument(0); }
void IfcPreDefinedItem::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPreDefinedItem::is(Type::Enum v) const { return v == Type::IfcPreDefinedItem || IfcPresentationItem::is(v); }
Type::Enum IfcPreDefinedItem::type() const { return Type::IfcPreDefinedItem; }
Type::Enum IfcPreDefinedItem::Class() { return Type::IfcPreDefinedItem; }
IfcPreDefinedItem::IfcPreDefinedItem(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedItem::IfcPreDefinedItem(IfcLabel v1_Name) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedProperties
bool IfcPreDefinedProperties::is(Type::Enum v) const { return v == Type::IfcPreDefinedProperties || IfcPropertyAbstraction::is(v); }
Type::Enum IfcPreDefinedProperties::type() const { return Type::IfcPreDefinedProperties; }
Type::Enum IfcPreDefinedProperties::Class() { return Type::IfcPreDefinedProperties; }
IfcPreDefinedProperties::IfcPreDefinedProperties(IfcAbstractEntityPtr e) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedProperties::IfcPreDefinedProperties() : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedPropertySet
bool IfcPreDefinedPropertySet::is(Type::Enum v) const { return v == Type::IfcPreDefinedPropertySet || IfcPropertySetDefinition::is(v); }
Type::Enum IfcPreDefinedPropertySet::type() const { return Type::IfcPreDefinedPropertySet; }
Type::Enum IfcPreDefinedPropertySet::Class() { return Type::IfcPreDefinedPropertySet; }
IfcPreDefinedPropertySet::IfcPreDefinedPropertySet(IfcAbstractEntityPtr e) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedPropertySet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedPropertySet::IfcPreDefinedPropertySet(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPreDefinedTextFont
bool IfcPreDefinedTextFont::is(Type::Enum v) const { return v == Type::IfcPreDefinedTextFont || IfcPreDefinedItem::is(v); }
Type::Enum IfcPreDefinedTextFont::type() const { return Type::IfcPreDefinedTextFont; }
Type::Enum IfcPreDefinedTextFont::Class() { return Type::IfcPreDefinedTextFont; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(IfcAbstractEntityPtr e) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPreDefinedTextFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPreDefinedTextFont::IfcPreDefinedTextFont(IfcLabel v1_Name) : IfcPreDefinedItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPresentationItem
bool IfcPresentationItem::is(Type::Enum v) const { return v == Type::IfcPresentationItem; }
Type::Enum IfcPresentationItem::type() const { return Type::IfcPresentationItem; }
Type::Enum IfcPresentationItem::Class() { return Type::IfcPresentationItem; }
IfcPresentationItem::IfcPresentationItem(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPresentationItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationItem::IfcPresentationItem() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPresentationLayerAssignment
IfcLabel IfcPresentationLayerAssignment::Name() { return *entity->getArgument(0); }
void IfcPresentationLayerAssignment::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPresentationLayerAssignment::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcPresentationLayerAssignment::Description() { return *entity->getArgument(1); }
void IfcPresentationLayerAssignment::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPresentationLayerAssignment::AssignedItems() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcPresentationLayerAssignment::setAssignedItems(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcPresentationLayerAssignment::hasIdentifier() { return !entity->getArgument(3)->isNull(); }
IfcIdentifier IfcPresentationLayerAssignment::Identifier() { return *entity->getArgument(3); }
void IfcPresentationLayerAssignment::setIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPresentationLayerAssignment::is(Type::Enum v) const { return v == Type::IfcPresentationLayerAssignment; }
Type::Enum IfcPresentationLayerAssignment::type() const { return Type::IfcPresentationLayerAssignment; }
Type::Enum IfcPresentationLayerAssignment::Class() { return Type::IfcPresentationLayerAssignment; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPresentationLayerAssignment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationLayerAssignment::IfcPresentationLayerAssignment(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcEntities v3_AssignedItems, boost::optional< IfcIdentifier > v4_Identifier) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_AssignedItems)); if (v4_Identifier) { e->setArgument(3,(*v4_Identifier)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPresentationLayerWithStyle
bool IfcPresentationLayerWithStyle::LayerOn() { return *entity->getArgument(4); }
void IfcPresentationLayerWithStyle::setLayerOn(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPresentationLayerWithStyle::LayerFrozen() { return *entity->getArgument(5); }
void IfcPresentationLayerWithStyle::setLayerFrozen(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPresentationLayerWithStyle::LayerBlocked() { return *entity->getArgument(6); }
void IfcPresentationLayerWithStyle::setLayerBlocked(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcPresentationStyle > > IfcPresentationLayerWithStyle::LayerStyles() { RETURN_AS_LIST(IfcPresentationStyle,7) }
void IfcPresentationLayerWithStyle::setLayerStyles(SHARED_PTR< IfcTemplatedEntityList< IfcPresentationStyle > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcPresentationLayerWithStyle::is(Type::Enum v) const { return v == Type::IfcPresentationLayerWithStyle || IfcPresentationLayerAssignment::is(v); }
Type::Enum IfcPresentationLayerWithStyle::type() const { return Type::IfcPresentationLayerWithStyle; }
Type::Enum IfcPresentationLayerWithStyle::Class() { return Type::IfcPresentationLayerWithStyle; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(IfcAbstractEntityPtr e) : IfcPresentationLayerAssignment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPresentationLayerWithStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationLayerWithStyle::IfcPresentationLayerWithStyle(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcEntities v3_AssignedItems, boost::optional< IfcIdentifier > v4_Identifier, bool v5_LayerOn, bool v6_LayerFrozen, bool v7_LayerBlocked, SHARED_PTR< IfcTemplatedEntityList< IfcPresentationStyle > > v8_LayerStyles) : IfcPresentationLayerAssignment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_AssignedItems)); if (v4_Identifier) { e->setArgument(3,(*v4_Identifier)); } else { e->setArgument(3); } e->setArgument(4,(v5_LayerOn)); e->setArgument(5,(v6_LayerFrozen)); e->setArgument(6,(v7_LayerBlocked)); e->setArgument(7,(v8_LayerStyles)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPresentationStyle
bool IfcPresentationStyle::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcPresentationStyle::Name() { return *entity->getArgument(0); }
void IfcPresentationStyle::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcPresentationStyle::is(Type::Enum v) const { return v == Type::IfcPresentationStyle; }
Type::Enum IfcPresentationStyle::type() const { return Type::IfcPresentationStyle; }
Type::Enum IfcPresentationStyle::Class() { return Type::IfcPresentationStyle; }
IfcPresentationStyle::IfcPresentationStyle(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPresentationStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationStyle::IfcPresentationStyle(boost::optional< IfcLabel > v1_Name) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPresentationStyleAssignment
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPresentationStyleAssignment::Styles() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcPresentationStyleAssignment::setStyles(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcPresentationStyleAssignment::is(Type::Enum v) const { return v == Type::IfcPresentationStyleAssignment; }
Type::Enum IfcPresentationStyleAssignment::type() const { return Type::IfcPresentationStyleAssignment; }
Type::Enum IfcPresentationStyleAssignment::Class() { return Type::IfcPresentationStyleAssignment; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPresentationStyleAssignment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPresentationStyleAssignment::IfcPresentationStyleAssignment(IfcEntities v1_Styles) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Styles)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProcedure
bool IfcProcedure::hasPredefinedType() { return !entity->getArgument(7)->isNull(); }
IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedure::PredefinedType() { return IfcProcedureTypeEnum::FromString(*entity->getArgument(7)); }
void IfcProcedure::setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcProcedureTypeEnum::ToString(v)); }
bool IfcProcedure::is(Type::Enum v) const { return v == Type::IfcProcedure || IfcProcess::is(v); }
Type::Enum IfcProcedure::type() const { return Type::IfcProcedure; }
Type::Enum IfcProcedure::Class() { return Type::IfcProcedure; }
IfcProcedure::IfcProcedure(IfcAbstractEntityPtr e) : IfcProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProcedure)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProcedure::IfcProcedure(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, boost::optional< IfcProcedureTypeEnum::IfcProcedureTypeEnum > v8_PredefinedType) : IfcProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } if (v8_PredefinedType) { e->setArgument(7,*v8_PredefinedType,IfcProcedureTypeEnum::ToString(*v8_PredefinedType)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProcedureType
IfcProcedureTypeEnum::IfcProcedureTypeEnum IfcProcedureType::PredefinedType() { return IfcProcedureTypeEnum::FromString(*entity->getArgument(9)); }
void IfcProcedureType::setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcProcedureTypeEnum::ToString(v)); }
bool IfcProcedureType::is(Type::Enum v) const { return v == Type::IfcProcedureType || IfcTypeProcess::is(v); }
Type::Enum IfcProcedureType::type() const { return Type::IfcProcedureType; }
Type::Enum IfcProcedureType::Class() { return Type::IfcProcedureType; }
IfcProcedureType::IfcProcedureType(IfcAbstractEntityPtr e) : IfcTypeProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProcedureType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProcedureType::IfcProcedureType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ProcessType, IfcProcedureTypeEnum::IfcProcedureTypeEnum v10_PredefinedType) : IfcTypeProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ProcessType) { e->setArgument(8,(*v9_ProcessType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcProcedureTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProcess
bool IfcProcess::hasIdentification() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcProcess::Identification() { return *entity->getArgument(5); }
void IfcProcess::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcProcess::hasLongDescription() { return !entity->getArgument(6)->isNull(); }
IfcText IfcProcess::LongDescription() { return *entity->getArgument(6); }
void IfcProcess::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcRelSequence::list IfcProcess::IsPredecessorTo() { RETURN_INVERSE(IfcRelSequence) }
IfcRelSequence::list IfcProcess::IsSuccessorFrom() { RETURN_INVERSE(IfcRelSequence) }
IfcRelAssignsToProcess::list IfcProcess::OperatesOn() { RETURN_INVERSE(IfcRelAssignsToProcess) }
bool IfcProcess::is(Type::Enum v) const { return v == Type::IfcProcess || IfcObject::is(v); }
Type::Enum IfcProcess::type() const { return Type::IfcProcess; }
Type::Enum IfcProcess::Class() { return Type::IfcProcess; }
IfcProcess::IfcProcess(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProcess)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProcess::IfcProcess(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProduct
bool IfcProduct::hasObjectPlacement() { return !entity->getArgument(5)->isNull(); }
IfcObjectPlacement* IfcProduct::ObjectPlacement() { return (IfcObjectPlacement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcProduct::setObjectPlacement(IfcObjectPlacement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcProduct::hasRepresentation() { return !entity->getArgument(6)->isNull(); }
IfcProductRepresentation* IfcProduct::Representation() { return (IfcProductRepresentation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcProduct::setRepresentation(IfcProductRepresentation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcRelAssignsToProduct::list IfcProduct::ReferencedBy() { RETURN_INVERSE(IfcRelAssignsToProduct) }
bool IfcProduct::is(Type::Enum v) const { return v == Type::IfcProduct || IfcObject::is(v); }
Type::Enum IfcProduct::type() const { return Type::IfcProduct; }
Type::Enum IfcProduct::Class() { return Type::IfcProduct; }
IfcProduct::IfcProduct(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProduct)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProduct::IfcProduct(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProductDefinitionShape
IfcProduct::list IfcProductDefinitionShape::ShapeOfProduct() { RETURN_INVERSE(IfcProduct) }
IfcShapeAspect::list IfcProductDefinitionShape::HasShapeAspects() { RETURN_INVERSE(IfcShapeAspect) }
bool IfcProductDefinitionShape::is(Type::Enum v) const { return v == Type::IfcProductDefinitionShape || IfcProductRepresentation::is(v); }
Type::Enum IfcProductDefinitionShape::type() const { return Type::IfcProductDefinitionShape; }
Type::Enum IfcProductDefinitionShape::Class() { return Type::IfcProductDefinitionShape; }
IfcProductDefinitionShape::IfcProductDefinitionShape(IfcAbstractEntityPtr e) : IfcProductRepresentation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProductDefinitionShape)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProductDefinitionShape::IfcProductDefinitionShape(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentation > > v3_Representations) : IfcProductRepresentation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Representations)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProductRepresentation
bool IfcProductRepresentation::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcProductRepresentation::Name() { return *entity->getArgument(0); }
void IfcProductRepresentation::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcProductRepresentation::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcProductRepresentation::Description() { return *entity->getArgument(1); }
void IfcProductRepresentation::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcRepresentation > > IfcProductRepresentation::Representations() { RETURN_AS_LIST(IfcRepresentation,2) }
void IfcProductRepresentation::setRepresentations(SHARED_PTR< IfcTemplatedEntityList< IfcRepresentation > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcProductRepresentation::is(Type::Enum v) const { return v == Type::IfcProductRepresentation; }
Type::Enum IfcProductRepresentation::type() const { return Type::IfcProductRepresentation; }
Type::Enum IfcProductRepresentation::Class() { return Type::IfcProductRepresentation; }
IfcProductRepresentation::IfcProductRepresentation(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcProductRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProductRepresentation::IfcProductRepresentation(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentation > > v3_Representations) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Representations)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProfileDef
IfcProfileTypeEnum::IfcProfileTypeEnum IfcProfileDef::ProfileType() { return IfcProfileTypeEnum::FromString(*entity->getArgument(0)); }
void IfcProfileDef::setProfileType(IfcProfileTypeEnum::IfcProfileTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcProfileTypeEnum::ToString(v)); }
bool IfcProfileDef::hasProfileName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcProfileDef::ProfileName() { return *entity->getArgument(1); }
void IfcProfileDef::setProfileName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcExternalReferenceRelationship::list IfcProfileDef::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
IfcProfileProperties::list IfcProfileDef::HasProperties() { RETURN_INVERSE(IfcProfileProperties) }
bool IfcProfileDef::is(Type::Enum v) const { return v == Type::IfcProfileDef; }
Type::Enum IfcProfileDef::type() const { return Type::IfcProfileDef; }
Type::Enum IfcProfileDef::Class() { return Type::IfcProfileDef; }
IfcProfileDef::IfcProfileDef(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProfileDef::IfcProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProfileProperties
IfcProfileDef* IfcProfileProperties::ProfileDefinition() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcProfileProperties::setProfileDefinition(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcProfileProperties::is(Type::Enum v) const { return v == Type::IfcProfileProperties || IfcExtendedProperties::is(v); }
Type::Enum IfcProfileProperties::type() const { return Type::IfcProfileProperties; }
Type::Enum IfcProfileProperties::Class() { return Type::IfcProfileProperties; }
IfcProfileProperties::IfcProfileProperties(IfcAbstractEntityPtr e) : IfcExtendedProperties((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProfileProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProfileProperties::IfcProfileProperties(boost::optional< IfcIdentifier > v1_Name, boost::optional< IfcText > v2_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v3_Properties, IfcProfileDef* v4_ProfileDefinition) : IfcExtendedProperties((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Properties)->generalize()); e->setArgument(3,(v4_ProfileDefinition)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProject
bool IfcProject::is(Type::Enum v) const { return v == Type::IfcProject || IfcContext::is(v); }
Type::Enum IfcProject::type() const { return Type::IfcProject; }
Type::Enum IfcProject::Class() { return Type::IfcProject; }
IfcProject::IfcProject(IfcAbstractEntityPtr e) : IfcContext((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProject)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProject::IfcProject(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName, boost::optional< IfcLabel > v7_Phase, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationContext > > > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcContext((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } if (v7_Phase) { e->setArgument(6,(*v7_Phase)); } else { e->setArgument(6); } if (v8_RepresentationContexts) { e->setArgument(7,(*v8_RepresentationContexts)->generalize()); } else { e->setArgument(7); } e->setArgument(8,(v9_UnitsInContext)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProjectLibrary
bool IfcProjectLibrary::is(Type::Enum v) const { return v == Type::IfcProjectLibrary || IfcContext::is(v); }
Type::Enum IfcProjectLibrary::type() const { return Type::IfcProjectLibrary; }
Type::Enum IfcProjectLibrary::Class() { return Type::IfcProjectLibrary; }
IfcProjectLibrary::IfcProjectLibrary(IfcAbstractEntityPtr e) : IfcContext((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProjectLibrary)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectLibrary::IfcProjectLibrary(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName, boost::optional< IfcLabel > v7_Phase, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationContext > > > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext) : IfcContext((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } if (v7_Phase) { e->setArgument(6,(*v7_Phase)); } else { e->setArgument(6); } if (v8_RepresentationContexts) { e->setArgument(7,(*v8_RepresentationContexts)->generalize()); } else { e->setArgument(7); } e->setArgument(8,(v9_UnitsInContext)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProjectOrder
bool IfcProjectOrder::hasPredefinedType() { return !entity->getArgument(6)->isNull(); }
IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum IfcProjectOrder::PredefinedType() { return IfcProjectOrderTypeEnum::FromString(*entity->getArgument(6)); }
void IfcProjectOrder::setPredefinedType(IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcProjectOrderTypeEnum::ToString(v)); }
bool IfcProjectOrder::hasStatus() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcProjectOrder::Status() { return *entity->getArgument(7); }
void IfcProjectOrder::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcProjectOrder::hasLongDescription() { return !entity->getArgument(8)->isNull(); }
IfcText IfcProjectOrder::LongDescription() { return *entity->getArgument(8); }
void IfcProjectOrder::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcProjectOrder::is(Type::Enum v) const { return v == Type::IfcProjectOrder || IfcControl::is(v); }
Type::Enum IfcProjectOrder::type() const { return Type::IfcProjectOrder; }
Type::Enum IfcProjectOrder::Class() { return Type::IfcProjectOrder; }
IfcProjectOrder::IfcProjectOrder(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProjectOrder)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectOrder::IfcProjectOrder(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum > v7_PredefinedType, boost::optional< IfcLabel > v8_Status, boost::optional< IfcText > v9_LongDescription) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_PredefinedType) { e->setArgument(6,*v7_PredefinedType,IfcProjectOrderTypeEnum::ToString(*v7_PredefinedType)); } else { e->setArgument(6); } if (v8_Status) { e->setArgument(7,(*v8_Status)); } else { e->setArgument(7); } if (v9_LongDescription) { e->setArgument(8,(*v9_LongDescription)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProjectedCRS
bool IfcProjectedCRS::hasMapProjection() { return !entity->getArgument(4)->isNull(); }
IfcIdentifier IfcProjectedCRS::MapProjection() { return *entity->getArgument(4); }
void IfcProjectedCRS::setMapProjection(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcProjectedCRS::hasMapZone() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcProjectedCRS::MapZone() { return *entity->getArgument(5); }
void IfcProjectedCRS::setMapZone(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcProjectedCRS::hasMapUnit() { return !entity->getArgument(6)->isNull(); }
IfcNamedUnit* IfcProjectedCRS::MapUnit() { return (IfcNamedUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcProjectedCRS::setMapUnit(IfcNamedUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcProjectedCRS::is(Type::Enum v) const { return v == Type::IfcProjectedCRS || IfcCoordinateReferenceSystem::is(v); }
Type::Enum IfcProjectedCRS::type() const { return Type::IfcProjectedCRS; }
Type::Enum IfcProjectedCRS::Class() { return Type::IfcProjectedCRS; }
IfcProjectedCRS::IfcProjectedCRS(IfcAbstractEntityPtr e) : IfcCoordinateReferenceSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProjectedCRS)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectedCRS::IfcProjectedCRS(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcIdentifier v3_GeodeticDatum, boost::optional< IfcIdentifier > v4_VerticalDatum, boost::optional< IfcIdentifier > v5_MapProjection, boost::optional< IfcIdentifier > v6_MapZone, IfcNamedUnit* v7_MapUnit) : IfcCoordinateReferenceSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_GeodeticDatum)); if (v4_VerticalDatum) { e->setArgument(3,(*v4_VerticalDatum)); } else { e->setArgument(3); } if (v5_MapProjection) { e->setArgument(4,(*v5_MapProjection)); } else { e->setArgument(4); } if (v6_MapZone) { e->setArgument(5,(*v6_MapZone)); } else { e->setArgument(5); } e->setArgument(6,(v7_MapUnit)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProjectionElement
bool IfcProjectionElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum IfcProjectionElement::PredefinedType() { return IfcProjectionElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcProjectionElement::setPredefinedType(IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcProjectionElementTypeEnum::ToString(v)); }
bool IfcProjectionElement::is(Type::Enum v) const { return v == Type::IfcProjectionElement || IfcFeatureElementAddition::is(v); }
Type::Enum IfcProjectionElement::type() const { return Type::IfcProjectionElement; }
Type::Enum IfcProjectionElement::Class() { return Type::IfcProjectionElement; }
IfcProjectionElement::IfcProjectionElement(IfcAbstractEntityPtr e) : IfcFeatureElementAddition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProjectionElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProjectionElement::IfcProjectionElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum > v9_PredefinedType) : IfcFeatureElementAddition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcProjectionElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProperty
IfcIdentifier IfcProperty::Name() { return *entity->getArgument(0); }
void IfcProperty::setName(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcProperty::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcProperty::Description() { return *entity->getArgument(1); }
void IfcProperty::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPropertySet::list IfcProperty::PartOfPset() { RETURN_INVERSE(IfcPropertySet) }
IfcPropertyDependencyRelationship::list IfcProperty::PropertyForDependance() { RETURN_INVERSE(IfcPropertyDependencyRelationship) }
IfcPropertyDependencyRelationship::list IfcProperty::PropertyDependsOn() { RETURN_INVERSE(IfcPropertyDependencyRelationship) }
IfcComplexProperty::list IfcProperty::PartOfComplex() { RETURN_INVERSE(IfcComplexProperty) }
bool IfcProperty::is(Type::Enum v) const { return v == Type::IfcProperty || IfcPropertyAbstraction::is(v); }
Type::Enum IfcProperty::type() const { return Type::IfcProperty; }
Type::Enum IfcProperty::Class() { return Type::IfcProperty; }
IfcProperty::IfcProperty(IfcAbstractEntityPtr e) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProperty)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProperty::IfcProperty(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyAbstraction
IfcExternalReferenceRelationship::list IfcPropertyAbstraction::HasExternalReferences() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcPropertyAbstraction::is(Type::Enum v) const { return v == Type::IfcPropertyAbstraction; }
Type::Enum IfcPropertyAbstraction::type() const { return Type::IfcPropertyAbstraction; }
Type::Enum IfcPropertyAbstraction::Class() { return Type::IfcPropertyAbstraction; }
IfcPropertyAbstraction::IfcPropertyAbstraction(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcPropertyAbstraction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyAbstraction::IfcPropertyAbstraction() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyBoundedValue
bool IfcPropertyBoundedValue::hasUpperBoundValue() { return !entity->getArgument(2)->isNull(); }
IfcValue IfcPropertyBoundedValue::UpperBoundValue() { return *entity->getArgument(2); }
void IfcPropertyBoundedValue::setUpperBoundValue(IfcValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPropertyBoundedValue::hasLowerBoundValue() { return !entity->getArgument(3)->isNull(); }
IfcValue IfcPropertyBoundedValue::LowerBoundValue() { return *entity->getArgument(3); }
void IfcPropertyBoundedValue::setLowerBoundValue(IfcValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertyBoundedValue::hasUnit() { return !entity->getArgument(4)->isNull(); }
IfcUnit IfcPropertyBoundedValue::Unit() { return *entity->getArgument(4); }
void IfcPropertyBoundedValue::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPropertyBoundedValue::hasSetPointValue() { return !entity->getArgument(5)->isNull(); }
IfcValue IfcPropertyBoundedValue::SetPointValue() { return *entity->getArgument(5); }
void IfcPropertyBoundedValue::setSetPointValue(IfcValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPropertyBoundedValue::is(Type::Enum v) const { return v == Type::IfcPropertyBoundedValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyBoundedValue::type() const { return Type::IfcPropertyBoundedValue; }
Type::Enum IfcPropertyBoundedValue::Class() { return Type::IfcPropertyBoundedValue; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyBoundedValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyBoundedValue::IfcPropertyBoundedValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcValue > v3_UpperBoundValue, boost::optional< IfcValue > v4_LowerBoundValue, boost::optional< IfcUnit > v5_Unit, boost::optional< IfcValue > v6_SetPointValue) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_UpperBoundValue) { e->setArgument(2,(*v3_UpperBoundValue)); } else { e->setArgument(2); } if (v4_LowerBoundValue) { e->setArgument(3,(*v4_LowerBoundValue)); } else { e->setArgument(3); } if (v5_Unit) { e->setArgument(4,(*v5_Unit)); } else { e->setArgument(4); } if (v6_SetPointValue) { e->setArgument(5,(*v6_SetPointValue)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyDefinition
IfcRelDeclares::list IfcPropertyDefinition::HasContext() { RETURN_INVERSE(IfcRelDeclares) }
IfcRelAssociates::list IfcPropertyDefinition::HasAssociations() { RETURN_INVERSE(IfcRelAssociates) }
bool IfcPropertyDefinition::is(Type::Enum v) const { return v == Type::IfcPropertyDefinition || IfcRoot::is(v); }
Type::Enum IfcPropertyDefinition::type() const { return Type::IfcPropertyDefinition; }
Type::Enum IfcPropertyDefinition::Class() { return Type::IfcPropertyDefinition; }
IfcPropertyDefinition::IfcPropertyDefinition(IfcAbstractEntityPtr e) : IfcRoot((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyDefinition::IfcPropertyDefinition(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRoot((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyDependencyRelationship
IfcProperty* IfcPropertyDependencyRelationship::DependingProperty() { return (IfcProperty*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcPropertyDependencyRelationship::setDependingProperty(IfcProperty* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcProperty* IfcPropertyDependencyRelationship::DependantProperty() { return (IfcProperty*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcPropertyDependencyRelationship::setDependantProperty(IfcProperty* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertyDependencyRelationship::hasExpression() { return !entity->getArgument(4)->isNull(); }
IfcText IfcPropertyDependencyRelationship::Expression() { return *entity->getArgument(4); }
void IfcPropertyDependencyRelationship::setExpression(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPropertyDependencyRelationship::is(Type::Enum v) const { return v == Type::IfcPropertyDependencyRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcPropertyDependencyRelationship::type() const { return Type::IfcPropertyDependencyRelationship; }
Type::Enum IfcPropertyDependencyRelationship::Class() { return Type::IfcPropertyDependencyRelationship; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyDependencyRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyDependencyRelationship::IfcPropertyDependencyRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcProperty* v3_DependingProperty, IfcProperty* v4_DependantProperty, boost::optional< IfcText > v5_Expression) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_DependingProperty)); e->setArgument(3,(v4_DependantProperty)); if (v5_Expression) { e->setArgument(4,(*v5_Expression)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyEnumeratedValue
bool IfcPropertyEnumeratedValue::hasEnumerationValues() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPropertyEnumeratedValue::EnumerationValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcPropertyEnumeratedValue::setEnumerationValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcPropertyEnumeratedValue::hasEnumerationReference() { return !entity->getArgument(3)->isNull(); }
IfcPropertyEnumeration* IfcPropertyEnumeratedValue::EnumerationReference() { return (IfcPropertyEnumeration*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcPropertyEnumeratedValue::setEnumerationReference(IfcPropertyEnumeration* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertyEnumeratedValue::is(Type::Enum v) const { return v == Type::IfcPropertyEnumeratedValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyEnumeratedValue::type() const { return Type::IfcPropertyEnumeratedValue; }
Type::Enum IfcPropertyEnumeratedValue::Class() { return Type::IfcPropertyEnumeratedValue; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyEnumeratedValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyEnumeratedValue::IfcPropertyEnumeratedValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcEntities > v3_EnumerationValues, IfcPropertyEnumeration* v4_EnumerationReference) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_EnumerationValues) { e->setArgument(2,(*v3_EnumerationValues)); } else { e->setArgument(2); } e->setArgument(3,(v4_EnumerationReference)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyEnumeration
IfcLabel IfcPropertyEnumeration::Name() { return *entity->getArgument(0); }
void IfcPropertyEnumeration::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPropertyEnumeration::EnumerationValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,1) }
void IfcPropertyEnumeration::setEnumerationValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcPropertyEnumeration::hasUnit() { return !entity->getArgument(2)->isNull(); }
IfcUnit IfcPropertyEnumeration::Unit() { return *entity->getArgument(2); }
void IfcPropertyEnumeration::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPropertyEnumeration::is(Type::Enum v) const { return v == Type::IfcPropertyEnumeration || IfcPropertyAbstraction::is(v); }
Type::Enum IfcPropertyEnumeration::type() const { return Type::IfcPropertyEnumeration; }
Type::Enum IfcPropertyEnumeration::Class() { return Type::IfcPropertyEnumeration; }
IfcPropertyEnumeration::IfcPropertyEnumeration(IfcAbstractEntityPtr e) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyEnumeration)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyEnumeration::IfcPropertyEnumeration(IfcLabel v1_Name, IfcEntities v2_EnumerationValues, boost::optional< IfcUnit > v3_Unit) : IfcPropertyAbstraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); e->setArgument(1,(v2_EnumerationValues)); if (v3_Unit) { e->setArgument(2,(*v3_Unit)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyListValue
bool IfcPropertyListValue::hasListValues() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPropertyListValue::ListValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcPropertyListValue::setListValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcPropertyListValue::hasUnit() { return !entity->getArgument(3)->isNull(); }
IfcUnit IfcPropertyListValue::Unit() { return *entity->getArgument(3); }
void IfcPropertyListValue::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertyListValue::is(Type::Enum v) const { return v == Type::IfcPropertyListValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyListValue::type() const { return Type::IfcPropertyListValue; }
Type::Enum IfcPropertyListValue::Class() { return Type::IfcPropertyListValue; }
IfcPropertyListValue::IfcPropertyListValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyListValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyListValue::IfcPropertyListValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcEntities > v3_ListValues, boost::optional< IfcUnit > v4_Unit) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_ListValues) { e->setArgument(2,(*v3_ListValues)); } else { e->setArgument(2); } if (v4_Unit) { e->setArgument(3,(*v4_Unit)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyReferenceValue
bool IfcPropertyReferenceValue::hasUsageName() { return !entity->getArgument(2)->isNull(); }
IfcText IfcPropertyReferenceValue::UsageName() { return *entity->getArgument(2); }
void IfcPropertyReferenceValue::setUsageName(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPropertyReferenceValue::hasPropertyReference() { return !entity->getArgument(3)->isNull(); }
IfcObjectReferenceSelect IfcPropertyReferenceValue::PropertyReference() { return *entity->getArgument(3); }
void IfcPropertyReferenceValue::setPropertyReference(IfcObjectReferenceSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertyReferenceValue::is(Type::Enum v) const { return v == Type::IfcPropertyReferenceValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyReferenceValue::type() const { return Type::IfcPropertyReferenceValue; }
Type::Enum IfcPropertyReferenceValue::Class() { return Type::IfcPropertyReferenceValue; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyReferenceValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyReferenceValue::IfcPropertyReferenceValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcText > v3_UsageName, boost::optional< IfcObjectReferenceSelect > v4_PropertyReference) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_UsageName) { e->setArgument(2,(*v3_UsageName)); } else { e->setArgument(2); } if (v4_PropertyReference) { e->setArgument(3,(*v4_PropertyReference)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertySet
SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > IfcPropertySet::HasProperties() { RETURN_AS_LIST(IfcProperty,4) }
void IfcPropertySet::setHasProperties(SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
bool IfcPropertySet::is(Type::Enum v) const { return v == Type::IfcPropertySet || IfcPropertySetDefinition::is(v); }
Type::Enum IfcPropertySet::type() const { return Type::IfcPropertySet; }
Type::Enum IfcPropertySet::Class() { return Type::IfcPropertySet; }
IfcPropertySet::IfcPropertySet(IfcAbstractEntityPtr e) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertySet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySet::IfcPropertySet(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProperty > > v5_HasProperties) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_HasProperties)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertySetDefinition
IfcTypeObject::list IfcPropertySetDefinition::DefinesType() { RETURN_INVERSE(IfcTypeObject) }
IfcRelDefinesByTemplate::list IfcPropertySetDefinition::IsDefinedBy() { RETURN_INVERSE(IfcRelDefinesByTemplate) }
IfcRelDefinesByProperties::list IfcPropertySetDefinition::DefinesOccurrence() { RETURN_INVERSE(IfcRelDefinesByProperties) }
bool IfcPropertySetDefinition::is(Type::Enum v) const { return v == Type::IfcPropertySetDefinition || IfcPropertyDefinition::is(v); }
Type::Enum IfcPropertySetDefinition::type() const { return Type::IfcPropertySetDefinition; }
Type::Enum IfcPropertySetDefinition::Class() { return Type::IfcPropertySetDefinition; }
IfcPropertySetDefinition::IfcPropertySetDefinition(IfcAbstractEntityPtr e) : IfcPropertyDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertySetDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySetDefinition::IfcPropertySetDefinition(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcPropertyDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertySetTemplate
bool IfcPropertySetTemplate::hasTemplateType() { return !entity->getArgument(4)->isNull(); }
IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum IfcPropertySetTemplate::TemplateType() { return IfcPropertySetTemplateTypeEnum::FromString(*entity->getArgument(4)); }
void IfcPropertySetTemplate::setTemplateType(IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcPropertySetTemplateTypeEnum::ToString(v)); }
bool IfcPropertySetTemplate::hasApplicableEntity() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcPropertySetTemplate::ApplicableEntity() { return *entity->getArgument(5); }
void IfcPropertySetTemplate::setApplicableEntity(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > IfcPropertySetTemplate::HasPropertyTemplates() { RETURN_AS_LIST(IfcPropertyTemplate,6) }
void IfcPropertySetTemplate::setHasPropertyTemplates(SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v->generalize()); }
IfcRelDefinesByTemplate::list IfcPropertySetTemplate::Defines() { RETURN_INVERSE(IfcRelDefinesByTemplate) }
bool IfcPropertySetTemplate::is(Type::Enum v) const { return v == Type::IfcPropertySetTemplate || IfcPropertyTemplateDefinition::is(v); }
Type::Enum IfcPropertySetTemplate::type() const { return Type::IfcPropertySetTemplate; }
Type::Enum IfcPropertySetTemplate::Class() { return Type::IfcPropertySetTemplate; }
IfcPropertySetTemplate::IfcPropertySetTemplate(IfcAbstractEntityPtr e) : IfcPropertyTemplateDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertySetTemplate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySetTemplate::IfcPropertySetTemplate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum > v5_TemplateType, boost::optional< IfcIdentifier > v6_ApplicableEntity, SHARED_PTR< IfcTemplatedEntityList< IfcPropertyTemplate > > v7_HasPropertyTemplates) : IfcPropertyTemplateDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_TemplateType) { e->setArgument(4,*v5_TemplateType,IfcPropertySetTemplateTypeEnum::ToString(*v5_TemplateType)); } else { e->setArgument(4); } if (v6_ApplicableEntity) { e->setArgument(5,(*v6_ApplicableEntity)); } else { e->setArgument(5); } e->setArgument(6,(v7_HasPropertyTemplates)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertySingleValue
bool IfcPropertySingleValue::hasNominalValue() { return !entity->getArgument(2)->isNull(); }
IfcValue IfcPropertySingleValue::NominalValue() { return *entity->getArgument(2); }
void IfcPropertySingleValue::setNominalValue(IfcValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcPropertySingleValue::hasUnit() { return !entity->getArgument(3)->isNull(); }
IfcUnit IfcPropertySingleValue::Unit() { return *entity->getArgument(3); }
void IfcPropertySingleValue::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcPropertySingleValue::is(Type::Enum v) const { return v == Type::IfcPropertySingleValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertySingleValue::type() const { return Type::IfcPropertySingleValue; }
Type::Enum IfcPropertySingleValue::Class() { return Type::IfcPropertySingleValue; }
IfcPropertySingleValue::IfcPropertySingleValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertySingleValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertySingleValue::IfcPropertySingleValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcValue > v3_NominalValue, boost::optional< IfcUnit > v4_Unit) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_NominalValue) { e->setArgument(2,(*v3_NominalValue)); } else { e->setArgument(2); } if (v4_Unit) { e->setArgument(3,(*v4_Unit)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyTableValue
bool IfcPropertyTableValue::hasDefiningValues() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPropertyTableValue::DefiningValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcPropertyTableValue::setDefiningValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcPropertyTableValue::hasDefinedValues() { return !entity->getArgument(3)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcPropertyTableValue::DefinedValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,3) }
void IfcPropertyTableValue::setDefinedValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcPropertyTableValue::hasExpression() { return !entity->getArgument(4)->isNull(); }
IfcText IfcPropertyTableValue::Expression() { return *entity->getArgument(4); }
void IfcPropertyTableValue::setExpression(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcPropertyTableValue::hasDefiningUnit() { return !entity->getArgument(5)->isNull(); }
IfcUnit IfcPropertyTableValue::DefiningUnit() { return *entity->getArgument(5); }
void IfcPropertyTableValue::setDefiningUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcPropertyTableValue::hasDefinedUnit() { return !entity->getArgument(6)->isNull(); }
IfcUnit IfcPropertyTableValue::DefinedUnit() { return *entity->getArgument(6); }
void IfcPropertyTableValue::setDefinedUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcPropertyTableValue::hasCurveInterpolation() { return !entity->getArgument(7)->isNull(); }
IfcCurveInterpolationEnum::IfcCurveInterpolationEnum IfcPropertyTableValue::CurveInterpolation() { return IfcCurveInterpolationEnum::FromString(*entity->getArgument(7)); }
void IfcPropertyTableValue::setCurveInterpolation(IfcCurveInterpolationEnum::IfcCurveInterpolationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcCurveInterpolationEnum::ToString(v)); }
bool IfcPropertyTableValue::is(Type::Enum v) const { return v == Type::IfcPropertyTableValue || IfcSimpleProperty::is(v); }
Type::Enum IfcPropertyTableValue::type() const { return Type::IfcPropertyTableValue; }
Type::Enum IfcPropertyTableValue::Class() { return Type::IfcPropertyTableValue; }
IfcPropertyTableValue::IfcPropertyTableValue(IfcAbstractEntityPtr e) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyTableValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyTableValue::IfcPropertyTableValue(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description, boost::optional< IfcEntities > v3_DefiningValues, boost::optional< IfcEntities > v4_DefinedValues, boost::optional< IfcText > v5_Expression, boost::optional< IfcUnit > v6_DefiningUnit, boost::optional< IfcUnit > v7_DefinedUnit, boost::optional< IfcCurveInterpolationEnum::IfcCurveInterpolationEnum > v8_CurveInterpolation) : IfcSimpleProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_DefiningValues) { e->setArgument(2,(*v3_DefiningValues)); } else { e->setArgument(2); } if (v4_DefinedValues) { e->setArgument(3,(*v4_DefinedValues)); } else { e->setArgument(3); } if (v5_Expression) { e->setArgument(4,(*v5_Expression)); } else { e->setArgument(4); } if (v6_DefiningUnit) { e->setArgument(5,(*v6_DefiningUnit)); } else { e->setArgument(5); } if (v7_DefinedUnit) { e->setArgument(6,(*v7_DefinedUnit)); } else { e->setArgument(6); } if (v8_CurveInterpolation) { e->setArgument(7,*v8_CurveInterpolation,IfcCurveInterpolationEnum::ToString(*v8_CurveInterpolation)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyTemplate
IfcComplexPropertyTemplate::list IfcPropertyTemplate::PartOfComplexTemplate() { RETURN_INVERSE(IfcComplexPropertyTemplate) }
IfcPropertySetTemplate::list IfcPropertyTemplate::PartOfPsetTemplate() { RETURN_INVERSE(IfcPropertySetTemplate) }
bool IfcPropertyTemplate::is(Type::Enum v) const { return v == Type::IfcPropertyTemplate || IfcPropertyTemplateDefinition::is(v); }
Type::Enum IfcPropertyTemplate::type() const { return Type::IfcPropertyTemplate; }
Type::Enum IfcPropertyTemplate::Class() { return Type::IfcPropertyTemplate; }
IfcPropertyTemplate::IfcPropertyTemplate(IfcAbstractEntityPtr e) : IfcPropertyTemplateDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyTemplate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyTemplate::IfcPropertyTemplate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcPropertyTemplateDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPropertyTemplateDefinition
bool IfcPropertyTemplateDefinition::is(Type::Enum v) const { return v == Type::IfcPropertyTemplateDefinition || IfcPropertyDefinition::is(v); }
Type::Enum IfcPropertyTemplateDefinition::type() const { return Type::IfcPropertyTemplateDefinition; }
Type::Enum IfcPropertyTemplateDefinition::Class() { return Type::IfcPropertyTemplateDefinition; }
IfcPropertyTemplateDefinition::IfcPropertyTemplateDefinition(IfcAbstractEntityPtr e) : IfcPropertyDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPropertyTemplateDefinition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPropertyTemplateDefinition::IfcPropertyTemplateDefinition(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcPropertyDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProtectiveDevice
bool IfcProtectiveDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDevice::PredefinedType() { return IfcProtectiveDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcProtectiveDevice::setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcProtectiveDeviceTypeEnum::ToString(v)); }
bool IfcProtectiveDevice::is(Type::Enum v) const { return v == Type::IfcProtectiveDevice || IfcFlowController::is(v); }
Type::Enum IfcProtectiveDevice::type() const { return Type::IfcProtectiveDevice; }
Type::Enum IfcProtectiveDevice::Class() { return Type::IfcProtectiveDevice; }
IfcProtectiveDevice::IfcProtectiveDevice(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProtectiveDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProtectiveDevice::IfcProtectiveDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcProtectiveDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProtectiveDeviceTrippingUnit
bool IfcProtectiveDeviceTrippingUnit::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnit::PredefinedType() { return IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(*entity->getArgument(8)); }
void IfcProtectiveDeviceTrippingUnit::setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v)); }
bool IfcProtectiveDeviceTrippingUnit::is(Type::Enum v) const { return v == Type::IfcProtectiveDeviceTrippingUnit || IfcDistributionControlElement::is(v); }
Type::Enum IfcProtectiveDeviceTrippingUnit::type() const { return Type::IfcProtectiveDeviceTrippingUnit; }
Type::Enum IfcProtectiveDeviceTrippingUnit::Class() { return Type::IfcProtectiveDeviceTrippingUnit; }
IfcProtectiveDeviceTrippingUnit::IfcProtectiveDeviceTrippingUnit(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProtectiveDeviceTrippingUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProtectiveDeviceTrippingUnit::IfcProtectiveDeviceTrippingUnit(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProtectiveDeviceTrippingUnitType
IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum IfcProtectiveDeviceTrippingUnitType::PredefinedType() { return IfcProtectiveDeviceTrippingUnitTypeEnum::FromString(*entity->getArgument(9)); }
void IfcProtectiveDeviceTrippingUnitType::setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v)); }
bool IfcProtectiveDeviceTrippingUnitType::is(Type::Enum v) const { return v == Type::IfcProtectiveDeviceTrippingUnitType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcProtectiveDeviceTrippingUnitType::type() const { return Type::IfcProtectiveDeviceTrippingUnitType; }
Type::Enum IfcProtectiveDeviceTrippingUnitType::Class() { return Type::IfcProtectiveDeviceTrippingUnitType; }
IfcProtectiveDeviceTrippingUnitType::IfcProtectiveDeviceTrippingUnitType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProtectiveDeviceTrippingUnitType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProtectiveDeviceTrippingUnitType::IfcProtectiveDeviceTrippingUnitType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcProtectiveDeviceTrippingUnitTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProtectiveDeviceType
IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum IfcProtectiveDeviceType::PredefinedType() { return IfcProtectiveDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcProtectiveDeviceType::setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcProtectiveDeviceTypeEnum::ToString(v)); }
bool IfcProtectiveDeviceType::is(Type::Enum v) const { return v == Type::IfcProtectiveDeviceType || IfcFlowControllerType::is(v); }
Type::Enum IfcProtectiveDeviceType::type() const { return Type::IfcProtectiveDeviceType; }
Type::Enum IfcProtectiveDeviceType::Class() { return Type::IfcProtectiveDeviceType; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProtectiveDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProtectiveDeviceType::IfcProtectiveDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcProtectiveDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcProxy
IfcObjectTypeEnum::IfcObjectTypeEnum IfcProxy::ProxyType() { return IfcObjectTypeEnum::FromString(*entity->getArgument(7)); }
void IfcProxy::setProxyType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcObjectTypeEnum::ToString(v)); }
bool IfcProxy::hasTag() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcProxy::Tag() { return *entity->getArgument(8); }
void IfcProxy::setTag(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcProxy::is(Type::Enum v) const { return v == Type::IfcProxy || IfcProduct::is(v); }
Type::Enum IfcProxy::type() const { return Type::IfcProxy; }
Type::Enum IfcProxy::Class() { return Type::IfcProxy; }
IfcProxy::IfcProxy(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcProxy)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcProxy::IfcProxy(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcObjectTypeEnum::IfcObjectTypeEnum v8_ProxyType, boost::optional< IfcLabel > v9_Tag) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,v8_ProxyType,IfcObjectTypeEnum::ToString(v8_ProxyType)); if (v9_Tag) { e->setArgument(8,(*v9_Tag)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPump
bool IfcPump::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcPumpTypeEnum::IfcPumpTypeEnum IfcPump::PredefinedType() { return IfcPumpTypeEnum::FromString(*entity->getArgument(8)); }
void IfcPump::setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcPumpTypeEnum::ToString(v)); }
bool IfcPump::is(Type::Enum v) const { return v == Type::IfcPump || IfcFlowMovingDevice::is(v); }
Type::Enum IfcPump::type() const { return Type::IfcPump; }
Type::Enum IfcPump::Class() { return Type::IfcPump; }
IfcPump::IfcPump(IfcAbstractEntityPtr e) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPump)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPump::IfcPump(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPumpTypeEnum::IfcPumpTypeEnum > v9_PredefinedType) : IfcFlowMovingDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcPumpTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcPumpType
IfcPumpTypeEnum::IfcPumpTypeEnum IfcPumpType::PredefinedType() { return IfcPumpTypeEnum::FromString(*entity->getArgument(9)); }
void IfcPumpType::setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcPumpTypeEnum::ToString(v)); }
bool IfcPumpType::is(Type::Enum v) const { return v == Type::IfcPumpType || IfcFlowMovingDeviceType::is(v); }
Type::Enum IfcPumpType::type() const { return Type::IfcPumpType; }
Type::Enum IfcPumpType::Class() { return Type::IfcPumpType; }
IfcPumpType::IfcPumpType(IfcAbstractEntityPtr e) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcPumpType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcPumpType::IfcPumpType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcPumpTypeEnum::IfcPumpTypeEnum v10_PredefinedType) : IfcFlowMovingDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcPumpTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityArea
IfcAreaMeasure IfcQuantityArea::AreaValue() { return *entity->getArgument(3); }
void IfcQuantityArea::setAreaValue(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityArea::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityArea::Formula() { return *entity->getArgument(4); }
void IfcQuantityArea::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityArea::is(Type::Enum v) const { return v == Type::IfcQuantityArea || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityArea::type() const { return Type::IfcQuantityArea; }
Type::Enum IfcQuantityArea::Class() { return Type::IfcQuantityArea; }
IfcQuantityArea::IfcQuantityArea(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityArea)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityArea::IfcQuantityArea(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcAreaMeasure v4_AreaValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_AreaValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityCount
IfcCountMeasure IfcQuantityCount::CountValue() { return *entity->getArgument(3); }
void IfcQuantityCount::setCountValue(IfcCountMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityCount::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityCount::Formula() { return *entity->getArgument(4); }
void IfcQuantityCount::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityCount::is(Type::Enum v) const { return v == Type::IfcQuantityCount || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityCount::type() const { return Type::IfcQuantityCount; }
Type::Enum IfcQuantityCount::Class() { return Type::IfcQuantityCount; }
IfcQuantityCount::IfcQuantityCount(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityCount)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityCount::IfcQuantityCount(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcCountMeasure v4_CountValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_CountValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityLength
IfcLengthMeasure IfcQuantityLength::LengthValue() { return *entity->getArgument(3); }
void IfcQuantityLength::setLengthValue(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityLength::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityLength::Formula() { return *entity->getArgument(4); }
void IfcQuantityLength::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityLength::is(Type::Enum v) const { return v == Type::IfcQuantityLength || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityLength::type() const { return Type::IfcQuantityLength; }
Type::Enum IfcQuantityLength::Class() { return Type::IfcQuantityLength; }
IfcQuantityLength::IfcQuantityLength(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityLength)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityLength::IfcQuantityLength(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcLengthMeasure v4_LengthValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_LengthValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantitySet
bool IfcQuantitySet::is(Type::Enum v) const { return v == Type::IfcQuantitySet || IfcPropertySetDefinition::is(v); }
Type::Enum IfcQuantitySet::type() const { return Type::IfcQuantitySet; }
Type::Enum IfcQuantitySet::Class() { return Type::IfcQuantitySet; }
IfcQuantitySet::IfcQuantitySet(IfcAbstractEntityPtr e) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantitySet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantitySet::IfcQuantitySet(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcPropertySetDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityTime
IfcTimeMeasure IfcQuantityTime::TimeValue() { return *entity->getArgument(3); }
void IfcQuantityTime::setTimeValue(IfcTimeMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityTime::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityTime::Formula() { return *entity->getArgument(4); }
void IfcQuantityTime::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityTime::is(Type::Enum v) const { return v == Type::IfcQuantityTime || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityTime::type() const { return Type::IfcQuantityTime; }
Type::Enum IfcQuantityTime::Class() { return Type::IfcQuantityTime; }
IfcQuantityTime::IfcQuantityTime(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityTime::IfcQuantityTime(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcTimeMeasure v4_TimeValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_TimeValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityVolume
IfcVolumeMeasure IfcQuantityVolume::VolumeValue() { return *entity->getArgument(3); }
void IfcQuantityVolume::setVolumeValue(IfcVolumeMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityVolume::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityVolume::Formula() { return *entity->getArgument(4); }
void IfcQuantityVolume::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityVolume::is(Type::Enum v) const { return v == Type::IfcQuantityVolume || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityVolume::type() const { return Type::IfcQuantityVolume; }
Type::Enum IfcQuantityVolume::Class() { return Type::IfcQuantityVolume; }
IfcQuantityVolume::IfcQuantityVolume(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityVolume)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityVolume::IfcQuantityVolume(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcVolumeMeasure v4_VolumeValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_VolumeValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcQuantityWeight
IfcMassMeasure IfcQuantityWeight::WeightValue() { return *entity->getArgument(3); }
void IfcQuantityWeight::setWeightValue(IfcMassMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcQuantityWeight::hasFormula() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcQuantityWeight::Formula() { return *entity->getArgument(4); }
void IfcQuantityWeight::setFormula(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcQuantityWeight::is(Type::Enum v) const { return v == Type::IfcQuantityWeight || IfcPhysicalSimpleQuantity::is(v); }
Type::Enum IfcQuantityWeight::type() const { return Type::IfcQuantityWeight; }
Type::Enum IfcQuantityWeight::Class() { return Type::IfcQuantityWeight; }
IfcQuantityWeight::IfcQuantityWeight(IfcAbstractEntityPtr e) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcQuantityWeight)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcQuantityWeight::IfcQuantityWeight(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcNamedUnit* v3_Unit, IfcMassMeasure v4_WeightValue, boost::optional< IfcLabel > v5_Formula) : IfcPhysicalSimpleQuantity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_Unit)); e->setArgument(3,(v4_WeightValue)); if (v5_Formula) { e->setArgument(4,(*v5_Formula)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRailing
bool IfcRailing::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailing::PredefinedType() { return IfcRailingTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRailing::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcRailingTypeEnum::ToString(v)); }
bool IfcRailing::is(Type::Enum v) const { return v == Type::IfcRailing || IfcBuildingElement::is(v); }
Type::Enum IfcRailing::type() const { return Type::IfcRailing; }
Type::Enum IfcRailing::Class() { return Type::IfcRailing; }
IfcRailing::IfcRailing(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRailing)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRailing::IfcRailing(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcRailingTypeEnum::IfcRailingTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcRailingTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRailingType
IfcRailingTypeEnum::IfcRailingTypeEnum IfcRailingType::PredefinedType() { return IfcRailingTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRailingType::setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcRailingTypeEnum::ToString(v)); }
bool IfcRailingType::is(Type::Enum v) const { return v == Type::IfcRailingType || IfcBuildingElementType::is(v); }
Type::Enum IfcRailingType::type() const { return Type::IfcRailingType; }
Type::Enum IfcRailingType::Class() { return Type::IfcRailingType; }
IfcRailingType::IfcRailingType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRailingType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRailingType::IfcRailingType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcRailingTypeEnum::IfcRailingTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcRailingTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRamp
bool IfcRamp::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcRampTypeEnum::IfcRampTypeEnum IfcRamp::PredefinedType() { return IfcRampTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRamp::setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcRampTypeEnum::ToString(v)); }
bool IfcRamp::is(Type::Enum v) const { return v == Type::IfcRamp || IfcBuildingElement::is(v); }
Type::Enum IfcRamp::type() const { return Type::IfcRamp; }
Type::Enum IfcRamp::Class() { return Type::IfcRamp; }
IfcRamp::IfcRamp(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRamp)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRamp::IfcRamp(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcRampTypeEnum::IfcRampTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcRampTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRampFlight
bool IfcRampFlight::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlight::PredefinedType() { return IfcRampFlightTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRampFlight::setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcRampFlightTypeEnum::ToString(v)); }
bool IfcRampFlight::is(Type::Enum v) const { return v == Type::IfcRampFlight || IfcBuildingElement::is(v); }
Type::Enum IfcRampFlight::type() const { return Type::IfcRampFlight; }
Type::Enum IfcRampFlight::Class() { return Type::IfcRampFlight; }
IfcRampFlight::IfcRampFlight(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRampFlight)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRampFlight::IfcRampFlight(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcRampFlightTypeEnum::IfcRampFlightTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcRampFlightTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRampFlightType
IfcRampFlightTypeEnum::IfcRampFlightTypeEnum IfcRampFlightType::PredefinedType() { return IfcRampFlightTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRampFlightType::setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcRampFlightTypeEnum::ToString(v)); }
bool IfcRampFlightType::is(Type::Enum v) const { return v == Type::IfcRampFlightType || IfcBuildingElementType::is(v); }
Type::Enum IfcRampFlightType::type() const { return Type::IfcRampFlightType; }
Type::Enum IfcRampFlightType::Class() { return Type::IfcRampFlightType; }
IfcRampFlightType::IfcRampFlightType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRampFlightType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRampFlightType::IfcRampFlightType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcRampFlightTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRampType
IfcRampTypeEnum::IfcRampTypeEnum IfcRampType::PredefinedType() { return IfcRampTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRampType::setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcRampTypeEnum::ToString(v)); }
bool IfcRampType::is(Type::Enum v) const { return v == Type::IfcRampType || IfcBuildingElementType::is(v); }
Type::Enum IfcRampType::type() const { return Type::IfcRampType; }
Type::Enum IfcRampType::Class() { return Type::IfcRampType; }
IfcRampType::IfcRampType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRampType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRampType::IfcRampType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcRampTypeEnum::IfcRampTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcRampTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRationalBSplineCurveWithKnots
std::vector< double > /*[2:?]*/ IfcRationalBSplineCurveWithKnots::WeightsData() { return *entity->getArgument(8); }
void IfcRationalBSplineCurveWithKnots::setWeightsData(std::vector< double > /*[2:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcRationalBSplineCurveWithKnots::is(Type::Enum v) const { return v == Type::IfcRationalBSplineCurveWithKnots || IfcBSplineCurveWithKnots::is(v); }
Type::Enum IfcRationalBSplineCurveWithKnots::type() const { return Type::IfcRationalBSplineCurveWithKnots; }
Type::Enum IfcRationalBSplineCurveWithKnots::Class() { return Type::IfcRationalBSplineCurveWithKnots; }
IfcRationalBSplineCurveWithKnots::IfcRationalBSplineCurveWithKnots(IfcAbstractEntityPtr e) : IfcBSplineCurveWithKnots((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRationalBSplineCurveWithKnots)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRationalBSplineCurveWithKnots::IfcRationalBSplineCurveWithKnots(int v1_Degree, SHARED_PTR< IfcTemplatedEntityList< IfcCartesianPoint > > v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< IfcParameterValue > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec, std::vector< double > /*[2:?]*/ v9_WeightsData) : IfcBSplineCurveWithKnots((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Degree)); e->setArgument(1,(v2_ControlPointsList)->generalize()); e->setArgument(2,v3_CurveForm,IfcBSplineCurveForm::ToString(v3_CurveForm)); e->setArgument(3,(v4_ClosedCurve)); e->setArgument(4,(v5_SelfIntersect)); e->setArgument(5,(v6_KnotMultiplicities)); e->setArgument(6,(v7_Knots)); e->setArgument(7,v8_KnotSpec,IfcKnotType::ToString(v8_KnotSpec)); e->setArgument(8,(v9_WeightsData)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRationalBSplineSurfaceWithKnots
bool IfcRationalBSplineSurfaceWithKnots::is(Type::Enum v) const { return v == Type::IfcRationalBSplineSurfaceWithKnots || IfcBSplineSurfaceWithKnots::is(v); }
Type::Enum IfcRationalBSplineSurfaceWithKnots::type() const { return Type::IfcRationalBSplineSurfaceWithKnots; }
Type::Enum IfcRationalBSplineSurfaceWithKnots::Class() { return Type::IfcRationalBSplineSurfaceWithKnots; }
IfcRationalBSplineSurfaceWithKnots::IfcRationalBSplineSurfaceWithKnots(IfcAbstractEntityPtr e) : IfcBSplineSurfaceWithKnots((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRationalBSplineSurfaceWithKnots)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRationalBSplineSurfaceWithKnots::IfcRationalBSplineSurfaceWithKnots(int v1_UDegree, int v2_VDegree, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< IfcParameterValue > /*[2:?]*/ v10_UKnots, std::vector< IfcParameterValue > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec) : IfcBSplineSurfaceWithKnots((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_UDegree)); e->setArgument(1,(v2_VDegree)); e->setArgument(3,v4_SurfaceForm,IfcBSplineSurfaceForm::ToString(v4_SurfaceForm)); e->setArgument(4,(v5_UClosed)); e->setArgument(5,(v6_VClosed)); e->setArgument(6,(v7_SelfIntersect)); e->setArgument(7,(v8_UMultiplicities)); e->setArgument(8,(v9_VMultiplicities)); e->setArgument(9,(v10_UKnots)); e->setArgument(10,(v11_VKnots)); e->setArgument(11,v12_KnotSpec,IfcKnotType::ToString(v12_KnotSpec)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRectangleHollowProfileDef
IfcPositiveLengthMeasure IfcRectangleHollowProfileDef::WallThickness() { return *entity->getArgument(5); }
void IfcRectangleHollowProfileDef::setWallThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRectangleHollowProfileDef::hasInnerFilletRadius() { return !entity->getArgument(6)->isNull(); }
IfcNonNegativeLengthMeasure IfcRectangleHollowProfileDef::InnerFilletRadius() { return *entity->getArgument(6); }
void IfcRectangleHollowProfileDef::setInnerFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRectangleHollowProfileDef::hasOuterFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcRectangleHollowProfileDef::OuterFilletRadius() { return *entity->getArgument(7); }
void IfcRectangleHollowProfileDef::setOuterFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRectangleHollowProfileDef::is(Type::Enum v) const { return v == Type::IfcRectangleHollowProfileDef || IfcRectangleProfileDef::is(v); }
Type::Enum IfcRectangleHollowProfileDef::type() const { return Type::IfcRectangleHollowProfileDef; }
Type::Enum IfcRectangleHollowProfileDef::Class() { return Type::IfcRectangleHollowProfileDef; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcAbstractEntityPtr e) : IfcRectangleProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRectangleHollowProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangleHollowProfileDef::IfcRectangleHollowProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_XDim, IfcPositiveLengthMeasure v5_YDim, IfcPositiveLengthMeasure v6_WallThickness, boost::optional< IfcNonNegativeLengthMeasure > v7_InnerFilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v8_OuterFilletRadius) : IfcRectangleProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_XDim)); e->setArgument(4,(v5_YDim)); e->setArgument(5,(v6_WallThickness)); if (v7_InnerFilletRadius) { e->setArgument(6,(*v7_InnerFilletRadius)); } else { e->setArgument(6); } if (v8_OuterFilletRadius) { e->setArgument(7,(*v8_OuterFilletRadius)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRectangleProfileDef
IfcPositiveLengthMeasure IfcRectangleProfileDef::XDim() { return *entity->getArgument(3); }
void IfcRectangleProfileDef::setXDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcRectangleProfileDef::YDim() { return *entity->getArgument(4); }
void IfcRectangleProfileDef::setYDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcRectangleProfileDef::is(Type::Enum v) const { return v == Type::IfcRectangleProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcRectangleProfileDef::type() const { return Type::IfcRectangleProfileDef; }
Type::Enum IfcRectangleProfileDef::Class() { return Type::IfcRectangleProfileDef; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRectangleProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangleProfileDef::IfcRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_XDim, IfcPositiveLengthMeasure v5_YDim) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_XDim)); e->setArgument(4,(v5_YDim)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRectangularPyramid
IfcPositiveLengthMeasure IfcRectangularPyramid::XLength() { return *entity->getArgument(1); }
void IfcRectangularPyramid::setXLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcRectangularPyramid::YLength() { return *entity->getArgument(2); }
void IfcRectangularPyramid::setYLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPositiveLengthMeasure IfcRectangularPyramid::Height() { return *entity->getArgument(3); }
void IfcRectangularPyramid::setHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcRectangularPyramid::is(Type::Enum v) const { return v == Type::IfcRectangularPyramid || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRectangularPyramid::type() const { return Type::IfcRectangularPyramid; }
Type::Enum IfcRectangularPyramid::Class() { return Type::IfcRectangularPyramid; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcAbstractEntityPtr e) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRectangularPyramid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangularPyramid::IfcRectangularPyramid(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_XLength, IfcPositiveLengthMeasure v3_YLength, IfcPositiveLengthMeasure v4_Height) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_XLength)); e->setArgument(2,(v3_YLength)); e->setArgument(3,(v4_Height)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRectangularTrimmedSurface
IfcSurface* IfcRectangularTrimmedSurface::BasisSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcRectangularTrimmedSurface::setBasisSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcParameterValue IfcRectangularTrimmedSurface::U1() { return *entity->getArgument(1); }
void IfcRectangularTrimmedSurface::setU1(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcParameterValue IfcRectangularTrimmedSurface::V1() { return *entity->getArgument(2); }
void IfcRectangularTrimmedSurface::setV1(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcParameterValue IfcRectangularTrimmedSurface::U2() { return *entity->getArgument(3); }
void IfcRectangularTrimmedSurface::setU2(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcParameterValue IfcRectangularTrimmedSurface::V2() { return *entity->getArgument(4); }
void IfcRectangularTrimmedSurface::setV2(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcRectangularTrimmedSurface::Usense() { return *entity->getArgument(5); }
void IfcRectangularTrimmedSurface::setUsense(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRectangularTrimmedSurface::Vsense() { return *entity->getArgument(6); }
void IfcRectangularTrimmedSurface::setVsense(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRectangularTrimmedSurface::is(Type::Enum v) const { return v == Type::IfcRectangularTrimmedSurface || IfcBoundedSurface::is(v); }
Type::Enum IfcRectangularTrimmedSurface::type() const { return Type::IfcRectangularTrimmedSurface; }
Type::Enum IfcRectangularTrimmedSurface::Class() { return Type::IfcRectangularTrimmedSurface; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcAbstractEntityPtr e) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRectangularTrimmedSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRectangularTrimmedSurface::IfcRectangularTrimmedSurface(IfcSurface* v1_BasisSurface, IfcParameterValue v2_U1, IfcParameterValue v3_V1, IfcParameterValue v4_U2, IfcParameterValue v5_V2, bool v6_Usense, bool v7_Vsense) : IfcBoundedSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisSurface)); e->setArgument(1,(v2_U1)); e->setArgument(2,(v3_V1)); e->setArgument(3,(v4_U2)); e->setArgument(4,(v5_V2)); e->setArgument(5,(v6_Usense)); e->setArgument(6,(v7_Vsense)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRecurrencePattern
IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum IfcRecurrencePattern::RecurrenceType() { return IfcRecurrenceTypeEnum::FromString(*entity->getArgument(0)); }
void IfcRecurrencePattern::setRecurrenceType(IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcRecurrenceTypeEnum::ToString(v)); }
bool IfcRecurrencePattern::hasDayComponent() { return !entity->getArgument(1)->isNull(); }
std::vector< IfcDayInMonthNumber > /*[1:?]*/ IfcRecurrencePattern::DayComponent() { return *entity->getArgument(1); }
void IfcRecurrencePattern::setDayComponent(std::vector< IfcDayInMonthNumber > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcRecurrencePattern::hasWeekdayComponent() { return !entity->getArgument(2)->isNull(); }
std::vector< IfcDayInWeekNumber > /*[1:?]*/ IfcRecurrencePattern::WeekdayComponent() { return *entity->getArgument(2); }
void IfcRecurrencePattern::setWeekdayComponent(std::vector< IfcDayInWeekNumber > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcRecurrencePattern::hasMonthComponent() { return !entity->getArgument(3)->isNull(); }
std::vector< IfcMonthInYearNumber > /*[1:?]*/ IfcRecurrencePattern::MonthComponent() { return *entity->getArgument(3); }
void IfcRecurrencePattern::setMonthComponent(std::vector< IfcMonthInYearNumber > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcRecurrencePattern::hasPosition() { return !entity->getArgument(4)->isNull(); }
IfcInteger IfcRecurrencePattern::Position() { return *entity->getArgument(4); }
void IfcRecurrencePattern::setPosition(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcRecurrencePattern::hasInterval() { return !entity->getArgument(5)->isNull(); }
IfcInteger IfcRecurrencePattern::Interval() { return *entity->getArgument(5); }
void IfcRecurrencePattern::setInterval(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRecurrencePattern::hasOccurrences() { return !entity->getArgument(6)->isNull(); }
IfcInteger IfcRecurrencePattern::Occurrences() { return *entity->getArgument(6); }
void IfcRecurrencePattern::setOccurrences(IfcInteger v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRecurrencePattern::hasTimePeriods() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcTimePeriod > > IfcRecurrencePattern::TimePeriods() { RETURN_AS_LIST(IfcTimePeriod,7) }
void IfcRecurrencePattern::setTimePeriods(SHARED_PTR< IfcTemplatedEntityList< IfcTimePeriod > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcRecurrencePattern::is(Type::Enum v) const { return v == Type::IfcRecurrencePattern; }
Type::Enum IfcRecurrencePattern::type() const { return Type::IfcRecurrencePattern; }
Type::Enum IfcRecurrencePattern::Class() { return Type::IfcRecurrencePattern; }
IfcRecurrencePattern::IfcRecurrencePattern(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRecurrencePattern)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRecurrencePattern::IfcRecurrencePattern(IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v1_RecurrenceType, boost::optional< std::vector< IfcDayInMonthNumber > /*[1:?]*/ > v2_DayComponent, boost::optional< std::vector< IfcDayInWeekNumber > /*[1:?]*/ > v3_WeekdayComponent, boost::optional< std::vector< IfcMonthInYearNumber > /*[1:?]*/ > v4_MonthComponent, boost::optional< IfcInteger > v5_Position, boost::optional< IfcInteger > v6_Interval, boost::optional< IfcInteger > v7_Occurrences, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcTimePeriod > > > v8_TimePeriods) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_RecurrenceType,IfcRecurrenceTypeEnum::ToString(v1_RecurrenceType)); if (v2_DayComponent) { e->setArgument(1,(*v2_DayComponent)); } else { e->setArgument(1); } if (v3_WeekdayComponent) { e->setArgument(2,(*v3_WeekdayComponent)); } else { e->setArgument(2); } if (v4_MonthComponent) { e->setArgument(3,(*v4_MonthComponent)); } else { e->setArgument(3); } if (v5_Position) { e->setArgument(4,(*v5_Position)); } else { e->setArgument(4); } if (v6_Interval) { e->setArgument(5,(*v6_Interval)); } else { e->setArgument(5); } if (v7_Occurrences) { e->setArgument(6,(*v7_Occurrences)); } else { e->setArgument(6); } if (v8_TimePeriods) { e->setArgument(7,(*v8_TimePeriods)->generalize()); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReference
bool IfcReference::hasTypeIdentifier() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcReference::TypeIdentifier() { return *entity->getArgument(0); }
void IfcReference::setTypeIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcReference::hasAttributeIdentifier() { return !entity->getArgument(1)->isNull(); }
IfcIdentifier IfcReference::AttributeIdentifier() { return *entity->getArgument(1); }
void IfcReference::setAttributeIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcReference::hasInstanceName() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcReference::InstanceName() { return *entity->getArgument(2); }
void IfcReference::setInstanceName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcReference::hasListPositions() { return !entity->getArgument(3)->isNull(); }
std::vector< int > /*[1:?]*/ IfcReference::ListPositions() { return *entity->getArgument(3); }
void IfcReference::setListPositions(std::vector< int > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcReference::hasInnerReference() { return !entity->getArgument(4)->isNull(); }
IfcReference* IfcReference::InnerReference() { return (IfcReference*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcReference::setInnerReference(IfcReference* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcReference::is(Type::Enum v) const { return v == Type::IfcReference; }
Type::Enum IfcReference::type() const { return Type::IfcReference; }
Type::Enum IfcReference::Class() { return Type::IfcReference; }
IfcReference::IfcReference(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcReference)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReference::IfcReference(boost::optional< IfcIdentifier > v1_TypeIdentifier, boost::optional< IfcIdentifier > v2_AttributeIdentifier, boost::optional< IfcLabel > v3_InstanceName, boost::optional< std::vector< int > /*[1:?]*/ > v4_ListPositions, IfcReference* v5_InnerReference) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_TypeIdentifier) { e->setArgument(0,(*v1_TypeIdentifier)); } else { e->setArgument(0); } if (v2_AttributeIdentifier) { e->setArgument(1,(*v2_AttributeIdentifier)); } else { e->setArgument(1); } if (v3_InstanceName) { e->setArgument(2,(*v3_InstanceName)); } else { e->setArgument(2); } if (v4_ListPositions) { e->setArgument(3,(*v4_ListPositions)); } else { e->setArgument(3); } e->setArgument(4,(v5_InnerReference)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRegularTimeSeries
IfcTimeMeasure IfcRegularTimeSeries::TimeStep() { return *entity->getArgument(8); }
void IfcRegularTimeSeries::setTimeStep(IfcTimeMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcTimeSeriesValue > > IfcRegularTimeSeries::Values() { RETURN_AS_LIST(IfcTimeSeriesValue,9) }
void IfcRegularTimeSeries::setValues(SHARED_PTR< IfcTemplatedEntityList< IfcTimeSeriesValue > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v->generalize()); }
bool IfcRegularTimeSeries::is(Type::Enum v) const { return v == Type::IfcRegularTimeSeries || IfcTimeSeries::is(v); }
Type::Enum IfcRegularTimeSeries::type() const { return Type::IfcRegularTimeSeries; }
Type::Enum IfcRegularTimeSeries::Class() { return Type::IfcRegularTimeSeries; }
IfcRegularTimeSeries::IfcRegularTimeSeries(IfcAbstractEntityPtr e) : IfcTimeSeries((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRegularTimeSeries)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRegularTimeSeries::IfcRegularTimeSeries(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcDateTime v3_StartTime, IfcDateTime v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< IfcLabel > v7_UserDefinedDataOrigin, boost::optional< IfcUnit > v8_Unit, IfcTimeMeasure v9_TimeStep, SHARED_PTR< IfcTemplatedEntityList< IfcTimeSeriesValue > > v10_Values) : IfcTimeSeries((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_StartTime)); e->setArgument(3,(v4_EndTime)); e->setArgument(4,v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType)); e->setArgument(5,v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin)); if (v7_UserDefinedDataOrigin) { e->setArgument(6,(*v7_UserDefinedDataOrigin)); } else { e->setArgument(6); } if (v8_Unit) { e->setArgument(7,(*v8_Unit)); } else { e->setArgument(7); } e->setArgument(8,(v9_TimeStep)); e->setArgument(9,(v10_Values)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcementBarProperties
IfcAreaMeasure IfcReinforcementBarProperties::TotalCrossSectionArea() { return *entity->getArgument(0); }
void IfcReinforcementBarProperties::setTotalCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLabel IfcReinforcementBarProperties::SteelGrade() { return *entity->getArgument(1); }
void IfcReinforcementBarProperties::setSteelGrade(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcReinforcementBarProperties::hasBarSurface() { return !entity->getArgument(2)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcementBarProperties::BarSurface() { return IfcReinforcingBarSurfaceEnum::FromString(*entity->getArgument(2)); }
void IfcReinforcementBarProperties::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcReinforcingBarSurfaceEnum::ToString(v)); }
bool IfcReinforcementBarProperties::hasEffectiveDepth() { return !entity->getArgument(3)->isNull(); }
IfcLengthMeasure IfcReinforcementBarProperties::EffectiveDepth() { return *entity->getArgument(3); }
void IfcReinforcementBarProperties::setEffectiveDepth(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcReinforcementBarProperties::hasNominalBarDiameter() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcementBarProperties::NominalBarDiameter() { return *entity->getArgument(4); }
void IfcReinforcementBarProperties::setNominalBarDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcReinforcementBarProperties::hasBarCount() { return !entity->getArgument(5)->isNull(); }
IfcCountMeasure IfcReinforcementBarProperties::BarCount() { return *entity->getArgument(5); }
void IfcReinforcementBarProperties::setBarCount(IfcCountMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcReinforcementBarProperties::is(Type::Enum v) const { return v == Type::IfcReinforcementBarProperties || IfcPreDefinedProperties::is(v); }
Type::Enum IfcReinforcementBarProperties::type() const { return Type::IfcReinforcementBarProperties; }
Type::Enum IfcReinforcementBarProperties::Class() { return Type::IfcReinforcementBarProperties; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(IfcAbstractEntityPtr e) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcementBarProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcementBarProperties::IfcReinforcementBarProperties(IfcAreaMeasure v1_TotalCrossSectionArea, IfcLabel v2_SteelGrade, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v3_BarSurface, boost::optional< IfcLengthMeasure > v4_EffectiveDepth, boost::optional< IfcPositiveLengthMeasure > v5_NominalBarDiameter, boost::optional< IfcCountMeasure > v6_BarCount) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_TotalCrossSectionArea)); e->setArgument(1,(v2_SteelGrade)); if (v3_BarSurface) { e->setArgument(2,*v3_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v3_BarSurface)); } else { e->setArgument(2); } if (v4_EffectiveDepth) { e->setArgument(3,(*v4_EffectiveDepth)); } else { e->setArgument(3); } if (v5_NominalBarDiameter) { e->setArgument(4,(*v5_NominalBarDiameter)); } else { e->setArgument(4); } if (v6_BarCount) { e->setArgument(5,(*v6_BarCount)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcementDefinitionProperties
bool IfcReinforcementDefinitionProperties::hasDefinitionType() { return !entity->getArgument(4)->isNull(); }
IfcLabel IfcReinforcementDefinitionProperties::DefinitionType() { return *entity->getArgument(4); }
void IfcReinforcementDefinitionProperties::setDefinitionType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcSectionReinforcementProperties > > IfcReinforcementDefinitionProperties::ReinforcementSectionDefinitions() { RETURN_AS_LIST(IfcSectionReinforcementProperties,5) }
void IfcReinforcementDefinitionProperties::setReinforcementSectionDefinitions(SHARED_PTR< IfcTemplatedEntityList< IfcSectionReinforcementProperties > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcReinforcementDefinitionProperties::is(Type::Enum v) const { return v == Type::IfcReinforcementDefinitionProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcReinforcementDefinitionProperties::type() const { return Type::IfcReinforcementDefinitionProperties; }
Type::Enum IfcReinforcementDefinitionProperties::Class() { return Type::IfcReinforcementDefinitionProperties; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcementDefinitionProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcementDefinitionProperties::IfcReinforcementDefinitionProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_DefinitionType, SHARED_PTR< IfcTemplatedEntityList< IfcSectionReinforcementProperties > > v6_ReinforcementSectionDefinitions) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_DefinitionType) { e->setArgument(4,(*v5_DefinitionType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ReinforcementSectionDefinitions)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingBar
bool IfcReinforcingBar::hasNominalDiameter() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingBar::NominalDiameter() { return *entity->getArgument(9); }
void IfcReinforcingBar::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcReinforcingBar::hasCrossSectionArea() { return !entity->getArgument(10)->isNull(); }
IfcAreaMeasure IfcReinforcingBar::CrossSectionArea() { return *entity->getArgument(10); }
void IfcReinforcingBar::setCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcReinforcingBar::hasBarLength() { return !entity->getArgument(11)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingBar::BarLength() { return *entity->getArgument(11); }
void IfcReinforcingBar::setBarLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcReinforcingBar::hasPredefinedType() { return !entity->getArgument(12)->isNull(); }
IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBar::PredefinedType() { return IfcReinforcingBarTypeEnum::FromString(*entity->getArgument(12)); }
void IfcReinforcingBar::setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v,IfcReinforcingBarTypeEnum::ToString(v)); }
bool IfcReinforcingBar::hasBarSurface() { return !entity->getArgument(13)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBar::BarSurface() { return IfcReinforcingBarSurfaceEnum::FromString(*entity->getArgument(13)); }
void IfcReinforcingBar::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v,IfcReinforcingBarSurfaceEnum::ToString(v)); }
bool IfcReinforcingBar::is(Type::Enum v) const { return v == Type::IfcReinforcingBar || IfcReinforcingElement::is(v); }
Type::Enum IfcReinforcingBar::type() const { return Type::IfcReinforcingBar; }
Type::Enum IfcReinforcingBar::Class() { return Type::IfcReinforcingBar; }
IfcReinforcingBar::IfcReinforcingBar(IfcAbstractEntityPtr e) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingBar)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingBar::IfcReinforcingBar(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLabel > v9_SteelGrade, boost::optional< IfcPositiveLengthMeasure > v10_NominalDiameter, boost::optional< IfcAreaMeasure > v11_CrossSectionArea, boost::optional< IfcPositiveLengthMeasure > v12_BarLength, boost::optional< IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum > v13_PredefinedType, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_SteelGrade) { e->setArgument(8,(*v9_SteelGrade)); } else { e->setArgument(8); } if (v10_NominalDiameter) { e->setArgument(9,(*v10_NominalDiameter)); } else { e->setArgument(9); } if (v11_CrossSectionArea) { e->setArgument(10,(*v11_CrossSectionArea)); } else { e->setArgument(10); } if (v12_BarLength) { e->setArgument(11,(*v12_BarLength)); } else { e->setArgument(11); } if (v13_PredefinedType) { e->setArgument(12,*v13_PredefinedType,IfcReinforcingBarTypeEnum::ToString(*v13_PredefinedType)); } else { e->setArgument(12); } if (v14_BarSurface) { e->setArgument(13,*v14_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface)); } else { e->setArgument(13); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingBarType
IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum IfcReinforcingBarType::PredefinedType() { return IfcReinforcingBarTypeEnum::FromString(*entity->getArgument(9)); }
void IfcReinforcingBarType::setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcReinforcingBarTypeEnum::ToString(v)); }
bool IfcReinforcingBarType::hasNominalDiameter() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingBarType::NominalDiameter() { return *entity->getArgument(10); }
void IfcReinforcingBarType::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcReinforcingBarType::hasCrossSectionArea() { return !entity->getArgument(11)->isNull(); }
IfcAreaMeasure IfcReinforcingBarType::CrossSectionArea() { return *entity->getArgument(11); }
void IfcReinforcingBarType::setCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcReinforcingBarType::hasBarLength() { return !entity->getArgument(12)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingBarType::BarLength() { return *entity->getArgument(12); }
void IfcReinforcingBarType::setBarLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcReinforcingBarType::hasBarSurface() { return !entity->getArgument(13)->isNull(); }
IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum IfcReinforcingBarType::BarSurface() { return IfcReinforcingBarSurfaceEnum::FromString(*entity->getArgument(13)); }
void IfcReinforcingBarType::setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v,IfcReinforcingBarSurfaceEnum::ToString(v)); }
bool IfcReinforcingBarType::hasBendingShapeCode() { return !entity->getArgument(14)->isNull(); }
IfcLabel IfcReinforcingBarType::BendingShapeCode() { return *entity->getArgument(14); }
void IfcReinforcingBarType::setBendingShapeCode(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcReinforcingBarType::hasBendingParameters() { return !entity->getArgument(15)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcReinforcingBarType::BendingParameters() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,15) }
void IfcReinforcingBarType::setBendingParameters(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v->generalize()); }
bool IfcReinforcingBarType::is(Type::Enum v) const { return v == Type::IfcReinforcingBarType || IfcReinforcingElementType::is(v); }
Type::Enum IfcReinforcingBarType::type() const { return Type::IfcReinforcingBarType; }
Type::Enum IfcReinforcingBarType::Class() { return Type::IfcReinforcingBarType; }
IfcReinforcingBarType::IfcReinforcingBarType(IfcAbstractEntityPtr e) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingBarType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingBarType::IfcReinforcingBarType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v10_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v11_NominalDiameter, boost::optional< IfcAreaMeasure > v12_CrossSectionArea, boost::optional< IfcPositiveLengthMeasure > v13_BarLength, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface, boost::optional< IfcLabel > v15_BendingShapeCode, boost::optional< IfcEntities > v16_BendingParameters) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcReinforcingBarTypeEnum::ToString(v10_PredefinedType)); if (v11_NominalDiameter) { e->setArgument(10,(*v11_NominalDiameter)); } else { e->setArgument(10); } if (v12_CrossSectionArea) { e->setArgument(11,(*v12_CrossSectionArea)); } else { e->setArgument(11); } if (v13_BarLength) { e->setArgument(12,(*v13_BarLength)); } else { e->setArgument(12); } if (v14_BarSurface) { e->setArgument(13,*v14_BarSurface,IfcReinforcingBarSurfaceEnum::ToString(*v14_BarSurface)); } else { e->setArgument(13); } if (v15_BendingShapeCode) { e->setArgument(14,(*v15_BendingShapeCode)); } else { e->setArgument(14); } if (v16_BendingParameters) { e->setArgument(15,(*v16_BendingParameters)); } else { e->setArgument(15); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingElement
bool IfcReinforcingElement::hasSteelGrade() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcReinforcingElement::SteelGrade() { return *entity->getArgument(8); }
void IfcReinforcingElement::setSteelGrade(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcReinforcingElement::is(Type::Enum v) const { return v == Type::IfcReinforcingElement || IfcElementComponent::is(v); }
Type::Enum IfcReinforcingElement::type() const { return Type::IfcReinforcingElement; }
Type::Enum IfcReinforcingElement::Class() { return Type::IfcReinforcingElement; }
IfcReinforcingElement::IfcReinforcingElement(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingElement::IfcReinforcingElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLabel > v9_SteelGrade) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_SteelGrade) { e->setArgument(8,(*v9_SteelGrade)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingElementType
bool IfcReinforcingElementType::is(Type::Enum v) const { return v == Type::IfcReinforcingElementType || IfcElementComponentType::is(v); }
Type::Enum IfcReinforcingElementType::type() const { return Type::IfcReinforcingElementType; }
Type::Enum IfcReinforcingElementType::Class() { return Type::IfcReinforcingElementType; }
IfcReinforcingElementType::IfcReinforcingElementType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingElementType::IfcReinforcingElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingMesh
bool IfcReinforcingMesh::hasMeshLength() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::MeshLength() { return *entity->getArgument(9); }
void IfcReinforcingMesh::setMeshLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcReinforcingMesh::hasMeshWidth() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::MeshWidth() { return *entity->getArgument(10); }
void IfcReinforcingMesh::setMeshWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcReinforcingMesh::hasLongitudinalBarNominalDiameter() { return !entity->getArgument(11)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::LongitudinalBarNominalDiameter() { return *entity->getArgument(11); }
void IfcReinforcingMesh::setLongitudinalBarNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcReinforcingMesh::hasTransverseBarNominalDiameter() { return !entity->getArgument(12)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::TransverseBarNominalDiameter() { return *entity->getArgument(12); }
void IfcReinforcingMesh::setTransverseBarNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcReinforcingMesh::hasLongitudinalBarCrossSectionArea() { return !entity->getArgument(13)->isNull(); }
IfcAreaMeasure IfcReinforcingMesh::LongitudinalBarCrossSectionArea() { return *entity->getArgument(13); }
void IfcReinforcingMesh::setLongitudinalBarCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcReinforcingMesh::hasTransverseBarCrossSectionArea() { return !entity->getArgument(14)->isNull(); }
IfcAreaMeasure IfcReinforcingMesh::TransverseBarCrossSectionArea() { return *entity->getArgument(14); }
void IfcReinforcingMesh::setTransverseBarCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcReinforcingMesh::hasLongitudinalBarSpacing() { return !entity->getArgument(15)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::LongitudinalBarSpacing() { return *entity->getArgument(15); }
void IfcReinforcingMesh::setLongitudinalBarSpacing(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcReinforcingMesh::hasTransverseBarSpacing() { return !entity->getArgument(16)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMesh::TransverseBarSpacing() { return *entity->getArgument(16); }
void IfcReinforcingMesh::setTransverseBarSpacing(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcReinforcingMesh::hasPredefinedType() { return !entity->getArgument(17)->isNull(); }
IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMesh::PredefinedType() { return IfcReinforcingMeshTypeEnum::FromString(*entity->getArgument(17)); }
void IfcReinforcingMesh::setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(17,v,IfcReinforcingMeshTypeEnum::ToString(v)); }
bool IfcReinforcingMesh::is(Type::Enum v) const { return v == Type::IfcReinforcingMesh || IfcReinforcingElement::is(v); }
Type::Enum IfcReinforcingMesh::type() const { return Type::IfcReinforcingMesh; }
Type::Enum IfcReinforcingMesh::Class() { return Type::IfcReinforcingMesh; }
IfcReinforcingMesh::IfcReinforcingMesh(IfcAbstractEntityPtr e) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingMesh)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingMesh::IfcReinforcingMesh(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLabel > v9_SteelGrade, boost::optional< IfcPositiveLengthMeasure > v10_MeshLength, boost::optional< IfcPositiveLengthMeasure > v11_MeshWidth, boost::optional< IfcPositiveLengthMeasure > v12_LongitudinalBarNominalDiameter, boost::optional< IfcPositiveLengthMeasure > v13_TransverseBarNominalDiameter, boost::optional< IfcAreaMeasure > v14_LongitudinalBarCrossSectionArea, boost::optional< IfcAreaMeasure > v15_TransverseBarCrossSectionArea, boost::optional< IfcPositiveLengthMeasure > v16_LongitudinalBarSpacing, boost::optional< IfcPositiveLengthMeasure > v17_TransverseBarSpacing, boost::optional< IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum > v18_PredefinedType) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_SteelGrade) { e->setArgument(8,(*v9_SteelGrade)); } else { e->setArgument(8); } if (v10_MeshLength) { e->setArgument(9,(*v10_MeshLength)); } else { e->setArgument(9); } if (v11_MeshWidth) { e->setArgument(10,(*v11_MeshWidth)); } else { e->setArgument(10); } if (v12_LongitudinalBarNominalDiameter) { e->setArgument(11,(*v12_LongitudinalBarNominalDiameter)); } else { e->setArgument(11); } if (v13_TransverseBarNominalDiameter) { e->setArgument(12,(*v13_TransverseBarNominalDiameter)); } else { e->setArgument(12); } if (v14_LongitudinalBarCrossSectionArea) { e->setArgument(13,(*v14_LongitudinalBarCrossSectionArea)); } else { e->setArgument(13); } if (v15_TransverseBarCrossSectionArea) { e->setArgument(14,(*v15_TransverseBarCrossSectionArea)); } else { e->setArgument(14); } if (v16_LongitudinalBarSpacing) { e->setArgument(15,(*v16_LongitudinalBarSpacing)); } else { e->setArgument(15); } if (v17_TransverseBarSpacing) { e->setArgument(16,(*v17_TransverseBarSpacing)); } else { e->setArgument(16); } if (v18_PredefinedType) { e->setArgument(17,*v18_PredefinedType,IfcReinforcingMeshTypeEnum::ToString(*v18_PredefinedType)); } else { e->setArgument(17); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReinforcingMeshType
IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum IfcReinforcingMeshType::PredefinedType() { return IfcReinforcingMeshTypeEnum::FromString(*entity->getArgument(9)); }
void IfcReinforcingMeshType::setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcReinforcingMeshTypeEnum::ToString(v)); }
bool IfcReinforcingMeshType::hasMeshLength() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::MeshLength() { return *entity->getArgument(10); }
void IfcReinforcingMeshType::setMeshLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcReinforcingMeshType::hasMeshWidth() { return !entity->getArgument(11)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::MeshWidth() { return *entity->getArgument(11); }
void IfcReinforcingMeshType::setMeshWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcReinforcingMeshType::hasLongitudinalBarNominalDiameter() { return !entity->getArgument(12)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::LongitudinalBarNominalDiameter() { return *entity->getArgument(12); }
void IfcReinforcingMeshType::setLongitudinalBarNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcReinforcingMeshType::hasTransverseBarNominalDiameter() { return !entity->getArgument(13)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::TransverseBarNominalDiameter() { return *entity->getArgument(13); }
void IfcReinforcingMeshType::setTransverseBarNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcReinforcingMeshType::hasLongitudinalBarCrossSectionArea() { return !entity->getArgument(14)->isNull(); }
IfcAreaMeasure IfcReinforcingMeshType::LongitudinalBarCrossSectionArea() { return *entity->getArgument(14); }
void IfcReinforcingMeshType::setLongitudinalBarCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcReinforcingMeshType::hasTransverseBarCrossSectionArea() { return !entity->getArgument(15)->isNull(); }
IfcAreaMeasure IfcReinforcingMeshType::TransverseBarCrossSectionArea() { return *entity->getArgument(15); }
void IfcReinforcingMeshType::setTransverseBarCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcReinforcingMeshType::hasLongitudinalBarSpacing() { return !entity->getArgument(16)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::LongitudinalBarSpacing() { return *entity->getArgument(16); }
void IfcReinforcingMeshType::setLongitudinalBarSpacing(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcReinforcingMeshType::hasTransverseBarSpacing() { return !entity->getArgument(17)->isNull(); }
IfcPositiveLengthMeasure IfcReinforcingMeshType::TransverseBarSpacing() { return *entity->getArgument(17); }
void IfcReinforcingMeshType::setTransverseBarSpacing(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(17,v); }
bool IfcReinforcingMeshType::hasBendingShapeCode() { return !entity->getArgument(18)->isNull(); }
IfcLabel IfcReinforcingMeshType::BendingShapeCode() { return *entity->getArgument(18); }
void IfcReinforcingMeshType::setBendingShapeCode(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(18,v); }
bool IfcReinforcingMeshType::hasBendingParameters() { return !entity->getArgument(19)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcReinforcingMeshType::BendingParameters() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,19) }
void IfcReinforcingMeshType::setBendingParameters(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(19,v->generalize()); }
bool IfcReinforcingMeshType::is(Type::Enum v) const { return v == Type::IfcReinforcingMeshType || IfcReinforcingElementType::is(v); }
Type::Enum IfcReinforcingMeshType::type() const { return Type::IfcReinforcingMeshType; }
Type::Enum IfcReinforcingMeshType::Class() { return Type::IfcReinforcingMeshType; }
IfcReinforcingMeshType::IfcReinforcingMeshType(IfcAbstractEntityPtr e) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReinforcingMeshType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReinforcingMeshType::IfcReinforcingMeshType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v10_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v11_MeshLength, boost::optional< IfcPositiveLengthMeasure > v12_MeshWidth, boost::optional< IfcPositiveLengthMeasure > v13_LongitudinalBarNominalDiameter, boost::optional< IfcPositiveLengthMeasure > v14_TransverseBarNominalDiameter, boost::optional< IfcAreaMeasure > v15_LongitudinalBarCrossSectionArea, boost::optional< IfcAreaMeasure > v16_TransverseBarCrossSectionArea, boost::optional< IfcPositiveLengthMeasure > v17_LongitudinalBarSpacing, boost::optional< IfcPositiveLengthMeasure > v18_TransverseBarSpacing, boost::optional< IfcLabel > v19_BendingShapeCode, boost::optional< IfcEntities > v20_BendingParameters) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcReinforcingMeshTypeEnum::ToString(v10_PredefinedType)); if (v11_MeshLength) { e->setArgument(10,(*v11_MeshLength)); } else { e->setArgument(10); } if (v12_MeshWidth) { e->setArgument(11,(*v12_MeshWidth)); } else { e->setArgument(11); } if (v13_LongitudinalBarNominalDiameter) { e->setArgument(12,(*v13_LongitudinalBarNominalDiameter)); } else { e->setArgument(12); } if (v14_TransverseBarNominalDiameter) { e->setArgument(13,(*v14_TransverseBarNominalDiameter)); } else { e->setArgument(13); } if (v15_LongitudinalBarCrossSectionArea) { e->setArgument(14,(*v15_LongitudinalBarCrossSectionArea)); } else { e->setArgument(14); } if (v16_TransverseBarCrossSectionArea) { e->setArgument(15,(*v16_TransverseBarCrossSectionArea)); } else { e->setArgument(15); } if (v17_LongitudinalBarSpacing) { e->setArgument(16,(*v17_LongitudinalBarSpacing)); } else { e->setArgument(16); } if (v18_TransverseBarSpacing) { e->setArgument(17,(*v18_TransverseBarSpacing)); } else { e->setArgument(17); } if (v19_BendingShapeCode) { e->setArgument(18,(*v19_BendingShapeCode)); } else { e->setArgument(18); } if (v20_BendingParameters) { e->setArgument(19,(*v20_BendingParameters)); } else { e->setArgument(19); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAggregates
IfcObjectDefinition* IfcRelAggregates::RelatingObject() { return (IfcObjectDefinition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelAggregates::setRelatingObject(IfcObjectDefinition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > IfcRelAggregates::RelatedObjects() { RETURN_AS_LIST(IfcObjectDefinition,5) }
void IfcRelAggregates::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelAggregates::is(Type::Enum v) const { return v == Type::IfcRelAggregates || IfcRelDecomposes::is(v); }
Type::Enum IfcRelAggregates::type() const { return Type::IfcRelAggregates; }
Type::Enum IfcRelAggregates::Class() { return Type::IfcRelAggregates; }
IfcRelAggregates::IfcRelAggregates(IfcAbstractEntityPtr e) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAggregates)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAggregates::IfcRelAggregates(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcObjectDefinition* v5_RelatingObject, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v6_RelatedObjects) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingObject)); e->setArgument(5,(v6_RelatedObjects)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssigns
SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > IfcRelAssigns::RelatedObjects() { RETURN_AS_LIST(IfcObjectDefinition,4) }
void IfcRelAssigns::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
bool IfcRelAssigns::hasRelatedObjectsType() { return !entity->getArgument(5)->isNull(); }
IfcObjectTypeEnum::IfcObjectTypeEnum IfcRelAssigns::RelatedObjectsType() { return IfcObjectTypeEnum::FromString(*entity->getArgument(5)); }
void IfcRelAssigns::setRelatedObjectsType(IfcObjectTypeEnum::IfcObjectTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcObjectTypeEnum::ToString(v)); }
bool IfcRelAssigns::is(Type::Enum v) const { return v == Type::IfcRelAssigns || IfcRelationship::is(v); }
Type::Enum IfcRelAssigns::type() const { return Type::IfcRelAssigns; }
Type::Enum IfcRelAssigns::Class() { return Type::IfcRelAssigns; }
IfcRelAssigns::IfcRelAssigns(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssigns)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssigns::IfcRelAssigns(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToActor
IfcActor* IfcRelAssignsToActor::RelatingActor() { return (IfcActor*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelAssignsToActor::setRelatingActor(IfcActor* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToActor::hasActingRole() { return !entity->getArgument(7)->isNull(); }
IfcActorRole* IfcRelAssignsToActor::ActingRole() { return (IfcActorRole*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcRelAssignsToActor::setActingRole(IfcActorRole* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRelAssignsToActor::is(Type::Enum v) const { return v == Type::IfcRelAssignsToActor || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToActor::type() const { return Type::IfcRelAssignsToActor; }
Type::Enum IfcRelAssignsToActor::Class() { return Type::IfcRelAssignsToActor; }
IfcRelAssignsToActor::IfcRelAssignsToActor(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToActor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToActor::IfcRelAssignsToActor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingActor)); e->setArgument(7,(v8_ActingRole)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToControl
IfcControl* IfcRelAssignsToControl::RelatingControl() { return (IfcControl*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelAssignsToControl::setRelatingControl(IfcControl* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToControl::is(Type::Enum v) const { return v == Type::IfcRelAssignsToControl || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToControl::type() const { return Type::IfcRelAssignsToControl; }
Type::Enum IfcRelAssignsToControl::Class() { return Type::IfcRelAssignsToControl; }
IfcRelAssignsToControl::IfcRelAssignsToControl(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToControl)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToControl::IfcRelAssignsToControl(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingControl)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToGroup
IfcGroup* IfcRelAssignsToGroup::RelatingGroup() { return (IfcGroup*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelAssignsToGroup::setRelatingGroup(IfcGroup* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToGroup::is(Type::Enum v) const { return v == Type::IfcRelAssignsToGroup || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToGroup::type() const { return Type::IfcRelAssignsToGroup; }
Type::Enum IfcRelAssignsToGroup::Class() { return Type::IfcRelAssignsToGroup; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToGroup)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToGroup::IfcRelAssignsToGroup(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingGroup)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToGroupByFactor
IfcRatioMeasure IfcRelAssignsToGroupByFactor::Factor() { return *entity->getArgument(7); }
void IfcRelAssignsToGroupByFactor::setFactor(IfcRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRelAssignsToGroupByFactor::is(Type::Enum v) const { return v == Type::IfcRelAssignsToGroupByFactor || IfcRelAssignsToGroup::is(v); }
Type::Enum IfcRelAssignsToGroupByFactor::type() const { return Type::IfcRelAssignsToGroupByFactor; }
Type::Enum IfcRelAssignsToGroupByFactor::Class() { return Type::IfcRelAssignsToGroupByFactor; }
IfcRelAssignsToGroupByFactor::IfcRelAssignsToGroupByFactor(IfcAbstractEntityPtr e) : IfcRelAssignsToGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToGroupByFactor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToGroupByFactor::IfcRelAssignsToGroupByFactor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup, IfcRatioMeasure v8_Factor) : IfcRelAssignsToGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingGroup)); e->setArgument(7,(v8_Factor)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToProcess
IfcProcessSelect IfcRelAssignsToProcess::RelatingProcess() { return *entity->getArgument(6); }
void IfcRelAssignsToProcess::setRelatingProcess(IfcProcessSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToProcess::hasQuantityInProcess() { return !entity->getArgument(7)->isNull(); }
IfcMeasureWithUnit* IfcRelAssignsToProcess::QuantityInProcess() { return (IfcMeasureWithUnit*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcRelAssignsToProcess::setQuantityInProcess(IfcMeasureWithUnit* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRelAssignsToProcess::is(Type::Enum v) const { return v == Type::IfcRelAssignsToProcess || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToProcess::type() const { return Type::IfcRelAssignsToProcess; }
Type::Enum IfcRelAssignsToProcess::Class() { return Type::IfcRelAssignsToProcess; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToProcess)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToProcess::IfcRelAssignsToProcess(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProcessSelect v7_RelatingProcess, IfcMeasureWithUnit* v8_QuantityInProcess) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingProcess)); e->setArgument(7,(v8_QuantityInProcess)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToProduct
IfcProductSelect IfcRelAssignsToProduct::RelatingProduct() { return *entity->getArgument(6); }
void IfcRelAssignsToProduct::setRelatingProduct(IfcProductSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToProduct::is(Type::Enum v) const { return v == Type::IfcRelAssignsToProduct || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToProduct::type() const { return Type::IfcRelAssignsToProduct; }
Type::Enum IfcRelAssignsToProduct::Class() { return Type::IfcRelAssignsToProduct; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToProduct)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToProduct::IfcRelAssignsToProduct(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProductSelect v7_RelatingProduct) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingProduct)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssignsToResource
IfcResourceSelect IfcRelAssignsToResource::RelatingResource() { return *entity->getArgument(6); }
void IfcRelAssignsToResource::setRelatingResource(IfcResourceSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssignsToResource::is(Type::Enum v) const { return v == Type::IfcRelAssignsToResource || IfcRelAssigns::is(v); }
Type::Enum IfcRelAssignsToResource::type() const { return Type::IfcRelAssignsToResource; }
Type::Enum IfcRelAssignsToResource::Class() { return Type::IfcRelAssignsToResource; }
IfcRelAssignsToResource::IfcRelAssignsToResource(IfcAbstractEntityPtr e) : IfcRelAssigns((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssignsToResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssignsToResource::IfcRelAssignsToResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcResourceSelect v7_RelatingResource) : IfcRelAssigns((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); if (v6_RelatedObjectsType) { e->setArgument(5,*v6_RelatedObjectsType,IfcObjectTypeEnum::ToString(*v6_RelatedObjectsType)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingResource)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociates
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcRelAssociates::RelatedObjects() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,4) }
void IfcRelAssociates::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
bool IfcRelAssociates::is(Type::Enum v) const { return v == Type::IfcRelAssociates || IfcRelationship::is(v); }
Type::Enum IfcRelAssociates::type() const { return Type::IfcRelAssociates; }
Type::Enum IfcRelAssociates::Class() { return Type::IfcRelAssociates; }
IfcRelAssociates::IfcRelAssociates(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociates)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociates::IfcRelAssociates(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesApproval
IfcApproval* IfcRelAssociatesApproval::RelatingApproval() { return (IfcApproval*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelAssociatesApproval::setRelatingApproval(IfcApproval* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelAssociatesApproval::is(Type::Enum v) const { return v == Type::IfcRelAssociatesApproval || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesApproval::type() const { return Type::IfcRelAssociatesApproval; }
Type::Enum IfcRelAssociatesApproval::Class() { return Type::IfcRelAssociatesApproval; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesApproval)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesApproval::IfcRelAssociatesApproval(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, IfcApproval* v6_RelatingApproval) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); e->setArgument(5,(v6_RelatingApproval)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesClassification
IfcClassificationSelect IfcRelAssociatesClassification::RelatingClassification() { return *entity->getArgument(5); }
void IfcRelAssociatesClassification::setRelatingClassification(IfcClassificationSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelAssociatesClassification::is(Type::Enum v) const { return v == Type::IfcRelAssociatesClassification || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesClassification::type() const { return Type::IfcRelAssociatesClassification; }
Type::Enum IfcRelAssociatesClassification::Class() { return Type::IfcRelAssociatesClassification; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesClassification)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesClassification::IfcRelAssociatesClassification(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, IfcClassificationSelect v6_RelatingClassification) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); e->setArgument(5,(v6_RelatingClassification)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesConstraint
bool IfcRelAssociatesConstraint::hasIntent() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcRelAssociatesConstraint::Intent() { return *entity->getArgument(5); }
void IfcRelAssociatesConstraint::setIntent(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcConstraint* IfcRelAssociatesConstraint::RelatingConstraint() { return (IfcConstraint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelAssociatesConstraint::setRelatingConstraint(IfcConstraint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelAssociatesConstraint::is(Type::Enum v) const { return v == Type::IfcRelAssociatesConstraint || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesConstraint::type() const { return Type::IfcRelAssociatesConstraint; }
Type::Enum IfcRelAssociatesConstraint::Class() { return Type::IfcRelAssociatesConstraint; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesConstraint)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesConstraint::IfcRelAssociatesConstraint(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, boost::optional< IfcLabel > v6_Intent, IfcConstraint* v7_RelatingConstraint) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); if (v6_Intent) { e->setArgument(5,(*v6_Intent)); } else { e->setArgument(5); } e->setArgument(6,(v7_RelatingConstraint)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesDocument
IfcDocumentSelect IfcRelAssociatesDocument::RelatingDocument() { return *entity->getArgument(5); }
void IfcRelAssociatesDocument::setRelatingDocument(IfcDocumentSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelAssociatesDocument::is(Type::Enum v) const { return v == Type::IfcRelAssociatesDocument || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesDocument::type() const { return Type::IfcRelAssociatesDocument; }
Type::Enum IfcRelAssociatesDocument::Class() { return Type::IfcRelAssociatesDocument; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesDocument)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesDocument::IfcRelAssociatesDocument(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, IfcDocumentSelect v6_RelatingDocument) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); e->setArgument(5,(v6_RelatingDocument)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesLibrary
IfcLibrarySelect IfcRelAssociatesLibrary::RelatingLibrary() { return *entity->getArgument(5); }
void IfcRelAssociatesLibrary::setRelatingLibrary(IfcLibrarySelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelAssociatesLibrary::is(Type::Enum v) const { return v == Type::IfcRelAssociatesLibrary || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesLibrary::type() const { return Type::IfcRelAssociatesLibrary; }
Type::Enum IfcRelAssociatesLibrary::Class() { return Type::IfcRelAssociatesLibrary; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesLibrary)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesLibrary::IfcRelAssociatesLibrary(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, IfcLibrarySelect v6_RelatingLibrary) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); e->setArgument(5,(v6_RelatingLibrary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelAssociatesMaterial
IfcMaterialSelect IfcRelAssociatesMaterial::RelatingMaterial() { return *entity->getArgument(5); }
void IfcRelAssociatesMaterial::setRelatingMaterial(IfcMaterialSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelAssociatesMaterial::is(Type::Enum v) const { return v == Type::IfcRelAssociatesMaterial || IfcRelAssociates::is(v); }
Type::Enum IfcRelAssociatesMaterial::type() const { return Type::IfcRelAssociatesMaterial; }
Type::Enum IfcRelAssociatesMaterial::Class() { return Type::IfcRelAssociatesMaterial; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(IfcAbstractEntityPtr e) : IfcRelAssociates((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelAssociatesMaterial)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelAssociatesMaterial::IfcRelAssociatesMaterial(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcEntities v5_RelatedObjects, IfcMaterialSelect v6_RelatingMaterial) : IfcRelAssociates((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)); e->setArgument(5,(v6_RelatingMaterial)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnects
bool IfcRelConnects::is(Type::Enum v) const { return v == Type::IfcRelConnects || IfcRelationship::is(v); }
Type::Enum IfcRelConnects::type() const { return Type::IfcRelConnects; }
Type::Enum IfcRelConnects::Class() { return Type::IfcRelConnects; }
IfcRelConnects::IfcRelConnects(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnects)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnects::IfcRelConnects(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsElements
bool IfcRelConnectsElements::hasConnectionGeometry() { return !entity->getArgument(4)->isNull(); }
IfcConnectionGeometry* IfcRelConnectsElements::ConnectionGeometry() { return (IfcConnectionGeometry*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelConnectsElements::setConnectionGeometry(IfcConnectionGeometry* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcElement* IfcRelConnectsElements::RelatingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelConnectsElements::setRelatingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcElement* IfcRelConnectsElements::RelatedElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelConnectsElements::setRelatedElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelConnectsElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsElements || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsElements::type() const { return Type::IfcRelConnectsElements; }
Type::Enum IfcRelConnectsElements::Class() { return Type::IfcRelConnectsElements; }
IfcRelConnectsElements::IfcRelConnectsElements(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsElements::IfcRelConnectsElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_ConnectionGeometry)); e->setArgument(5,(v6_RelatingElement)); e->setArgument(6,(v7_RelatedElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsPathElements
std::vector< double > /*[0:?]*/ IfcRelConnectsPathElements::RelatingPriorities() { return *entity->getArgument(7); }
void IfcRelConnectsPathElements::setRelatingPriorities(std::vector< double > /*[0:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
std::vector< double > /*[0:?]*/ IfcRelConnectsPathElements::RelatedPriorities() { return *entity->getArgument(8); }
void IfcRelConnectsPathElements::setRelatedPriorities(std::vector< double > /*[0:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatedConnectionType() { return IfcConnectionTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRelConnectsPathElements::setRelatedConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcConnectionTypeEnum::ToString(v)); }
IfcConnectionTypeEnum::IfcConnectionTypeEnum IfcRelConnectsPathElements::RelatingConnectionType() { return IfcConnectionTypeEnum::FromString(*entity->getArgument(10)); }
void IfcRelConnectsPathElements::setRelatingConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcConnectionTypeEnum::ToString(v)); }
bool IfcRelConnectsPathElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsPathElements || IfcRelConnectsElements::is(v); }
Type::Enum IfcRelConnectsPathElements::type() const { return Type::IfcRelConnectsPathElements; }
Type::Enum IfcRelConnectsPathElements::Class() { return Type::IfcRelConnectsPathElements; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(IfcAbstractEntityPtr e) : IfcRelConnectsElements((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsPathElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPathElements::IfcRelConnectsPathElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, std::vector< double > /*[0:?]*/ v8_RelatingPriorities, std::vector< double > /*[0:?]*/ v9_RelatedPriorities, IfcConnectionTypeEnum::IfcConnectionTypeEnum v10_RelatedConnectionType, IfcConnectionTypeEnum::IfcConnectionTypeEnum v11_RelatingConnectionType) : IfcRelConnectsElements((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_ConnectionGeometry)); e->setArgument(5,(v6_RelatingElement)); e->setArgument(6,(v7_RelatedElement)); e->setArgument(7,(v8_RelatingPriorities)); e->setArgument(8,(v9_RelatedPriorities)); e->setArgument(9,v10_RelatedConnectionType,IfcConnectionTypeEnum::ToString(v10_RelatedConnectionType)); e->setArgument(10,v11_RelatingConnectionType,IfcConnectionTypeEnum::ToString(v11_RelatingConnectionType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsPortToElement
IfcPort* IfcRelConnectsPortToElement::RelatingPort() { return (IfcPort*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelConnectsPortToElement::setRelatingPort(IfcPort* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcDistributionElement* IfcRelConnectsPortToElement::RelatedElement() { return (IfcDistributionElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelConnectsPortToElement::setRelatedElement(IfcDistributionElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelConnectsPortToElement::is(Type::Enum v) const { return v == Type::IfcRelConnectsPortToElement || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsPortToElement::type() const { return Type::IfcRelConnectsPortToElement; }
Type::Enum IfcRelConnectsPortToElement::Class() { return Type::IfcRelConnectsPortToElement; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsPortToElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPortToElement::IfcRelConnectsPortToElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcPort* v5_RelatingPort, IfcDistributionElement* v6_RelatedElement) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingPort)); e->setArgument(5,(v6_RelatedElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsPorts
IfcPort* IfcRelConnectsPorts::RelatingPort() { return (IfcPort*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelConnectsPorts::setRelatingPort(IfcPort* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPort* IfcRelConnectsPorts::RelatedPort() { return (IfcPort*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelConnectsPorts::setRelatedPort(IfcPort* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelConnectsPorts::hasRealizingElement() { return !entity->getArgument(6)->isNull(); }
IfcElement* IfcRelConnectsPorts::RealizingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelConnectsPorts::setRealizingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelConnectsPorts::is(Type::Enum v) const { return v == Type::IfcRelConnectsPorts || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsPorts::type() const { return Type::IfcRelConnectsPorts; }
Type::Enum IfcRelConnectsPorts::Class() { return Type::IfcRelConnectsPorts; }
IfcRelConnectsPorts::IfcRelConnectsPorts(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsPorts)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsPorts::IfcRelConnectsPorts(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcPort* v5_RelatingPort, IfcPort* v6_RelatedPort, IfcElement* v7_RealizingElement) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingPort)); e->setArgument(5,(v6_RelatedPort)); e->setArgument(6,(v7_RealizingElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsStructuralActivity
IfcStructuralActivityAssignmentSelect IfcRelConnectsStructuralActivity::RelatingElement() { return *entity->getArgument(4); }
void IfcRelConnectsStructuralActivity::setRelatingElement(IfcStructuralActivityAssignmentSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcStructuralActivity* IfcRelConnectsStructuralActivity::RelatedStructuralActivity() { return (IfcStructuralActivity*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelConnectsStructuralActivity::setRelatedStructuralActivity(IfcStructuralActivity* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelConnectsStructuralActivity::is(Type::Enum v) const { return v == Type::IfcRelConnectsStructuralActivity || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsStructuralActivity::type() const { return Type::IfcRelConnectsStructuralActivity; }
Type::Enum IfcRelConnectsStructuralActivity::Class() { return Type::IfcRelConnectsStructuralActivity; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsStructuralActivity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsStructuralActivity::IfcRelConnectsStructuralActivity(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcStructuralActivityAssignmentSelect v5_RelatingElement, IfcStructuralActivity* v6_RelatedStructuralActivity) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingElement)); e->setArgument(5,(v6_RelatedStructuralActivity)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsStructuralMember
IfcStructuralMember* IfcRelConnectsStructuralMember::RelatingStructuralMember() { return (IfcStructuralMember*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelConnectsStructuralMember::setRelatingStructuralMember(IfcStructuralMember* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcStructuralConnection* IfcRelConnectsStructuralMember::RelatedStructuralConnection() { return (IfcStructuralConnection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelConnectsStructuralMember::setRelatedStructuralConnection(IfcStructuralConnection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelConnectsStructuralMember::hasAppliedCondition() { return !entity->getArgument(6)->isNull(); }
IfcBoundaryCondition* IfcRelConnectsStructuralMember::AppliedCondition() { return (IfcBoundaryCondition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelConnectsStructuralMember::setAppliedCondition(IfcBoundaryCondition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelConnectsStructuralMember::hasAdditionalConditions() { return !entity->getArgument(7)->isNull(); }
IfcStructuralConnectionCondition* IfcRelConnectsStructuralMember::AdditionalConditions() { return (IfcStructuralConnectionCondition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcRelConnectsStructuralMember::setAdditionalConditions(IfcStructuralConnectionCondition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRelConnectsStructuralMember::hasSupportedLength() { return !entity->getArgument(8)->isNull(); }
IfcLengthMeasure IfcRelConnectsStructuralMember::SupportedLength() { return *entity->getArgument(8); }
void IfcRelConnectsStructuralMember::setSupportedLength(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcRelConnectsStructuralMember::hasConditionCoordinateSystem() { return !entity->getArgument(9)->isNull(); }
IfcAxis2Placement3D* IfcRelConnectsStructuralMember::ConditionCoordinateSystem() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcRelConnectsStructuralMember::setConditionCoordinateSystem(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcRelConnectsStructuralMember::is(Type::Enum v) const { return v == Type::IfcRelConnectsStructuralMember || IfcRelConnects::is(v); }
Type::Enum IfcRelConnectsStructuralMember::type() const { return Type::IfcRelConnectsStructuralMember; }
Type::Enum IfcRelConnectsStructuralMember::Class() { return Type::IfcRelConnectsStructuralMember; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsStructuralMember)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsStructuralMember::IfcRelConnectsStructuralMember(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< IfcLengthMeasure > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingStructuralMember)); e->setArgument(5,(v6_RelatedStructuralConnection)); e->setArgument(6,(v7_AppliedCondition)); e->setArgument(7,(v8_AdditionalConditions)); if (v9_SupportedLength) { e->setArgument(8,(*v9_SupportedLength)); } else { e->setArgument(8); } e->setArgument(9,(v10_ConditionCoordinateSystem)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsWithEccentricity
IfcConnectionGeometry* IfcRelConnectsWithEccentricity::ConnectionConstraint() { return (IfcConnectionGeometry*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcRelConnectsWithEccentricity::setConnectionConstraint(IfcConnectionGeometry* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcRelConnectsWithEccentricity::is(Type::Enum v) const { return v == Type::IfcRelConnectsWithEccentricity || IfcRelConnectsStructuralMember::is(v); }
Type::Enum IfcRelConnectsWithEccentricity::type() const { return Type::IfcRelConnectsWithEccentricity; }
Type::Enum IfcRelConnectsWithEccentricity::Class() { return Type::IfcRelConnectsWithEccentricity; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(IfcAbstractEntityPtr e) : IfcRelConnectsStructuralMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsWithEccentricity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsWithEccentricity::IfcRelConnectsWithEccentricity(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< IfcLengthMeasure > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem, IfcConnectionGeometry* v11_ConnectionConstraint) : IfcRelConnectsStructuralMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingStructuralMember)); e->setArgument(5,(v6_RelatedStructuralConnection)); e->setArgument(6,(v7_AppliedCondition)); e->setArgument(7,(v8_AdditionalConditions)); if (v9_SupportedLength) { e->setArgument(8,(*v9_SupportedLength)); } else { e->setArgument(8); } e->setArgument(9,(v10_ConditionCoordinateSystem)); e->setArgument(10,(v11_ConnectionConstraint)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelConnectsWithRealizingElements
SHARED_PTR< IfcTemplatedEntityList< IfcElement > > IfcRelConnectsWithRealizingElements::RealizingElements() { RETURN_AS_LIST(IfcElement,7) }
void IfcRelConnectsWithRealizingElements::setRealizingElements(SHARED_PTR< IfcTemplatedEntityList< IfcElement > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcRelConnectsWithRealizingElements::hasConnectionType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcRelConnectsWithRealizingElements::ConnectionType() { return *entity->getArgument(8); }
void IfcRelConnectsWithRealizingElements::setConnectionType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcRelConnectsWithRealizingElements::is(Type::Enum v) const { return v == Type::IfcRelConnectsWithRealizingElements || IfcRelConnectsElements::is(v); }
Type::Enum IfcRelConnectsWithRealizingElements::type() const { return Type::IfcRelConnectsWithRealizingElements; }
Type::Enum IfcRelConnectsWithRealizingElements::Class() { return Type::IfcRelConnectsWithRealizingElements; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(IfcAbstractEntityPtr e) : IfcRelConnectsElements((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelConnectsWithRealizingElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelConnectsWithRealizingElements::IfcRelConnectsWithRealizingElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, SHARED_PTR< IfcTemplatedEntityList< IfcElement > > v8_RealizingElements, boost::optional< IfcLabel > v9_ConnectionType) : IfcRelConnectsElements((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_ConnectionGeometry)); e->setArgument(5,(v6_RelatingElement)); e->setArgument(6,(v7_RelatedElement)); e->setArgument(7,(v8_RealizingElements)->generalize()); if (v9_ConnectionType) { e->setArgument(8,(*v9_ConnectionType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelContainedInSpatialStructure
SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > IfcRelContainedInSpatialStructure::RelatedElements() { RETURN_AS_LIST(IfcProduct,4) }
void IfcRelContainedInSpatialStructure::setRelatedElements(SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcSpatialElement* IfcRelContainedInSpatialStructure::RelatingStructure() { return (IfcSpatialElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelContainedInSpatialStructure::setRelatingStructure(IfcSpatialElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelContainedInSpatialStructure::is(Type::Enum v) const { return v == Type::IfcRelContainedInSpatialStructure || IfcRelConnects::is(v); }
Type::Enum IfcRelContainedInSpatialStructure::type() const { return Type::IfcRelContainedInSpatialStructure; }
Type::Enum IfcRelContainedInSpatialStructure::Class() { return Type::IfcRelContainedInSpatialStructure; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelContainedInSpatialStructure)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelContainedInSpatialStructure::IfcRelContainedInSpatialStructure(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedElements)->generalize()); e->setArgument(5,(v6_RelatingStructure)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelCoversBldgElements
IfcElement* IfcRelCoversBldgElements::RelatingBuildingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelCoversBldgElements::setRelatingBuildingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > IfcRelCoversBldgElements::RelatedCoverings() { RETURN_AS_LIST(IfcCovering,5) }
void IfcRelCoversBldgElements::setRelatedCoverings(SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelCoversBldgElements::is(Type::Enum v) const { return v == Type::IfcRelCoversBldgElements || IfcRelConnects::is(v); }
Type::Enum IfcRelCoversBldgElements::type() const { return Type::IfcRelCoversBldgElements; }
Type::Enum IfcRelCoversBldgElements::Class() { return Type::IfcRelCoversBldgElements; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelCoversBldgElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelCoversBldgElements::IfcRelCoversBldgElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcElement* v5_RelatingBuildingElement, SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > v6_RelatedCoverings) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingBuildingElement)); e->setArgument(5,(v6_RelatedCoverings)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelCoversSpaces
IfcSpace* IfcRelCoversSpaces::RelatingSpace() { return (IfcSpace*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelCoversSpaces::setRelatingSpace(IfcSpace* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > IfcRelCoversSpaces::RelatedCoverings() { RETURN_AS_LIST(IfcCovering,5) }
void IfcRelCoversSpaces::setRelatedCoverings(SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelCoversSpaces::is(Type::Enum v) const { return v == Type::IfcRelCoversSpaces || IfcRelConnects::is(v); }
Type::Enum IfcRelCoversSpaces::type() const { return Type::IfcRelCoversSpaces; }
Type::Enum IfcRelCoversSpaces::Class() { return Type::IfcRelCoversSpaces; }
IfcRelCoversSpaces::IfcRelCoversSpaces(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelCoversSpaces)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelCoversSpaces::IfcRelCoversSpaces(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcSpace* v5_RelatingSpace, SHARED_PTR< IfcTemplatedEntityList< IfcCovering > > v6_RelatedCoverings) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingSpace)); e->setArgument(5,(v6_RelatedCoverings)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDeclares
IfcContext* IfcRelDeclares::RelatingContext() { return (IfcContext*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelDeclares::setRelatingContext(IfcContext* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcRelDeclares::RelatedDefinitions() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,5) }
void IfcRelDeclares::setRelatedDefinitions(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelDeclares::is(Type::Enum v) const { return v == Type::IfcRelDeclares || IfcRelationship::is(v); }
Type::Enum IfcRelDeclares::type() const { return Type::IfcRelDeclares; }
Type::Enum IfcRelDeclares::Class() { return Type::IfcRelDeclares; }
IfcRelDeclares::IfcRelDeclares(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDeclares)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDeclares::IfcRelDeclares(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcContext* v5_RelatingContext, IfcEntities v6_RelatedDefinitions) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingContext)); e->setArgument(5,(v6_RelatedDefinitions)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDecomposes
bool IfcRelDecomposes::is(Type::Enum v) const { return v == Type::IfcRelDecomposes || IfcRelationship::is(v); }
Type::Enum IfcRelDecomposes::type() const { return Type::IfcRelDecomposes; }
Type::Enum IfcRelDecomposes::Class() { return Type::IfcRelDecomposes; }
IfcRelDecomposes::IfcRelDecomposes(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDecomposes)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDecomposes::IfcRelDecomposes(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDefines
bool IfcRelDefines::is(Type::Enum v) const { return v == Type::IfcRelDefines || IfcRelationship::is(v); }
Type::Enum IfcRelDefines::type() const { return Type::IfcRelDefines; }
Type::Enum IfcRelDefines::Class() { return Type::IfcRelDefines; }
IfcRelDefines::IfcRelDefines(IfcAbstractEntityPtr e) : IfcRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDefines)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefines::IfcRelDefines(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDefinesByObject
SHARED_PTR< IfcTemplatedEntityList< IfcObject > > IfcRelDefinesByObject::RelatedObjects() { RETURN_AS_LIST(IfcObject,4) }
void IfcRelDefinesByObject::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObject > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcObject* IfcRelDefinesByObject::RelatingObject() { return (IfcObject*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelDefinesByObject::setRelatingObject(IfcObject* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelDefinesByObject::is(Type::Enum v) const { return v == Type::IfcRelDefinesByObject || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByObject::type() const { return Type::IfcRelDefinesByObject; }
Type::Enum IfcRelDefinesByObject::Class() { return Type::IfcRelDefinesByObject; }
IfcRelDefinesByObject::IfcRelDefinesByObject(IfcAbstractEntityPtr e) : IfcRelDefines((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDefinesByObject)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByObject::IfcRelDefinesByObject(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObject > > v5_RelatedObjects, IfcObject* v6_RelatingObject) : IfcRelDefines((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); e->setArgument(5,(v6_RelatingObject)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDefinesByProperties
SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > IfcRelDefinesByProperties::RelatedObjects() { RETURN_AS_LIST(IfcObjectDefinition,4) }
void IfcRelDefinesByProperties::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcPropertySetDefinitionSelect IfcRelDefinesByProperties::RelatingPropertyDefinition() { return *entity->getArgument(5); }
void IfcRelDefinesByProperties::setRelatingPropertyDefinition(IfcPropertySetDefinitionSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelDefinesByProperties::is(Type::Enum v) const { return v == Type::IfcRelDefinesByProperties || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByProperties::type() const { return Type::IfcRelDefinesByProperties; }
Type::Enum IfcRelDefinesByProperties::Class() { return Type::IfcRelDefinesByProperties; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(IfcAbstractEntityPtr e) : IfcRelDefines((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDefinesByProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByProperties::IfcRelDefinesByProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v5_RelatedObjects, IfcPropertySetDefinitionSelect v6_RelatingPropertyDefinition) : IfcRelDefines((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); e->setArgument(5,(v6_RelatingPropertyDefinition)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDefinesByTemplate
SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > IfcRelDefinesByTemplate::RelatedPropertySets() { RETURN_AS_LIST(IfcPropertySetDefinition,4) }
void IfcRelDefinesByTemplate::setRelatedPropertySets(SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcPropertySetTemplate* IfcRelDefinesByTemplate::RelatingTemplate() { return (IfcPropertySetTemplate*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelDefinesByTemplate::setRelatingTemplate(IfcPropertySetTemplate* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelDefinesByTemplate::is(Type::Enum v) const { return v == Type::IfcRelDefinesByTemplate || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByTemplate::type() const { return Type::IfcRelDefinesByTemplate; }
Type::Enum IfcRelDefinesByTemplate::Class() { return Type::IfcRelDefinesByTemplate; }
IfcRelDefinesByTemplate::IfcRelDefinesByTemplate(IfcAbstractEntityPtr e) : IfcRelDefines((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDefinesByTemplate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByTemplate::IfcRelDefinesByTemplate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > v5_RelatedPropertySets, IfcPropertySetTemplate* v6_RelatingTemplate) : IfcRelDefines((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedPropertySets)->generalize()); e->setArgument(5,(v6_RelatingTemplate)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelDefinesByType
SHARED_PTR< IfcTemplatedEntityList< IfcObject > > IfcRelDefinesByType::RelatedObjects() { RETURN_AS_LIST(IfcObject,4) }
void IfcRelDefinesByType::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObject > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcTypeObject* IfcRelDefinesByType::RelatingType() { return (IfcTypeObject*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelDefinesByType::setRelatingType(IfcTypeObject* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelDefinesByType::is(Type::Enum v) const { return v == Type::IfcRelDefinesByType || IfcRelDefines::is(v); }
Type::Enum IfcRelDefinesByType::type() const { return Type::IfcRelDefinesByType; }
Type::Enum IfcRelDefinesByType::Class() { return Type::IfcRelDefinesByType; }
IfcRelDefinesByType::IfcRelDefinesByType(IfcAbstractEntityPtr e) : IfcRelDefines((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelDefinesByType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelDefinesByType::IfcRelDefinesByType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcObject > > v5_RelatedObjects, IfcTypeObject* v6_RelatingType) : IfcRelDefines((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedObjects)->generalize()); e->setArgument(5,(v6_RelatingType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelFillsElement
IfcOpeningElement* IfcRelFillsElement::RelatingOpeningElement() { return (IfcOpeningElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelFillsElement::setRelatingOpeningElement(IfcOpeningElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcElement* IfcRelFillsElement::RelatedBuildingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelFillsElement::setRelatedBuildingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelFillsElement::is(Type::Enum v) const { return v == Type::IfcRelFillsElement || IfcRelConnects::is(v); }
Type::Enum IfcRelFillsElement::type() const { return Type::IfcRelFillsElement; }
Type::Enum IfcRelFillsElement::Class() { return Type::IfcRelFillsElement; }
IfcRelFillsElement::IfcRelFillsElement(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelFillsElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelFillsElement::IfcRelFillsElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcOpeningElement* v5_RelatingOpeningElement, IfcElement* v6_RelatedBuildingElement) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingOpeningElement)); e->setArgument(5,(v6_RelatedBuildingElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelFlowControlElements
SHARED_PTR< IfcTemplatedEntityList< IfcDistributionControlElement > > IfcRelFlowControlElements::RelatedControlElements() { RETURN_AS_LIST(IfcDistributionControlElement,4) }
void IfcRelFlowControlElements::setRelatedControlElements(SHARED_PTR< IfcTemplatedEntityList< IfcDistributionControlElement > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcDistributionFlowElement* IfcRelFlowControlElements::RelatingFlowElement() { return (IfcDistributionFlowElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelFlowControlElements::setRelatingFlowElement(IfcDistributionFlowElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelFlowControlElements::is(Type::Enum v) const { return v == Type::IfcRelFlowControlElements || IfcRelConnects::is(v); }
Type::Enum IfcRelFlowControlElements::type() const { return Type::IfcRelFlowControlElements; }
Type::Enum IfcRelFlowControlElements::Class() { return Type::IfcRelFlowControlElements; }
IfcRelFlowControlElements::IfcRelFlowControlElements(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelFlowControlElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelFlowControlElements::IfcRelFlowControlElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcDistributionControlElement > > v5_RelatedControlElements, IfcDistributionFlowElement* v6_RelatingFlowElement) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedControlElements)->generalize()); e->setArgument(5,(v6_RelatingFlowElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelInterferesElements
IfcElement* IfcRelInterferesElements::RelatingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelInterferesElements::setRelatingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcElement* IfcRelInterferesElements::RelatedElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelInterferesElements::setRelatedElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelInterferesElements::hasInterferenceGeometry() { return !entity->getArgument(6)->isNull(); }
IfcConnectionGeometry* IfcRelInterferesElements::InterferenceGeometry() { return (IfcConnectionGeometry*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelInterferesElements::setInterferenceGeometry(IfcConnectionGeometry* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelInterferesElements::hasInterferenceType() { return !entity->getArgument(7)->isNull(); }
IfcIdentifier IfcRelInterferesElements::InterferenceType() { return *entity->getArgument(7); }
void IfcRelInterferesElements::setInterferenceType(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcRelInterferesElements::ImpliedOrder() { return *entity->getArgument(8); }
void IfcRelInterferesElements::setImpliedOrder(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcRelInterferesElements::is(Type::Enum v) const { return v == Type::IfcRelInterferesElements || IfcRelConnects::is(v); }
Type::Enum IfcRelInterferesElements::type() const { return Type::IfcRelInterferesElements; }
Type::Enum IfcRelInterferesElements::Class() { return Type::IfcRelInterferesElements; }
IfcRelInterferesElements::IfcRelInterferesElements(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelInterferesElements)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelInterferesElements::IfcRelInterferesElements(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcElement* v5_RelatingElement, IfcElement* v6_RelatedElement, IfcConnectionGeometry* v7_InterferenceGeometry, boost::optional< IfcIdentifier > v8_InterferenceType, bool v9_ImpliedOrder) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingElement)); e->setArgument(5,(v6_RelatedElement)); e->setArgument(6,(v7_InterferenceGeometry)); if (v8_InterferenceType) { e->setArgument(7,(*v8_InterferenceType)); } else { e->setArgument(7); } e->setArgument(8,(v9_ImpliedOrder)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelNests
IfcObjectDefinition* IfcRelNests::RelatingObject() { return (IfcObjectDefinition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelNests::setRelatingObject(IfcObjectDefinition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > IfcRelNests::RelatedObjects() { RETURN_AS_LIST(IfcObjectDefinition,5) }
void IfcRelNests::setRelatedObjects(SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelNests::is(Type::Enum v) const { return v == Type::IfcRelNests || IfcRelDecomposes::is(v); }
Type::Enum IfcRelNests::type() const { return Type::IfcRelNests; }
Type::Enum IfcRelNests::Class() { return Type::IfcRelNests; }
IfcRelNests::IfcRelNests(IfcAbstractEntityPtr e) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelNests)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelNests::IfcRelNests(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcObjectDefinition* v5_RelatingObject, SHARED_PTR< IfcTemplatedEntityList< IfcObjectDefinition > > v6_RelatedObjects) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingObject)); e->setArgument(5,(v6_RelatedObjects)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelProjectsElement
IfcElement* IfcRelProjectsElement::RelatingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelProjectsElement::setRelatingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcFeatureElementAddition* IfcRelProjectsElement::RelatedFeatureElement() { return (IfcFeatureElementAddition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelProjectsElement::setRelatedFeatureElement(IfcFeatureElementAddition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelProjectsElement::is(Type::Enum v) const { return v == Type::IfcRelProjectsElement || IfcRelDecomposes::is(v); }
Type::Enum IfcRelProjectsElement::type() const { return Type::IfcRelProjectsElement; }
Type::Enum IfcRelProjectsElement::Class() { return Type::IfcRelProjectsElement; }
IfcRelProjectsElement::IfcRelProjectsElement(IfcAbstractEntityPtr e) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelProjectsElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelProjectsElement::IfcRelProjectsElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcElement* v5_RelatingElement, IfcFeatureElementAddition* v6_RelatedFeatureElement) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingElement)); e->setArgument(5,(v6_RelatedFeatureElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelReferencedInSpatialStructure
SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > IfcRelReferencedInSpatialStructure::RelatedElements() { RETURN_AS_LIST(IfcProduct,4) }
void IfcRelReferencedInSpatialStructure::setRelatedElements(SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v->generalize()); }
IfcSpatialElement* IfcRelReferencedInSpatialStructure::RelatingStructure() { return (IfcSpatialElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelReferencedInSpatialStructure::setRelatingStructure(IfcSpatialElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelReferencedInSpatialStructure::is(Type::Enum v) const { return v == Type::IfcRelReferencedInSpatialStructure || IfcRelConnects::is(v); }
Type::Enum IfcRelReferencedInSpatialStructure::type() const { return Type::IfcRelReferencedInSpatialStructure; }
Type::Enum IfcRelReferencedInSpatialStructure::Class() { return Type::IfcRelReferencedInSpatialStructure; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelReferencedInSpatialStructure)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelReferencedInSpatialStructure::IfcRelReferencedInSpatialStructure(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, SHARED_PTR< IfcTemplatedEntityList< IfcProduct > > v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatedElements)->generalize()); e->setArgument(5,(v6_RelatingStructure)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelSequence
IfcProcess* IfcRelSequence::RelatingProcess() { return (IfcProcess*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelSequence::setRelatingProcess(IfcProcess* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcProcess* IfcRelSequence::RelatedProcess() { return (IfcProcess*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelSequence::setRelatedProcess(IfcProcess* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelSequence::hasTimeLag() { return !entity->getArgument(6)->isNull(); }
IfcLagTime* IfcRelSequence::TimeLag() { return (IfcLagTime*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelSequence::setTimeLag(IfcLagTime* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcRelSequence::hasSequenceType() { return !entity->getArgument(7)->isNull(); }
IfcSequenceEnum::IfcSequenceEnum IfcRelSequence::SequenceType() { return IfcSequenceEnum::FromString(*entity->getArgument(7)); }
void IfcRelSequence::setSequenceType(IfcSequenceEnum::IfcSequenceEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcSequenceEnum::ToString(v)); }
bool IfcRelSequence::hasUserDefinedSequenceType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcRelSequence::UserDefinedSequenceType() { return *entity->getArgument(8); }
void IfcRelSequence::setUserDefinedSequenceType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcRelSequence::is(Type::Enum v) const { return v == Type::IfcRelSequence || IfcRelConnects::is(v); }
Type::Enum IfcRelSequence::type() const { return Type::IfcRelSequence; }
Type::Enum IfcRelSequence::Class() { return Type::IfcRelSequence; }
IfcRelSequence::IfcRelSequence(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelSequence)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSequence::IfcRelSequence(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcProcess* v5_RelatingProcess, IfcProcess* v6_RelatedProcess, IfcLagTime* v7_TimeLag, boost::optional< IfcSequenceEnum::IfcSequenceEnum > v8_SequenceType, boost::optional< IfcLabel > v9_UserDefinedSequenceType) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingProcess)); e->setArgument(5,(v6_RelatedProcess)); e->setArgument(6,(v7_TimeLag)); if (v8_SequenceType) { e->setArgument(7,*v8_SequenceType,IfcSequenceEnum::ToString(*v8_SequenceType)); } else { e->setArgument(7); } if (v9_UserDefinedSequenceType) { e->setArgument(8,(*v9_UserDefinedSequenceType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelServicesBuildings
IfcSystem* IfcRelServicesBuildings::RelatingSystem() { return (IfcSystem*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelServicesBuildings::setRelatingSystem(IfcSystem* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcSpatialElement > > IfcRelServicesBuildings::RelatedBuildings() { RETURN_AS_LIST(IfcSpatialElement,5) }
void IfcRelServicesBuildings::setRelatedBuildings(SHARED_PTR< IfcTemplatedEntityList< IfcSpatialElement > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcRelServicesBuildings::is(Type::Enum v) const { return v == Type::IfcRelServicesBuildings || IfcRelConnects::is(v); }
Type::Enum IfcRelServicesBuildings::type() const { return Type::IfcRelServicesBuildings; }
Type::Enum IfcRelServicesBuildings::Class() { return Type::IfcRelServicesBuildings; }
IfcRelServicesBuildings::IfcRelServicesBuildings(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelServicesBuildings)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelServicesBuildings::IfcRelServicesBuildings(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcSystem* v5_RelatingSystem, SHARED_PTR< IfcTemplatedEntityList< IfcSpatialElement > > v6_RelatedBuildings) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingSystem)); e->setArgument(5,(v6_RelatedBuildings)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelSpaceBoundary
IfcSpaceBoundarySelect IfcRelSpaceBoundary::RelatingSpace() { return *entity->getArgument(4); }
void IfcRelSpaceBoundary::setRelatingSpace(IfcSpaceBoundarySelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcElement* IfcRelSpaceBoundary::RelatedBuildingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelSpaceBoundary::setRelatedBuildingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelSpaceBoundary::hasConnectionGeometry() { return !entity->getArgument(6)->isNull(); }
IfcConnectionGeometry* IfcRelSpaceBoundary::ConnectionGeometry() { return (IfcConnectionGeometry*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcRelSpaceBoundary::setConnectionGeometry(IfcConnectionGeometry* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum IfcRelSpaceBoundary::PhysicalOrVirtualBoundary() { return IfcPhysicalOrVirtualEnum::FromString(*entity->getArgument(7)); }
void IfcRelSpaceBoundary::setPhysicalOrVirtualBoundary(IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcPhysicalOrVirtualEnum::ToString(v)); }
IfcInternalOrExternalEnum::IfcInternalOrExternalEnum IfcRelSpaceBoundary::InternalOrExternalBoundary() { return IfcInternalOrExternalEnum::FromString(*entity->getArgument(8)); }
void IfcRelSpaceBoundary::setInternalOrExternalBoundary(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcInternalOrExternalEnum::ToString(v)); }
bool IfcRelSpaceBoundary::is(Type::Enum v) const { return v == Type::IfcRelSpaceBoundary || IfcRelConnects::is(v); }
Type::Enum IfcRelSpaceBoundary::type() const { return Type::IfcRelSpaceBoundary; }
Type::Enum IfcRelSpaceBoundary::Class() { return Type::IfcRelSpaceBoundary; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(IfcAbstractEntityPtr e) : IfcRelConnects((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelSpaceBoundary)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSpaceBoundary::IfcRelSpaceBoundary(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcSpaceBoundarySelect v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary) : IfcRelConnects((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingSpace)); e->setArgument(5,(v6_RelatedBuildingElement)); e->setArgument(6,(v7_ConnectionGeometry)); e->setArgument(7,v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary)); e->setArgument(8,v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelSpaceBoundary1stLevel
bool IfcRelSpaceBoundary1stLevel::hasParentBoundary() { return !entity->getArgument(9)->isNull(); }
IfcRelSpaceBoundary1stLevel* IfcRelSpaceBoundary1stLevel::ParentBoundary() { return (IfcRelSpaceBoundary1stLevel*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcRelSpaceBoundary1stLevel::setParentBoundary(IfcRelSpaceBoundary1stLevel* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
IfcRelSpaceBoundary1stLevel::list IfcRelSpaceBoundary1stLevel::InnerBoundaries() { RETURN_INVERSE(IfcRelSpaceBoundary1stLevel) }
bool IfcRelSpaceBoundary1stLevel::is(Type::Enum v) const { return v == Type::IfcRelSpaceBoundary1stLevel || IfcRelSpaceBoundary::is(v); }
Type::Enum IfcRelSpaceBoundary1stLevel::type() const { return Type::IfcRelSpaceBoundary1stLevel; }
Type::Enum IfcRelSpaceBoundary1stLevel::Class() { return Type::IfcRelSpaceBoundary1stLevel; }
IfcRelSpaceBoundary1stLevel::IfcRelSpaceBoundary1stLevel(IfcAbstractEntityPtr e) : IfcRelSpaceBoundary((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelSpaceBoundary1stLevel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSpaceBoundary1stLevel::IfcRelSpaceBoundary1stLevel(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcSpaceBoundarySelect v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary) : IfcRelSpaceBoundary((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingSpace)); e->setArgument(5,(v6_RelatedBuildingElement)); e->setArgument(6,(v7_ConnectionGeometry)); e->setArgument(7,v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary)); e->setArgument(8,v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary)); e->setArgument(9,(v10_ParentBoundary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelSpaceBoundary2ndLevel
bool IfcRelSpaceBoundary2ndLevel::hasCorrespondingBoundary() { return !entity->getArgument(10)->isNull(); }
IfcRelSpaceBoundary2ndLevel* IfcRelSpaceBoundary2ndLevel::CorrespondingBoundary() { return (IfcRelSpaceBoundary2ndLevel*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(10))); }
void IfcRelSpaceBoundary2ndLevel::setCorrespondingBoundary(IfcRelSpaceBoundary2ndLevel* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
IfcRelSpaceBoundary2ndLevel::list IfcRelSpaceBoundary2ndLevel::Corresponds() { RETURN_INVERSE(IfcRelSpaceBoundary2ndLevel) }
bool IfcRelSpaceBoundary2ndLevel::is(Type::Enum v) const { return v == Type::IfcRelSpaceBoundary2ndLevel || IfcRelSpaceBoundary1stLevel::is(v); }
Type::Enum IfcRelSpaceBoundary2ndLevel::type() const { return Type::IfcRelSpaceBoundary2ndLevel; }
Type::Enum IfcRelSpaceBoundary2ndLevel::Class() { return Type::IfcRelSpaceBoundary2ndLevel; }
IfcRelSpaceBoundary2ndLevel::IfcRelSpaceBoundary2ndLevel(IfcAbstractEntityPtr e) : IfcRelSpaceBoundary1stLevel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelSpaceBoundary2ndLevel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelSpaceBoundary2ndLevel::IfcRelSpaceBoundary2ndLevel(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcSpaceBoundarySelect v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary, IfcRelSpaceBoundary2ndLevel* v11_CorrespondingBoundary) : IfcRelSpaceBoundary1stLevel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingSpace)); e->setArgument(5,(v6_RelatedBuildingElement)); e->setArgument(6,(v7_ConnectionGeometry)); e->setArgument(7,v8_PhysicalOrVirtualBoundary,IfcPhysicalOrVirtualEnum::ToString(v8_PhysicalOrVirtualBoundary)); e->setArgument(8,v9_InternalOrExternalBoundary,IfcInternalOrExternalEnum::ToString(v9_InternalOrExternalBoundary)); e->setArgument(9,(v10_ParentBoundary)); e->setArgument(10,(v11_CorrespondingBoundary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelVoidsElement
IfcElement* IfcRelVoidsElement::RelatingBuildingElement() { return (IfcElement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRelVoidsElement::setRelatingBuildingElement(IfcElement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcFeatureElementSubtraction* IfcRelVoidsElement::RelatedOpeningElement() { return (IfcFeatureElementSubtraction*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcRelVoidsElement::setRelatedOpeningElement(IfcFeatureElementSubtraction* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRelVoidsElement::is(Type::Enum v) const { return v == Type::IfcRelVoidsElement || IfcRelDecomposes::is(v); }
Type::Enum IfcRelVoidsElement::type() const { return Type::IfcRelVoidsElement; }
Type::Enum IfcRelVoidsElement::Class() { return Type::IfcRelVoidsElement; }
IfcRelVoidsElement::IfcRelVoidsElement(IfcAbstractEntityPtr e) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelVoidsElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelVoidsElement::IfcRelVoidsElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcFeatureElementSubtraction* v6_RelatedOpeningElement) : IfcRelDecomposes((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,(v5_RelatingBuildingElement)); e->setArgument(5,(v6_RelatedOpeningElement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRelationship
bool IfcRelationship::is(Type::Enum v) const { return v == Type::IfcRelationship || IfcRoot::is(v); }
Type::Enum IfcRelationship::type() const { return Type::IfcRelationship; }
Type::Enum IfcRelationship::Class() { return Type::IfcRelationship; }
IfcRelationship::IfcRelationship(IfcAbstractEntityPtr e) : IfcRoot((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRelationship::IfcRelationship(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcRoot((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcReparametrisedCompositeCurveSegment
IfcParameterValue IfcReparametrisedCompositeCurveSegment::ParamLength() { return *entity->getArgument(3); }
void IfcReparametrisedCompositeCurveSegment::setParamLength(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcReparametrisedCompositeCurveSegment::is(Type::Enum v) const { return v == Type::IfcReparametrisedCompositeCurveSegment || IfcCompositeCurveSegment::is(v); }
Type::Enum IfcReparametrisedCompositeCurveSegment::type() const { return Type::IfcReparametrisedCompositeCurveSegment; }
Type::Enum IfcReparametrisedCompositeCurveSegment::Class() { return Type::IfcReparametrisedCompositeCurveSegment; }
IfcReparametrisedCompositeCurveSegment::IfcReparametrisedCompositeCurveSegment(IfcAbstractEntityPtr e) : IfcCompositeCurveSegment((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcReparametrisedCompositeCurveSegment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcReparametrisedCompositeCurveSegment::IfcReparametrisedCompositeCurveSegment(IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve, IfcParameterValue v4_ParamLength) : IfcCompositeCurveSegment((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_Transition,IfcTransitionCode::ToString(v1_Transition)); e->setArgument(1,(v2_SameSense)); e->setArgument(2,(v3_ParentCurve)); e->setArgument(3,(v4_ParamLength)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRepresentation
IfcRepresentationContext* IfcRepresentation::ContextOfItems() { return (IfcRepresentationContext*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcRepresentation::setContextOfItems(IfcRepresentationContext* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcRepresentation::hasRepresentationIdentifier() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcRepresentation::RepresentationIdentifier() { return *entity->getArgument(1); }
void IfcRepresentation::setRepresentationIdentifier(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcRepresentation::hasRepresentationType() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcRepresentation::RepresentationType() { return *entity->getArgument(2); }
void IfcRepresentation::setRepresentationType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > IfcRepresentation::Items() { RETURN_AS_LIST(IfcRepresentationItem,3) }
void IfcRepresentation::setItems(SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
IfcRepresentationMap::list IfcRepresentation::RepresentationMap() { RETURN_INVERSE(IfcRepresentationMap) }
IfcPresentationLayerAssignment::list IfcRepresentation::LayerAssignments() { RETURN_INVERSE(IfcPresentationLayerAssignment) }
IfcProductRepresentation::list IfcRepresentation::OfProductRepresentation() { RETURN_INVERSE(IfcProductRepresentation) }
bool IfcRepresentation::is(Type::Enum v) const { return v == Type::IfcRepresentation; }
Type::Enum IfcRepresentation::type() const { return Type::IfcRepresentation; }
Type::Enum IfcRepresentation::Class() { return Type::IfcRepresentation; }
IfcRepresentation::IfcRepresentation(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentation::IfcRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRepresentationContext
bool IfcRepresentationContext::hasContextIdentifier() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcRepresentationContext::ContextIdentifier() { return *entity->getArgument(0); }
void IfcRepresentationContext::setContextIdentifier(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcRepresentationContext::hasContextType() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcRepresentationContext::ContextType() { return *entity->getArgument(1); }
void IfcRepresentationContext::setContextType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcRepresentation::list IfcRepresentationContext::RepresentationsInContext() { RETURN_INVERSE(IfcRepresentation) }
bool IfcRepresentationContext::is(Type::Enum v) const { return v == Type::IfcRepresentationContext; }
Type::Enum IfcRepresentationContext::type() const { return Type::IfcRepresentationContext; }
Type::Enum IfcRepresentationContext::Class() { return Type::IfcRepresentationContext; }
IfcRepresentationContext::IfcRepresentationContext(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRepresentationContext)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationContext::IfcRepresentationContext(boost::optional< IfcLabel > v1_ContextIdentifier, boost::optional< IfcLabel > v2_ContextType) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_ContextIdentifier) { e->setArgument(0,(*v1_ContextIdentifier)); } else { e->setArgument(0); } if (v2_ContextType) { e->setArgument(1,(*v2_ContextType)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRepresentationItem
IfcPresentationLayerAssignment::list IfcRepresentationItem::LayerAssignment() { RETURN_INVERSE(IfcPresentationLayerAssignment) }
IfcStyledItem::list IfcRepresentationItem::StyledByItem() { RETURN_INVERSE(IfcStyledItem) }
bool IfcRepresentationItem::is(Type::Enum v) const { return v == Type::IfcRepresentationItem; }
Type::Enum IfcRepresentationItem::type() const { return Type::IfcRepresentationItem; }
Type::Enum IfcRepresentationItem::Class() { return Type::IfcRepresentationItem; }
IfcRepresentationItem::IfcRepresentationItem(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRepresentationItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationItem::IfcRepresentationItem() : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRepresentationMap
IfcAxis2Placement IfcRepresentationMap::MappingOrigin() { return *entity->getArgument(0); }
void IfcRepresentationMap::setMappingOrigin(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcRepresentation* IfcRepresentationMap::MappedRepresentation() { return (IfcRepresentation*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcRepresentationMap::setMappedRepresentation(IfcRepresentation* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcShapeAspect::list IfcRepresentationMap::HasShapeAspects() { RETURN_INVERSE(IfcShapeAspect) }
IfcMappedItem::list IfcRepresentationMap::MapUsage() { RETURN_INVERSE(IfcMappedItem) }
bool IfcRepresentationMap::is(Type::Enum v) const { return v == Type::IfcRepresentationMap; }
Type::Enum IfcRepresentationMap::type() const { return Type::IfcRepresentationMap; }
Type::Enum IfcRepresentationMap::Class() { return Type::IfcRepresentationMap; }
IfcRepresentationMap::IfcRepresentationMap(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRepresentationMap)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRepresentationMap::IfcRepresentationMap(IfcAxis2Placement v1_MappingOrigin, IfcRepresentation* v2_MappedRepresentation) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_MappingOrigin)); e->setArgument(1,(v2_MappedRepresentation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcResource
bool IfcResource::hasIdentification() { return !entity->getArgument(5)->isNull(); }
IfcIdentifier IfcResource::Identification() { return *entity->getArgument(5); }
void IfcResource::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcResource::hasLongDescription() { return !entity->getArgument(6)->isNull(); }
IfcText IfcResource::LongDescription() { return *entity->getArgument(6); }
void IfcResource::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
IfcRelAssignsToResource::list IfcResource::ResourceOf() { RETURN_INVERSE(IfcRelAssignsToResource) }
bool IfcResource::is(Type::Enum v) const { return v == Type::IfcResource || IfcObject::is(v); }
Type::Enum IfcResource::type() const { return Type::IfcResource; }
Type::Enum IfcResource::Class() { return Type::IfcResource; }
IfcResource::IfcResource(IfcAbstractEntityPtr e) : IfcObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResource::IfcResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription) : IfcObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcResourceApprovalRelationship
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcResourceApprovalRelationship::RelatedResourceObjects() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcResourceApprovalRelationship::setRelatedResourceObjects(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
IfcApproval* IfcResourceApprovalRelationship::RelatingApproval() { return (IfcApproval*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcResourceApprovalRelationship::setRelatingApproval(IfcApproval* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcResourceApprovalRelationship::is(Type::Enum v) const { return v == Type::IfcResourceApprovalRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcResourceApprovalRelationship::type() const { return Type::IfcResourceApprovalRelationship; }
Type::Enum IfcResourceApprovalRelationship::Class() { return Type::IfcResourceApprovalRelationship; }
IfcResourceApprovalRelationship::IfcResourceApprovalRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcResourceApprovalRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResourceApprovalRelationship::IfcResourceApprovalRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcEntities v3_RelatedResourceObjects, IfcApproval* v4_RelatingApproval) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatedResourceObjects)); e->setArgument(3,(v4_RelatingApproval)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcResourceConstraintRelationship
IfcConstraint* IfcResourceConstraintRelationship::RelatingConstraint() { return (IfcConstraint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcResourceConstraintRelationship::setRelatingConstraint(IfcConstraint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcResourceConstraintRelationship::RelatedResourceObjects() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,3) }
void IfcResourceConstraintRelationship::setRelatedResourceObjects(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v->generalize()); }
bool IfcResourceConstraintRelationship::is(Type::Enum v) const { return v == Type::IfcResourceConstraintRelationship || IfcResourceLevelRelationship::is(v); }
Type::Enum IfcResourceConstraintRelationship::type() const { return Type::IfcResourceConstraintRelationship; }
Type::Enum IfcResourceConstraintRelationship::Class() { return Type::IfcResourceConstraintRelationship; }
IfcResourceConstraintRelationship::IfcResourceConstraintRelationship(IfcAbstractEntityPtr e) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcResourceConstraintRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResourceConstraintRelationship::IfcResourceConstraintRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcEntities v4_RelatedResourceObjects) : IfcResourceLevelRelationship((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_RelatingConstraint)); e->setArgument(3,(v4_RelatedResourceObjects)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcResourceLevelRelationship
bool IfcResourceLevelRelationship::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcResourceLevelRelationship::Name() { return *entity->getArgument(0); }
void IfcResourceLevelRelationship::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcResourceLevelRelationship::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcResourceLevelRelationship::Description() { return *entity->getArgument(1); }
void IfcResourceLevelRelationship::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcResourceLevelRelationship::is(Type::Enum v) const { return v == Type::IfcResourceLevelRelationship; }
Type::Enum IfcResourceLevelRelationship::type() const { return Type::IfcResourceLevelRelationship; }
Type::Enum IfcResourceLevelRelationship::Class() { return Type::IfcResourceLevelRelationship; }
IfcResourceLevelRelationship::IfcResourceLevelRelationship(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcResourceLevelRelationship)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResourceLevelRelationship::IfcResourceLevelRelationship(boost::optional< IfcLabel > v1_Name, boost::optional< IfcText > v2_Description) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcResourceTime
bool IfcResourceTime::hasScheduleWork() { return !entity->getArgument(3)->isNull(); }
IfcDuration IfcResourceTime::ScheduleWork() { return *entity->getArgument(3); }
void IfcResourceTime::setScheduleWork(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcResourceTime::hasScheduleUsage() { return !entity->getArgument(4)->isNull(); }
IfcPositiveRatioMeasure IfcResourceTime::ScheduleUsage() { return *entity->getArgument(4); }
void IfcResourceTime::setScheduleUsage(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcResourceTime::hasScheduleStart() { return !entity->getArgument(5)->isNull(); }
IfcDateTime IfcResourceTime::ScheduleStart() { return *entity->getArgument(5); }
void IfcResourceTime::setScheduleStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcResourceTime::hasScheduleFinish() { return !entity->getArgument(6)->isNull(); }
IfcDateTime IfcResourceTime::ScheduleFinish() { return *entity->getArgument(6); }
void IfcResourceTime::setScheduleFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcResourceTime::hasScheduleContour() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcResourceTime::ScheduleContour() { return *entity->getArgument(7); }
void IfcResourceTime::setScheduleContour(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcResourceTime::hasLevelingDelay() { return !entity->getArgument(8)->isNull(); }
IfcDuration IfcResourceTime::LevelingDelay() { return *entity->getArgument(8); }
void IfcResourceTime::setLevelingDelay(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcResourceTime::hasIsOverAllocated() { return !entity->getArgument(9)->isNull(); }
bool IfcResourceTime::IsOverAllocated() { return *entity->getArgument(9); }
void IfcResourceTime::setIsOverAllocated(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcResourceTime::hasStatusTime() { return !entity->getArgument(10)->isNull(); }
IfcDateTime IfcResourceTime::StatusTime() { return *entity->getArgument(10); }
void IfcResourceTime::setStatusTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcResourceTime::hasActualWork() { return !entity->getArgument(11)->isNull(); }
IfcDuration IfcResourceTime::ActualWork() { return *entity->getArgument(11); }
void IfcResourceTime::setActualWork(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcResourceTime::hasActualUsage() { return !entity->getArgument(12)->isNull(); }
IfcPositiveRatioMeasure IfcResourceTime::ActualUsage() { return *entity->getArgument(12); }
void IfcResourceTime::setActualUsage(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcResourceTime::hasActualStart() { return !entity->getArgument(13)->isNull(); }
IfcDateTime IfcResourceTime::ActualStart() { return *entity->getArgument(13); }
void IfcResourceTime::setActualStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcResourceTime::hasActualFinish() { return !entity->getArgument(14)->isNull(); }
IfcDateTime IfcResourceTime::ActualFinish() { return *entity->getArgument(14); }
void IfcResourceTime::setActualFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcResourceTime::hasRemainingWork() { return !entity->getArgument(15)->isNull(); }
IfcDuration IfcResourceTime::RemainingWork() { return *entity->getArgument(15); }
void IfcResourceTime::setRemainingWork(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcResourceTime::hasRemainingUsage() { return !entity->getArgument(16)->isNull(); }
IfcPositiveRatioMeasure IfcResourceTime::RemainingUsage() { return *entity->getArgument(16); }
void IfcResourceTime::setRemainingUsage(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcResourceTime::hasCompletion() { return !entity->getArgument(17)->isNull(); }
IfcPositiveRatioMeasure IfcResourceTime::Completion() { return *entity->getArgument(17); }
void IfcResourceTime::setCompletion(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(17,v); }
bool IfcResourceTime::is(Type::Enum v) const { return v == Type::IfcResourceTime || IfcSchedulingTime::is(v); }
Type::Enum IfcResourceTime::type() const { return Type::IfcResourceTime; }
Type::Enum IfcResourceTime::Class() { return Type::IfcResourceTime; }
IfcResourceTime::IfcResourceTime(IfcAbstractEntityPtr e) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcResourceTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcResourceTime::IfcResourceTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, boost::optional< IfcDuration > v4_ScheduleWork, boost::optional< IfcPositiveRatioMeasure > v5_ScheduleUsage, boost::optional< IfcDateTime > v6_ScheduleStart, boost::optional< IfcDateTime > v7_ScheduleFinish, boost::optional< IfcLabel > v8_ScheduleContour, boost::optional< IfcDuration > v9_LevelingDelay, boost::optional< bool > v10_IsOverAllocated, boost::optional< IfcDateTime > v11_StatusTime, boost::optional< IfcDuration > v12_ActualWork, boost::optional< IfcPositiveRatioMeasure > v13_ActualUsage, boost::optional< IfcDateTime > v14_ActualStart, boost::optional< IfcDateTime > v15_ActualFinish, boost::optional< IfcDuration > v16_RemainingWork, boost::optional< IfcPositiveRatioMeasure > v17_RemainingUsage, boost::optional< IfcPositiveRatioMeasure > v18_Completion) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } if (v4_ScheduleWork) { e->setArgument(3,(*v4_ScheduleWork)); } else { e->setArgument(3); } if (v5_ScheduleUsage) { e->setArgument(4,(*v5_ScheduleUsage)); } else { e->setArgument(4); } if (v6_ScheduleStart) { e->setArgument(5,(*v6_ScheduleStart)); } else { e->setArgument(5); } if (v7_ScheduleFinish) { e->setArgument(6,(*v7_ScheduleFinish)); } else { e->setArgument(6); } if (v8_ScheduleContour) { e->setArgument(7,(*v8_ScheduleContour)); } else { e->setArgument(7); } if (v9_LevelingDelay) { e->setArgument(8,(*v9_LevelingDelay)); } else { e->setArgument(8); } if (v10_IsOverAllocated) { e->setArgument(9,(*v10_IsOverAllocated)); } else { e->setArgument(9); } if (v11_StatusTime) { e->setArgument(10,(*v11_StatusTime)); } else { e->setArgument(10); } if (v12_ActualWork) { e->setArgument(11,(*v12_ActualWork)); } else { e->setArgument(11); } if (v13_ActualUsage) { e->setArgument(12,(*v13_ActualUsage)); } else { e->setArgument(12); } if (v14_ActualStart) { e->setArgument(13,(*v14_ActualStart)); } else { e->setArgument(13); } if (v15_ActualFinish) { e->setArgument(14,(*v15_ActualFinish)); } else { e->setArgument(14); } if (v16_RemainingWork) { e->setArgument(15,(*v16_RemainingWork)); } else { e->setArgument(15); } if (v17_RemainingUsage) { e->setArgument(16,(*v17_RemainingUsage)); } else { e->setArgument(16); } if (v18_Completion) { e->setArgument(17,(*v18_Completion)); } else { e->setArgument(17); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRevolvedAreaSolid
IfcAxis1Placement* IfcRevolvedAreaSolid::Axis() { return (IfcAxis1Placement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcRevolvedAreaSolid::setAxis(IfcAxis1Placement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcPlaneAngleMeasure IfcRevolvedAreaSolid::Angle() { return *entity->getArgument(3); }
void IfcRevolvedAreaSolid::setAngle(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcRevolvedAreaSolid::is(Type::Enum v) const { return v == Type::IfcRevolvedAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcRevolvedAreaSolid::type() const { return Type::IfcRevolvedAreaSolid; }
Type::Enum IfcRevolvedAreaSolid::Class() { return Type::IfcRevolvedAreaSolid; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcAbstractEntityPtr e) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRevolvedAreaSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRevolvedAreaSolid::IfcRevolvedAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, IfcPlaneAngleMeasure v4_Angle) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_Axis)); e->setArgument(3,(v4_Angle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRevolvedAreaSolidTapered
IfcProfileDef* IfcRevolvedAreaSolidTapered::EndSweptArea() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcRevolvedAreaSolidTapered::setEndSweptArea(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcRevolvedAreaSolidTapered::is(Type::Enum v) const { return v == Type::IfcRevolvedAreaSolidTapered || IfcRevolvedAreaSolid::is(v); }
Type::Enum IfcRevolvedAreaSolidTapered::type() const { return Type::IfcRevolvedAreaSolidTapered; }
Type::Enum IfcRevolvedAreaSolidTapered::Class() { return Type::IfcRevolvedAreaSolidTapered; }
IfcRevolvedAreaSolidTapered::IfcRevolvedAreaSolidTapered(IfcAbstractEntityPtr e) : IfcRevolvedAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRevolvedAreaSolidTapered)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRevolvedAreaSolidTapered::IfcRevolvedAreaSolidTapered(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, IfcPlaneAngleMeasure v4_Angle, IfcProfileDef* v5_EndSweptArea) : IfcRevolvedAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_Axis)); e->setArgument(3,(v4_Angle)); e->setArgument(4,(v5_EndSweptArea)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRightCircularCone
IfcPositiveLengthMeasure IfcRightCircularCone::Height() { return *entity->getArgument(1); }
void IfcRightCircularCone::setHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcRightCircularCone::BottomRadius() { return *entity->getArgument(2); }
void IfcRightCircularCone::setBottomRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcRightCircularCone::is(Type::Enum v) const { return v == Type::IfcRightCircularCone || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRightCircularCone::type() const { return Type::IfcRightCircularCone; }
Type::Enum IfcRightCircularCone::Class() { return Type::IfcRightCircularCone; }
IfcRightCircularCone::IfcRightCircularCone(IfcAbstractEntityPtr e) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRightCircularCone)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRightCircularCone::IfcRightCircularCone(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_Height, IfcPositiveLengthMeasure v3_BottomRadius) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_Height)); e->setArgument(2,(v3_BottomRadius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRightCircularCylinder
IfcPositiveLengthMeasure IfcRightCircularCylinder::Height() { return *entity->getArgument(1); }
void IfcRightCircularCylinder::setHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcPositiveLengthMeasure IfcRightCircularCylinder::Radius() { return *entity->getArgument(2); }
void IfcRightCircularCylinder::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcRightCircularCylinder::is(Type::Enum v) const { return v == Type::IfcRightCircularCylinder || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcRightCircularCylinder::type() const { return Type::IfcRightCircularCylinder; }
Type::Enum IfcRightCircularCylinder::Class() { return Type::IfcRightCircularCylinder; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcAbstractEntityPtr e) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRightCircularCylinder)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRightCircularCylinder::IfcRightCircularCylinder(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_Height, IfcPositiveLengthMeasure v3_Radius) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_Height)); e->setArgument(2,(v3_Radius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRoof
bool IfcRoof::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoof::PredefinedType() { return IfcRoofTypeEnum::FromString(*entity->getArgument(8)); }
void IfcRoof::setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcRoofTypeEnum::ToString(v)); }
bool IfcRoof::is(Type::Enum v) const { return v == Type::IfcRoof || IfcBuildingElement::is(v); }
Type::Enum IfcRoof::type() const { return Type::IfcRoof; }
Type::Enum IfcRoof::Class() { return Type::IfcRoof; }
IfcRoof::IfcRoof(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRoof)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoof::IfcRoof(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcRoofTypeEnum::IfcRoofTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcRoofTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRoofType
IfcRoofTypeEnum::IfcRoofTypeEnum IfcRoofType::PredefinedType() { return IfcRoofTypeEnum::FromString(*entity->getArgument(9)); }
void IfcRoofType::setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcRoofTypeEnum::ToString(v)); }
bool IfcRoofType::is(Type::Enum v) const { return v == Type::IfcRoofType || IfcBuildingElementType::is(v); }
Type::Enum IfcRoofType::type() const { return Type::IfcRoofType; }
Type::Enum IfcRoofType::Class() { return Type::IfcRoofType; }
IfcRoofType::IfcRoofType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRoofType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoofType::IfcRoofType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcRoofTypeEnum::IfcRoofTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcRoofTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRoot
IfcGloballyUniqueId IfcRoot::GlobalId() { return *entity->getArgument(0); }
void IfcRoot::setGlobalId(IfcGloballyUniqueId v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcRoot::hasOwnerHistory() { return !entity->getArgument(1)->isNull(); }
IfcOwnerHistory* IfcRoot::OwnerHistory() { return (IfcOwnerHistory*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcRoot::setOwnerHistory(IfcOwnerHistory* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcRoot::hasName() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcRoot::Name() { return *entity->getArgument(2); }
void IfcRoot::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcRoot::hasDescription() { return !entity->getArgument(3)->isNull(); }
IfcText IfcRoot::Description() { return *entity->getArgument(3); }
void IfcRoot::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcRoot::is(Type::Enum v) const { return v == Type::IfcRoot; }
Type::Enum IfcRoot::type() const { return Type::IfcRoot; }
Type::Enum IfcRoot::Class() { return Type::IfcRoot; }
IfcRoot::IfcRoot(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcRoot)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoot::IfcRoot(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcRoundedRectangleProfileDef
IfcPositiveLengthMeasure IfcRoundedRectangleProfileDef::RoundingRadius() { return *entity->getArgument(5); }
void IfcRoundedRectangleProfileDef::setRoundingRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcRoundedRectangleProfileDef::is(Type::Enum v) const { return v == Type::IfcRoundedRectangleProfileDef || IfcRectangleProfileDef::is(v); }
Type::Enum IfcRoundedRectangleProfileDef::type() const { return Type::IfcRoundedRectangleProfileDef; }
Type::Enum IfcRoundedRectangleProfileDef::Class() { return Type::IfcRoundedRectangleProfileDef; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcAbstractEntityPtr e) : IfcRectangleProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcRoundedRectangleProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcRoundedRectangleProfileDef::IfcRoundedRectangleProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_XDim, IfcPositiveLengthMeasure v5_YDim, IfcPositiveLengthMeasure v6_RoundingRadius) : IfcRectangleProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_XDim)); e->setArgument(4,(v5_YDim)); e->setArgument(5,(v6_RoundingRadius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSIUnit
bool IfcSIUnit::hasPrefix() { return !entity->getArgument(2)->isNull(); }
IfcSIPrefix::IfcSIPrefix IfcSIUnit::Prefix() { return IfcSIPrefix::FromString(*entity->getArgument(2)); }
void IfcSIUnit::setPrefix(IfcSIPrefix::IfcSIPrefix v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcSIPrefix::ToString(v)); }
IfcSIUnitName::IfcSIUnitName IfcSIUnit::Name() { return IfcSIUnitName::FromString(*entity->getArgument(3)); }
void IfcSIUnit::setName(IfcSIUnitName::IfcSIUnitName v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v,IfcSIUnitName::ToString(v)); }
bool IfcSIUnit::is(Type::Enum v) const { return v == Type::IfcSIUnit || IfcNamedUnit::is(v); }
Type::Enum IfcSIUnit::type() const { return Type::IfcSIUnit; }
Type::Enum IfcSIUnit::Class() { return Type::IfcSIUnit; }
IfcSIUnit::IfcSIUnit(IfcAbstractEntityPtr e) : IfcNamedUnit((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSIUnit)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSIUnit::IfcSIUnit(IfcUnitEnum::IfcUnitEnum v2_UnitType, boost::optional< IfcSIPrefix::IfcSIPrefix > v3_Prefix, IfcSIUnitName::IfcSIUnitName v4_Name) : IfcNamedUnit((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgumentDerived(0); e->setArgument(1,v2_UnitType,IfcUnitEnum::ToString(v2_UnitType)); if (v3_Prefix) { e->setArgument(2,*v3_Prefix,IfcSIPrefix::ToString(*v3_Prefix)); } else { e->setArgument(2); } e->setArgument(3,v4_Name,IfcSIUnitName::ToString(v4_Name)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSanitaryTerminal
bool IfcSanitaryTerminal::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminal::PredefinedType() { return IfcSanitaryTerminalTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSanitaryTerminal::setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSanitaryTerminalTypeEnum::ToString(v)); }
bool IfcSanitaryTerminal::is(Type::Enum v) const { return v == Type::IfcSanitaryTerminal || IfcFlowTerminal::is(v); }
Type::Enum IfcSanitaryTerminal::type() const { return Type::IfcSanitaryTerminal; }
Type::Enum IfcSanitaryTerminal::Class() { return Type::IfcSanitaryTerminal; }
IfcSanitaryTerminal::IfcSanitaryTerminal(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSanitaryTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSanitaryTerminal::IfcSanitaryTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSanitaryTerminalTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSanitaryTerminalType
IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum IfcSanitaryTerminalType::PredefinedType() { return IfcSanitaryTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSanitaryTerminalType::setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSanitaryTerminalTypeEnum::ToString(v)); }
bool IfcSanitaryTerminalType::is(Type::Enum v) const { return v == Type::IfcSanitaryTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcSanitaryTerminalType::type() const { return Type::IfcSanitaryTerminalType; }
Type::Enum IfcSanitaryTerminalType::Class() { return Type::IfcSanitaryTerminalType; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSanitaryTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSanitaryTerminalType::IfcSanitaryTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSanitaryTerminalTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSchedulingTime
bool IfcSchedulingTime::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcSchedulingTime::Name() { return *entity->getArgument(0); }
void IfcSchedulingTime::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSchedulingTime::hasDataOrigin() { return !entity->getArgument(1)->isNull(); }
IfcDataOriginEnum::IfcDataOriginEnum IfcSchedulingTime::DataOrigin() { return IfcDataOriginEnum::FromString(*entity->getArgument(1)); }
void IfcSchedulingTime::setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v,IfcDataOriginEnum::ToString(v)); }
bool IfcSchedulingTime::hasUserDefinedDataOrigin() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcSchedulingTime::UserDefinedDataOrigin() { return *entity->getArgument(2); }
void IfcSchedulingTime::setUserDefinedDataOrigin(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSchedulingTime::is(Type::Enum v) const { return v == Type::IfcSchedulingTime; }
Type::Enum IfcSchedulingTime::type() const { return Type::IfcSchedulingTime; }
Type::Enum IfcSchedulingTime::Class() { return Type::IfcSchedulingTime; }
IfcSchedulingTime::IfcSchedulingTime(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcSchedulingTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSchedulingTime::IfcSchedulingTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSectionProperties
IfcSectionTypeEnum::IfcSectionTypeEnum IfcSectionProperties::SectionType() { return IfcSectionTypeEnum::FromString(*entity->getArgument(0)); }
void IfcSectionProperties::setSectionType(IfcSectionTypeEnum::IfcSectionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v,IfcSectionTypeEnum::ToString(v)); }
IfcProfileDef* IfcSectionProperties::StartProfile() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcSectionProperties::setStartProfile(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSectionProperties::hasEndProfile() { return !entity->getArgument(2)->isNull(); }
IfcProfileDef* IfcSectionProperties::EndProfile() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSectionProperties::setEndProfile(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSectionProperties::is(Type::Enum v) const { return v == Type::IfcSectionProperties || IfcPreDefinedProperties::is(v); }
Type::Enum IfcSectionProperties::type() const { return Type::IfcSectionProperties; }
Type::Enum IfcSectionProperties::Class() { return Type::IfcSectionProperties; }
IfcSectionProperties::IfcSectionProperties(IfcAbstractEntityPtr e) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSectionProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionProperties::IfcSectionProperties(IfcSectionTypeEnum::IfcSectionTypeEnum v1_SectionType, IfcProfileDef* v2_StartProfile, IfcProfileDef* v3_EndProfile) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_SectionType,IfcSectionTypeEnum::ToString(v1_SectionType)); e->setArgument(1,(v2_StartProfile)); e->setArgument(2,(v3_EndProfile)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSectionReinforcementProperties
IfcLengthMeasure IfcSectionReinforcementProperties::LongitudinalStartPosition() { return *entity->getArgument(0); }
void IfcSectionReinforcementProperties::setLongitudinalStartPosition(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLengthMeasure IfcSectionReinforcementProperties::LongitudinalEndPosition() { return *entity->getArgument(1); }
void IfcSectionReinforcementProperties::setLongitudinalEndPosition(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSectionReinforcementProperties::hasTransversePosition() { return !entity->getArgument(2)->isNull(); }
IfcLengthMeasure IfcSectionReinforcementProperties::TransversePosition() { return *entity->getArgument(2); }
void IfcSectionReinforcementProperties::setTransversePosition(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum IfcSectionReinforcementProperties::ReinforcementRole() { return IfcReinforcingBarRoleEnum::FromString(*entity->getArgument(3)); }
void IfcSectionReinforcementProperties::setReinforcementRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v,IfcReinforcingBarRoleEnum::ToString(v)); }
IfcSectionProperties* IfcSectionReinforcementProperties::SectionDefinition() { return (IfcSectionProperties*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcSectionReinforcementProperties::setSectionDefinition(IfcSectionProperties* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcReinforcementBarProperties > > IfcSectionReinforcementProperties::CrossSectionReinforcementDefinitions() { RETURN_AS_LIST(IfcReinforcementBarProperties,5) }
void IfcSectionReinforcementProperties::setCrossSectionReinforcementDefinitions(SHARED_PTR< IfcTemplatedEntityList< IfcReinforcementBarProperties > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
bool IfcSectionReinforcementProperties::is(Type::Enum v) const { return v == Type::IfcSectionReinforcementProperties || IfcPreDefinedProperties::is(v); }
Type::Enum IfcSectionReinforcementProperties::type() const { return Type::IfcSectionReinforcementProperties; }
Type::Enum IfcSectionReinforcementProperties::Class() { return Type::IfcSectionReinforcementProperties; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(IfcAbstractEntityPtr e) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSectionReinforcementProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionReinforcementProperties::IfcSectionReinforcementProperties(IfcLengthMeasure v1_LongitudinalStartPosition, IfcLengthMeasure v2_LongitudinalEndPosition, boost::optional< IfcLengthMeasure > v3_TransversePosition, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v4_ReinforcementRole, IfcSectionProperties* v5_SectionDefinition, SHARED_PTR< IfcTemplatedEntityList< IfcReinforcementBarProperties > > v6_CrossSectionReinforcementDefinitions) : IfcPreDefinedProperties((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_LongitudinalStartPosition)); e->setArgument(1,(v2_LongitudinalEndPosition)); if (v3_TransversePosition) { e->setArgument(2,(*v3_TransversePosition)); } else { e->setArgument(2); } e->setArgument(3,v4_ReinforcementRole,IfcReinforcingBarRoleEnum::ToString(v4_ReinforcementRole)); e->setArgument(4,(v5_SectionDefinition)); e->setArgument(5,(v6_CrossSectionReinforcementDefinitions)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSectionedSpine
IfcCompositeCurve* IfcSectionedSpine::SpineCurve() { return (IfcCompositeCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSectionedSpine::setSpineCurve(IfcCompositeCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > IfcSectionedSpine::CrossSections() { RETURN_AS_LIST(IfcProfileDef,1) }
void IfcSectionedSpine::setCrossSections(SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
SHARED_PTR< IfcTemplatedEntityList< IfcAxis2Placement3D > > IfcSectionedSpine::CrossSectionPositions() { RETURN_AS_LIST(IfcAxis2Placement3D,2) }
void IfcSectionedSpine::setCrossSectionPositions(SHARED_PTR< IfcTemplatedEntityList< IfcAxis2Placement3D > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcSectionedSpine::is(Type::Enum v) const { return v == Type::IfcSectionedSpine || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSectionedSpine::type() const { return Type::IfcSectionedSpine; }
Type::Enum IfcSectionedSpine::Class() { return Type::IfcSectionedSpine; }
IfcSectionedSpine::IfcSectionedSpine(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSectionedSpine)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSectionedSpine::IfcSectionedSpine(IfcCompositeCurve* v1_SpineCurve, SHARED_PTR< IfcTemplatedEntityList< IfcProfileDef > > v2_CrossSections, SHARED_PTR< IfcTemplatedEntityList< IfcAxis2Placement3D > > v3_CrossSectionPositions) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SpineCurve)); e->setArgument(1,(v2_CrossSections)->generalize()); e->setArgument(2,(v3_CrossSectionPositions)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSensor
bool IfcSensor::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensor::PredefinedType() { return IfcSensorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSensor::setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSensorTypeEnum::ToString(v)); }
bool IfcSensor::is(Type::Enum v) const { return v == Type::IfcSensor || IfcDistributionControlElement::is(v); }
Type::Enum IfcSensor::type() const { return Type::IfcSensor; }
Type::Enum IfcSensor::Class() { return Type::IfcSensor; }
IfcSensor::IfcSensor(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSensor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSensor::IfcSensor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSensorTypeEnum::IfcSensorTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSensorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSensorType
IfcSensorTypeEnum::IfcSensorTypeEnum IfcSensorType::PredefinedType() { return IfcSensorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSensorType::setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSensorTypeEnum::ToString(v)); }
bool IfcSensorType::is(Type::Enum v) const { return v == Type::IfcSensorType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcSensorType::type() const { return Type::IfcSensorType; }
Type::Enum IfcSensorType::Class() { return Type::IfcSensorType; }
IfcSensorType::IfcSensorType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSensorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSensorType::IfcSensorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSensorTypeEnum::IfcSensorTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSensorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShadingDevice
bool IfcShadingDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDevice::PredefinedType() { return IfcShadingDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcShadingDevice::setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcShadingDeviceTypeEnum::ToString(v)); }
bool IfcShadingDevice::is(Type::Enum v) const { return v == Type::IfcShadingDevice || IfcBuildingElement::is(v); }
Type::Enum IfcShadingDevice::type() const { return Type::IfcShadingDevice; }
Type::Enum IfcShadingDevice::Class() { return Type::IfcShadingDevice; }
IfcShadingDevice::IfcShadingDevice(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcShadingDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShadingDevice::IfcShadingDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcShadingDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShadingDeviceType
IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum IfcShadingDeviceType::PredefinedType() { return IfcShadingDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcShadingDeviceType::setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcShadingDeviceTypeEnum::ToString(v)); }
bool IfcShadingDeviceType::is(Type::Enum v) const { return v == Type::IfcShadingDeviceType || IfcBuildingElementType::is(v); }
Type::Enum IfcShadingDeviceType::type() const { return Type::IfcShadingDeviceType; }
Type::Enum IfcShadingDeviceType::Class() { return Type::IfcShadingDeviceType; }
IfcShadingDeviceType::IfcShadingDeviceType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcShadingDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShadingDeviceType::IfcShadingDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcShadingDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShapeAspect
SHARED_PTR< IfcTemplatedEntityList< IfcShapeModel > > IfcShapeAspect::ShapeRepresentations() { RETURN_AS_LIST(IfcShapeModel,0) }
void IfcShapeAspect::setShapeRepresentations(SHARED_PTR< IfcTemplatedEntityList< IfcShapeModel > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcShapeAspect::hasName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcShapeAspect::Name() { return *entity->getArgument(1); }
void IfcShapeAspect::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcShapeAspect::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcShapeAspect::Description() { return *entity->getArgument(2); }
void IfcShapeAspect::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcShapeAspect::ProductDefinitional() { return *entity->getArgument(3); }
void IfcShapeAspect::setProductDefinitional(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcShapeAspect::hasPartOfProductDefinitionShape() { return !entity->getArgument(4)->isNull(); }
IfcProductRepresentationSelect IfcShapeAspect::PartOfProductDefinitionShape() { return *entity->getArgument(4); }
void IfcShapeAspect::setPartOfProductDefinitionShape(IfcProductRepresentationSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcShapeAspect::is(Type::Enum v) const { return v == Type::IfcShapeAspect; }
Type::Enum IfcShapeAspect::type() const { return Type::IfcShapeAspect; }
Type::Enum IfcShapeAspect::Class() { return Type::IfcShapeAspect; }
IfcShapeAspect::IfcShapeAspect(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcShapeAspect)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeAspect::IfcShapeAspect(SHARED_PTR< IfcTemplatedEntityList< IfcShapeModel > > v1_ShapeRepresentations, boost::optional< IfcLabel > v2_Name, boost::optional< IfcText > v3_Description, bool v4_ProductDefinitional, boost::optional< IfcProductRepresentationSelect > v5_PartOfProductDefinitionShape) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ShapeRepresentations)->generalize()); if (v2_Name) { e->setArgument(1,(*v2_Name)); } else { e->setArgument(1); } if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } e->setArgument(3,(v4_ProductDefinitional)); if (v5_PartOfProductDefinitionShape) { e->setArgument(4,(*v5_PartOfProductDefinitionShape)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShapeModel
IfcShapeAspect::list IfcShapeModel::OfShapeAspect() { RETURN_INVERSE(IfcShapeAspect) }
bool IfcShapeModel::is(Type::Enum v) const { return v == Type::IfcShapeModel || IfcRepresentation::is(v); }
Type::Enum IfcShapeModel::type() const { return Type::IfcShapeModel; }
Type::Enum IfcShapeModel::Class() { return Type::IfcShapeModel; }
IfcShapeModel::IfcShapeModel(IfcAbstractEntityPtr e) : IfcRepresentation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcShapeModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeModel::IfcShapeModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcRepresentation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShapeRepresentation
bool IfcShapeRepresentation::is(Type::Enum v) const { return v == Type::IfcShapeRepresentation || IfcShapeModel::is(v); }
Type::Enum IfcShapeRepresentation::type() const { return Type::IfcShapeRepresentation; }
Type::Enum IfcShapeRepresentation::Class() { return Type::IfcShapeRepresentation; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcAbstractEntityPtr e) : IfcShapeModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcShapeRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShapeRepresentation::IfcShapeRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcShapeModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcShellBasedSurfaceModel
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcShellBasedSurfaceModel::SbsmBoundary() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcShellBasedSurfaceModel::setSbsmBoundary(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcShellBasedSurfaceModel::is(Type::Enum v) const { return v == Type::IfcShellBasedSurfaceModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcShellBasedSurfaceModel::type() const { return Type::IfcShellBasedSurfaceModel; }
Type::Enum IfcShellBasedSurfaceModel::Class() { return Type::IfcShellBasedSurfaceModel; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcShellBasedSurfaceModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcShellBasedSurfaceModel::IfcShellBasedSurfaceModel(IfcEntities v1_SbsmBoundary) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SbsmBoundary)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSimpleProperty
bool IfcSimpleProperty::is(Type::Enum v) const { return v == Type::IfcSimpleProperty || IfcProperty::is(v); }
Type::Enum IfcSimpleProperty::type() const { return Type::IfcSimpleProperty; }
Type::Enum IfcSimpleProperty::Class() { return Type::IfcSimpleProperty; }
IfcSimpleProperty::IfcSimpleProperty(IfcAbstractEntityPtr e) : IfcProperty((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSimpleProperty)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSimpleProperty::IfcSimpleProperty(IfcIdentifier v1_Name, boost::optional< IfcText > v2_Description) : IfcProperty((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSimplePropertyTemplate
bool IfcSimplePropertyTemplate::hasTemplateType() { return !entity->getArgument(4)->isNull(); }
IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum IfcSimplePropertyTemplate::TemplateType() { return IfcSimplePropertyTemplateTypeEnum::FromString(*entity->getArgument(4)); }
void IfcSimplePropertyTemplate::setTemplateType(IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcSimplePropertyTemplateTypeEnum::ToString(v)); }
bool IfcSimplePropertyTemplate::hasPrimaryMeasureType() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcSimplePropertyTemplate::PrimaryMeasureType() { return *entity->getArgument(5); }
void IfcSimplePropertyTemplate::setPrimaryMeasureType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcSimplePropertyTemplate::hasSecondaryMeasureType() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcSimplePropertyTemplate::SecondaryMeasureType() { return *entity->getArgument(6); }
void IfcSimplePropertyTemplate::setSecondaryMeasureType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcSimplePropertyTemplate::hasEnumerators() { return !entity->getArgument(7)->isNull(); }
IfcPropertyEnumeration* IfcSimplePropertyTemplate::Enumerators() { return (IfcPropertyEnumeration*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcSimplePropertyTemplate::setEnumerators(IfcPropertyEnumeration* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcSimplePropertyTemplate::hasPrimaryUnit() { return !entity->getArgument(8)->isNull(); }
IfcUnit IfcSimplePropertyTemplate::PrimaryUnit() { return *entity->getArgument(8); }
void IfcSimplePropertyTemplate::setPrimaryUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcSimplePropertyTemplate::hasSecondaryUnit() { return !entity->getArgument(9)->isNull(); }
IfcUnit IfcSimplePropertyTemplate::SecondaryUnit() { return *entity->getArgument(9); }
void IfcSimplePropertyTemplate::setSecondaryUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcSimplePropertyTemplate::hasExpression() { return !entity->getArgument(10)->isNull(); }
IfcLabel IfcSimplePropertyTemplate::Expression() { return *entity->getArgument(10); }
void IfcSimplePropertyTemplate::setExpression(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcSimplePropertyTemplate::hasAccessState() { return !entity->getArgument(11)->isNull(); }
IfcStateEnum::IfcStateEnum IfcSimplePropertyTemplate::AccessState() { return IfcStateEnum::FromString(*entity->getArgument(11)); }
void IfcSimplePropertyTemplate::setAccessState(IfcStateEnum::IfcStateEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcStateEnum::ToString(v)); }
bool IfcSimplePropertyTemplate::is(Type::Enum v) const { return v == Type::IfcSimplePropertyTemplate || IfcPropertyTemplate::is(v); }
Type::Enum IfcSimplePropertyTemplate::type() const { return Type::IfcSimplePropertyTemplate; }
Type::Enum IfcSimplePropertyTemplate::Class() { return Type::IfcSimplePropertyTemplate; }
IfcSimplePropertyTemplate::IfcSimplePropertyTemplate(IfcAbstractEntityPtr e) : IfcPropertyTemplate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSimplePropertyTemplate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSimplePropertyTemplate::IfcSimplePropertyTemplate(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum > v5_TemplateType, boost::optional< IfcLabel > v6_PrimaryMeasureType, boost::optional< IfcLabel > v7_SecondaryMeasureType, IfcPropertyEnumeration* v8_Enumerators, boost::optional< IfcUnit > v9_PrimaryUnit, boost::optional< IfcUnit > v10_SecondaryUnit, boost::optional< IfcLabel > v11_Expression, boost::optional< IfcStateEnum::IfcStateEnum > v12_AccessState) : IfcPropertyTemplate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_TemplateType) { e->setArgument(4,*v5_TemplateType,IfcSimplePropertyTemplateTypeEnum::ToString(*v5_TemplateType)); } else { e->setArgument(4); } if (v6_PrimaryMeasureType) { e->setArgument(5,(*v6_PrimaryMeasureType)); } else { e->setArgument(5); } if (v7_SecondaryMeasureType) { e->setArgument(6,(*v7_SecondaryMeasureType)); } else { e->setArgument(6); } e->setArgument(7,(v8_Enumerators)); if (v9_PrimaryUnit) { e->setArgument(8,(*v9_PrimaryUnit)); } else { e->setArgument(8); } if (v10_SecondaryUnit) { e->setArgument(9,(*v10_SecondaryUnit)); } else { e->setArgument(9); } if (v11_Expression) { e->setArgument(10,(*v11_Expression)); } else { e->setArgument(10); } if (v12_AccessState) { e->setArgument(11,*v12_AccessState,IfcStateEnum::ToString(*v12_AccessState)); } else { e->setArgument(11); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSite
bool IfcSite::hasRefLatitude() { return !entity->getArgument(9)->isNull(); }
IfcCompoundPlaneAngleMeasure IfcSite::RefLatitude() { return *entity->getArgument(9); }
void IfcSite::setRefLatitude(IfcCompoundPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcSite::hasRefLongitude() { return !entity->getArgument(10)->isNull(); }
IfcCompoundPlaneAngleMeasure IfcSite::RefLongitude() { return *entity->getArgument(10); }
void IfcSite::setRefLongitude(IfcCompoundPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcSite::hasRefElevation() { return !entity->getArgument(11)->isNull(); }
IfcLengthMeasure IfcSite::RefElevation() { return *entity->getArgument(11); }
void IfcSite::setRefElevation(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcSite::hasLandTitleNumber() { return !entity->getArgument(12)->isNull(); }
IfcLabel IfcSite::LandTitleNumber() { return *entity->getArgument(12); }
void IfcSite::setLandTitleNumber(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcSite::hasSiteAddress() { return !entity->getArgument(13)->isNull(); }
IfcPostalAddress* IfcSite::SiteAddress() { return (IfcPostalAddress*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(13))); }
void IfcSite::setSiteAddress(IfcPostalAddress* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcSite::is(Type::Enum v) const { return v == Type::IfcSite || IfcSpatialStructureElement::is(v); }
Type::Enum IfcSite::type() const { return Type::IfcSite; }
Type::Enum IfcSite::Class() { return Type::IfcSite; }
IfcSite::IfcSite(IfcAbstractEntityPtr e) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSite)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSite::IfcSite(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcCompoundPlaneAngleMeasure > v10_RefLatitude, boost::optional< IfcCompoundPlaneAngleMeasure > v11_RefLongitude, boost::optional< IfcLengthMeasure > v12_RefElevation, boost::optional< IfcLabel > v13_LandTitleNumber, IfcPostalAddress* v14_SiteAddress) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_CompositionType) { e->setArgument(8,*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType)); } else { e->setArgument(8); } if (v10_RefLatitude) { e->setArgument(9,(*v10_RefLatitude)); } else { e->setArgument(9); } if (v11_RefLongitude) { e->setArgument(10,(*v11_RefLongitude)); } else { e->setArgument(10); } if (v12_RefElevation) { e->setArgument(11,(*v12_RefElevation)); } else { e->setArgument(11); } if (v13_LandTitleNumber) { e->setArgument(12,(*v13_LandTitleNumber)); } else { e->setArgument(12); } e->setArgument(13,(v14_SiteAddress)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSlab
bool IfcSlab::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlab::PredefinedType() { return IfcSlabTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSlab::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSlabTypeEnum::ToString(v)); }
bool IfcSlab::is(Type::Enum v) const { return v == Type::IfcSlab || IfcBuildingElement::is(v); }
Type::Enum IfcSlab::type() const { return Type::IfcSlab; }
Type::Enum IfcSlab::Class() { return Type::IfcSlab; }
IfcSlab::IfcSlab(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSlab)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlab::IfcSlab(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSlabElementedCase
bool IfcSlabElementedCase::is(Type::Enum v) const { return v == Type::IfcSlabElementedCase || IfcSlab::is(v); }
Type::Enum IfcSlabElementedCase::type() const { return Type::IfcSlabElementedCase; }
Type::Enum IfcSlabElementedCase::Class() { return Type::IfcSlabElementedCase; }
IfcSlabElementedCase::IfcSlabElementedCase(IfcAbstractEntityPtr e) : IfcSlab((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSlabElementedCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlabElementedCase::IfcSlabElementedCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcSlab((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSlabStandardCase
bool IfcSlabStandardCase::is(Type::Enum v) const { return v == Type::IfcSlabStandardCase || IfcSlab::is(v); }
Type::Enum IfcSlabStandardCase::type() const { return Type::IfcSlabStandardCase; }
Type::Enum IfcSlabStandardCase::Class() { return Type::IfcSlabStandardCase; }
IfcSlabStandardCase::IfcSlabStandardCase(IfcAbstractEntityPtr e) : IfcSlab((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSlabStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlabStandardCase::IfcSlabStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType) : IfcSlab((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSlabTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSlabType
IfcSlabTypeEnum::IfcSlabTypeEnum IfcSlabType::PredefinedType() { return IfcSlabTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSlabType::setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSlabTypeEnum::ToString(v)); }
bool IfcSlabType::is(Type::Enum v) const { return v == Type::IfcSlabType || IfcBuildingElementType::is(v); }
Type::Enum IfcSlabType::type() const { return Type::IfcSlabType; }
Type::Enum IfcSlabType::Class() { return Type::IfcSlabType; }
IfcSlabType::IfcSlabType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSlabType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlabType::IfcSlabType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSlabTypeEnum::IfcSlabTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSlabTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSlippageConnectionCondition
bool IfcSlippageConnectionCondition::hasSlippageX() { return !entity->getArgument(1)->isNull(); }
IfcLengthMeasure IfcSlippageConnectionCondition::SlippageX() { return *entity->getArgument(1); }
void IfcSlippageConnectionCondition::setSlippageX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSlippageConnectionCondition::hasSlippageY() { return !entity->getArgument(2)->isNull(); }
IfcLengthMeasure IfcSlippageConnectionCondition::SlippageY() { return *entity->getArgument(2); }
void IfcSlippageConnectionCondition::setSlippageY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSlippageConnectionCondition::hasSlippageZ() { return !entity->getArgument(3)->isNull(); }
IfcLengthMeasure IfcSlippageConnectionCondition::SlippageZ() { return *entity->getArgument(3); }
void IfcSlippageConnectionCondition::setSlippageZ(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSlippageConnectionCondition::is(Type::Enum v) const { return v == Type::IfcSlippageConnectionCondition || IfcStructuralConnectionCondition::is(v); }
Type::Enum IfcSlippageConnectionCondition::type() const { return Type::IfcSlippageConnectionCondition; }
Type::Enum IfcSlippageConnectionCondition::Class() { return Type::IfcSlippageConnectionCondition; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(IfcAbstractEntityPtr e) : IfcStructuralConnectionCondition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSlippageConnectionCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSlippageConnectionCondition::IfcSlippageConnectionCondition(boost::optional< IfcLabel > v1_Name, boost::optional< IfcLengthMeasure > v2_SlippageX, boost::optional< IfcLengthMeasure > v3_SlippageY, boost::optional< IfcLengthMeasure > v4_SlippageZ) : IfcStructuralConnectionCondition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_SlippageX) { e->setArgument(1,(*v2_SlippageX)); } else { e->setArgument(1); } if (v3_SlippageY) { e->setArgument(2,(*v3_SlippageY)); } else { e->setArgument(2); } if (v4_SlippageZ) { e->setArgument(3,(*v4_SlippageZ)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSolarDevice
bool IfcSolarDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDevice::PredefinedType() { return IfcSolarDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSolarDevice::setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSolarDeviceTypeEnum::ToString(v)); }
bool IfcSolarDevice::is(Type::Enum v) const { return v == Type::IfcSolarDevice || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcSolarDevice::type() const { return Type::IfcSolarDevice; }
Type::Enum IfcSolarDevice::Class() { return Type::IfcSolarDevice; }
IfcSolarDevice::IfcSolarDevice(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSolarDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSolarDevice::IfcSolarDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSolarDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSolarDeviceType
IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum IfcSolarDeviceType::PredefinedType() { return IfcSolarDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSolarDeviceType::setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSolarDeviceTypeEnum::ToString(v)); }
bool IfcSolarDeviceType::is(Type::Enum v) const { return v == Type::IfcSolarDeviceType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcSolarDeviceType::type() const { return Type::IfcSolarDeviceType; }
Type::Enum IfcSolarDeviceType::Class() { return Type::IfcSolarDeviceType; }
IfcSolarDeviceType::IfcSolarDeviceType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSolarDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSolarDeviceType::IfcSolarDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSolarDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSolidModel
bool IfcSolidModel::is(Type::Enum v) const { return v == Type::IfcSolidModel || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSolidModel::type() const { return Type::IfcSolidModel; }
Type::Enum IfcSolidModel::Class() { return Type::IfcSolidModel; }
IfcSolidModel::IfcSolidModel(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSolidModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSolidModel::IfcSolidModel() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpace
bool IfcSpace::hasPredefinedType() { return !entity->getArgument(9)->isNull(); }
IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpace::PredefinedType() { return IfcSpaceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpace::setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSpaceTypeEnum::ToString(v)); }
bool IfcSpace::hasElevationWithFlooring() { return !entity->getArgument(10)->isNull(); }
IfcLengthMeasure IfcSpace::ElevationWithFlooring() { return *entity->getArgument(10); }
void IfcSpace::setElevationWithFlooring(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
IfcRelCoversSpaces::list IfcSpace::HasCoverings() { RETURN_INVERSE(IfcRelCoversSpaces) }
IfcRelSpaceBoundary::list IfcSpace::BoundedBy() { RETURN_INVERSE(IfcRelSpaceBoundary) }
bool IfcSpace::is(Type::Enum v) const { return v == Type::IfcSpace || IfcSpatialStructureElement::is(v); }
Type::Enum IfcSpace::type() const { return Type::IfcSpace; }
Type::Enum IfcSpace::Class() { return Type::IfcSpace; }
IfcSpace::IfcSpace(IfcAbstractEntityPtr e) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpace)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpace::IfcSpace(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcSpaceTypeEnum::IfcSpaceTypeEnum > v10_PredefinedType, boost::optional< IfcLengthMeasure > v11_ElevationWithFlooring) : IfcSpatialStructureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_CompositionType) { e->setArgument(8,*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType)); } else { e->setArgument(8); } if (v10_PredefinedType) { e->setArgument(9,*v10_PredefinedType,IfcSpaceTypeEnum::ToString(*v10_PredefinedType)); } else { e->setArgument(9); } if (v11_ElevationWithFlooring) { e->setArgument(10,(*v11_ElevationWithFlooring)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpaceHeater
bool IfcSpaceHeater::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeater::PredefinedType() { return IfcSpaceHeaterTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSpaceHeater::setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSpaceHeaterTypeEnum::ToString(v)); }
bool IfcSpaceHeater::is(Type::Enum v) const { return v == Type::IfcSpaceHeater || IfcFlowTerminal::is(v); }
Type::Enum IfcSpaceHeater::type() const { return Type::IfcSpaceHeater; }
Type::Enum IfcSpaceHeater::Class() { return Type::IfcSpaceHeater; }
IfcSpaceHeater::IfcSpaceHeater(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpaceHeater)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceHeater::IfcSpaceHeater(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSpaceHeaterTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpaceHeaterType
IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum IfcSpaceHeaterType::PredefinedType() { return IfcSpaceHeaterTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpaceHeaterType::setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSpaceHeaterTypeEnum::ToString(v)); }
bool IfcSpaceHeaterType::is(Type::Enum v) const { return v == Type::IfcSpaceHeaterType || IfcFlowTerminalType::is(v); }
Type::Enum IfcSpaceHeaterType::type() const { return Type::IfcSpaceHeaterType; }
Type::Enum IfcSpaceHeaterType::Class() { return Type::IfcSpaceHeaterType; }
IfcSpaceHeaterType::IfcSpaceHeaterType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpaceHeaterType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceHeaterType::IfcSpaceHeaterType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSpaceHeaterTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpaceType
IfcSpaceTypeEnum::IfcSpaceTypeEnum IfcSpaceType::PredefinedType() { return IfcSpaceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpaceType::setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSpaceTypeEnum::ToString(v)); }
bool IfcSpaceType::hasLongName() { return !entity->getArgument(10)->isNull(); }
IfcLabel IfcSpaceType::LongName() { return *entity->getArgument(10); }
void IfcSpaceType::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcSpaceType::is(Type::Enum v) const { return v == Type::IfcSpaceType || IfcSpatialStructureElementType::is(v); }
Type::Enum IfcSpaceType::type() const { return Type::IfcSpaceType; }
Type::Enum IfcSpaceType::Class() { return Type::IfcSpaceType; }
IfcSpaceType::IfcSpaceType(IfcAbstractEntityPtr e) : IfcSpatialStructureElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpaceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpaceType::IfcSpaceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSpaceTypeEnum::IfcSpaceTypeEnum v10_PredefinedType, boost::optional< IfcLabel > v11_LongName) : IfcSpatialStructureElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSpaceTypeEnum::ToString(v10_PredefinedType)); if (v11_LongName) { e->setArgument(10,(*v11_LongName)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialElement
bool IfcSpatialElement::hasLongName() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcSpatialElement::LongName() { return *entity->getArgument(7); }
void IfcSpatialElement::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcRelContainedInSpatialStructure::list IfcSpatialElement::ContainsElements() { RETURN_INVERSE(IfcRelContainedInSpatialStructure) }
IfcRelServicesBuildings::list IfcSpatialElement::ServicedBySystems() { RETURN_INVERSE(IfcRelServicesBuildings) }
IfcRelReferencedInSpatialStructure::list IfcSpatialElement::ReferencesElements() { RETURN_INVERSE(IfcRelReferencedInSpatialStructure) }
bool IfcSpatialElement::is(Type::Enum v) const { return v == Type::IfcSpatialElement || IfcProduct::is(v); }
Type::Enum IfcSpatialElement::type() const { return Type::IfcSpatialElement; }
Type::Enum IfcSpatialElement::Class() { return Type::IfcSpatialElement; }
IfcSpatialElement::IfcSpatialElement(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialElement::IfcSpatialElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialElementType
bool IfcSpatialElementType::hasElementType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcSpatialElementType::ElementType() { return *entity->getArgument(8); }
void IfcSpatialElementType::setElementType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcSpatialElementType::is(Type::Enum v) const { return v == Type::IfcSpatialElementType || IfcTypeProduct::is(v); }
Type::Enum IfcSpatialElementType::type() const { return Type::IfcSpatialElementType; }
Type::Enum IfcSpatialElementType::Class() { return Type::IfcSpatialElementType; }
IfcSpatialElementType::IfcSpatialElementType(IfcAbstractEntityPtr e) : IfcTypeProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialElementType::IfcSpatialElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcTypeProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialStructureElement
bool IfcSpatialStructureElement::hasCompositionType() { return !entity->getArgument(8)->isNull(); }
IfcElementCompositionEnum::IfcElementCompositionEnum IfcSpatialStructureElement::CompositionType() { return IfcElementCompositionEnum::FromString(*entity->getArgument(8)); }
void IfcSpatialStructureElement::setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcElementCompositionEnum::ToString(v)); }
bool IfcSpatialStructureElement::is(Type::Enum v) const { return v == Type::IfcSpatialStructureElement || IfcSpatialElement::is(v); }
Type::Enum IfcSpatialStructureElement::type() const { return Type::IfcSpatialStructureElement; }
Type::Enum IfcSpatialStructureElement::Class() { return Type::IfcSpatialStructureElement; }
IfcSpatialStructureElement::IfcSpatialStructureElement(IfcAbstractEntityPtr e) : IfcSpatialElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialStructureElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialStructureElement::IfcSpatialStructureElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType) : IfcSpatialElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_CompositionType) { e->setArgument(8,*v9_CompositionType,IfcElementCompositionEnum::ToString(*v9_CompositionType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialStructureElementType
bool IfcSpatialStructureElementType::is(Type::Enum v) const { return v == Type::IfcSpatialStructureElementType || IfcSpatialElementType::is(v); }
Type::Enum IfcSpatialStructureElementType::type() const { return Type::IfcSpatialStructureElementType; }
Type::Enum IfcSpatialStructureElementType::Class() { return Type::IfcSpatialStructureElementType; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(IfcAbstractEntityPtr e) : IfcSpatialElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialStructureElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialStructureElementType::IfcSpatialStructureElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType) : IfcSpatialElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialZone
bool IfcSpatialZone::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZone::PredefinedType() { return IfcSpatialZoneTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSpatialZone::setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSpatialZoneTypeEnum::ToString(v)); }
bool IfcSpatialZone::is(Type::Enum v) const { return v == Type::IfcSpatialZone || IfcSpatialElement::is(v); }
Type::Enum IfcSpatialZone::type() const { return Type::IfcSpatialZone; }
Type::Enum IfcSpatialZone::Class() { return Type::IfcSpatialZone; }
IfcSpatialZone::IfcSpatialZone(IfcAbstractEntityPtr e) : IfcSpatialElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialZone)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialZone::IfcSpatialZone(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcLabel > v8_LongName, boost::optional< IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum > v9_PredefinedType) : IfcSpatialElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_LongName) { e->setArgument(7,(*v8_LongName)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSpatialZoneTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSpatialZoneType
IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum IfcSpatialZoneType::PredefinedType() { return IfcSpatialZoneTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSpatialZoneType::setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSpatialZoneTypeEnum::ToString(v)); }
bool IfcSpatialZoneType::hasLongName() { return !entity->getArgument(10)->isNull(); }
IfcLabel IfcSpatialZoneType::LongName() { return *entity->getArgument(10); }
void IfcSpatialZoneType::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcSpatialZoneType::is(Type::Enum v) const { return v == Type::IfcSpatialZoneType || IfcSpatialElementType::is(v); }
Type::Enum IfcSpatialZoneType::type() const { return Type::IfcSpatialZoneType; }
Type::Enum IfcSpatialZoneType::Class() { return Type::IfcSpatialZoneType; }
IfcSpatialZoneType::IfcSpatialZoneType(IfcAbstractEntityPtr e) : IfcSpatialElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSpatialZoneType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSpatialZoneType::IfcSpatialZoneType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v10_PredefinedType, boost::optional< IfcLabel > v11_LongName) : IfcSpatialElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSpatialZoneTypeEnum::ToString(v10_PredefinedType)); if (v11_LongName) { e->setArgument(10,(*v11_LongName)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSphere
IfcPositiveLengthMeasure IfcSphere::Radius() { return *entity->getArgument(1); }
void IfcSphere::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSphere::is(Type::Enum v) const { return v == Type::IfcSphere || IfcCsgPrimitive3D::is(v); }
Type::Enum IfcSphere::type() const { return Type::IfcSphere; }
Type::Enum IfcSphere::Class() { return Type::IfcSphere; }
IfcSphere::IfcSphere(IfcAbstractEntityPtr e) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSphere)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSphere::IfcSphere(IfcAxis2Placement3D* v1_Position, IfcPositiveLengthMeasure v2_Radius) : IfcCsgPrimitive3D((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Position)); e->setArgument(1,(v2_Radius)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStackTerminal
bool IfcStackTerminal::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminal::PredefinedType() { return IfcStackTerminalTypeEnum::FromString(*entity->getArgument(8)); }
void IfcStackTerminal::setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcStackTerminalTypeEnum::ToString(v)); }
bool IfcStackTerminal::is(Type::Enum v) const { return v == Type::IfcStackTerminal || IfcFlowTerminal::is(v); }
Type::Enum IfcStackTerminal::type() const { return Type::IfcStackTerminal; }
Type::Enum IfcStackTerminal::Class() { return Type::IfcStackTerminal; }
IfcStackTerminal::IfcStackTerminal(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStackTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStackTerminal::IfcStackTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcStackTerminalTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStackTerminalType
IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum IfcStackTerminalType::PredefinedType() { return IfcStackTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStackTerminalType::setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcStackTerminalTypeEnum::ToString(v)); }
bool IfcStackTerminalType::is(Type::Enum v) const { return v == Type::IfcStackTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcStackTerminalType::type() const { return Type::IfcStackTerminalType; }
Type::Enum IfcStackTerminalType::Class() { return Type::IfcStackTerminalType; }
IfcStackTerminalType::IfcStackTerminalType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStackTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStackTerminalType::IfcStackTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcStackTerminalTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStair
bool IfcStair::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcStairTypeEnum::IfcStairTypeEnum IfcStair::PredefinedType() { return IfcStairTypeEnum::FromString(*entity->getArgument(8)); }
void IfcStair::setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcStairTypeEnum::ToString(v)); }
bool IfcStair::is(Type::Enum v) const { return v == Type::IfcStair || IfcBuildingElement::is(v); }
Type::Enum IfcStair::type() const { return Type::IfcStair; }
Type::Enum IfcStair::Class() { return Type::IfcStair; }
IfcStair::IfcStair(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStair)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStair::IfcStair(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcStairTypeEnum::IfcStairTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcStairTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStairFlight
bool IfcStairFlight::hasNumberOfRiser() { return !entity->getArgument(8)->isNull(); }
int IfcStairFlight::NumberOfRiser() { return *entity->getArgument(8); }
void IfcStairFlight::setNumberOfRiser(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStairFlight::hasNumberOfTreads() { return !entity->getArgument(9)->isNull(); }
int IfcStairFlight::NumberOfTreads() { return *entity->getArgument(9); }
void IfcStairFlight::setNumberOfTreads(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcStairFlight::hasRiserHeight() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcStairFlight::RiserHeight() { return *entity->getArgument(10); }
void IfcStairFlight::setRiserHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcStairFlight::hasTreadLength() { return !entity->getArgument(11)->isNull(); }
IfcPositiveLengthMeasure IfcStairFlight::TreadLength() { return *entity->getArgument(11); }
void IfcStairFlight::setTreadLength(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcStairFlight::hasPredefinedType() { return !entity->getArgument(12)->isNull(); }
IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlight::PredefinedType() { return IfcStairFlightTypeEnum::FromString(*entity->getArgument(12)); }
void IfcStairFlight::setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v,IfcStairFlightTypeEnum::ToString(v)); }
bool IfcStairFlight::is(Type::Enum v) const { return v == Type::IfcStairFlight || IfcBuildingElement::is(v); }
Type::Enum IfcStairFlight::type() const { return Type::IfcStairFlight; }
Type::Enum IfcStairFlight::Class() { return Type::IfcStairFlight; }
IfcStairFlight::IfcStairFlight(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStairFlight)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStairFlight::IfcStairFlight(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< int > v9_NumberOfRiser, boost::optional< int > v10_NumberOfTreads, boost::optional< IfcPositiveLengthMeasure > v11_RiserHeight, boost::optional< IfcPositiveLengthMeasure > v12_TreadLength, boost::optional< IfcStairFlightTypeEnum::IfcStairFlightTypeEnum > v13_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_NumberOfRiser) { e->setArgument(8,(*v9_NumberOfRiser)); } else { e->setArgument(8); } if (v10_NumberOfTreads) { e->setArgument(9,(*v10_NumberOfTreads)); } else { e->setArgument(9); } if (v11_RiserHeight) { e->setArgument(10,(*v11_RiserHeight)); } else { e->setArgument(10); } if (v12_TreadLength) { e->setArgument(11,(*v12_TreadLength)); } else { e->setArgument(11); } if (v13_PredefinedType) { e->setArgument(12,*v13_PredefinedType,IfcStairFlightTypeEnum::ToString(*v13_PredefinedType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStairFlightType
IfcStairFlightTypeEnum::IfcStairFlightTypeEnum IfcStairFlightType::PredefinedType() { return IfcStairFlightTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStairFlightType::setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcStairFlightTypeEnum::ToString(v)); }
bool IfcStairFlightType::is(Type::Enum v) const { return v == Type::IfcStairFlightType || IfcBuildingElementType::is(v); }
Type::Enum IfcStairFlightType::type() const { return Type::IfcStairFlightType; }
Type::Enum IfcStairFlightType::Class() { return Type::IfcStairFlightType; }
IfcStairFlightType::IfcStairFlightType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStairFlightType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStairFlightType::IfcStairFlightType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcStairFlightTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStairType
IfcStairTypeEnum::IfcStairTypeEnum IfcStairType::PredefinedType() { return IfcStairTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStairType::setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcStairTypeEnum::ToString(v)); }
bool IfcStairType::is(Type::Enum v) const { return v == Type::IfcStairType || IfcBuildingElementType::is(v); }
Type::Enum IfcStairType::type() const { return Type::IfcStairType; }
Type::Enum IfcStairType::Class() { return Type::IfcStairType; }
IfcStairType::IfcStairType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStairType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStairType::IfcStairType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcStairTypeEnum::IfcStairTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcStairTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralAction
bool IfcStructuralAction::hasDestabilizingLoad() { return !entity->getArgument(9)->isNull(); }
bool IfcStructuralAction::DestabilizingLoad() { return *entity->getArgument(9); }
void IfcStructuralAction::setDestabilizingLoad(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcStructuralAction::is(Type::Enum v) const { return v == Type::IfcStructuralAction || IfcStructuralActivity::is(v); }
Type::Enum IfcStructuralAction::type() const { return Type::IfcStructuralAction; }
Type::Enum IfcStructuralAction::Class() { return Type::IfcStructuralAction; }
IfcStructuralAction::IfcStructuralAction(IfcAbstractEntityPtr e) : IfcStructuralActivity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralAction::IfcStructuralAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad) : IfcStructuralActivity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralActivity
IfcStructuralLoad* IfcStructuralActivity::AppliedLoad() { return (IfcStructuralLoad*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcStructuralActivity::setAppliedLoad(IfcStructuralLoad* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum IfcStructuralActivity::GlobalOrLocal() { return IfcGlobalOrLocalEnum::FromString(*entity->getArgument(8)); }
void IfcStructuralActivity::setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcGlobalOrLocalEnum::ToString(v)); }
IfcRelConnectsStructuralActivity::list IfcStructuralActivity::AssignedToStructuralItem() { RETURN_INVERSE(IfcRelConnectsStructuralActivity) }
bool IfcStructuralActivity::is(Type::Enum v) const { return v == Type::IfcStructuralActivity || IfcProduct::is(v); }
Type::Enum IfcStructuralActivity::type() const { return Type::IfcStructuralActivity; }
Type::Enum IfcStructuralActivity::Class() { return Type::IfcStructuralActivity; }
IfcStructuralActivity::IfcStructuralActivity(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralActivity)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralActivity::IfcStructuralActivity(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralAnalysisModel
IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum IfcStructuralAnalysisModel::PredefinedType() { return IfcAnalysisModelTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralAnalysisModel::setPredefinedType(IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcAnalysisModelTypeEnum::ToString(v)); }
bool IfcStructuralAnalysisModel::hasOrientationOf2DPlane() { return !entity->getArgument(6)->isNull(); }
IfcAxis2Placement3D* IfcStructuralAnalysisModel::OrientationOf2DPlane() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcStructuralAnalysisModel::setOrientationOf2DPlane(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcStructuralAnalysisModel::hasLoadedBy() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadGroup > > IfcStructuralAnalysisModel::LoadedBy() { RETURN_AS_LIST(IfcStructuralLoadGroup,7) }
void IfcStructuralAnalysisModel::setLoadedBy(SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadGroup > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcStructuralAnalysisModel::hasHasResults() { return !entity->getArgument(8)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcStructuralResultGroup > > IfcStructuralAnalysisModel::HasResults() { RETURN_AS_LIST(IfcStructuralResultGroup,8) }
void IfcStructuralAnalysisModel::setHasResults(SHARED_PTR< IfcTemplatedEntityList< IfcStructuralResultGroup > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v->generalize()); }
bool IfcStructuralAnalysisModel::hasSharedPlacement() { return !entity->getArgument(9)->isNull(); }
IfcObjectPlacement* IfcStructuralAnalysisModel::SharedPlacement() { return (IfcObjectPlacement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(9))); }
void IfcStructuralAnalysisModel::setSharedPlacement(IfcObjectPlacement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcStructuralAnalysisModel::is(Type::Enum v) const { return v == Type::IfcStructuralAnalysisModel || IfcSystem::is(v); }
Type::Enum IfcStructuralAnalysisModel::type() const { return Type::IfcStructuralAnalysisModel; }
Type::Enum IfcStructuralAnalysisModel::Class() { return Type::IfcStructuralAnalysisModel; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(IfcAbstractEntityPtr e) : IfcSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralAnalysisModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralAnalysisModel::IfcStructuralAnalysisModel(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v6_PredefinedType, IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadGroup > > > v8_LoadedBy, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcStructuralResultGroup > > > v9_HasResults, IfcObjectPlacement* v10_SharedPlacement) : IfcSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,v6_PredefinedType,IfcAnalysisModelTypeEnum::ToString(v6_PredefinedType)); e->setArgument(6,(v7_OrientationOf2DPlane)); if (v8_LoadedBy) { e->setArgument(7,(*v8_LoadedBy)->generalize()); } else { e->setArgument(7); } if (v9_HasResults) { e->setArgument(8,(*v9_HasResults)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_SharedPlacement)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralConnection
bool IfcStructuralConnection::hasAppliedCondition() { return !entity->getArgument(7)->isNull(); }
IfcBoundaryCondition* IfcStructuralConnection::AppliedCondition() { return (IfcBoundaryCondition*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(7))); }
void IfcStructuralConnection::setAppliedCondition(IfcBoundaryCondition* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcRelConnectsStructuralMember::list IfcStructuralConnection::ConnectsStructuralMembers() { RETURN_INVERSE(IfcRelConnectsStructuralMember) }
bool IfcStructuralConnection::is(Type::Enum v) const { return v == Type::IfcStructuralConnection || IfcStructuralItem::is(v); }
Type::Enum IfcStructuralConnection::type() const { return Type::IfcStructuralConnection; }
Type::Enum IfcStructuralConnection::Class() { return Type::IfcStructuralConnection; }
IfcStructuralConnection::IfcStructuralConnection(IfcAbstractEntityPtr e) : IfcStructuralItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralConnection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralConnection::IfcStructuralConnection(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedCondition)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralConnectionCondition
bool IfcStructuralConnectionCondition::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcStructuralConnectionCondition::Name() { return *entity->getArgument(0); }
void IfcStructuralConnectionCondition::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcStructuralConnectionCondition::is(Type::Enum v) const { return v == Type::IfcStructuralConnectionCondition; }
Type::Enum IfcStructuralConnectionCondition::type() const { return Type::IfcStructuralConnectionCondition; }
Type::Enum IfcStructuralConnectionCondition::Class() { return Type::IfcStructuralConnectionCondition; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcStructuralConnectionCondition)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralConnectionCondition::IfcStructuralConnectionCondition(boost::optional< IfcLabel > v1_Name) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralCurveAction
bool IfcStructuralCurveAction::hasProjectedOrTrue() { return !entity->getArgument(10)->isNull(); }
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralCurveAction::ProjectedOrTrue() { return IfcProjectedOrTrueLengthEnum::FromString(*entity->getArgument(10)); }
void IfcStructuralCurveAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcProjectedOrTrueLengthEnum::ToString(v)); }
IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveAction::PredefinedType() { return IfcStructuralCurveActivityTypeEnum::FromString(*entity->getArgument(11)); }
void IfcStructuralCurveAction::setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcStructuralCurveActivityTypeEnum::ToString(v)); }
bool IfcStructuralCurveAction::is(Type::Enum v) const { return v == Type::IfcStructuralCurveAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralCurveAction::type() const { return Type::IfcStructuralCurveAction; }
Type::Enum IfcStructuralCurveAction::Class() { return Type::IfcStructuralCurveAction; }
IfcStructuralCurveAction::IfcStructuralCurveAction(IfcAbstractEntityPtr e) : IfcStructuralAction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralCurveAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveAction::IfcStructuralCurveAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType) : IfcStructuralAction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } if (v11_ProjectedOrTrue) { e->setArgument(10,*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue)); } else { e->setArgument(10); } e->setArgument(11,v12_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralCurveConnection
IfcDirection* IfcStructuralCurveConnection::Axis() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcStructuralCurveConnection::setAxis(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStructuralCurveConnection::is(Type::Enum v) const { return v == Type::IfcStructuralCurveConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralCurveConnection::type() const { return Type::IfcStructuralCurveConnection; }
Type::Enum IfcStructuralCurveConnection::Class() { return Type::IfcStructuralCurveConnection; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(IfcAbstractEntityPtr e) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralCurveConnection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveConnection::IfcStructuralCurveConnection(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcDirection* v9_Axis) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedCondition)); e->setArgument(8,(v9_Axis)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralCurveMember
IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum IfcStructuralCurveMember::PredefinedType() { return IfcStructuralCurveMemberTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralCurveMember::setPredefinedType(IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcStructuralCurveMemberTypeEnum::ToString(v)); }
IfcDirection* IfcStructuralCurveMember::Axis() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcStructuralCurveMember::setAxis(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStructuralCurveMember::is(Type::Enum v) const { return v == Type::IfcStructuralCurveMember || IfcStructuralMember::is(v); }
Type::Enum IfcStructuralCurveMember::type() const { return Type::IfcStructuralCurveMember; }
Type::Enum IfcStructuralCurveMember::Class() { return Type::IfcStructuralCurveMember; }
IfcStructuralCurveMember::IfcStructuralCurveMember(IfcAbstractEntityPtr e) : IfcStructuralMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralCurveMember)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveMember::IfcStructuralCurveMember(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis) : IfcStructuralMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,v8_PredefinedType,IfcStructuralCurveMemberTypeEnum::ToString(v8_PredefinedType)); e->setArgument(8,(v9_Axis)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralCurveMemberVarying
bool IfcStructuralCurveMemberVarying::is(Type::Enum v) const { return v == Type::IfcStructuralCurveMemberVarying || IfcStructuralCurveMember::is(v); }
Type::Enum IfcStructuralCurveMemberVarying::type() const { return Type::IfcStructuralCurveMemberVarying; }
Type::Enum IfcStructuralCurveMemberVarying::Class() { return Type::IfcStructuralCurveMemberVarying; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(IfcAbstractEntityPtr e) : IfcStructuralCurveMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralCurveMemberVarying)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveMemberVarying::IfcStructuralCurveMemberVarying(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis) : IfcStructuralCurveMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,v8_PredefinedType,IfcStructuralCurveMemberTypeEnum::ToString(v8_PredefinedType)); e->setArgument(8,(v9_Axis)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralCurveReaction
IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum IfcStructuralCurveReaction::PredefinedType() { return IfcStructuralCurveActivityTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStructuralCurveReaction::setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcStructuralCurveActivityTypeEnum::ToString(v)); }
bool IfcStructuralCurveReaction::is(Type::Enum v) const { return v == Type::IfcStructuralCurveReaction || IfcStructuralReaction::is(v); }
Type::Enum IfcStructuralCurveReaction::type() const { return Type::IfcStructuralCurveReaction; }
Type::Enum IfcStructuralCurveReaction::Class() { return Type::IfcStructuralCurveReaction; }
IfcStructuralCurveReaction::IfcStructuralCurveReaction(IfcAbstractEntityPtr e) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralCurveReaction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralCurveReaction::IfcStructuralCurveReaction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v10_PredefinedType) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); e->setArgument(9,v10_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralItem
IfcRelConnectsStructuralActivity::list IfcStructuralItem::AssignedStructuralActivity() { RETURN_INVERSE(IfcRelConnectsStructuralActivity) }
bool IfcStructuralItem::is(Type::Enum v) const { return v == Type::IfcStructuralItem || IfcProduct::is(v); }
Type::Enum IfcStructuralItem::type() const { return Type::IfcStructuralItem; }
Type::Enum IfcStructuralItem::Class() { return Type::IfcStructuralItem; }
IfcStructuralItem::IfcStructuralItem(IfcAbstractEntityPtr e) : IfcProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralItem::IfcStructuralItem(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLinearAction
bool IfcStructuralLinearAction::is(Type::Enum v) const { return v == Type::IfcStructuralLinearAction || IfcStructuralCurveAction::is(v); }
Type::Enum IfcStructuralLinearAction::type() const { return Type::IfcStructuralLinearAction; }
Type::Enum IfcStructuralLinearAction::Class() { return Type::IfcStructuralLinearAction; }
IfcStructuralLinearAction::IfcStructuralLinearAction(IfcAbstractEntityPtr e) : IfcStructuralCurveAction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLinearAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLinearAction::IfcStructuralLinearAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType) : IfcStructuralCurveAction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } if (v11_ProjectedOrTrue) { e->setArgument(10,*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue)); } else { e->setArgument(10); } e->setArgument(11,v12_PredefinedType,IfcStructuralCurveActivityTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoad
bool IfcStructuralLoad::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcStructuralLoad::Name() { return *entity->getArgument(0); }
void IfcStructuralLoad::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcStructuralLoad::is(Type::Enum v) const { return v == Type::IfcStructuralLoad; }
Type::Enum IfcStructuralLoad::type() const { return Type::IfcStructuralLoad; }
Type::Enum IfcStructuralLoad::Class() { return Type::IfcStructuralLoad; }
IfcStructuralLoad::IfcStructuralLoad(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcStructuralLoad)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoad::IfcStructuralLoad(boost::optional< IfcLabel > v1_Name) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadCase
bool IfcStructuralLoadCase::hasSelfWeightCoefficients() { return !entity->getArgument(10)->isNull(); }
std::vector< IfcRatioMeasure > /*[3:3]*/ IfcStructuralLoadCase::SelfWeightCoefficients() { return *entity->getArgument(10); }
void IfcStructuralLoadCase::setSelfWeightCoefficients(std::vector< IfcRatioMeasure > /*[3:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcStructuralLoadCase::is(Type::Enum v) const { return v == Type::IfcStructuralLoadCase || IfcStructuralLoadGroup::is(v); }
Type::Enum IfcStructuralLoadCase::type() const { return Type::IfcStructuralLoadCase; }
Type::Enum IfcStructuralLoadCase::Class() { return Type::IfcStructuralLoadCase; }
IfcStructuralLoadCase::IfcStructuralLoadCase(IfcAbstractEntityPtr e) : IfcStructuralLoadGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadCase::IfcStructuralLoadCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< IfcRatioMeasure > v9_Coefficient, boost::optional< IfcLabel > v10_Purpose, boost::optional< std::vector< IfcRatioMeasure > /*[3:3]*/ > v11_SelfWeightCoefficients) : IfcStructuralLoadGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,v6_PredefinedType,IfcLoadGroupTypeEnum::ToString(v6_PredefinedType)); e->setArgument(6,v7_ActionType,IfcActionTypeEnum::ToString(v7_ActionType)); e->setArgument(7,v8_ActionSource,IfcActionSourceTypeEnum::ToString(v8_ActionSource)); if (v9_Coefficient) { e->setArgument(8,(*v9_Coefficient)); } else { e->setArgument(8); } if (v10_Purpose) { e->setArgument(9,(*v10_Purpose)); } else { e->setArgument(9); } if (v11_SelfWeightCoefficients) { e->setArgument(10,(*v11_SelfWeightCoefficients)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadConfiguration
SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadOrResult > > IfcStructuralLoadConfiguration::Values() { RETURN_AS_LIST(IfcStructuralLoadOrResult,1) }
void IfcStructuralLoadConfiguration::setValues(SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadOrResult > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcStructuralLoadConfiguration::is(Type::Enum v) const { return v == Type::IfcStructuralLoadConfiguration || IfcStructuralLoad::is(v); }
Type::Enum IfcStructuralLoadConfiguration::type() const { return Type::IfcStructuralLoadConfiguration; }
Type::Enum IfcStructuralLoadConfiguration::Class() { return Type::IfcStructuralLoadConfiguration; }
IfcStructuralLoadConfiguration::IfcStructuralLoadConfiguration(IfcAbstractEntityPtr e) : IfcStructuralLoad((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadConfiguration)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadConfiguration::IfcStructuralLoadConfiguration(boost::optional< IfcLabel > v1_Name, SHARED_PTR< IfcTemplatedEntityList< IfcStructuralLoadOrResult > > v2_Values) : IfcStructuralLoad((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_Values)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadGroup
IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum IfcStructuralLoadGroup::PredefinedType() { return IfcLoadGroupTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralLoadGroup::setPredefinedType(IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcLoadGroupTypeEnum::ToString(v)); }
IfcActionTypeEnum::IfcActionTypeEnum IfcStructuralLoadGroup::ActionType() { return IfcActionTypeEnum::FromString(*entity->getArgument(6)); }
void IfcStructuralLoadGroup::setActionType(IfcActionTypeEnum::IfcActionTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v,IfcActionTypeEnum::ToString(v)); }
IfcActionSourceTypeEnum::IfcActionSourceTypeEnum IfcStructuralLoadGroup::ActionSource() { return IfcActionSourceTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralLoadGroup::setActionSource(IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcActionSourceTypeEnum::ToString(v)); }
bool IfcStructuralLoadGroup::hasCoefficient() { return !entity->getArgument(8)->isNull(); }
IfcRatioMeasure IfcStructuralLoadGroup::Coefficient() { return *entity->getArgument(8); }
void IfcStructuralLoadGroup::setCoefficient(IfcRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStructuralLoadGroup::hasPurpose() { return !entity->getArgument(9)->isNull(); }
IfcLabel IfcStructuralLoadGroup::Purpose() { return *entity->getArgument(9); }
void IfcStructuralLoadGroup::setPurpose(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
IfcStructuralResultGroup::list IfcStructuralLoadGroup::SourceOfResultGroup() { RETURN_INVERSE(IfcStructuralResultGroup) }
IfcStructuralAnalysisModel::list IfcStructuralLoadGroup::LoadGroupFor() { RETURN_INVERSE(IfcStructuralAnalysisModel) }
bool IfcStructuralLoadGroup::is(Type::Enum v) const { return v == Type::IfcStructuralLoadGroup || IfcGroup::is(v); }
Type::Enum IfcStructuralLoadGroup::type() const { return Type::IfcStructuralLoadGroup; }
Type::Enum IfcStructuralLoadGroup::Class() { return Type::IfcStructuralLoadGroup; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(IfcAbstractEntityPtr e) : IfcGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadGroup)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadGroup::IfcStructuralLoadGroup(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< IfcRatioMeasure > v9_Coefficient, boost::optional< IfcLabel > v10_Purpose) : IfcGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,v6_PredefinedType,IfcLoadGroupTypeEnum::ToString(v6_PredefinedType)); e->setArgument(6,v7_ActionType,IfcActionTypeEnum::ToString(v7_ActionType)); e->setArgument(7,v8_ActionSource,IfcActionSourceTypeEnum::ToString(v8_ActionSource)); if (v9_Coefficient) { e->setArgument(8,(*v9_Coefficient)); } else { e->setArgument(8); } if (v10_Purpose) { e->setArgument(9,(*v10_Purpose)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadLinearForce
bool IfcStructuralLoadLinearForce::hasLinearForceX() { return !entity->getArgument(1)->isNull(); }
IfcLinearForceMeasure IfcStructuralLoadLinearForce::LinearForceX() { return *entity->getArgument(1); }
void IfcStructuralLoadLinearForce::setLinearForceX(IfcLinearForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcStructuralLoadLinearForce::hasLinearForceY() { return !entity->getArgument(2)->isNull(); }
IfcLinearForceMeasure IfcStructuralLoadLinearForce::LinearForceY() { return *entity->getArgument(2); }
void IfcStructuralLoadLinearForce::setLinearForceY(IfcLinearForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStructuralLoadLinearForce::hasLinearForceZ() { return !entity->getArgument(3)->isNull(); }
IfcLinearForceMeasure IfcStructuralLoadLinearForce::LinearForceZ() { return *entity->getArgument(3); }
void IfcStructuralLoadLinearForce::setLinearForceZ(IfcLinearForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcStructuralLoadLinearForce::hasLinearMomentX() { return !entity->getArgument(4)->isNull(); }
IfcLinearMomentMeasure IfcStructuralLoadLinearForce::LinearMomentX() { return *entity->getArgument(4); }
void IfcStructuralLoadLinearForce::setLinearMomentX(IfcLinearMomentMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcStructuralLoadLinearForce::hasLinearMomentY() { return !entity->getArgument(5)->isNull(); }
IfcLinearMomentMeasure IfcStructuralLoadLinearForce::LinearMomentY() { return *entity->getArgument(5); }
void IfcStructuralLoadLinearForce::setLinearMomentY(IfcLinearMomentMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcStructuralLoadLinearForce::hasLinearMomentZ() { return !entity->getArgument(6)->isNull(); }
IfcLinearMomentMeasure IfcStructuralLoadLinearForce::LinearMomentZ() { return *entity->getArgument(6); }
void IfcStructuralLoadLinearForce::setLinearMomentZ(IfcLinearMomentMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcStructuralLoadLinearForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadLinearForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadLinearForce::type() const { return Type::IfcStructuralLoadLinearForce; }
Type::Enum IfcStructuralLoadLinearForce::Class() { return Type::IfcStructuralLoadLinearForce; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(IfcAbstractEntityPtr e) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadLinearForce)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadLinearForce::IfcStructuralLoadLinearForce(boost::optional< IfcLabel > v1_Name, boost::optional< IfcLinearForceMeasure > v2_LinearForceX, boost::optional< IfcLinearForceMeasure > v3_LinearForceY, boost::optional< IfcLinearForceMeasure > v4_LinearForceZ, boost::optional< IfcLinearMomentMeasure > v5_LinearMomentX, boost::optional< IfcLinearMomentMeasure > v6_LinearMomentY, boost::optional< IfcLinearMomentMeasure > v7_LinearMomentZ) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_LinearForceX) { e->setArgument(1,(*v2_LinearForceX)); } else { e->setArgument(1); } if (v3_LinearForceY) { e->setArgument(2,(*v3_LinearForceY)); } else { e->setArgument(2); } if (v4_LinearForceZ) { e->setArgument(3,(*v4_LinearForceZ)); } else { e->setArgument(3); } if (v5_LinearMomentX) { e->setArgument(4,(*v5_LinearMomentX)); } else { e->setArgument(4); } if (v6_LinearMomentY) { e->setArgument(5,(*v6_LinearMomentY)); } else { e->setArgument(5); } if (v7_LinearMomentZ) { e->setArgument(6,(*v7_LinearMomentZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadOrResult
bool IfcStructuralLoadOrResult::is(Type::Enum v) const { return v == Type::IfcStructuralLoadOrResult || IfcStructuralLoad::is(v); }
Type::Enum IfcStructuralLoadOrResult::type() const { return Type::IfcStructuralLoadOrResult; }
Type::Enum IfcStructuralLoadOrResult::Class() { return Type::IfcStructuralLoadOrResult; }
IfcStructuralLoadOrResult::IfcStructuralLoadOrResult(IfcAbstractEntityPtr e) : IfcStructuralLoad((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadOrResult)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadOrResult::IfcStructuralLoadOrResult(boost::optional< IfcLabel > v1_Name) : IfcStructuralLoad((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadPlanarForce
bool IfcStructuralLoadPlanarForce::hasPlanarForceX() { return !entity->getArgument(1)->isNull(); }
IfcPlanarForceMeasure IfcStructuralLoadPlanarForce::PlanarForceX() { return *entity->getArgument(1); }
void IfcStructuralLoadPlanarForce::setPlanarForceX(IfcPlanarForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcStructuralLoadPlanarForce::hasPlanarForceY() { return !entity->getArgument(2)->isNull(); }
IfcPlanarForceMeasure IfcStructuralLoadPlanarForce::PlanarForceY() { return *entity->getArgument(2); }
void IfcStructuralLoadPlanarForce::setPlanarForceY(IfcPlanarForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStructuralLoadPlanarForce::hasPlanarForceZ() { return !entity->getArgument(3)->isNull(); }
IfcPlanarForceMeasure IfcStructuralLoadPlanarForce::PlanarForceZ() { return *entity->getArgument(3); }
void IfcStructuralLoadPlanarForce::setPlanarForceZ(IfcPlanarForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcStructuralLoadPlanarForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadPlanarForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadPlanarForce::type() const { return Type::IfcStructuralLoadPlanarForce; }
Type::Enum IfcStructuralLoadPlanarForce::Class() { return Type::IfcStructuralLoadPlanarForce; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(IfcAbstractEntityPtr e) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadPlanarForce)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadPlanarForce::IfcStructuralLoadPlanarForce(boost::optional< IfcLabel > v1_Name, boost::optional< IfcPlanarForceMeasure > v2_PlanarForceX, boost::optional< IfcPlanarForceMeasure > v3_PlanarForceY, boost::optional< IfcPlanarForceMeasure > v4_PlanarForceZ) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_PlanarForceX) { e->setArgument(1,(*v2_PlanarForceX)); } else { e->setArgument(1); } if (v3_PlanarForceY) { e->setArgument(2,(*v3_PlanarForceY)); } else { e->setArgument(2); } if (v4_PlanarForceZ) { e->setArgument(3,(*v4_PlanarForceZ)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadSingleDisplacement
bool IfcStructuralLoadSingleDisplacement::hasDisplacementX() { return !entity->getArgument(1)->isNull(); }
IfcLengthMeasure IfcStructuralLoadSingleDisplacement::DisplacementX() { return *entity->getArgument(1); }
void IfcStructuralLoadSingleDisplacement::setDisplacementX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementY() { return !entity->getArgument(2)->isNull(); }
IfcLengthMeasure IfcStructuralLoadSingleDisplacement::DisplacementY() { return *entity->getArgument(2); }
void IfcStructuralLoadSingleDisplacement::setDisplacementY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStructuralLoadSingleDisplacement::hasDisplacementZ() { return !entity->getArgument(3)->isNull(); }
IfcLengthMeasure IfcStructuralLoadSingleDisplacement::DisplacementZ() { return *entity->getArgument(3); }
void IfcStructuralLoadSingleDisplacement::setDisplacementZ(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRX() { return !entity->getArgument(4)->isNull(); }
IfcPlaneAngleMeasure IfcStructuralLoadSingleDisplacement::RotationalDisplacementRX() { return *entity->getArgument(4); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRX(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRY() { return !entity->getArgument(5)->isNull(); }
IfcPlaneAngleMeasure IfcStructuralLoadSingleDisplacement::RotationalDisplacementRY() { return *entity->getArgument(5); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRY(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcStructuralLoadSingleDisplacement::hasRotationalDisplacementRZ() { return !entity->getArgument(6)->isNull(); }
IfcPlaneAngleMeasure IfcStructuralLoadSingleDisplacement::RotationalDisplacementRZ() { return *entity->getArgument(6); }
void IfcStructuralLoadSingleDisplacement::setRotationalDisplacementRZ(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcStructuralLoadSingleDisplacement::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleDisplacement || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadSingleDisplacement::type() const { return Type::IfcStructuralLoadSingleDisplacement; }
Type::Enum IfcStructuralLoadSingleDisplacement::Class() { return Type::IfcStructuralLoadSingleDisplacement; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(IfcAbstractEntityPtr e) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadSingleDisplacement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleDisplacement::IfcStructuralLoadSingleDisplacement(boost::optional< IfcLabel > v1_Name, boost::optional< IfcLengthMeasure > v2_DisplacementX, boost::optional< IfcLengthMeasure > v3_DisplacementY, boost::optional< IfcLengthMeasure > v4_DisplacementZ, boost::optional< IfcPlaneAngleMeasure > v5_RotationalDisplacementRX, boost::optional< IfcPlaneAngleMeasure > v6_RotationalDisplacementRY, boost::optional< IfcPlaneAngleMeasure > v7_RotationalDisplacementRZ) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DisplacementX) { e->setArgument(1,(*v2_DisplacementX)); } else { e->setArgument(1); } if (v3_DisplacementY) { e->setArgument(2,(*v3_DisplacementY)); } else { e->setArgument(2); } if (v4_DisplacementZ) { e->setArgument(3,(*v4_DisplacementZ)); } else { e->setArgument(3); } if (v5_RotationalDisplacementRX) { e->setArgument(4,(*v5_RotationalDisplacementRX)); } else { e->setArgument(4); } if (v6_RotationalDisplacementRY) { e->setArgument(5,(*v6_RotationalDisplacementRY)); } else { e->setArgument(5); } if (v7_RotationalDisplacementRZ) { e->setArgument(6,(*v7_RotationalDisplacementRZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadSingleDisplacementDistortion
bool IfcStructuralLoadSingleDisplacementDistortion::hasDistortion() { return !entity->getArgument(7)->isNull(); }
IfcCurvatureMeasure IfcStructuralLoadSingleDisplacementDistortion::Distortion() { return *entity->getArgument(7); }
void IfcStructuralLoadSingleDisplacementDistortion::setDistortion(IfcCurvatureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcStructuralLoadSingleDisplacementDistortion::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleDisplacementDistortion || IfcStructuralLoadSingleDisplacement::is(v); }
Type::Enum IfcStructuralLoadSingleDisplacementDistortion::type() const { return Type::IfcStructuralLoadSingleDisplacementDistortion; }
Type::Enum IfcStructuralLoadSingleDisplacementDistortion::Class() { return Type::IfcStructuralLoadSingleDisplacementDistortion; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(IfcAbstractEntityPtr e) : IfcStructuralLoadSingleDisplacement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadSingleDisplacementDistortion)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleDisplacementDistortion::IfcStructuralLoadSingleDisplacementDistortion(boost::optional< IfcLabel > v1_Name, boost::optional< IfcLengthMeasure > v2_DisplacementX, boost::optional< IfcLengthMeasure > v3_DisplacementY, boost::optional< IfcLengthMeasure > v4_DisplacementZ, boost::optional< IfcPlaneAngleMeasure > v5_RotationalDisplacementRX, boost::optional< IfcPlaneAngleMeasure > v6_RotationalDisplacementRY, boost::optional< IfcPlaneAngleMeasure > v7_RotationalDisplacementRZ, boost::optional< IfcCurvatureMeasure > v8_Distortion) : IfcStructuralLoadSingleDisplacement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DisplacementX) { e->setArgument(1,(*v2_DisplacementX)); } else { e->setArgument(1); } if (v3_DisplacementY) { e->setArgument(2,(*v3_DisplacementY)); } else { e->setArgument(2); } if (v4_DisplacementZ) { e->setArgument(3,(*v4_DisplacementZ)); } else { e->setArgument(3); } if (v5_RotationalDisplacementRX) { e->setArgument(4,(*v5_RotationalDisplacementRX)); } else { e->setArgument(4); } if (v6_RotationalDisplacementRY) { e->setArgument(5,(*v6_RotationalDisplacementRY)); } else { e->setArgument(5); } if (v7_RotationalDisplacementRZ) { e->setArgument(6,(*v7_RotationalDisplacementRZ)); } else { e->setArgument(6); } if (v8_Distortion) { e->setArgument(7,(*v8_Distortion)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadSingleForce
bool IfcStructuralLoadSingleForce::hasForceX() { return !entity->getArgument(1)->isNull(); }
IfcForceMeasure IfcStructuralLoadSingleForce::ForceX() { return *entity->getArgument(1); }
void IfcStructuralLoadSingleForce::setForceX(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcStructuralLoadSingleForce::hasForceY() { return !entity->getArgument(2)->isNull(); }
IfcForceMeasure IfcStructuralLoadSingleForce::ForceY() { return *entity->getArgument(2); }
void IfcStructuralLoadSingleForce::setForceY(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStructuralLoadSingleForce::hasForceZ() { return !entity->getArgument(3)->isNull(); }
IfcForceMeasure IfcStructuralLoadSingleForce::ForceZ() { return *entity->getArgument(3); }
void IfcStructuralLoadSingleForce::setForceZ(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcStructuralLoadSingleForce::hasMomentX() { return !entity->getArgument(4)->isNull(); }
IfcTorqueMeasure IfcStructuralLoadSingleForce::MomentX() { return *entity->getArgument(4); }
void IfcStructuralLoadSingleForce::setMomentX(IfcTorqueMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcStructuralLoadSingleForce::hasMomentY() { return !entity->getArgument(5)->isNull(); }
IfcTorqueMeasure IfcStructuralLoadSingleForce::MomentY() { return *entity->getArgument(5); }
void IfcStructuralLoadSingleForce::setMomentY(IfcTorqueMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcStructuralLoadSingleForce::hasMomentZ() { return !entity->getArgument(6)->isNull(); }
IfcTorqueMeasure IfcStructuralLoadSingleForce::MomentZ() { return *entity->getArgument(6); }
void IfcStructuralLoadSingleForce::setMomentZ(IfcTorqueMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcStructuralLoadSingleForce::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleForce || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadSingleForce::type() const { return Type::IfcStructuralLoadSingleForce; }
Type::Enum IfcStructuralLoadSingleForce::Class() { return Type::IfcStructuralLoadSingleForce; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(IfcAbstractEntityPtr e) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadSingleForce)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleForce::IfcStructuralLoadSingleForce(boost::optional< IfcLabel > v1_Name, boost::optional< IfcForceMeasure > v2_ForceX, boost::optional< IfcForceMeasure > v3_ForceY, boost::optional< IfcForceMeasure > v4_ForceZ, boost::optional< IfcTorqueMeasure > v5_MomentX, boost::optional< IfcTorqueMeasure > v6_MomentY, boost::optional< IfcTorqueMeasure > v7_MomentZ) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_ForceX) { e->setArgument(1,(*v2_ForceX)); } else { e->setArgument(1); } if (v3_ForceY) { e->setArgument(2,(*v3_ForceY)); } else { e->setArgument(2); } if (v4_ForceZ) { e->setArgument(3,(*v4_ForceZ)); } else { e->setArgument(3); } if (v5_MomentX) { e->setArgument(4,(*v5_MomentX)); } else { e->setArgument(4); } if (v6_MomentY) { e->setArgument(5,(*v6_MomentY)); } else { e->setArgument(5); } if (v7_MomentZ) { e->setArgument(6,(*v7_MomentZ)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadSingleForceWarping
bool IfcStructuralLoadSingleForceWarping::hasWarpingMoment() { return !entity->getArgument(7)->isNull(); }
IfcWarpingMomentMeasure IfcStructuralLoadSingleForceWarping::WarpingMoment() { return *entity->getArgument(7); }
void IfcStructuralLoadSingleForceWarping::setWarpingMoment(IfcWarpingMomentMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcStructuralLoadSingleForceWarping::is(Type::Enum v) const { return v == Type::IfcStructuralLoadSingleForceWarping || IfcStructuralLoadSingleForce::is(v); }
Type::Enum IfcStructuralLoadSingleForceWarping::type() const { return Type::IfcStructuralLoadSingleForceWarping; }
Type::Enum IfcStructuralLoadSingleForceWarping::Class() { return Type::IfcStructuralLoadSingleForceWarping; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(IfcAbstractEntityPtr e) : IfcStructuralLoadSingleForce((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadSingleForceWarping)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadSingleForceWarping::IfcStructuralLoadSingleForceWarping(boost::optional< IfcLabel > v1_Name, boost::optional< IfcForceMeasure > v2_ForceX, boost::optional< IfcForceMeasure > v3_ForceY, boost::optional< IfcForceMeasure > v4_ForceZ, boost::optional< IfcTorqueMeasure > v5_MomentX, boost::optional< IfcTorqueMeasure > v6_MomentY, boost::optional< IfcTorqueMeasure > v7_MomentZ, boost::optional< IfcWarpingMomentMeasure > v8_WarpingMoment) : IfcStructuralLoadSingleForce((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_ForceX) { e->setArgument(1,(*v2_ForceX)); } else { e->setArgument(1); } if (v3_ForceY) { e->setArgument(2,(*v3_ForceY)); } else { e->setArgument(2); } if (v4_ForceZ) { e->setArgument(3,(*v4_ForceZ)); } else { e->setArgument(3); } if (v5_MomentX) { e->setArgument(4,(*v5_MomentX)); } else { e->setArgument(4); } if (v6_MomentY) { e->setArgument(5,(*v6_MomentY)); } else { e->setArgument(5); } if (v7_MomentZ) { e->setArgument(6,(*v7_MomentZ)); } else { e->setArgument(6); } if (v8_WarpingMoment) { e->setArgument(7,(*v8_WarpingMoment)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadStatic
bool IfcStructuralLoadStatic::is(Type::Enum v) const { return v == Type::IfcStructuralLoadStatic || IfcStructuralLoadOrResult::is(v); }
Type::Enum IfcStructuralLoadStatic::type() const { return Type::IfcStructuralLoadStatic; }
Type::Enum IfcStructuralLoadStatic::Class() { return Type::IfcStructuralLoadStatic; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(IfcAbstractEntityPtr e) : IfcStructuralLoadOrResult((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadStatic)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadStatic::IfcStructuralLoadStatic(boost::optional< IfcLabel > v1_Name) : IfcStructuralLoadOrResult((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralLoadTemperature
bool IfcStructuralLoadTemperature::hasDeltaTConstant() { return !entity->getArgument(1)->isNull(); }
IfcThermodynamicTemperatureMeasure IfcStructuralLoadTemperature::DeltaTConstant() { return *entity->getArgument(1); }
void IfcStructuralLoadTemperature::setDeltaTConstant(IfcThermodynamicTemperatureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcStructuralLoadTemperature::hasDeltaTY() { return !entity->getArgument(2)->isNull(); }
IfcThermodynamicTemperatureMeasure IfcStructuralLoadTemperature::DeltaTY() { return *entity->getArgument(2); }
void IfcStructuralLoadTemperature::setDeltaTY(IfcThermodynamicTemperatureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStructuralLoadTemperature::hasDeltaTZ() { return !entity->getArgument(3)->isNull(); }
IfcThermodynamicTemperatureMeasure IfcStructuralLoadTemperature::DeltaTZ() { return *entity->getArgument(3); }
void IfcStructuralLoadTemperature::setDeltaTZ(IfcThermodynamicTemperatureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcStructuralLoadTemperature::is(Type::Enum v) const { return v == Type::IfcStructuralLoadTemperature || IfcStructuralLoadStatic::is(v); }
Type::Enum IfcStructuralLoadTemperature::type() const { return Type::IfcStructuralLoadTemperature; }
Type::Enum IfcStructuralLoadTemperature::Class() { return Type::IfcStructuralLoadTemperature; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(IfcAbstractEntityPtr e) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralLoadTemperature)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralLoadTemperature::IfcStructuralLoadTemperature(boost::optional< IfcLabel > v1_Name, boost::optional< IfcThermodynamicTemperatureMeasure > v2_DeltaTConstant, boost::optional< IfcThermodynamicTemperatureMeasure > v3_DeltaTY, boost::optional< IfcThermodynamicTemperatureMeasure > v4_DeltaTZ) : IfcStructuralLoadStatic((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DeltaTConstant) { e->setArgument(1,(*v2_DeltaTConstant)); } else { e->setArgument(1); } if (v3_DeltaTY) { e->setArgument(2,(*v3_DeltaTY)); } else { e->setArgument(2); } if (v4_DeltaTZ) { e->setArgument(3,(*v4_DeltaTZ)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralMember
IfcRelConnectsStructuralMember::list IfcStructuralMember::ConnectedBy() { RETURN_INVERSE(IfcRelConnectsStructuralMember) }
bool IfcStructuralMember::is(Type::Enum v) const { return v == Type::IfcStructuralMember || IfcStructuralItem::is(v); }
Type::Enum IfcStructuralMember::type() const { return Type::IfcStructuralMember; }
Type::Enum IfcStructuralMember::Class() { return Type::IfcStructuralMember; }
IfcStructuralMember::IfcStructuralMember(IfcAbstractEntityPtr e) : IfcStructuralItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralMember)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralMember::IfcStructuralMember(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation) : IfcStructuralItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralPlanarAction
bool IfcStructuralPlanarAction::is(Type::Enum v) const { return v == Type::IfcStructuralPlanarAction || IfcStructuralSurfaceAction::is(v); }
Type::Enum IfcStructuralPlanarAction::type() const { return Type::IfcStructuralPlanarAction; }
Type::Enum IfcStructuralPlanarAction::Class() { return Type::IfcStructuralPlanarAction; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(IfcAbstractEntityPtr e) : IfcStructuralSurfaceAction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralPlanarAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPlanarAction::IfcStructuralPlanarAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType) : IfcStructuralSurfaceAction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } if (v11_ProjectedOrTrue) { e->setArgument(10,*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue)); } else { e->setArgument(10); } e->setArgument(11,v12_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralPointAction
bool IfcStructuralPointAction::is(Type::Enum v) const { return v == Type::IfcStructuralPointAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralPointAction::type() const { return Type::IfcStructuralPointAction; }
Type::Enum IfcStructuralPointAction::Class() { return Type::IfcStructuralPointAction; }
IfcStructuralPointAction::IfcStructuralPointAction(IfcAbstractEntityPtr e) : IfcStructuralAction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralPointAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointAction::IfcStructuralPointAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad) : IfcStructuralAction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralPointConnection
bool IfcStructuralPointConnection::hasConditionCoordinateSystem() { return !entity->getArgument(8)->isNull(); }
IfcAxis2Placement3D* IfcStructuralPointConnection::ConditionCoordinateSystem() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcStructuralPointConnection::setConditionCoordinateSystem(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStructuralPointConnection::is(Type::Enum v) const { return v == Type::IfcStructuralPointConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralPointConnection::type() const { return Type::IfcStructuralPointConnection; }
Type::Enum IfcStructuralPointConnection::Class() { return Type::IfcStructuralPointConnection; }
IfcStructuralPointConnection::IfcStructuralPointConnection(IfcAbstractEntityPtr e) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralPointConnection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointConnection::IfcStructuralPointConnection(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcAxis2Placement3D* v9_ConditionCoordinateSystem) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedCondition)); e->setArgument(8,(v9_ConditionCoordinateSystem)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralPointReaction
bool IfcStructuralPointReaction::is(Type::Enum v) const { return v == Type::IfcStructuralPointReaction || IfcStructuralReaction::is(v); }
Type::Enum IfcStructuralPointReaction::type() const { return Type::IfcStructuralPointReaction; }
Type::Enum IfcStructuralPointReaction::Class() { return Type::IfcStructuralPointReaction; }
IfcStructuralPointReaction::IfcStructuralPointReaction(IfcAbstractEntityPtr e) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralPointReaction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralPointReaction::IfcStructuralPointReaction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralReaction
bool IfcStructuralReaction::is(Type::Enum v) const { return v == Type::IfcStructuralReaction || IfcStructuralActivity::is(v); }
Type::Enum IfcStructuralReaction::type() const { return Type::IfcStructuralReaction; }
Type::Enum IfcStructuralReaction::Class() { return Type::IfcStructuralReaction; }
IfcStructuralReaction::IfcStructuralReaction(IfcAbstractEntityPtr e) : IfcStructuralActivity((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralReaction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralReaction::IfcStructuralReaction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal) : IfcStructuralActivity((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralResultGroup
IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum IfcStructuralResultGroup::TheoryType() { return IfcAnalysisTheoryTypeEnum::FromString(*entity->getArgument(5)); }
void IfcStructuralResultGroup::setTheoryType(IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcAnalysisTheoryTypeEnum::ToString(v)); }
bool IfcStructuralResultGroup::hasResultForLoadGroup() { return !entity->getArgument(6)->isNull(); }
IfcStructuralLoadGroup* IfcStructuralResultGroup::ResultForLoadGroup() { return (IfcStructuralLoadGroup*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(6))); }
void IfcStructuralResultGroup::setResultForLoadGroup(IfcStructuralLoadGroup* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcStructuralResultGroup::IsLinear() { return *entity->getArgument(7); }
void IfcStructuralResultGroup::setIsLinear(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcStructuralAnalysisModel::list IfcStructuralResultGroup::ResultGroupFor() { RETURN_INVERSE(IfcStructuralAnalysisModel) }
bool IfcStructuralResultGroup::is(Type::Enum v) const { return v == Type::IfcStructuralResultGroup || IfcGroup::is(v); }
Type::Enum IfcStructuralResultGroup::type() const { return Type::IfcStructuralResultGroup; }
Type::Enum IfcStructuralResultGroup::Class() { return Type::IfcStructuralResultGroup; }
IfcStructuralResultGroup::IfcStructuralResultGroup(IfcAbstractEntityPtr e) : IfcGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralResultGroup)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralResultGroup::IfcStructuralResultGroup(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v6_TheoryType, IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear) : IfcGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,v6_TheoryType,IfcAnalysisTheoryTypeEnum::ToString(v6_TheoryType)); e->setArgument(6,(v7_ResultForLoadGroup)); e->setArgument(7,(v8_IsLinear)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralSurfaceAction
bool IfcStructuralSurfaceAction::hasProjectedOrTrue() { return !entity->getArgument(10)->isNull(); }
IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum IfcStructuralSurfaceAction::ProjectedOrTrue() { return IfcProjectedOrTrueLengthEnum::FromString(*entity->getArgument(10)); }
void IfcStructuralSurfaceAction::setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcProjectedOrTrueLengthEnum::ToString(v)); }
IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceAction::PredefinedType() { return IfcStructuralSurfaceActivityTypeEnum::FromString(*entity->getArgument(11)); }
void IfcStructuralSurfaceAction::setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcStructuralSurfaceActivityTypeEnum::ToString(v)); }
bool IfcStructuralSurfaceAction::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceAction || IfcStructuralAction::is(v); }
Type::Enum IfcStructuralSurfaceAction::type() const { return Type::IfcStructuralSurfaceAction; }
Type::Enum IfcStructuralSurfaceAction::Class() { return Type::IfcStructuralSurfaceAction; }
IfcStructuralSurfaceAction::IfcStructuralSurfaceAction(IfcAbstractEntityPtr e) : IfcStructuralAction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralSurfaceAction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceAction::IfcStructuralSurfaceAction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType) : IfcStructuralAction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); if (v10_DestabilizingLoad) { e->setArgument(9,(*v10_DestabilizingLoad)); } else { e->setArgument(9); } if (v11_ProjectedOrTrue) { e->setArgument(10,*v11_ProjectedOrTrue,IfcProjectedOrTrueLengthEnum::ToString(*v11_ProjectedOrTrue)); } else { e->setArgument(10); } e->setArgument(11,v12_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralSurfaceConnection
bool IfcStructuralSurfaceConnection::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceConnection || IfcStructuralConnection::is(v); }
Type::Enum IfcStructuralSurfaceConnection::type() const { return Type::IfcStructuralSurfaceConnection; }
Type::Enum IfcStructuralSurfaceConnection::Class() { return Type::IfcStructuralSurfaceConnection; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(IfcAbstractEntityPtr e) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralSurfaceConnection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceConnection::IfcStructuralSurfaceConnection(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition) : IfcStructuralConnection((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedCondition)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralSurfaceMember
IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum IfcStructuralSurfaceMember::PredefinedType() { return IfcStructuralSurfaceMemberTypeEnum::FromString(*entity->getArgument(7)); }
void IfcStructuralSurfaceMember::setPredefinedType(IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v,IfcStructuralSurfaceMemberTypeEnum::ToString(v)); }
bool IfcStructuralSurfaceMember::hasThickness() { return !entity->getArgument(8)->isNull(); }
IfcPositiveLengthMeasure IfcStructuralSurfaceMember::Thickness() { return *entity->getArgument(8); }
void IfcStructuralSurfaceMember::setThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcStructuralSurfaceMember::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceMember || IfcStructuralMember::is(v); }
Type::Enum IfcStructuralSurfaceMember::type() const { return Type::IfcStructuralSurfaceMember; }
Type::Enum IfcStructuralSurfaceMember::Class() { return Type::IfcStructuralSurfaceMember; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(IfcAbstractEntityPtr e) : IfcStructuralMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralSurfaceMember)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceMember::IfcStructuralSurfaceMember(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v9_Thickness) : IfcStructuralMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,v8_PredefinedType,IfcStructuralSurfaceMemberTypeEnum::ToString(v8_PredefinedType)); if (v9_Thickness) { e->setArgument(8,(*v9_Thickness)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralSurfaceMemberVarying
bool IfcStructuralSurfaceMemberVarying::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceMemberVarying || IfcStructuralSurfaceMember::is(v); }
Type::Enum IfcStructuralSurfaceMemberVarying::type() const { return Type::IfcStructuralSurfaceMemberVarying; }
Type::Enum IfcStructuralSurfaceMemberVarying::Class() { return Type::IfcStructuralSurfaceMemberVarying; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(IfcAbstractEntityPtr e) : IfcStructuralSurfaceMember((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralSurfaceMemberVarying)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceMemberVarying::IfcStructuralSurfaceMemberVarying(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v9_Thickness) : IfcStructuralSurfaceMember((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,v8_PredefinedType,IfcStructuralSurfaceMemberTypeEnum::ToString(v8_PredefinedType)); if (v9_Thickness) { e->setArgument(8,(*v9_Thickness)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStructuralSurfaceReaction
IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum IfcStructuralSurfaceReaction::PredefinedType() { return IfcStructuralSurfaceActivityTypeEnum::FromString(*entity->getArgument(9)); }
void IfcStructuralSurfaceReaction::setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcStructuralSurfaceActivityTypeEnum::ToString(v)); }
bool IfcStructuralSurfaceReaction::is(Type::Enum v) const { return v == Type::IfcStructuralSurfaceReaction || IfcStructuralReaction::is(v); }
Type::Enum IfcStructuralSurfaceReaction::type() const { return Type::IfcStructuralSurfaceReaction; }
Type::Enum IfcStructuralSurfaceReaction::Class() { return Type::IfcStructuralSurfaceReaction; }
IfcStructuralSurfaceReaction::IfcStructuralSurfaceReaction(IfcAbstractEntityPtr e) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStructuralSurfaceReaction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStructuralSurfaceReaction::IfcStructuralSurfaceReaction(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v10_PredefinedType) : IfcStructuralReaction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); e->setArgument(7,(v8_AppliedLoad)); e->setArgument(8,v9_GlobalOrLocal,IfcGlobalOrLocalEnum::ToString(v9_GlobalOrLocal)); e->setArgument(9,v10_PredefinedType,IfcStructuralSurfaceActivityTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStyleModel
bool IfcStyleModel::is(Type::Enum v) const { return v == Type::IfcStyleModel || IfcRepresentation::is(v); }
Type::Enum IfcStyleModel::type() const { return Type::IfcStyleModel; }
Type::Enum IfcStyleModel::Class() { return Type::IfcStyleModel; }
IfcStyleModel::IfcStyleModel(IfcAbstractEntityPtr e) : IfcRepresentation((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStyleModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyleModel::IfcStyleModel(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcRepresentation((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStyledItem
bool IfcStyledItem::hasItem() { return !entity->getArgument(0)->isNull(); }
IfcRepresentationItem* IfcStyledItem::Item() { return (IfcRepresentationItem*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcStyledItem::setItem(IfcRepresentationItem* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcStyledItem::Styles() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,1) }
void IfcStyledItem::setStyles(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcStyledItem::hasName() { return !entity->getArgument(2)->isNull(); }
IfcLabel IfcStyledItem::Name() { return *entity->getArgument(2); }
void IfcStyledItem::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcStyledItem::is(Type::Enum v) const { return v == Type::IfcStyledItem || IfcRepresentationItem::is(v); }
Type::Enum IfcStyledItem::type() const { return Type::IfcStyledItem; }
Type::Enum IfcStyledItem::Class() { return Type::IfcStyledItem; }
IfcStyledItem::IfcStyledItem(IfcAbstractEntityPtr e) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStyledItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyledItem::IfcStyledItem(IfcRepresentationItem* v1_Item, IfcEntities v2_Styles, boost::optional< IfcLabel > v3_Name) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Item)); e->setArgument(1,(v2_Styles)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcStyledRepresentation
bool IfcStyledRepresentation::is(Type::Enum v) const { return v == Type::IfcStyledRepresentation || IfcStyleModel::is(v); }
Type::Enum IfcStyledRepresentation::type() const { return Type::IfcStyledRepresentation; }
Type::Enum IfcStyledRepresentation::Class() { return Type::IfcStyledRepresentation; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcAbstractEntityPtr e) : IfcStyleModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcStyledRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcStyledRepresentation::IfcStyledRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcStyleModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSubContractResource
bool IfcSubContractResource::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResource::PredefinedType() { return IfcSubContractResourceTypeEnum::FromString(*entity->getArgument(10)); }
void IfcSubContractResource::setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcSubContractResourceTypeEnum::ToString(v)); }
bool IfcSubContractResource::is(Type::Enum v) const { return v == Type::IfcSubContractResource || IfcConstructionResource::is(v); }
Type::Enum IfcSubContractResource::type() const { return Type::IfcSubContractResource; }
Type::Enum IfcSubContractResource::Class() { return Type::IfcSubContractResource; }
IfcSubContractResource::IfcSubContractResource(IfcAbstractEntityPtr e) : IfcConstructionResource((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSubContractResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSubContractResource::IfcSubContractResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum > v11_PredefinedType) : IfcConstructionResource((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } e->setArgument(7,(v8_Usage)); if (v9_BaseCosts) { e->setArgument(8,(*v9_BaseCosts)->generalize()); } else { e->setArgument(8); } e->setArgument(9,(v10_BaseQuantity)); if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcSubContractResourceTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSubContractResourceType
IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum IfcSubContractResourceType::PredefinedType() { return IfcSubContractResourceTypeEnum::FromString(*entity->getArgument(11)); }
void IfcSubContractResourceType::setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcSubContractResourceTypeEnum::ToString(v)); }
bool IfcSubContractResourceType::is(Type::Enum v) const { return v == Type::IfcSubContractResourceType || IfcConstructionResourceType::is(v); }
Type::Enum IfcSubContractResourceType::type() const { return Type::IfcSubContractResourceType; }
Type::Enum IfcSubContractResourceType::Class() { return Type::IfcSubContractResourceType; }
IfcSubContractResourceType::IfcSubContractResourceType(IfcAbstractEntityPtr e) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSubContractResourceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSubContractResourceType::IfcSubContractResourceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcAppliedValue > > > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v12_PredefinedType) : IfcConstructionResourceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } if (v10_BaseCosts) { e->setArgument(9,(*v10_BaseCosts)->generalize()); } else { e->setArgument(9); } e->setArgument(10,(v11_BaseQuantity)); e->setArgument(11,v12_PredefinedType,IfcSubContractResourceTypeEnum::ToString(v12_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSubedge
IfcEdge* IfcSubedge::ParentEdge() { return (IfcEdge*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSubedge::setParentEdge(IfcEdge* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSubedge::is(Type::Enum v) const { return v == Type::IfcSubedge || IfcEdge::is(v); }
Type::Enum IfcSubedge::type() const { return Type::IfcSubedge; }
Type::Enum IfcSubedge::Class() { return Type::IfcSubedge; }
IfcSubedge::IfcSubedge(IfcAbstractEntityPtr e) : IfcEdge((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSubedge)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSubedge::IfcSubedge(IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcEdge* v3_ParentEdge) : IfcEdge((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_EdgeStart)); e->setArgument(1,(v2_EdgeEnd)); e->setArgument(2,(v3_ParentEdge)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurface
bool IfcSurface::is(Type::Enum v) const { return v == Type::IfcSurface || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcSurface::type() const { return Type::IfcSurface; }
Type::Enum IfcSurface::Class() { return Type::IfcSurface; }
IfcSurface::IfcSurface(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurface::IfcSurface() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceCurveSweptAreaSolid
IfcCurve* IfcSurfaceCurveSweptAreaSolid::Directrix() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSurfaceCurveSweptAreaSolid::setDirectrix(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSurfaceCurveSweptAreaSolid::hasStartParam() { return !entity->getArgument(3)->isNull(); }
IfcParameterValue IfcSurfaceCurveSweptAreaSolid::StartParam() { return *entity->getArgument(3); }
void IfcSurfaceCurveSweptAreaSolid::setStartParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceCurveSweptAreaSolid::hasEndParam() { return !entity->getArgument(4)->isNull(); }
IfcParameterValue IfcSurfaceCurveSweptAreaSolid::EndParam() { return *entity->getArgument(4); }
void IfcSurfaceCurveSweptAreaSolid::setEndParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcSurface* IfcSurfaceCurveSweptAreaSolid::ReferenceSurface() { return (IfcSurface*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(5))); }
void IfcSurfaceCurveSweptAreaSolid::setReferenceSurface(IfcSurface* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcSurfaceCurveSweptAreaSolid::is(Type::Enum v) const { return v == Type::IfcSurfaceCurveSweptAreaSolid || IfcSweptAreaSolid::is(v); }
Type::Enum IfcSurfaceCurveSweptAreaSolid::type() const { return Type::IfcSurfaceCurveSweptAreaSolid; }
Type::Enum IfcSurfaceCurveSweptAreaSolid::Class() { return Type::IfcSurfaceCurveSweptAreaSolid; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcAbstractEntityPtr e) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceCurveSweptAreaSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceCurveSweptAreaSolid::IfcSurfaceCurveSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< IfcParameterValue > v4_StartParam, boost::optional< IfcParameterValue > v5_EndParam, IfcSurface* v6_ReferenceSurface) : IfcSweptAreaSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_Directrix)); if (v4_StartParam) { e->setArgument(3,(*v4_StartParam)); } else { e->setArgument(3); } if (v5_EndParam) { e->setArgument(4,(*v5_EndParam)); } else { e->setArgument(4); } e->setArgument(5,(v6_ReferenceSurface)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceFeature
bool IfcSurfaceFeature::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum IfcSurfaceFeature::PredefinedType() { return IfcSurfaceFeatureTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSurfaceFeature::setPredefinedType(IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSurfaceFeatureTypeEnum::ToString(v)); }
bool IfcSurfaceFeature::is(Type::Enum v) const { return v == Type::IfcSurfaceFeature || IfcFeatureElement::is(v); }
Type::Enum IfcSurfaceFeature::type() const { return Type::IfcSurfaceFeature; }
Type::Enum IfcSurfaceFeature::Class() { return Type::IfcSurfaceFeature; }
IfcSurfaceFeature::IfcSurfaceFeature(IfcAbstractEntityPtr e) : IfcFeatureElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceFeature)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceFeature::IfcSurfaceFeature(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum > v9_PredefinedType) : IfcFeatureElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSurfaceFeatureTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceOfLinearExtrusion
IfcDirection* IfcSurfaceOfLinearExtrusion::ExtrudedDirection() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSurfaceOfLinearExtrusion::setExtrudedDirection(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcLengthMeasure IfcSurfaceOfLinearExtrusion::Depth() { return *entity->getArgument(3); }
void IfcSurfaceOfLinearExtrusion::setDepth(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceOfLinearExtrusion::is(Type::Enum v) const { return v == Type::IfcSurfaceOfLinearExtrusion || IfcSweptSurface::is(v); }
Type::Enum IfcSurfaceOfLinearExtrusion::type() const { return Type::IfcSurfaceOfLinearExtrusion; }
Type::Enum IfcSurfaceOfLinearExtrusion::Class() { return Type::IfcSurfaceOfLinearExtrusion; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcAbstractEntityPtr e) : IfcSweptSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceOfLinearExtrusion)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceOfLinearExtrusion::IfcSurfaceOfLinearExtrusion(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, IfcLengthMeasure v4_Depth) : IfcSweptSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptCurve)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_ExtrudedDirection)); e->setArgument(3,(v4_Depth)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceOfRevolution
IfcAxis1Placement* IfcSurfaceOfRevolution::AxisPosition() { return (IfcAxis1Placement*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSurfaceOfRevolution::setAxisPosition(IfcAxis1Placement* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSurfaceOfRevolution::is(Type::Enum v) const { return v == Type::IfcSurfaceOfRevolution || IfcSweptSurface::is(v); }
Type::Enum IfcSurfaceOfRevolution::type() const { return Type::IfcSurfaceOfRevolution; }
Type::Enum IfcSurfaceOfRevolution::Class() { return Type::IfcSurfaceOfRevolution; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcAbstractEntityPtr e) : IfcSweptSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceOfRevolution)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceOfRevolution::IfcSurfaceOfRevolution(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_AxisPosition) : IfcSweptSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptCurve)); e->setArgument(1,(v2_Position)); e->setArgument(2,(v3_AxisPosition)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceReinforcementArea
bool IfcSurfaceReinforcementArea::hasSurfaceReinforcement1() { return !entity->getArgument(1)->isNull(); }
std::vector< IfcLengthMeasure > /*[2:3]*/ IfcSurfaceReinforcementArea::SurfaceReinforcement1() { return *entity->getArgument(1); }
void IfcSurfaceReinforcementArea::setSurfaceReinforcement1(std::vector< IfcLengthMeasure > /*[2:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSurfaceReinforcementArea::hasSurfaceReinforcement2() { return !entity->getArgument(2)->isNull(); }
std::vector< IfcLengthMeasure > /*[2:3]*/ IfcSurfaceReinforcementArea::SurfaceReinforcement2() { return *entity->getArgument(2); }
void IfcSurfaceReinforcementArea::setSurfaceReinforcement2(std::vector< IfcLengthMeasure > /*[2:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSurfaceReinforcementArea::hasShearReinforcement() { return !entity->getArgument(3)->isNull(); }
IfcRatioMeasure IfcSurfaceReinforcementArea::ShearReinforcement() { return *entity->getArgument(3); }
void IfcSurfaceReinforcementArea::setShearReinforcement(IfcRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceReinforcementArea::is(Type::Enum v) const { return v == Type::IfcSurfaceReinforcementArea || IfcStructuralLoadOrResult::is(v); }
Type::Enum IfcSurfaceReinforcementArea::type() const { return Type::IfcSurfaceReinforcementArea; }
Type::Enum IfcSurfaceReinforcementArea::Class() { return Type::IfcSurfaceReinforcementArea; }
IfcSurfaceReinforcementArea::IfcSurfaceReinforcementArea(IfcAbstractEntityPtr e) : IfcStructuralLoadOrResult((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceReinforcementArea)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceReinforcementArea::IfcSurfaceReinforcementArea(boost::optional< IfcLabel > v1_Name, boost::optional< std::vector< IfcLengthMeasure > /*[2:3]*/ > v2_SurfaceReinforcement1, boost::optional< std::vector< IfcLengthMeasure > /*[2:3]*/ > v3_SurfaceReinforcement2, boost::optional< IfcRatioMeasure > v4_ShearReinforcement) : IfcStructuralLoadOrResult((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_SurfaceReinforcement1) { e->setArgument(1,(*v2_SurfaceReinforcement1)); } else { e->setArgument(1); } if (v3_SurfaceReinforcement2) { e->setArgument(2,(*v3_SurfaceReinforcement2)); } else { e->setArgument(2); } if (v4_ShearReinforcement) { e->setArgument(3,(*v4_ShearReinforcement)); } else { e->setArgument(3); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyle
IfcSurfaceSide::IfcSurfaceSide IfcSurfaceStyle::Side() { return IfcSurfaceSide::FromString(*entity->getArgument(1)); }
void IfcSurfaceStyle::setSide(IfcSurfaceSide::IfcSurfaceSide v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v,IfcSurfaceSide::ToString(v)); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcSurfaceStyle::Styles() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcSurfaceStyle::setStyles(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcSurfaceStyle::is(Type::Enum v) const { return v == Type::IfcSurfaceStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcSurfaceStyle::type() const { return Type::IfcSurfaceStyle; }
Type::Enum IfcSurfaceStyle::Class() { return Type::IfcSurfaceStyle; }
IfcSurfaceStyle::IfcSurfaceStyle(IfcAbstractEntityPtr e) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyle::IfcSurfaceStyle(boost::optional< IfcLabel > v1_Name, IfcSurfaceSide::IfcSurfaceSide v2_Side, IfcEntities v3_Styles) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,v2_Side,IfcSurfaceSide::ToString(v2_Side)); e->setArgument(2,(v3_Styles)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyleLighting
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseTransmissionColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSurfaceStyleLighting::setDiffuseTransmissionColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcColourRgb* IfcSurfaceStyleLighting::DiffuseReflectionColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcSurfaceStyleLighting::setDiffuseReflectionColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcColourRgb* IfcSurfaceStyleLighting::TransmissionColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcSurfaceStyleLighting::setTransmissionColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcColourRgb* IfcSurfaceStyleLighting::ReflectanceColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcSurfaceStyleLighting::setReflectanceColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceStyleLighting::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleLighting || IfcPresentationItem::is(v); }
Type::Enum IfcSurfaceStyleLighting::type() const { return Type::IfcSurfaceStyleLighting; }
Type::Enum IfcSurfaceStyleLighting::Class() { return Type::IfcSurfaceStyleLighting; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyleLighting)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleLighting::IfcSurfaceStyleLighting(IfcColourRgb* v1_DiffuseTransmissionColour, IfcColourRgb* v2_DiffuseReflectionColour, IfcColourRgb* v3_TransmissionColour, IfcColourRgb* v4_ReflectanceColour) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_DiffuseTransmissionColour)); e->setArgument(1,(v2_DiffuseReflectionColour)); e->setArgument(2,(v3_TransmissionColour)); e->setArgument(3,(v4_ReflectanceColour)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyleRefraction
bool IfcSurfaceStyleRefraction::hasRefractionIndex() { return !entity->getArgument(0)->isNull(); }
IfcReal IfcSurfaceStyleRefraction::RefractionIndex() { return *entity->getArgument(0); }
void IfcSurfaceStyleRefraction::setRefractionIndex(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSurfaceStyleRefraction::hasDispersionFactor() { return !entity->getArgument(1)->isNull(); }
IfcReal IfcSurfaceStyleRefraction::DispersionFactor() { return *entity->getArgument(1); }
void IfcSurfaceStyleRefraction::setDispersionFactor(IfcReal v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSurfaceStyleRefraction::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleRefraction || IfcPresentationItem::is(v); }
Type::Enum IfcSurfaceStyleRefraction::type() const { return Type::IfcSurfaceStyleRefraction; }
Type::Enum IfcSurfaceStyleRefraction::Class() { return Type::IfcSurfaceStyleRefraction; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyleRefraction)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleRefraction::IfcSurfaceStyleRefraction(boost::optional< IfcReal > v1_RefractionIndex, boost::optional< IfcReal > v2_DispersionFactor) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_RefractionIndex) { e->setArgument(0,(*v1_RefractionIndex)); } else { e->setArgument(0); } if (v2_DispersionFactor) { e->setArgument(1,(*v2_DispersionFactor)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyleRendering
bool IfcSurfaceStyleRendering::hasTransparency() { return !entity->getArgument(1)->isNull(); }
IfcNormalisedRatioMeasure IfcSurfaceStyleRendering::Transparency() { return *entity->getArgument(1); }
void IfcSurfaceStyleRendering::setTransparency(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSurfaceStyleRendering::hasDiffuseColour() { return !entity->getArgument(2)->isNull(); }
IfcColourOrFactor IfcSurfaceStyleRendering::DiffuseColour() { return *entity->getArgument(2); }
void IfcSurfaceStyleRendering::setDiffuseColour(IfcColourOrFactor v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSurfaceStyleRendering::hasTransmissionColour() { return !entity->getArgument(3)->isNull(); }
IfcColourOrFactor IfcSurfaceStyleRendering::TransmissionColour() { return *entity->getArgument(3); }
void IfcSurfaceStyleRendering::setTransmissionColour(IfcColourOrFactor v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceStyleRendering::hasDiffuseTransmissionColour() { return !entity->getArgument(4)->isNull(); }
IfcColourOrFactor IfcSurfaceStyleRendering::DiffuseTransmissionColour() { return *entity->getArgument(4); }
void IfcSurfaceStyleRendering::setDiffuseTransmissionColour(IfcColourOrFactor v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcSurfaceStyleRendering::hasReflectionColour() { return !entity->getArgument(5)->isNull(); }
IfcColourOrFactor IfcSurfaceStyleRendering::ReflectionColour() { return *entity->getArgument(5); }
void IfcSurfaceStyleRendering::setReflectionColour(IfcColourOrFactor v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcSurfaceStyleRendering::hasSpecularColour() { return !entity->getArgument(6)->isNull(); }
IfcColourOrFactor IfcSurfaceStyleRendering::SpecularColour() { return *entity->getArgument(6); }
void IfcSurfaceStyleRendering::setSpecularColour(IfcColourOrFactor v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcSurfaceStyleRendering::hasSpecularHighlight() { return !entity->getArgument(7)->isNull(); }
IfcSpecularHighlightSelect IfcSurfaceStyleRendering::SpecularHighlight() { return *entity->getArgument(7); }
void IfcSurfaceStyleRendering::setSpecularHighlight(IfcSpecularHighlightSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcReflectanceMethodEnum::IfcReflectanceMethodEnum IfcSurfaceStyleRendering::ReflectanceMethod() { return IfcReflectanceMethodEnum::FromString(*entity->getArgument(8)); }
void IfcSurfaceStyleRendering::setReflectanceMethod(IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcReflectanceMethodEnum::ToString(v)); }
bool IfcSurfaceStyleRendering::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleRendering || IfcSurfaceStyleShading::is(v); }
Type::Enum IfcSurfaceStyleRendering::type() const { return Type::IfcSurfaceStyleRendering; }
Type::Enum IfcSurfaceStyleRendering::Class() { return Type::IfcSurfaceStyleRendering; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcAbstractEntityPtr e) : IfcSurfaceStyleShading((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyleRendering)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleRendering::IfcSurfaceStyleRendering(IfcColourRgb* v1_SurfaceColour, boost::optional< IfcNormalisedRatioMeasure > v2_Transparency, boost::optional< IfcColourOrFactor > v3_DiffuseColour, boost::optional< IfcColourOrFactor > v4_TransmissionColour, boost::optional< IfcColourOrFactor > v5_DiffuseTransmissionColour, boost::optional< IfcColourOrFactor > v6_ReflectionColour, boost::optional< IfcColourOrFactor > v7_SpecularColour, boost::optional< IfcSpecularHighlightSelect > v8_SpecularHighlight, IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v9_ReflectanceMethod) : IfcSurfaceStyleShading((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SurfaceColour)); if (v2_Transparency) { e->setArgument(1,(*v2_Transparency)); } else { e->setArgument(1); } if (v3_DiffuseColour) { e->setArgument(2,(*v3_DiffuseColour)); } else { e->setArgument(2); } if (v4_TransmissionColour) { e->setArgument(3,(*v4_TransmissionColour)); } else { e->setArgument(3); } if (v5_DiffuseTransmissionColour) { e->setArgument(4,(*v5_DiffuseTransmissionColour)); } else { e->setArgument(4); } if (v6_ReflectionColour) { e->setArgument(5,(*v6_ReflectionColour)); } else { e->setArgument(5); } if (v7_SpecularColour) { e->setArgument(6,(*v7_SpecularColour)); } else { e->setArgument(6); } if (v8_SpecularHighlight) { e->setArgument(7,(*v8_SpecularHighlight)); } else { e->setArgument(7); } e->setArgument(8,v9_ReflectanceMethod,IfcReflectanceMethodEnum::ToString(v9_ReflectanceMethod)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyleShading
IfcColourRgb* IfcSurfaceStyleShading::SurfaceColour() { return (IfcColourRgb*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSurfaceStyleShading::setSurfaceColour(IfcColourRgb* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSurfaceStyleShading::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleShading || IfcPresentationItem::is(v); }
Type::Enum IfcSurfaceStyleShading::type() const { return Type::IfcSurfaceStyleShading; }
Type::Enum IfcSurfaceStyleShading::Class() { return Type::IfcSurfaceStyleShading; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyleShading)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleShading::IfcSurfaceStyleShading(IfcColourRgb* v1_SurfaceColour) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SurfaceColour)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceStyleWithTextures
SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > IfcSurfaceStyleWithTextures::Textures() { RETURN_AS_LIST(IfcSurfaceTexture,0) }
void IfcSurfaceStyleWithTextures::setTextures(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcSurfaceStyleWithTextures::is(Type::Enum v) const { return v == Type::IfcSurfaceStyleWithTextures || IfcPresentationItem::is(v); }
Type::Enum IfcSurfaceStyleWithTextures::type() const { return Type::IfcSurfaceStyleWithTextures; }
Type::Enum IfcSurfaceStyleWithTextures::Class() { return Type::IfcSurfaceStyleWithTextures; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceStyleWithTextures)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceStyleWithTextures::IfcSurfaceStyleWithTextures(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Textures) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Textures)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSurfaceTexture
bool IfcSurfaceTexture::RepeatS() { return *entity->getArgument(0); }
void IfcSurfaceTexture::setRepeatS(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSurfaceTexture::RepeatT() { return *entity->getArgument(1); }
void IfcSurfaceTexture::setRepeatT(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSurfaceTexture::hasMode() { return !entity->getArgument(2)->isNull(); }
IfcIdentifier IfcSurfaceTexture::Mode() { return *entity->getArgument(2); }
void IfcSurfaceTexture::setMode(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSurfaceTexture::hasTextureTransform() { return !entity->getArgument(3)->isNull(); }
IfcCartesianTransformationOperator2D* IfcSurfaceTexture::TextureTransform() { return (IfcCartesianTransformationOperator2D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcSurfaceTexture::setTextureTransform(IfcCartesianTransformationOperator2D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSurfaceTexture::hasParameter() { return !entity->getArgument(4)->isNull(); }
std::vector< IfcIdentifier > /*[1:?]*/ IfcSurfaceTexture::Parameter() { return *entity->getArgument(4); }
void IfcSurfaceTexture::setParameter(std::vector< IfcIdentifier > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcTextureCoordinate::list IfcSurfaceTexture::IsMappedBy() { RETURN_INVERSE(IfcTextureCoordinate) }
IfcSurfaceStyleWithTextures::list IfcSurfaceTexture::UsedInStyles() { RETURN_INVERSE(IfcSurfaceStyleWithTextures) }
bool IfcSurfaceTexture::is(Type::Enum v) const { return v == Type::IfcSurfaceTexture || IfcPresentationItem::is(v); }
Type::Enum IfcSurfaceTexture::type() const { return Type::IfcSurfaceTexture; }
Type::Enum IfcSurfaceTexture::Class() { return Type::IfcSurfaceTexture; }
IfcSurfaceTexture::IfcSurfaceTexture(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSurfaceTexture)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSurfaceTexture::IfcSurfaceTexture(bool v1_RepeatS, bool v2_RepeatT, boost::optional< IfcIdentifier > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< IfcIdentifier > /*[1:?]*/ > v5_Parameter) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_RepeatS)); e->setArgument(1,(v2_RepeatT)); if (v3_Mode) { e->setArgument(2,(*v3_Mode)); } else { e->setArgument(2); } e->setArgument(3,(v4_TextureTransform)); if (v5_Parameter) { e->setArgument(4,(*v5_Parameter)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSweptAreaSolid
IfcProfileDef* IfcSweptAreaSolid::SweptArea() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSweptAreaSolid::setSweptArea(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSweptAreaSolid::hasPosition() { return !entity->getArgument(1)->isNull(); }
IfcAxis2Placement3D* IfcSweptAreaSolid::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcSweptAreaSolid::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSweptAreaSolid::is(Type::Enum v) const { return v == Type::IfcSweptAreaSolid || IfcSolidModel::is(v); }
Type::Enum IfcSweptAreaSolid::type() const { return Type::IfcSweptAreaSolid; }
Type::Enum IfcSweptAreaSolid::Class() { return Type::IfcSweptAreaSolid; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcAbstractEntityPtr e) : IfcSolidModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSweptAreaSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptAreaSolid::IfcSweptAreaSolid(IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position) : IfcSolidModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptArea)); e->setArgument(1,(v2_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSweptDiskSolid
IfcCurve* IfcSweptDiskSolid::Directrix() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSweptDiskSolid::setDirectrix(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcPositiveLengthMeasure IfcSweptDiskSolid::Radius() { return *entity->getArgument(1); }
void IfcSweptDiskSolid::setRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSweptDiskSolid::hasInnerRadius() { return !entity->getArgument(2)->isNull(); }
IfcPositiveLengthMeasure IfcSweptDiskSolid::InnerRadius() { return *entity->getArgument(2); }
void IfcSweptDiskSolid::setInnerRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcSweptDiskSolid::hasStartParam() { return !entity->getArgument(3)->isNull(); }
IfcParameterValue IfcSweptDiskSolid::StartParam() { return *entity->getArgument(3); }
void IfcSweptDiskSolid::setStartParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcSweptDiskSolid::hasEndParam() { return !entity->getArgument(4)->isNull(); }
IfcParameterValue IfcSweptDiskSolid::EndParam() { return *entity->getArgument(4); }
void IfcSweptDiskSolid::setEndParam(IfcParameterValue v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcSweptDiskSolid::is(Type::Enum v) const { return v == Type::IfcSweptDiskSolid || IfcSolidModel::is(v); }
Type::Enum IfcSweptDiskSolid::type() const { return Type::IfcSweptDiskSolid; }
Type::Enum IfcSweptDiskSolid::Class() { return Type::IfcSweptDiskSolid; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcAbstractEntityPtr e) : IfcSolidModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSweptDiskSolid)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptDiskSolid::IfcSweptDiskSolid(IfcCurve* v1_Directrix, IfcPositiveLengthMeasure v2_Radius, boost::optional< IfcPositiveLengthMeasure > v3_InnerRadius, boost::optional< IfcParameterValue > v4_StartParam, boost::optional< IfcParameterValue > v5_EndParam) : IfcSolidModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Directrix)); e->setArgument(1,(v2_Radius)); if (v3_InnerRadius) { e->setArgument(2,(*v3_InnerRadius)); } else { e->setArgument(2); } if (v4_StartParam) { e->setArgument(3,(*v4_StartParam)); } else { e->setArgument(3); } if (v5_EndParam) { e->setArgument(4,(*v5_EndParam)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSweptDiskSolidPolygonal
bool IfcSweptDiskSolidPolygonal::hasFilletRadius() { return !entity->getArgument(5)->isNull(); }
IfcPositiveLengthMeasure IfcSweptDiskSolidPolygonal::FilletRadius() { return *entity->getArgument(5); }
void IfcSweptDiskSolidPolygonal::setFilletRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcSweptDiskSolidPolygonal::is(Type::Enum v) const { return v == Type::IfcSweptDiskSolidPolygonal || IfcSweptDiskSolid::is(v); }
Type::Enum IfcSweptDiskSolidPolygonal::type() const { return Type::IfcSweptDiskSolidPolygonal; }
Type::Enum IfcSweptDiskSolidPolygonal::Class() { return Type::IfcSweptDiskSolidPolygonal; }
IfcSweptDiskSolidPolygonal::IfcSweptDiskSolidPolygonal(IfcAbstractEntityPtr e) : IfcSweptDiskSolid((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSweptDiskSolidPolygonal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptDiskSolidPolygonal::IfcSweptDiskSolidPolygonal(IfcCurve* v1_Directrix, IfcPositiveLengthMeasure v2_Radius, boost::optional< IfcPositiveLengthMeasure > v3_InnerRadius, boost::optional< IfcParameterValue > v4_StartParam, boost::optional< IfcParameterValue > v5_EndParam, boost::optional< IfcPositiveLengthMeasure > v6_FilletRadius) : IfcSweptDiskSolid((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Directrix)); e->setArgument(1,(v2_Radius)); if (v3_InnerRadius) { e->setArgument(2,(*v3_InnerRadius)); } else { e->setArgument(2); } if (v4_StartParam) { e->setArgument(3,(*v4_StartParam)); } else { e->setArgument(3); } if (v5_EndParam) { e->setArgument(4,(*v5_EndParam)); } else { e->setArgument(4); } if (v6_FilletRadius) { e->setArgument(5,(*v6_FilletRadius)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSweptSurface
IfcProfileDef* IfcSweptSurface::SweptCurve() { return (IfcProfileDef*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcSweptSurface::setSweptCurve(IfcProfileDef* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcSweptSurface::hasPosition() { return !entity->getArgument(1)->isNull(); }
IfcAxis2Placement3D* IfcSweptSurface::Position() { return (IfcAxis2Placement3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcSweptSurface::setPosition(IfcAxis2Placement3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcSweptSurface::is(Type::Enum v) const { return v == Type::IfcSweptSurface || IfcSurface::is(v); }
Type::Enum IfcSweptSurface::type() const { return Type::IfcSweptSurface; }
Type::Enum IfcSweptSurface::Class() { return Type::IfcSweptSurface; }
IfcSweptSurface::IfcSweptSurface(IfcAbstractEntityPtr e) : IfcSurface((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSweptSurface)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSweptSurface::IfcSweptSurface(IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position) : IfcSurface((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_SweptCurve)); e->setArgument(1,(v2_Position)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSwitchingDevice
bool IfcSwitchingDevice::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDevice::PredefinedType() { return IfcSwitchingDeviceTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSwitchingDevice::setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSwitchingDeviceTypeEnum::ToString(v)); }
bool IfcSwitchingDevice::is(Type::Enum v) const { return v == Type::IfcSwitchingDevice || IfcFlowController::is(v); }
Type::Enum IfcSwitchingDevice::type() const { return Type::IfcSwitchingDevice; }
Type::Enum IfcSwitchingDevice::Class() { return Type::IfcSwitchingDevice; }
IfcSwitchingDevice::IfcSwitchingDevice(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSwitchingDevice)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSwitchingDevice::IfcSwitchingDevice(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSwitchingDeviceTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSwitchingDeviceType
IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum IfcSwitchingDeviceType::PredefinedType() { return IfcSwitchingDeviceTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSwitchingDeviceType::setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSwitchingDeviceTypeEnum::ToString(v)); }
bool IfcSwitchingDeviceType::is(Type::Enum v) const { return v == Type::IfcSwitchingDeviceType || IfcFlowControllerType::is(v); }
Type::Enum IfcSwitchingDeviceType::type() const { return Type::IfcSwitchingDeviceType; }
Type::Enum IfcSwitchingDeviceType::Class() { return Type::IfcSwitchingDeviceType; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSwitchingDeviceType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSwitchingDeviceType::IfcSwitchingDeviceType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcSwitchingDeviceTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSystem
IfcRelServicesBuildings::list IfcSystem::ServicesBuildings() { RETURN_INVERSE(IfcRelServicesBuildings) }
bool IfcSystem::is(Type::Enum v) const { return v == Type::IfcSystem || IfcGroup::is(v); }
Type::Enum IfcSystem::type() const { return Type::IfcSystem; }
Type::Enum IfcSystem::Class() { return Type::IfcSystem; }
IfcSystem::IfcSystem(IfcAbstractEntityPtr e) : IfcGroup((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSystem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSystem::IfcSystem(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType) : IfcGroup((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSystemFurnitureElement
bool IfcSystemFurnitureElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElement::PredefinedType() { return IfcSystemFurnitureElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcSystemFurnitureElement::setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcSystemFurnitureElementTypeEnum::ToString(v)); }
bool IfcSystemFurnitureElement::is(Type::Enum v) const { return v == Type::IfcSystemFurnitureElement || IfcFurnishingElement::is(v); }
Type::Enum IfcSystemFurnitureElement::type() const { return Type::IfcSystemFurnitureElement; }
Type::Enum IfcSystemFurnitureElement::Class() { return Type::IfcSystemFurnitureElement; }
IfcSystemFurnitureElement::IfcSystemFurnitureElement(IfcAbstractEntityPtr e) : IfcFurnishingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSystemFurnitureElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSystemFurnitureElement::IfcSystemFurnitureElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v9_PredefinedType) : IfcFurnishingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcSystemFurnitureElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcSystemFurnitureElementType
bool IfcSystemFurnitureElementType::hasPredefinedType() { return !entity->getArgument(9)->isNull(); }
IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum IfcSystemFurnitureElementType::PredefinedType() { return IfcSystemFurnitureElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcSystemFurnitureElementType::setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcSystemFurnitureElementTypeEnum::ToString(v)); }
bool IfcSystemFurnitureElementType::is(Type::Enum v) const { return v == Type::IfcSystemFurnitureElementType || IfcFurnishingElementType::is(v); }
Type::Enum IfcSystemFurnitureElementType::type() const { return Type::IfcSystemFurnitureElementType; }
Type::Enum IfcSystemFurnitureElementType::Class() { return Type::IfcSystemFurnitureElementType; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(IfcAbstractEntityPtr e) : IfcFurnishingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcSystemFurnitureElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcSystemFurnitureElementType::IfcSystemFurnitureElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v10_PredefinedType) : IfcFurnishingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } if (v10_PredefinedType) { e->setArgument(9,*v10_PredefinedType,IfcSystemFurnitureElementTypeEnum::ToString(*v10_PredefinedType)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTShapeProfileDef
IfcPositiveLengthMeasure IfcTShapeProfileDef::Depth() { return *entity->getArgument(3); }
void IfcTShapeProfileDef::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcTShapeProfileDef::FlangeWidth() { return *entity->getArgument(4); }
void IfcTShapeProfileDef::setFlangeWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcTShapeProfileDef::WebThickness() { return *entity->getArgument(5); }
void IfcTShapeProfileDef::setWebThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcTShapeProfileDef::FlangeThickness() { return *entity->getArgument(6); }
void IfcTShapeProfileDef::setFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTShapeProfileDef::hasFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcTShapeProfileDef::FilletRadius() { return *entity->getArgument(7); }
void IfcTShapeProfileDef::setFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTShapeProfileDef::hasFlangeEdgeRadius() { return !entity->getArgument(8)->isNull(); }
IfcNonNegativeLengthMeasure IfcTShapeProfileDef::FlangeEdgeRadius() { return *entity->getArgument(8); }
void IfcTShapeProfileDef::setFlangeEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcTShapeProfileDef::hasWebEdgeRadius() { return !entity->getArgument(9)->isNull(); }
IfcNonNegativeLengthMeasure IfcTShapeProfileDef::WebEdgeRadius() { return *entity->getArgument(9); }
void IfcTShapeProfileDef::setWebEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcTShapeProfileDef::hasWebSlope() { return !entity->getArgument(10)->isNull(); }
IfcPlaneAngleMeasure IfcTShapeProfileDef::WebSlope() { return *entity->getArgument(10); }
void IfcTShapeProfileDef::setWebSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTShapeProfileDef::hasFlangeSlope() { return !entity->getArgument(11)->isNull(); }
IfcPlaneAngleMeasure IfcTShapeProfileDef::FlangeSlope() { return *entity->getArgument(11); }
void IfcTShapeProfileDef::setFlangeSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcTShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcTShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcTShapeProfileDef::type() const { return Type::IfcTShapeProfileDef; }
Type::Enum IfcTShapeProfileDef::Class() { return Type::IfcTShapeProfileDef; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTShapeProfileDef::IfcTShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Depth, IfcPositiveLengthMeasure v5_FlangeWidth, IfcPositiveLengthMeasure v6_WebThickness, IfcPositiveLengthMeasure v7_FlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_FilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v9_FlangeEdgeRadius, boost::optional< IfcNonNegativeLengthMeasure > v10_WebEdgeRadius, boost::optional< IfcPlaneAngleMeasure > v11_WebSlope, boost::optional< IfcPlaneAngleMeasure > v12_FlangeSlope) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Depth)); e->setArgument(4,(v5_FlangeWidth)); e->setArgument(5,(v6_WebThickness)); e->setArgument(6,(v7_FlangeThickness)); if (v8_FilletRadius) { e->setArgument(7,(*v8_FilletRadius)); } else { e->setArgument(7); } if (v9_FlangeEdgeRadius) { e->setArgument(8,(*v9_FlangeEdgeRadius)); } else { e->setArgument(8); } if (v10_WebEdgeRadius) { e->setArgument(9,(*v10_WebEdgeRadius)); } else { e->setArgument(9); } if (v11_WebSlope) { e->setArgument(10,(*v11_WebSlope)); } else { e->setArgument(10); } if (v12_FlangeSlope) { e->setArgument(11,(*v12_FlangeSlope)); } else { e->setArgument(11); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTable
bool IfcTable::hasName() { return !entity->getArgument(0)->isNull(); }
IfcLabel IfcTable::Name() { return *entity->getArgument(0); }
void IfcTable::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTable::hasRows() { return !entity->getArgument(1)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcTableRow > > IfcTable::Rows() { RETURN_AS_LIST(IfcTableRow,1) }
void IfcTable::setRows(SHARED_PTR< IfcTemplatedEntityList< IfcTableRow > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
bool IfcTable::hasColumns() { return !entity->getArgument(2)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcTableColumn > > IfcTable::Columns() { RETURN_AS_LIST(IfcTableColumn,2) }
void IfcTable::setColumns(SHARED_PTR< IfcTemplatedEntityList< IfcTableColumn > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcTable::is(Type::Enum v) const { return v == Type::IfcTable; }
Type::Enum IfcTable::type() const { return Type::IfcTable; }
Type::Enum IfcTable::Class() { return Type::IfcTable; }
IfcTable::IfcTable(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTable)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTable::IfcTable(boost::optional< IfcLabel > v1_Name, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcTableRow > > > v2_Rows, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcTableColumn > > > v3_Columns) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_Rows) { e->setArgument(1,(*v2_Rows)->generalize()); } else { e->setArgument(1); } if (v3_Columns) { e->setArgument(2,(*v3_Columns)->generalize()); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTableColumn
bool IfcTableColumn::hasIdentifier() { return !entity->getArgument(0)->isNull(); }
IfcIdentifier IfcTableColumn::Identifier() { return *entity->getArgument(0); }
void IfcTableColumn::setIdentifier(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTableColumn::hasName() { return !entity->getArgument(1)->isNull(); }
IfcLabel IfcTableColumn::Name() { return *entity->getArgument(1); }
void IfcTableColumn::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTableColumn::hasDescription() { return !entity->getArgument(2)->isNull(); }
IfcText IfcTableColumn::Description() { return *entity->getArgument(2); }
void IfcTableColumn::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcTableColumn::hasUnit() { return !entity->getArgument(3)->isNull(); }
IfcUnit IfcTableColumn::Unit() { return *entity->getArgument(3); }
void IfcTableColumn::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcTableColumn::hasReferencePath() { return !entity->getArgument(4)->isNull(); }
IfcReference* IfcTableColumn::ReferencePath() { return (IfcReference*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(4))); }
void IfcTableColumn::setReferencePath(IfcReference* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTableColumn::is(Type::Enum v) const { return v == Type::IfcTableColumn; }
Type::Enum IfcTableColumn::type() const { return Type::IfcTableColumn; }
Type::Enum IfcTableColumn::Class() { return Type::IfcTableColumn; }
IfcTableColumn::IfcTableColumn(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTableColumn)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTableColumn::IfcTableColumn(boost::optional< IfcIdentifier > v1_Identifier, boost::optional< IfcLabel > v2_Name, boost::optional< IfcText > v3_Description, boost::optional< IfcUnit > v4_Unit, IfcReference* v5_ReferencePath) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Identifier) { e->setArgument(0,(*v1_Identifier)); } else { e->setArgument(0); } if (v2_Name) { e->setArgument(1,(*v2_Name)); } else { e->setArgument(1); } if (v3_Description) { e->setArgument(2,(*v3_Description)); } else { e->setArgument(2); } if (v4_Unit) { e->setArgument(3,(*v4_Unit)); } else { e->setArgument(3); } e->setArgument(4,(v5_ReferencePath)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTableRow
bool IfcTableRow::hasRowCells() { return !entity->getArgument(0)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcTableRow::RowCells() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcTableRow::setRowCells(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcTableRow::hasIsHeading() { return !entity->getArgument(1)->isNull(); }
bool IfcTableRow::IsHeading() { return *entity->getArgument(1); }
void IfcTableRow::setIsHeading(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcTable::list IfcTableRow::OfTable() { RETURN_INVERSE(IfcTable) }
bool IfcTableRow::is(Type::Enum v) const { return v == Type::IfcTableRow; }
Type::Enum IfcTableRow::type() const { return Type::IfcTableRow; }
Type::Enum IfcTableRow::Class() { return Type::IfcTableRow; }
IfcTableRow::IfcTableRow(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTableRow)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTableRow::IfcTableRow(boost::optional< IfcEntities > v1_RowCells, boost::optional< bool > v2_IsHeading) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_RowCells) { e->setArgument(0,(*v1_RowCells)); } else { e->setArgument(0); } if (v2_IsHeading) { e->setArgument(1,(*v2_IsHeading)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTank
bool IfcTank::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcTankTypeEnum::IfcTankTypeEnum IfcTank::PredefinedType() { return IfcTankTypeEnum::FromString(*entity->getArgument(8)); }
void IfcTank::setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcTankTypeEnum::ToString(v)); }
bool IfcTank::is(Type::Enum v) const { return v == Type::IfcTank || IfcFlowStorageDevice::is(v); }
Type::Enum IfcTank::type() const { return Type::IfcTank; }
Type::Enum IfcTank::Class() { return Type::IfcTank; }
IfcTank::IfcTank(IfcAbstractEntityPtr e) : IfcFlowStorageDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTank)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTank::IfcTank(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcTankTypeEnum::IfcTankTypeEnum > v9_PredefinedType) : IfcFlowStorageDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcTankTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTankType
IfcTankTypeEnum::IfcTankTypeEnum IfcTankType::PredefinedType() { return IfcTankTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTankType::setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTankTypeEnum::ToString(v)); }
bool IfcTankType::is(Type::Enum v) const { return v == Type::IfcTankType || IfcFlowStorageDeviceType::is(v); }
Type::Enum IfcTankType::type() const { return Type::IfcTankType; }
Type::Enum IfcTankType::Class() { return Type::IfcTankType; }
IfcTankType::IfcTankType(IfcAbstractEntityPtr e) : IfcFlowStorageDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTankType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTankType::IfcTankType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTankTypeEnum::IfcTankTypeEnum v10_PredefinedType) : IfcFlowStorageDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTankTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTask
bool IfcTask::hasStatus() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcTask::Status() { return *entity->getArgument(7); }
void IfcTask::setStatus(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTask::hasWorkMethod() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcTask::WorkMethod() { return *entity->getArgument(8); }
void IfcTask::setWorkMethod(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcTask::IsMilestone() { return *entity->getArgument(9); }
void IfcTask::setIsMilestone(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcTask::hasPriority() { return !entity->getArgument(10)->isNull(); }
int IfcTask::Priority() { return *entity->getArgument(10); }
void IfcTask::setPriority(int v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTask::hasTaskTime() { return !entity->getArgument(11)->isNull(); }
IfcTaskTime* IfcTask::TaskTime() { return (IfcTaskTime*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(11))); }
void IfcTask::setTaskTime(IfcTaskTime* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcTask::hasPredefinedType() { return !entity->getArgument(12)->isNull(); }
IfcTaskTypeEnum::IfcTaskTypeEnum IfcTask::PredefinedType() { return IfcTaskTypeEnum::FromString(*entity->getArgument(12)); }
void IfcTask::setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v,IfcTaskTypeEnum::ToString(v)); }
bool IfcTask::is(Type::Enum v) const { return v == Type::IfcTask || IfcProcess::is(v); }
Type::Enum IfcTask::type() const { return Type::IfcTask; }
Type::Enum IfcTask::Class() { return Type::IfcTask; }
IfcTask::IfcTask(IfcAbstractEntityPtr e) : IfcProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTask)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTask::IfcTask(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< IfcText > v7_LongDescription, boost::optional< IfcLabel > v8_Status, boost::optional< IfcLabel > v9_WorkMethod, bool v10_IsMilestone, boost::optional< int > v11_Priority, IfcTaskTime* v12_TaskTime, boost::optional< IfcTaskTypeEnum::IfcTaskTypeEnum > v13_PredefinedType) : IfcProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_LongDescription) { e->setArgument(6,(*v7_LongDescription)); } else { e->setArgument(6); } if (v8_Status) { e->setArgument(7,(*v8_Status)); } else { e->setArgument(7); } if (v9_WorkMethod) { e->setArgument(8,(*v9_WorkMethod)); } else { e->setArgument(8); } e->setArgument(9,(v10_IsMilestone)); if (v11_Priority) { e->setArgument(10,(*v11_Priority)); } else { e->setArgument(10); } e->setArgument(11,(v12_TaskTime)); if (v13_PredefinedType) { e->setArgument(12,*v13_PredefinedType,IfcTaskTypeEnum::ToString(*v13_PredefinedType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTaskTime
bool IfcTaskTime::hasDurationType() { return !entity->getArgument(3)->isNull(); }
IfcTaskDurationEnum::IfcTaskDurationEnum IfcTaskTime::DurationType() { return IfcTaskDurationEnum::FromString(*entity->getArgument(3)); }
void IfcTaskTime::setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v,IfcTaskDurationEnum::ToString(v)); }
bool IfcTaskTime::hasScheduleDuration() { return !entity->getArgument(4)->isNull(); }
IfcDuration IfcTaskTime::ScheduleDuration() { return *entity->getArgument(4); }
void IfcTaskTime::setScheduleDuration(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTaskTime::hasScheduleStart() { return !entity->getArgument(5)->isNull(); }
IfcDateTime IfcTaskTime::ScheduleStart() { return *entity->getArgument(5); }
void IfcTaskTime::setScheduleStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcTaskTime::hasScheduleFinish() { return !entity->getArgument(6)->isNull(); }
IfcDateTime IfcTaskTime::ScheduleFinish() { return *entity->getArgument(6); }
void IfcTaskTime::setScheduleFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTaskTime::hasEarlyStart() { return !entity->getArgument(7)->isNull(); }
IfcDateTime IfcTaskTime::EarlyStart() { return *entity->getArgument(7); }
void IfcTaskTime::setEarlyStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTaskTime::hasEarlyFinish() { return !entity->getArgument(8)->isNull(); }
IfcDateTime IfcTaskTime::EarlyFinish() { return *entity->getArgument(8); }
void IfcTaskTime::setEarlyFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcTaskTime::hasLateStart() { return !entity->getArgument(9)->isNull(); }
IfcDateTime IfcTaskTime::LateStart() { return *entity->getArgument(9); }
void IfcTaskTime::setLateStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcTaskTime::hasLateFinish() { return !entity->getArgument(10)->isNull(); }
IfcDateTime IfcTaskTime::LateFinish() { return *entity->getArgument(10); }
void IfcTaskTime::setLateFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTaskTime::hasFreeFloat() { return !entity->getArgument(11)->isNull(); }
IfcDuration IfcTaskTime::FreeFloat() { return *entity->getArgument(11); }
void IfcTaskTime::setFreeFloat(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcTaskTime::hasTotalFloat() { return !entity->getArgument(12)->isNull(); }
IfcDuration IfcTaskTime::TotalFloat() { return *entity->getArgument(12); }
void IfcTaskTime::setTotalFloat(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcTaskTime::hasIsCritical() { return !entity->getArgument(13)->isNull(); }
bool IfcTaskTime::IsCritical() { return *entity->getArgument(13); }
void IfcTaskTime::setIsCritical(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcTaskTime::hasStatusTime() { return !entity->getArgument(14)->isNull(); }
IfcDateTime IfcTaskTime::StatusTime() { return *entity->getArgument(14); }
void IfcTaskTime::setStatusTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcTaskTime::hasActualDuration() { return !entity->getArgument(15)->isNull(); }
IfcDuration IfcTaskTime::ActualDuration() { return *entity->getArgument(15); }
void IfcTaskTime::setActualDuration(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcTaskTime::hasActualStart() { return !entity->getArgument(16)->isNull(); }
IfcDateTime IfcTaskTime::ActualStart() { return *entity->getArgument(16); }
void IfcTaskTime::setActualStart(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcTaskTime::hasActualFinish() { return !entity->getArgument(17)->isNull(); }
IfcDateTime IfcTaskTime::ActualFinish() { return *entity->getArgument(17); }
void IfcTaskTime::setActualFinish(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(17,v); }
bool IfcTaskTime::hasRemainingTime() { return !entity->getArgument(18)->isNull(); }
IfcDuration IfcTaskTime::RemainingTime() { return *entity->getArgument(18); }
void IfcTaskTime::setRemainingTime(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(18,v); }
bool IfcTaskTime::hasCompletion() { return !entity->getArgument(19)->isNull(); }
IfcPositiveRatioMeasure IfcTaskTime::Completion() { return *entity->getArgument(19); }
void IfcTaskTime::setCompletion(IfcPositiveRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(19,v); }
bool IfcTaskTime::is(Type::Enum v) const { return v == Type::IfcTaskTime || IfcSchedulingTime::is(v); }
Type::Enum IfcTaskTime::type() const { return Type::IfcTaskTime; }
Type::Enum IfcTaskTime::Class() { return Type::IfcTaskTime; }
IfcTaskTime::IfcTaskTime(IfcAbstractEntityPtr e) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTaskTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTaskTime::IfcTaskTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< IfcDuration > v5_ScheduleDuration, boost::optional< IfcDateTime > v6_ScheduleStart, boost::optional< IfcDateTime > v7_ScheduleFinish, boost::optional< IfcDateTime > v8_EarlyStart, boost::optional< IfcDateTime > v9_EarlyFinish, boost::optional< IfcDateTime > v10_LateStart, boost::optional< IfcDateTime > v11_LateFinish, boost::optional< IfcDuration > v12_FreeFloat, boost::optional< IfcDuration > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< IfcDateTime > v15_StatusTime, boost::optional< IfcDuration > v16_ActualDuration, boost::optional< IfcDateTime > v17_ActualStart, boost::optional< IfcDateTime > v18_ActualFinish, boost::optional< IfcDuration > v19_RemainingTime, boost::optional< IfcPositiveRatioMeasure > v20_Completion) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } if (v4_DurationType) { e->setArgument(3,*v4_DurationType,IfcTaskDurationEnum::ToString(*v4_DurationType)); } else { e->setArgument(3); } if (v5_ScheduleDuration) { e->setArgument(4,(*v5_ScheduleDuration)); } else { e->setArgument(4); } if (v6_ScheduleStart) { e->setArgument(5,(*v6_ScheduleStart)); } else { e->setArgument(5); } if (v7_ScheduleFinish) { e->setArgument(6,(*v7_ScheduleFinish)); } else { e->setArgument(6); } if (v8_EarlyStart) { e->setArgument(7,(*v8_EarlyStart)); } else { e->setArgument(7); } if (v9_EarlyFinish) { e->setArgument(8,(*v9_EarlyFinish)); } else { e->setArgument(8); } if (v10_LateStart) { e->setArgument(9,(*v10_LateStart)); } else { e->setArgument(9); } if (v11_LateFinish) { e->setArgument(10,(*v11_LateFinish)); } else { e->setArgument(10); } if (v12_FreeFloat) { e->setArgument(11,(*v12_FreeFloat)); } else { e->setArgument(11); } if (v13_TotalFloat) { e->setArgument(12,(*v13_TotalFloat)); } else { e->setArgument(12); } if (v14_IsCritical) { e->setArgument(13,(*v14_IsCritical)); } else { e->setArgument(13); } if (v15_StatusTime) { e->setArgument(14,(*v15_StatusTime)); } else { e->setArgument(14); } if (v16_ActualDuration) { e->setArgument(15,(*v16_ActualDuration)); } else { e->setArgument(15); } if (v17_ActualStart) { e->setArgument(16,(*v17_ActualStart)); } else { e->setArgument(16); } if (v18_ActualFinish) { e->setArgument(17,(*v18_ActualFinish)); } else { e->setArgument(17); } if (v19_RemainingTime) { e->setArgument(18,(*v19_RemainingTime)); } else { e->setArgument(18); } if (v20_Completion) { e->setArgument(19,(*v20_Completion)); } else { e->setArgument(19); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTaskTimeRecurring
IfcRecurrencePattern* IfcTaskTimeRecurring::Recurrance() { return (IfcRecurrencePattern*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(20))); }
void IfcTaskTimeRecurring::setRecurrance(IfcRecurrencePattern* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(20,v); }
bool IfcTaskTimeRecurring::is(Type::Enum v) const { return v == Type::IfcTaskTimeRecurring || IfcTaskTime::is(v); }
Type::Enum IfcTaskTimeRecurring::type() const { return Type::IfcTaskTimeRecurring; }
Type::Enum IfcTaskTimeRecurring::Class() { return Type::IfcTaskTimeRecurring; }
IfcTaskTimeRecurring::IfcTaskTimeRecurring(IfcAbstractEntityPtr e) : IfcTaskTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTaskTimeRecurring)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTaskTimeRecurring::IfcTaskTimeRecurring(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< IfcDuration > v5_ScheduleDuration, boost::optional< IfcDateTime > v6_ScheduleStart, boost::optional< IfcDateTime > v7_ScheduleFinish, boost::optional< IfcDateTime > v8_EarlyStart, boost::optional< IfcDateTime > v9_EarlyFinish, boost::optional< IfcDateTime > v10_LateStart, boost::optional< IfcDateTime > v11_LateFinish, boost::optional< IfcDuration > v12_FreeFloat, boost::optional< IfcDuration > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< IfcDateTime > v15_StatusTime, boost::optional< IfcDuration > v16_ActualDuration, boost::optional< IfcDateTime > v17_ActualStart, boost::optional< IfcDateTime > v18_ActualFinish, boost::optional< IfcDuration > v19_RemainingTime, boost::optional< IfcPositiveRatioMeasure > v20_Completion, IfcRecurrencePattern* v21_Recurrance) : IfcTaskTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } if (v4_DurationType) { e->setArgument(3,*v4_DurationType,IfcTaskDurationEnum::ToString(*v4_DurationType)); } else { e->setArgument(3); } if (v5_ScheduleDuration) { e->setArgument(4,(*v5_ScheduleDuration)); } else { e->setArgument(4); } if (v6_ScheduleStart) { e->setArgument(5,(*v6_ScheduleStart)); } else { e->setArgument(5); } if (v7_ScheduleFinish) { e->setArgument(6,(*v7_ScheduleFinish)); } else { e->setArgument(6); } if (v8_EarlyStart) { e->setArgument(7,(*v8_EarlyStart)); } else { e->setArgument(7); } if (v9_EarlyFinish) { e->setArgument(8,(*v9_EarlyFinish)); } else { e->setArgument(8); } if (v10_LateStart) { e->setArgument(9,(*v10_LateStart)); } else { e->setArgument(9); } if (v11_LateFinish) { e->setArgument(10,(*v11_LateFinish)); } else { e->setArgument(10); } if (v12_FreeFloat) { e->setArgument(11,(*v12_FreeFloat)); } else { e->setArgument(11); } if (v13_TotalFloat) { e->setArgument(12,(*v13_TotalFloat)); } else { e->setArgument(12); } if (v14_IsCritical) { e->setArgument(13,(*v14_IsCritical)); } else { e->setArgument(13); } if (v15_StatusTime) { e->setArgument(14,(*v15_StatusTime)); } else { e->setArgument(14); } if (v16_ActualDuration) { e->setArgument(15,(*v16_ActualDuration)); } else { e->setArgument(15); } if (v17_ActualStart) { e->setArgument(16,(*v17_ActualStart)); } else { e->setArgument(16); } if (v18_ActualFinish) { e->setArgument(17,(*v18_ActualFinish)); } else { e->setArgument(17); } if (v19_RemainingTime) { e->setArgument(18,(*v19_RemainingTime)); } else { e->setArgument(18); } if (v20_Completion) { e->setArgument(19,(*v20_Completion)); } else { e->setArgument(19); } e->setArgument(20,(v21_Recurrance)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTaskType
IfcTaskTypeEnum::IfcTaskTypeEnum IfcTaskType::PredefinedType() { return IfcTaskTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTaskType::setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTaskTypeEnum::ToString(v)); }
bool IfcTaskType::hasWorkMethod() { return !entity->getArgument(10)->isNull(); }
IfcLabel IfcTaskType::WorkMethod() { return *entity->getArgument(10); }
void IfcTaskType::setWorkMethod(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTaskType::is(Type::Enum v) const { return v == Type::IfcTaskType || IfcTypeProcess::is(v); }
Type::Enum IfcTaskType::type() const { return Type::IfcTaskType; }
Type::Enum IfcTaskType::Class() { return Type::IfcTaskType; }
IfcTaskType::IfcTaskType(IfcAbstractEntityPtr e) : IfcTypeProcess((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTaskType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTaskType::IfcTaskType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ProcessType, IfcTaskTypeEnum::IfcTaskTypeEnum v10_PredefinedType, boost::optional< IfcLabel > v11_WorkMethod) : IfcTypeProcess((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ProcessType) { e->setArgument(8,(*v9_ProcessType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTaskTypeEnum::ToString(v10_PredefinedType)); if (v11_WorkMethod) { e->setArgument(10,(*v11_WorkMethod)); } else { e->setArgument(10); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTelecomAddress
bool IfcTelecomAddress::hasTelephoneNumbers() { return !entity->getArgument(3)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcTelecomAddress::TelephoneNumbers() { return *entity->getArgument(3); }
void IfcTelecomAddress::setTelephoneNumbers(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcTelecomAddress::hasFacsimileNumbers() { return !entity->getArgument(4)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcTelecomAddress::FacsimileNumbers() { return *entity->getArgument(4); }
void IfcTelecomAddress::setFacsimileNumbers(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTelecomAddress::hasPagerNumber() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcTelecomAddress::PagerNumber() { return *entity->getArgument(5); }
void IfcTelecomAddress::setPagerNumber(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcTelecomAddress::hasElectronicMailAddresses() { return !entity->getArgument(6)->isNull(); }
std::vector< IfcLabel > /*[1:?]*/ IfcTelecomAddress::ElectronicMailAddresses() { return *entity->getArgument(6); }
void IfcTelecomAddress::setElectronicMailAddresses(std::vector< IfcLabel > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTelecomAddress::hasWWWHomePageURL() { return !entity->getArgument(7)->isNull(); }
IfcURIReference IfcTelecomAddress::WWWHomePageURL() { return *entity->getArgument(7); }
void IfcTelecomAddress::setWWWHomePageURL(IfcURIReference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTelecomAddress::hasMessagingIDs() { return !entity->getArgument(8)->isNull(); }
std::vector< IfcURIReference > /*[1:?]*/ IfcTelecomAddress::MessagingIDs() { return *entity->getArgument(8); }
void IfcTelecomAddress::setMessagingIDs(std::vector< IfcURIReference > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcTelecomAddress::is(Type::Enum v) const { return v == Type::IfcTelecomAddress || IfcAddress::is(v); }
Type::Enum IfcTelecomAddress::type() const { return Type::IfcTelecomAddress; }
Type::Enum IfcTelecomAddress::Class() { return Type::IfcTelecomAddress; }
IfcTelecomAddress::IfcTelecomAddress(IfcAbstractEntityPtr e) : IfcAddress((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTelecomAddress)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTelecomAddress::IfcTelecomAddress(boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< IfcText > v2_Description, boost::optional< IfcLabel > v3_UserDefinedPurpose, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< IfcLabel > v6_PagerNumber, boost::optional< std::vector< IfcLabel > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< IfcURIReference > v8_WWWHomePageURL, boost::optional< std::vector< IfcURIReference > /*[1:?]*/ > v9_MessagingIDs) : IfcAddress((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Purpose) { e->setArgument(0,*v1_Purpose,IfcAddressTypeEnum::ToString(*v1_Purpose)); } else { e->setArgument(0); } if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } if (v3_UserDefinedPurpose) { e->setArgument(2,(*v3_UserDefinedPurpose)); } else { e->setArgument(2); } if (v4_TelephoneNumbers) { e->setArgument(3,(*v4_TelephoneNumbers)); } else { e->setArgument(3); } if (v5_FacsimileNumbers) { e->setArgument(4,(*v5_FacsimileNumbers)); } else { e->setArgument(4); } if (v6_PagerNumber) { e->setArgument(5,(*v6_PagerNumber)); } else { e->setArgument(5); } if (v7_ElectronicMailAddresses) { e->setArgument(6,(*v7_ElectronicMailAddresses)); } else { e->setArgument(6); } if (v8_WWWHomePageURL) { e->setArgument(7,(*v8_WWWHomePageURL)); } else { e->setArgument(7); } if (v9_MessagingIDs) { e->setArgument(8,(*v9_MessagingIDs)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTendon
bool IfcTendon::hasPredefinedType() { return !entity->getArgument(9)->isNull(); }
IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendon::PredefinedType() { return IfcTendonTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTendon::setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTendonTypeEnum::ToString(v)); }
bool IfcTendon::hasNominalDiameter() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcTendon::NominalDiameter() { return *entity->getArgument(10); }
void IfcTendon::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTendon::hasCrossSectionArea() { return !entity->getArgument(11)->isNull(); }
IfcAreaMeasure IfcTendon::CrossSectionArea() { return *entity->getArgument(11); }
void IfcTendon::setCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcTendon::hasTensionForce() { return !entity->getArgument(12)->isNull(); }
IfcForceMeasure IfcTendon::TensionForce() { return *entity->getArgument(12); }
void IfcTendon::setTensionForce(IfcForceMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcTendon::hasPreStress() { return !entity->getArgument(13)->isNull(); }
IfcPressureMeasure IfcTendon::PreStress() { return *entity->getArgument(13); }
void IfcTendon::setPreStress(IfcPressureMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcTendon::hasFrictionCoefficient() { return !entity->getArgument(14)->isNull(); }
IfcNormalisedRatioMeasure IfcTendon::FrictionCoefficient() { return *entity->getArgument(14); }
void IfcTendon::setFrictionCoefficient(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcTendon::hasAnchorageSlip() { return !entity->getArgument(15)->isNull(); }
IfcPositiveLengthMeasure IfcTendon::AnchorageSlip() { return *entity->getArgument(15); }
void IfcTendon::setAnchorageSlip(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcTendon::hasMinCurvatureRadius() { return !entity->getArgument(16)->isNull(); }
IfcPositiveLengthMeasure IfcTendon::MinCurvatureRadius() { return *entity->getArgument(16); }
void IfcTendon::setMinCurvatureRadius(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(16,v); }
bool IfcTendon::is(Type::Enum v) const { return v == Type::IfcTendon || IfcReinforcingElement::is(v); }
Type::Enum IfcTendon::type() const { return Type::IfcTendon; }
Type::Enum IfcTendon::Class() { return Type::IfcTendon; }
IfcTendon::IfcTendon(IfcAbstractEntityPtr e) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTendon)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendon::IfcTendon(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLabel > v9_SteelGrade, boost::optional< IfcTendonTypeEnum::IfcTendonTypeEnum > v10_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v11_NominalDiameter, boost::optional< IfcAreaMeasure > v12_CrossSectionArea, boost::optional< IfcForceMeasure > v13_TensionForce, boost::optional< IfcPressureMeasure > v14_PreStress, boost::optional< IfcNormalisedRatioMeasure > v15_FrictionCoefficient, boost::optional< IfcPositiveLengthMeasure > v16_AnchorageSlip, boost::optional< IfcPositiveLengthMeasure > v17_MinCurvatureRadius) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_SteelGrade) { e->setArgument(8,(*v9_SteelGrade)); } else { e->setArgument(8); } if (v10_PredefinedType) { e->setArgument(9,*v10_PredefinedType,IfcTendonTypeEnum::ToString(*v10_PredefinedType)); } else { e->setArgument(9); } if (v11_NominalDiameter) { e->setArgument(10,(*v11_NominalDiameter)); } else { e->setArgument(10); } if (v12_CrossSectionArea) { e->setArgument(11,(*v12_CrossSectionArea)); } else { e->setArgument(11); } if (v13_TensionForce) { e->setArgument(12,(*v13_TensionForce)); } else { e->setArgument(12); } if (v14_PreStress) { e->setArgument(13,(*v14_PreStress)); } else { e->setArgument(13); } if (v15_FrictionCoefficient) { e->setArgument(14,(*v15_FrictionCoefficient)); } else { e->setArgument(14); } if (v16_AnchorageSlip) { e->setArgument(15,(*v16_AnchorageSlip)); } else { e->setArgument(15); } if (v17_MinCurvatureRadius) { e->setArgument(16,(*v17_MinCurvatureRadius)); } else { e->setArgument(16); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTendonAnchor
bool IfcTendonAnchor::hasPredefinedType() { return !entity->getArgument(9)->isNull(); }
IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchor::PredefinedType() { return IfcTendonAnchorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTendonAnchor::setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTendonAnchorTypeEnum::ToString(v)); }
bool IfcTendonAnchor::is(Type::Enum v) const { return v == Type::IfcTendonAnchor || IfcReinforcingElement::is(v); }
Type::Enum IfcTendonAnchor::type() const { return Type::IfcTendonAnchor; }
Type::Enum IfcTendonAnchor::Class() { return Type::IfcTendonAnchor; }
IfcTendonAnchor::IfcTendonAnchor(IfcAbstractEntityPtr e) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTendonAnchor)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendonAnchor::IfcTendonAnchor(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcLabel > v9_SteelGrade, boost::optional< IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum > v10_PredefinedType) : IfcReinforcingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_SteelGrade) { e->setArgument(8,(*v9_SteelGrade)); } else { e->setArgument(8); } if (v10_PredefinedType) { e->setArgument(9,*v10_PredefinedType,IfcTendonAnchorTypeEnum::ToString(*v10_PredefinedType)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTendonAnchorType
IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum IfcTendonAnchorType::PredefinedType() { return IfcTendonAnchorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTendonAnchorType::setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTendonAnchorTypeEnum::ToString(v)); }
bool IfcTendonAnchorType::is(Type::Enum v) const { return v == Type::IfcTendonAnchorType || IfcReinforcingElementType::is(v); }
Type::Enum IfcTendonAnchorType::type() const { return Type::IfcTendonAnchorType; }
Type::Enum IfcTendonAnchorType::Class() { return Type::IfcTendonAnchorType; }
IfcTendonAnchorType::IfcTendonAnchorType(IfcAbstractEntityPtr e) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTendonAnchorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendonAnchorType::IfcTendonAnchorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v10_PredefinedType) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTendonAnchorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTendonType
IfcTendonTypeEnum::IfcTendonTypeEnum IfcTendonType::PredefinedType() { return IfcTendonTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTendonType::setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTendonTypeEnum::ToString(v)); }
bool IfcTendonType::hasNominalDiameter() { return !entity->getArgument(10)->isNull(); }
IfcPositiveLengthMeasure IfcTendonType::NominalDiameter() { return *entity->getArgument(10); }
void IfcTendonType::setNominalDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcTendonType::hasCrossSectionArea() { return !entity->getArgument(11)->isNull(); }
IfcAreaMeasure IfcTendonType::CrossSectionArea() { return *entity->getArgument(11); }
void IfcTendonType::setCrossSectionArea(IfcAreaMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcTendonType::hasSheethDiameter() { return !entity->getArgument(12)->isNull(); }
IfcPositiveLengthMeasure IfcTendonType::SheethDiameter() { return *entity->getArgument(12); }
void IfcTendonType::setSheethDiameter(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcTendonType::is(Type::Enum v) const { return v == Type::IfcTendonType || IfcReinforcingElementType::is(v); }
Type::Enum IfcTendonType::type() const { return Type::IfcTendonType; }
Type::Enum IfcTendonType::Class() { return Type::IfcTendonType; }
IfcTendonType::IfcTendonType(IfcAbstractEntityPtr e) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTendonType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTendonType::IfcTendonType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTendonTypeEnum::IfcTendonTypeEnum v10_PredefinedType, boost::optional< IfcPositiveLengthMeasure > v11_NominalDiameter, boost::optional< IfcAreaMeasure > v12_CrossSectionArea, boost::optional< IfcPositiveLengthMeasure > v13_SheethDiameter) : IfcReinforcingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTendonTypeEnum::ToString(v10_PredefinedType)); if (v11_NominalDiameter) { e->setArgument(10,(*v11_NominalDiameter)); } else { e->setArgument(10); } if (v12_CrossSectionArea) { e->setArgument(11,(*v12_CrossSectionArea)); } else { e->setArgument(11); } if (v13_SheethDiameter) { e->setArgument(12,(*v13_SheethDiameter)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTessellatedFaceSet
IfcCartesianPointList3D* IfcTessellatedFaceSet::Coordinates() { return (IfcCartesianPointList3D*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcTessellatedFaceSet::setCoordinates(IfcCartesianPointList3D* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTessellatedFaceSet::hasClosed() { return !entity->getArgument(2)->isNull(); }
bool IfcTessellatedFaceSet::Closed() { return *entity->getArgument(2); }
void IfcTessellatedFaceSet::setClosed(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcIndexedColourMap::list IfcTessellatedFaceSet::HasColours() { RETURN_INVERSE(IfcIndexedColourMap) }
IfcIndexedTextureMap::list IfcTessellatedFaceSet::HasTextures() { RETURN_INVERSE(IfcIndexedTextureMap) }
bool IfcTessellatedFaceSet::is(Type::Enum v) const { return v == Type::IfcTessellatedFaceSet || IfcTessellatedItem::is(v); }
Type::Enum IfcTessellatedFaceSet::type() const { return Type::IfcTessellatedFaceSet; }
Type::Enum IfcTessellatedFaceSet::Class() { return Type::IfcTessellatedFaceSet; }
IfcTessellatedFaceSet::IfcTessellatedFaceSet(IfcAbstractEntityPtr e) : IfcTessellatedItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTessellatedFaceSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTessellatedFaceSet::IfcTessellatedFaceSet(IfcCartesianPointList3D* v1_Coordinates, boost::optional< bool > v3_Closed) : IfcTessellatedItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Coordinates)); if (v3_Closed) { e->setArgument(2,(*v3_Closed)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTessellatedItem
bool IfcTessellatedItem::is(Type::Enum v) const { return v == Type::IfcTessellatedItem || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcTessellatedItem::type() const { return Type::IfcTessellatedItem; }
Type::Enum IfcTessellatedItem::Class() { return Type::IfcTessellatedItem; }
IfcTessellatedItem::IfcTessellatedItem(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTessellatedItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTessellatedItem::IfcTessellatedItem() : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextLiteral
IfcPresentableText IfcTextLiteral::Literal() { return *entity->getArgument(0); }
void IfcTextLiteral::setLiteral(IfcPresentableText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcAxis2Placement IfcTextLiteral::Placement() { return *entity->getArgument(1); }
void IfcTextLiteral::setPlacement(IfcAxis2Placement v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcTextPath::IfcTextPath IfcTextLiteral::Path() { return IfcTextPath::FromString(*entity->getArgument(2)); }
void IfcTextLiteral::setPath(IfcTextPath::IfcTextPath v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v,IfcTextPath::ToString(v)); }
bool IfcTextLiteral::is(Type::Enum v) const { return v == Type::IfcTextLiteral || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcTextLiteral::type() const { return Type::IfcTextLiteral; }
Type::Enum IfcTextLiteral::Class() { return Type::IfcTextLiteral; }
IfcTextLiteral::IfcTextLiteral(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextLiteral)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextLiteral::IfcTextLiteral(IfcPresentableText v1_Literal, IfcAxis2Placement v2_Placement, IfcTextPath::IfcTextPath v3_Path) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Literal)); e->setArgument(1,(v2_Placement)); e->setArgument(2,v3_Path,IfcTextPath::ToString(v3_Path)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextLiteralWithExtent
IfcPlanarExtent* IfcTextLiteralWithExtent::Extent() { return (IfcPlanarExtent*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcTextLiteralWithExtent::setExtent(IfcPlanarExtent* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcBoxAlignment IfcTextLiteralWithExtent::BoxAlignment() { return *entity->getArgument(4); }
void IfcTextLiteralWithExtent::setBoxAlignment(IfcBoxAlignment v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTextLiteralWithExtent::is(Type::Enum v) const { return v == Type::IfcTextLiteralWithExtent || IfcTextLiteral::is(v); }
Type::Enum IfcTextLiteralWithExtent::type() const { return Type::IfcTextLiteralWithExtent; }
Type::Enum IfcTextLiteralWithExtent::Class() { return Type::IfcTextLiteralWithExtent; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(IfcAbstractEntityPtr e) : IfcTextLiteral((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextLiteralWithExtent)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextLiteralWithExtent::IfcTextLiteralWithExtent(IfcPresentableText v1_Literal, IfcAxis2Placement v2_Placement, IfcTextPath::IfcTextPath v3_Path, IfcPlanarExtent* v4_Extent, IfcBoxAlignment v5_BoxAlignment) : IfcTextLiteral((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Literal)); e->setArgument(1,(v2_Placement)); e->setArgument(2,v3_Path,IfcTextPath::ToString(v3_Path)); e->setArgument(3,(v4_Extent)); e->setArgument(4,(v5_BoxAlignment)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextStyle
bool IfcTextStyle::hasTextCharacterAppearance() { return !entity->getArgument(1)->isNull(); }
IfcTextStyleForDefinedFont* IfcTextStyle::TextCharacterAppearance() { return (IfcTextStyleForDefinedFont*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(1))); }
void IfcTextStyle::setTextCharacterAppearance(IfcTextStyleForDefinedFont* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTextStyle::hasTextStyle() { return !entity->getArgument(2)->isNull(); }
IfcTextStyleTextModel* IfcTextStyle::TextStyle() { return (IfcTextStyleTextModel*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcTextStyle::setTextStyle(IfcTextStyleTextModel* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcTextFontSelect IfcTextStyle::TextFontStyle() { return *entity->getArgument(3); }
void IfcTextStyle::setTextFontStyle(IfcTextFontSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcTextStyle::hasModelOrDraughting() { return !entity->getArgument(4)->isNull(); }
bool IfcTextStyle::ModelOrDraughting() { return *entity->getArgument(4); }
void IfcTextStyle::setModelOrDraughting(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTextStyle::is(Type::Enum v) const { return v == Type::IfcTextStyle || IfcPresentationStyle::is(v); }
Type::Enum IfcTextStyle::type() const { return Type::IfcTextStyle; }
Type::Enum IfcTextStyle::Class() { return Type::IfcTextStyle; }
IfcTextStyle::IfcTextStyle(IfcAbstractEntityPtr e) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyle::IfcTextStyle(boost::optional< IfcLabel > v1_Name, IfcTextStyleForDefinedFont* v2_TextCharacterAppearance, IfcTextStyleTextModel* v3_TextStyle, IfcTextFontSelect v4_TextFontStyle, boost::optional< bool > v5_ModelOrDraughting) : IfcPresentationStyle((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } e->setArgument(1,(v2_TextCharacterAppearance)); e->setArgument(2,(v3_TextStyle)); e->setArgument(3,(v4_TextFontStyle)); if (v5_ModelOrDraughting) { e->setArgument(4,(*v5_ModelOrDraughting)); } else { e->setArgument(4); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextStyleFontModel
std::vector< IfcTextFontName > /*[1:?]*/ IfcTextStyleFontModel::FontFamily() { return *entity->getArgument(1); }
void IfcTextStyleFontModel::setFontFamily(std::vector< IfcTextFontName > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTextStyleFontModel::hasFontStyle() { return !entity->getArgument(2)->isNull(); }
IfcFontStyle IfcTextStyleFontModel::FontStyle() { return *entity->getArgument(2); }
void IfcTextStyleFontModel::setFontStyle(IfcFontStyle v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcTextStyleFontModel::hasFontVariant() { return !entity->getArgument(3)->isNull(); }
IfcFontVariant IfcTextStyleFontModel::FontVariant() { return *entity->getArgument(3); }
void IfcTextStyleFontModel::setFontVariant(IfcFontVariant v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcTextStyleFontModel::hasFontWeight() { return !entity->getArgument(4)->isNull(); }
IfcFontWeight IfcTextStyleFontModel::FontWeight() { return *entity->getArgument(4); }
void IfcTextStyleFontModel::setFontWeight(IfcFontWeight v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcSizeSelect IfcTextStyleFontModel::FontSize() { return *entity->getArgument(5); }
void IfcTextStyleFontModel::setFontSize(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcTextStyleFontModel::is(Type::Enum v) const { return v == Type::IfcTextStyleFontModel || IfcPreDefinedTextFont::is(v); }
Type::Enum IfcTextStyleFontModel::type() const { return Type::IfcTextStyleFontModel; }
Type::Enum IfcTextStyleFontModel::Class() { return Type::IfcTextStyleFontModel; }
IfcTextStyleFontModel::IfcTextStyleFontModel(IfcAbstractEntityPtr e) : IfcPreDefinedTextFont((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextStyleFontModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleFontModel::IfcTextStyleFontModel(IfcLabel v1_Name, std::vector< IfcTextFontName > /*[1:?]*/ v2_FontFamily, boost::optional< IfcFontStyle > v3_FontStyle, boost::optional< IfcFontVariant > v4_FontVariant, boost::optional< IfcFontWeight > v5_FontWeight, IfcSizeSelect v6_FontSize) : IfcPreDefinedTextFont((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); e->setArgument(1,(v2_FontFamily)); if (v3_FontStyle) { e->setArgument(2,(*v3_FontStyle)); } else { e->setArgument(2); } if (v4_FontVariant) { e->setArgument(3,(*v4_FontVariant)); } else { e->setArgument(3); } if (v5_FontWeight) { e->setArgument(4,(*v5_FontWeight)); } else { e->setArgument(4); } e->setArgument(5,(v6_FontSize)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextStyleForDefinedFont
IfcColour IfcTextStyleForDefinedFont::Colour() { return *entity->getArgument(0); }
void IfcTextStyleForDefinedFont::setColour(IfcColour v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTextStyleForDefinedFont::hasBackgroundColour() { return !entity->getArgument(1)->isNull(); }
IfcColour IfcTextStyleForDefinedFont::BackgroundColour() { return *entity->getArgument(1); }
void IfcTextStyleForDefinedFont::setBackgroundColour(IfcColour v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTextStyleForDefinedFont::is(Type::Enum v) const { return v == Type::IfcTextStyleForDefinedFont || IfcPresentationItem::is(v); }
Type::Enum IfcTextStyleForDefinedFont::type() const { return Type::IfcTextStyleForDefinedFont; }
Type::Enum IfcTextStyleForDefinedFont::Class() { return Type::IfcTextStyleForDefinedFont; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextStyleForDefinedFont)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleForDefinedFont::IfcTextStyleForDefinedFont(IfcColour v1_Colour, boost::optional< IfcColour > v2_BackgroundColour) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Colour)); if (v2_BackgroundColour) { e->setArgument(1,(*v2_BackgroundColour)); } else { e->setArgument(1); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextStyleTextModel
bool IfcTextStyleTextModel::hasTextIndent() { return !entity->getArgument(0)->isNull(); }
IfcSizeSelect IfcTextStyleTextModel::TextIndent() { return *entity->getArgument(0); }
void IfcTextStyleTextModel::setTextIndent(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTextStyleTextModel::hasTextAlign() { return !entity->getArgument(1)->isNull(); }
IfcTextAlignment IfcTextStyleTextModel::TextAlign() { return *entity->getArgument(1); }
void IfcTextStyleTextModel::setTextAlign(IfcTextAlignment v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTextStyleTextModel::hasTextDecoration() { return !entity->getArgument(2)->isNull(); }
IfcTextDecoration IfcTextStyleTextModel::TextDecoration() { return *entity->getArgument(2); }
void IfcTextStyleTextModel::setTextDecoration(IfcTextDecoration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcTextStyleTextModel::hasLetterSpacing() { return !entity->getArgument(3)->isNull(); }
IfcSizeSelect IfcTextStyleTextModel::LetterSpacing() { return *entity->getArgument(3); }
void IfcTextStyleTextModel::setLetterSpacing(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcTextStyleTextModel::hasWordSpacing() { return !entity->getArgument(4)->isNull(); }
IfcSizeSelect IfcTextStyleTextModel::WordSpacing() { return *entity->getArgument(4); }
void IfcTextStyleTextModel::setWordSpacing(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTextStyleTextModel::hasTextTransform() { return !entity->getArgument(5)->isNull(); }
IfcTextTransformation IfcTextStyleTextModel::TextTransform() { return *entity->getArgument(5); }
void IfcTextStyleTextModel::setTextTransform(IfcTextTransformation v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcTextStyleTextModel::hasLineHeight() { return !entity->getArgument(6)->isNull(); }
IfcSizeSelect IfcTextStyleTextModel::LineHeight() { return *entity->getArgument(6); }
void IfcTextStyleTextModel::setLineHeight(IfcSizeSelect v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTextStyleTextModel::is(Type::Enum v) const { return v == Type::IfcTextStyleTextModel || IfcPresentationItem::is(v); }
Type::Enum IfcTextStyleTextModel::type() const { return Type::IfcTextStyleTextModel; }
Type::Enum IfcTextStyleTextModel::Class() { return Type::IfcTextStyleTextModel; }
IfcTextStyleTextModel::IfcTextStyleTextModel(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextStyleTextModel)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextStyleTextModel::IfcTextStyleTextModel(boost::optional< IfcSizeSelect > v1_TextIndent, boost::optional< IfcTextAlignment > v2_TextAlign, boost::optional< IfcTextDecoration > v3_TextDecoration, boost::optional< IfcSizeSelect > v4_LetterSpacing, boost::optional< IfcSizeSelect > v5_WordSpacing, boost::optional< IfcTextTransformation > v6_TextTransform, boost::optional< IfcSizeSelect > v7_LineHeight) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_TextIndent) { e->setArgument(0,(*v1_TextIndent)); } else { e->setArgument(0); } if (v2_TextAlign) { e->setArgument(1,(*v2_TextAlign)); } else { e->setArgument(1); } if (v3_TextDecoration) { e->setArgument(2,(*v3_TextDecoration)); } else { e->setArgument(2); } if (v4_LetterSpacing) { e->setArgument(3,(*v4_LetterSpacing)); } else { e->setArgument(3); } if (v5_WordSpacing) { e->setArgument(4,(*v5_WordSpacing)); } else { e->setArgument(4); } if (v6_TextTransform) { e->setArgument(5,(*v6_TextTransform)); } else { e->setArgument(5); } if (v7_LineHeight) { e->setArgument(6,(*v7_LineHeight)); } else { e->setArgument(6); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextureCoordinate
SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > IfcTextureCoordinate::Maps() { RETURN_AS_LIST(IfcSurfaceTexture,0) }
void IfcTextureCoordinate::setMaps(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcTextureCoordinate::is(Type::Enum v) const { return v == Type::IfcTextureCoordinate || IfcPresentationItem::is(v); }
Type::Enum IfcTextureCoordinate::type() const { return Type::IfcTextureCoordinate; }
Type::Enum IfcTextureCoordinate::Class() { return Type::IfcTextureCoordinate; }
IfcTextureCoordinate::IfcTextureCoordinate(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextureCoordinate)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureCoordinate::IfcTextureCoordinate(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Maps) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Maps)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextureCoordinateGenerator
IfcLabel IfcTextureCoordinateGenerator::Mode() { return *entity->getArgument(1); }
void IfcTextureCoordinateGenerator::setMode(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTextureCoordinateGenerator::hasParameter() { return !entity->getArgument(2)->isNull(); }
std::vector< IfcReal > /*[1:?]*/ IfcTextureCoordinateGenerator::Parameter() { return *entity->getArgument(2); }
void IfcTextureCoordinateGenerator::setParameter(std::vector< IfcReal > /*[1:?]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcTextureCoordinateGenerator::is(Type::Enum v) const { return v == Type::IfcTextureCoordinateGenerator || IfcTextureCoordinate::is(v); }
Type::Enum IfcTextureCoordinateGenerator::type() const { return Type::IfcTextureCoordinateGenerator; }
Type::Enum IfcTextureCoordinateGenerator::Class() { return Type::IfcTextureCoordinateGenerator; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(IfcAbstractEntityPtr e) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextureCoordinateGenerator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureCoordinateGenerator::IfcTextureCoordinateGenerator(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Maps, IfcLabel v2_Mode, boost::optional< std::vector< IfcReal > /*[1:?]*/ > v3_Parameter) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Maps)->generalize()); e->setArgument(1,(v2_Mode)); if (v3_Parameter) { e->setArgument(2,(*v3_Parameter)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextureMap
SHARED_PTR< IfcTemplatedEntityList< IfcTextureVertex > > IfcTextureMap::Vertices() { RETURN_AS_LIST(IfcTextureVertex,1) }
void IfcTextureMap::setVertices(SHARED_PTR< IfcTemplatedEntityList< IfcTextureVertex > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
IfcFace* IfcTextureMap::MappedTo() { return (IfcFace*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(2))); }
void IfcTextureMap::setMappedTo(IfcFace* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
bool IfcTextureMap::is(Type::Enum v) const { return v == Type::IfcTextureMap || IfcTextureCoordinate::is(v); }
Type::Enum IfcTextureMap::type() const { return Type::IfcTextureMap; }
Type::Enum IfcTextureMap::Class() { return Type::IfcTextureMap; }
IfcTextureMap::IfcTextureMap(IfcAbstractEntityPtr e) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextureMap)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureMap::IfcTextureMap(SHARED_PTR< IfcTemplatedEntityList< IfcSurfaceTexture > > v1_Maps, SHARED_PTR< IfcTemplatedEntityList< IfcTextureVertex > > v2_Vertices, IfcFace* v3_MappedTo) : IfcTextureCoordinate((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Maps)->generalize()); e->setArgument(1,(v2_Vertices)->generalize()); e->setArgument(2,(v3_MappedTo)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextureVertex
std::vector< IfcParameterValue > /*[2:2]*/ IfcTextureVertex::Coordinates() { return *entity->getArgument(0); }
void IfcTextureVertex::setCoordinates(std::vector< IfcParameterValue > /*[2:2]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTextureVertex::is(Type::Enum v) const { return v == Type::IfcTextureVertex || IfcPresentationItem::is(v); }
Type::Enum IfcTextureVertex::type() const { return Type::IfcTextureVertex; }
Type::Enum IfcTextureVertex::Class() { return Type::IfcTextureVertex; }
IfcTextureVertex::IfcTextureVertex(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextureVertex)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureVertex::IfcTextureVertex(std::vector< IfcParameterValue > /*[2:2]*/ v1_Coordinates) : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Coordinates)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTextureVertexList
bool IfcTextureVertexList::is(Type::Enum v) const { return v == Type::IfcTextureVertexList || IfcPresentationItem::is(v); }
Type::Enum IfcTextureVertexList::type() const { return Type::IfcTextureVertexList; }
Type::Enum IfcTextureVertexList::Class() { return Type::IfcTextureVertexList; }
IfcTextureVertexList::IfcTextureVertexList(IfcAbstractEntityPtr e) : IfcPresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTextureVertexList)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTextureVertexList::IfcTextureVertexList() : IfcPresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTimePeriod
IfcTime IfcTimePeriod::StartTime() { return *entity->getArgument(0); }
void IfcTimePeriod::setStartTime(IfcTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcTime IfcTimePeriod::EndTime() { return *entity->getArgument(1); }
void IfcTimePeriod::setEndTime(IfcTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcTimePeriod::is(Type::Enum v) const { return v == Type::IfcTimePeriod; }
Type::Enum IfcTimePeriod::type() const { return Type::IfcTimePeriod; }
Type::Enum IfcTimePeriod::Class() { return Type::IfcTimePeriod; }
IfcTimePeriod::IfcTimePeriod(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTimePeriod)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimePeriod::IfcTimePeriod(IfcTime v1_StartTime, IfcTime v2_EndTime) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_StartTime)); e->setArgument(1,(v2_EndTime)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTimeSeries
IfcLabel IfcTimeSeries::Name() { return *entity->getArgument(0); }
void IfcTimeSeries::setName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcTimeSeries::hasDescription() { return !entity->getArgument(1)->isNull(); }
IfcText IfcTimeSeries::Description() { return *entity->getArgument(1); }
void IfcTimeSeries::setDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
IfcDateTime IfcTimeSeries::StartTime() { return *entity->getArgument(2); }
void IfcTimeSeries::setStartTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v); }
IfcDateTime IfcTimeSeries::EndTime() { return *entity->getArgument(3); }
void IfcTimeSeries::setEndTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum IfcTimeSeries::TimeSeriesDataType() { return IfcTimeSeriesDataTypeEnum::FromString(*entity->getArgument(4)); }
void IfcTimeSeries::setTimeSeriesDataType(IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcTimeSeriesDataTypeEnum::ToString(v)); }
IfcDataOriginEnum::IfcDataOriginEnum IfcTimeSeries::DataOrigin() { return IfcDataOriginEnum::FromString(*entity->getArgument(5)); }
void IfcTimeSeries::setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcDataOriginEnum::ToString(v)); }
bool IfcTimeSeries::hasUserDefinedDataOrigin() { return !entity->getArgument(6)->isNull(); }
IfcLabel IfcTimeSeries::UserDefinedDataOrigin() { return *entity->getArgument(6); }
void IfcTimeSeries::setUserDefinedDataOrigin(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTimeSeries::hasUnit() { return !entity->getArgument(7)->isNull(); }
IfcUnit IfcTimeSeries::Unit() { return *entity->getArgument(7); }
void IfcTimeSeries::setUnit(IfcUnit v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcExternalReferenceRelationship::list IfcTimeSeries::HasExternalReference() { RETURN_INVERSE(IfcExternalReferenceRelationship) }
bool IfcTimeSeries::is(Type::Enum v) const { return v == Type::IfcTimeSeries; }
Type::Enum IfcTimeSeries::type() const { return Type::IfcTimeSeries; }
Type::Enum IfcTimeSeries::Class() { return Type::IfcTimeSeries; }
IfcTimeSeries::IfcTimeSeries(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTimeSeries)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeries::IfcTimeSeries(IfcLabel v1_Name, boost::optional< IfcText > v2_Description, IfcDateTime v3_StartTime, IfcDateTime v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< IfcLabel > v7_UserDefinedDataOrigin, boost::optional< IfcUnit > v8_Unit) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Name)); if (v2_Description) { e->setArgument(1,(*v2_Description)); } else { e->setArgument(1); } e->setArgument(2,(v3_StartTime)); e->setArgument(3,(v4_EndTime)); e->setArgument(4,v5_TimeSeriesDataType,IfcTimeSeriesDataTypeEnum::ToString(v5_TimeSeriesDataType)); e->setArgument(5,v6_DataOrigin,IfcDataOriginEnum::ToString(v6_DataOrigin)); if (v7_UserDefinedDataOrigin) { e->setArgument(6,(*v7_UserDefinedDataOrigin)); } else { e->setArgument(6); } if (v8_Unit) { e->setArgument(7,(*v8_Unit)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTimeSeriesValue
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcTimeSeriesValue::ListValues() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcTimeSeriesValue::setListValues(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcTimeSeriesValue::is(Type::Enum v) const { return v == Type::IfcTimeSeriesValue; }
Type::Enum IfcTimeSeriesValue::type() const { return Type::IfcTimeSeriesValue; }
Type::Enum IfcTimeSeriesValue::Class() { return Type::IfcTimeSeriesValue; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcTimeSeriesValue)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTimeSeriesValue::IfcTimeSeriesValue(IfcEntities v1_ListValues) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ListValues)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTopologicalRepresentationItem
bool IfcTopologicalRepresentationItem::is(Type::Enum v) const { return v == Type::IfcTopologicalRepresentationItem || IfcRepresentationItem::is(v); }
Type::Enum IfcTopologicalRepresentationItem::type() const { return Type::IfcTopologicalRepresentationItem; }
Type::Enum IfcTopologicalRepresentationItem::Class() { return Type::IfcTopologicalRepresentationItem; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem(IfcAbstractEntityPtr e) : IfcRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTopologicalRepresentationItem)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTopologicalRepresentationItem::IfcTopologicalRepresentationItem() : IfcRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTopologyRepresentation
bool IfcTopologyRepresentation::is(Type::Enum v) const { return v == Type::IfcTopologyRepresentation || IfcShapeModel::is(v); }
Type::Enum IfcTopologyRepresentation::type() const { return Type::IfcTopologyRepresentation; }
Type::Enum IfcTopologyRepresentation::Class() { return Type::IfcTopologyRepresentation; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcAbstractEntityPtr e) : IfcShapeModel((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTopologyRepresentation)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTopologyRepresentation::IfcTopologyRepresentation(IfcRepresentationContext* v1_ContextOfItems, boost::optional< IfcLabel > v2_RepresentationIdentifier, boost::optional< IfcLabel > v3_RepresentationType, SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationItem > > v4_Items) : IfcShapeModel((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_ContextOfItems)); if (v2_RepresentationIdentifier) { e->setArgument(1,(*v2_RepresentationIdentifier)); } else { e->setArgument(1); } if (v3_RepresentationType) { e->setArgument(2,(*v3_RepresentationType)); } else { e->setArgument(2); } e->setArgument(3,(v4_Items)->generalize()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTransformer
bool IfcTransformer::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformer::PredefinedType() { return IfcTransformerTypeEnum::FromString(*entity->getArgument(8)); }
void IfcTransformer::setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcTransformerTypeEnum::ToString(v)); }
bool IfcTransformer::is(Type::Enum v) const { return v == Type::IfcTransformer || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcTransformer::type() const { return Type::IfcTransformer; }
Type::Enum IfcTransformer::Class() { return Type::IfcTransformer; }
IfcTransformer::IfcTransformer(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTransformer)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransformer::IfcTransformer(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcTransformerTypeEnum::IfcTransformerTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcTransformerTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTransformerType
IfcTransformerTypeEnum::IfcTransformerTypeEnum IfcTransformerType::PredefinedType() { return IfcTransformerTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTransformerType::setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTransformerTypeEnum::ToString(v)); }
bool IfcTransformerType::is(Type::Enum v) const { return v == Type::IfcTransformerType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcTransformerType::type() const { return Type::IfcTransformerType; }
Type::Enum IfcTransformerType::Class() { return Type::IfcTransformerType; }
IfcTransformerType::IfcTransformerType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTransformerType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransformerType::IfcTransformerType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTransformerTypeEnum::IfcTransformerTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTransformerTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTransportElement
bool IfcTransportElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElement::PredefinedType() { return IfcTransportElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcTransportElement::setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcTransportElementTypeEnum::ToString(v)); }
bool IfcTransportElement::is(Type::Enum v) const { return v == Type::IfcTransportElement || IfcElement::is(v); }
Type::Enum IfcTransportElement::type() const { return Type::IfcTransportElement; }
Type::Enum IfcTransportElement::Class() { return Type::IfcTransportElement; }
IfcTransportElement::IfcTransportElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTransportElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransportElement::IfcTransportElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcTransportElementTypeEnum::IfcTransportElementTypeEnum > v9_PredefinedType) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcTransportElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTransportElementType
IfcTransportElementTypeEnum::IfcTransportElementTypeEnum IfcTransportElementType::PredefinedType() { return IfcTransportElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTransportElementType::setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTransportElementTypeEnum::ToString(v)); }
bool IfcTransportElementType::is(Type::Enum v) const { return v == Type::IfcTransportElementType || IfcElementType::is(v); }
Type::Enum IfcTransportElementType::type() const { return Type::IfcTransportElementType; }
Type::Enum IfcTransportElementType::Class() { return Type::IfcTransportElementType; }
IfcTransportElementType::IfcTransportElementType(IfcAbstractEntityPtr e) : IfcElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTransportElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTransportElementType::IfcTransportElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v10_PredefinedType) : IfcElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTransportElementTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTrapeziumProfileDef
IfcPositiveLengthMeasure IfcTrapeziumProfileDef::BottomXDim() { return *entity->getArgument(3); }
void IfcTrapeziumProfileDef::setBottomXDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcTrapeziumProfileDef::TopXDim() { return *entity->getArgument(4); }
void IfcTrapeziumProfileDef::setTopXDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcTrapeziumProfileDef::YDim() { return *entity->getArgument(5); }
void IfcTrapeziumProfileDef::setYDim(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcLengthMeasure IfcTrapeziumProfileDef::TopXOffset() { return *entity->getArgument(6); }
void IfcTrapeziumProfileDef::setTopXOffset(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTrapeziumProfileDef::is(Type::Enum v) const { return v == Type::IfcTrapeziumProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcTrapeziumProfileDef::type() const { return Type::IfcTrapeziumProfileDef; }
Type::Enum IfcTrapeziumProfileDef::Class() { return Type::IfcTrapeziumProfileDef; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTrapeziumProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTrapeziumProfileDef::IfcTrapeziumProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_BottomXDim, IfcPositiveLengthMeasure v5_TopXDim, IfcPositiveLengthMeasure v6_YDim, IfcLengthMeasure v7_TopXOffset) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_BottomXDim)); e->setArgument(4,(v5_TopXDim)); e->setArgument(5,(v6_YDim)); e->setArgument(6,(v7_TopXOffset)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTriangulatedFaceSet
bool IfcTriangulatedFaceSet::is(Type::Enum v) const { return v == Type::IfcTriangulatedFaceSet || IfcTessellatedFaceSet::is(v); }
Type::Enum IfcTriangulatedFaceSet::type() const { return Type::IfcTriangulatedFaceSet; }
Type::Enum IfcTriangulatedFaceSet::Class() { return Type::IfcTriangulatedFaceSet; }
IfcTriangulatedFaceSet::IfcTriangulatedFaceSet(IfcAbstractEntityPtr e) : IfcTessellatedFaceSet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTriangulatedFaceSet)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTriangulatedFaceSet::IfcTriangulatedFaceSet(IfcCartesianPointList3D* v1_Coordinates, boost::optional< bool > v3_Closed) : IfcTessellatedFaceSet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Coordinates)); if (v3_Closed) { e->setArgument(2,(*v3_Closed)); } else { e->setArgument(2); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTrimmedCurve
IfcCurve* IfcTrimmedCurve::BasisCurve() { return (IfcCurve*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcTrimmedCurve::setBasisCurve(IfcCurve* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcTrimmedCurve::Trim1() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,1) }
void IfcTrimmedCurve::setTrim1(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v->generalize()); }
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcTrimmedCurve::Trim2() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,2) }
void IfcTrimmedCurve::setTrim2(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(2,v->generalize()); }
bool IfcTrimmedCurve::SenseAgreement() { return *entity->getArgument(3); }
void IfcTrimmedCurve::setSenseAgreement(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcTrimmingPreference::IfcTrimmingPreference IfcTrimmedCurve::MasterRepresentation() { return IfcTrimmingPreference::FromString(*entity->getArgument(4)); }
void IfcTrimmedCurve::setMasterRepresentation(IfcTrimmingPreference::IfcTrimmingPreference v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcTrimmingPreference::ToString(v)); }
bool IfcTrimmedCurve::is(Type::Enum v) const { return v == Type::IfcTrimmedCurve || IfcBoundedCurve::is(v); }
Type::Enum IfcTrimmedCurve::type() const { return Type::IfcTrimmedCurve; }
Type::Enum IfcTrimmedCurve::Class() { return Type::IfcTrimmedCurve; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcAbstractEntityPtr e) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTrimmedCurve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTrimmedCurve::IfcTrimmedCurve(IfcCurve* v1_BasisCurve, IfcEntities v2_Trim1, IfcEntities v3_Trim2, bool v4_SenseAgreement, IfcTrimmingPreference::IfcTrimmingPreference v5_MasterRepresentation) : IfcBoundedCurve((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_BasisCurve)); e->setArgument(1,(v2_Trim1)); e->setArgument(2,(v3_Trim2)); e->setArgument(3,(v4_SenseAgreement)); e->setArgument(4,v5_MasterRepresentation,IfcTrimmingPreference::ToString(v5_MasterRepresentation)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTubeBundle
bool IfcTubeBundle::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundle::PredefinedType() { return IfcTubeBundleTypeEnum::FromString(*entity->getArgument(8)); }
void IfcTubeBundle::setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcTubeBundleTypeEnum::ToString(v)); }
bool IfcTubeBundle::is(Type::Enum v) const { return v == Type::IfcTubeBundle || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcTubeBundle::type() const { return Type::IfcTubeBundle; }
Type::Enum IfcTubeBundle::Class() { return Type::IfcTubeBundle; }
IfcTubeBundle::IfcTubeBundle(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTubeBundle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTubeBundle::IfcTubeBundle(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcTubeBundleTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTubeBundleType
IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum IfcTubeBundleType::PredefinedType() { return IfcTubeBundleTypeEnum::FromString(*entity->getArgument(9)); }
void IfcTubeBundleType::setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcTubeBundleTypeEnum::ToString(v)); }
bool IfcTubeBundleType::is(Type::Enum v) const { return v == Type::IfcTubeBundleType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcTubeBundleType::type() const { return Type::IfcTubeBundleType; }
Type::Enum IfcTubeBundleType::Class() { return Type::IfcTubeBundleType; }
IfcTubeBundleType::IfcTubeBundleType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTubeBundleType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTubeBundleType::IfcTubeBundleType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcTubeBundleTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTypeObject
bool IfcTypeObject::hasApplicableOccurrence() { return !entity->getArgument(4)->isNull(); }
IfcIdentifier IfcTypeObject::ApplicableOccurrence() { return *entity->getArgument(4); }
void IfcTypeObject::setApplicableOccurrence(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcTypeObject::hasHasPropertySets() { return !entity->getArgument(5)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > IfcTypeObject::HasPropertySets() { RETURN_AS_LIST(IfcPropertySetDefinition,5) }
void IfcTypeObject::setHasPropertySets(SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v->generalize()); }
IfcRelDefinesByType::list IfcTypeObject::Types() { RETURN_INVERSE(IfcRelDefinesByType) }
bool IfcTypeObject::is(Type::Enum v) const { return v == Type::IfcTypeObject || IfcObjectDefinition::is(v); }
Type::Enum IfcTypeObject::type() const { return Type::IfcTypeObject; }
Type::Enum IfcTypeObject::Class() { return Type::IfcTypeObject; }
IfcTypeObject::IfcTypeObject(IfcAbstractEntityPtr e) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTypeObject)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeObject::IfcTypeObject(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets) : IfcObjectDefinition((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTypeProcess
bool IfcTypeProcess::hasIdentification() { return !entity->getArgument(6)->isNull(); }
IfcIdentifier IfcTypeProcess::Identification() { return *entity->getArgument(6); }
void IfcTypeProcess::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTypeProcess::hasLongDescription() { return !entity->getArgument(7)->isNull(); }
IfcText IfcTypeProcess::LongDescription() { return *entity->getArgument(7); }
void IfcTypeProcess::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTypeProcess::hasProcessType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcTypeProcess::ProcessType() { return *entity->getArgument(8); }
void IfcTypeProcess::setProcessType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcRelAssignsToProcess::list IfcTypeProcess::OperatesOn() { RETURN_INVERSE(IfcRelAssignsToProcess) }
bool IfcTypeProcess::is(Type::Enum v) const { return v == Type::IfcTypeProcess || IfcTypeObject::is(v); }
Type::Enum IfcTypeProcess::type() const { return Type::IfcTypeProcess; }
Type::Enum IfcTypeProcess::Class() { return Type::IfcTypeProcess; }
IfcTypeProcess::IfcTypeProcess(IfcAbstractEntityPtr e) : IfcTypeObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTypeProcess)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeProcess::IfcTypeProcess(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ProcessType) : IfcTypeObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ProcessType) { e->setArgument(8,(*v9_ProcessType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTypeProduct
bool IfcTypeProduct::hasRepresentationMaps() { return !entity->getArgument(6)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > IfcTypeProduct::RepresentationMaps() { RETURN_AS_LIST(IfcRepresentationMap,6) }
void IfcTypeProduct::setRepresentationMaps(SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v->generalize()); }
bool IfcTypeProduct::hasTag() { return !entity->getArgument(7)->isNull(); }
IfcLabel IfcTypeProduct::Tag() { return *entity->getArgument(7); }
void IfcTypeProduct::setTag(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
IfcRelAssignsToProduct::list IfcTypeProduct::ReferencedBy() { RETURN_INVERSE(IfcRelAssignsToProduct) }
bool IfcTypeProduct::is(Type::Enum v) const { return v == Type::IfcTypeProduct || IfcTypeObject::is(v); }
Type::Enum IfcTypeProduct::type() const { return Type::IfcTypeProduct; }
Type::Enum IfcTypeProduct::Class() { return Type::IfcTypeProduct; }
IfcTypeProduct::IfcTypeProduct(IfcAbstractEntityPtr e) : IfcTypeObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTypeProduct)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeProduct::IfcTypeProduct(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag) : IfcTypeObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcTypeResource
bool IfcTypeResource::hasIdentification() { return !entity->getArgument(6)->isNull(); }
IfcIdentifier IfcTypeResource::Identification() { return *entity->getArgument(6); }
void IfcTypeResource::setIdentification(IfcIdentifier v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcTypeResource::hasLongDescription() { return !entity->getArgument(7)->isNull(); }
IfcText IfcTypeResource::LongDescription() { return *entity->getArgument(7); }
void IfcTypeResource::setLongDescription(IfcText v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcTypeResource::hasResourceType() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcTypeResource::ResourceType() { return *entity->getArgument(8); }
void IfcTypeResource::setResourceType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
IfcRelAssignsToResource::list IfcTypeResource::ResourceOf() { RETURN_INVERSE(IfcRelAssignsToResource) }
bool IfcTypeResource::is(Type::Enum v) const { return v == Type::IfcTypeResource || IfcTypeObject::is(v); }
Type::Enum IfcTypeResource::type() const { return Type::IfcTypeResource; }
Type::Enum IfcTypeResource::Class() { return Type::IfcTypeResource; }
IfcTypeResource::IfcTypeResource(IfcAbstractEntityPtr e) : IfcTypeObject((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcTypeResource)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcTypeResource::IfcTypeResource(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< IfcIdentifier > v7_Identification, boost::optional< IfcText > v8_LongDescription, boost::optional< IfcLabel > v9_ResourceType) : IfcTypeObject((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_Identification) { e->setArgument(6,(*v7_Identification)); } else { e->setArgument(6); } if (v8_LongDescription) { e->setArgument(7,(*v8_LongDescription)); } else { e->setArgument(7); } if (v9_ResourceType) { e->setArgument(8,(*v9_ResourceType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUShapeProfileDef
IfcPositiveLengthMeasure IfcUShapeProfileDef::Depth() { return *entity->getArgument(3); }
void IfcUShapeProfileDef::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcUShapeProfileDef::FlangeWidth() { return *entity->getArgument(4); }
void IfcUShapeProfileDef::setFlangeWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcUShapeProfileDef::WebThickness() { return *entity->getArgument(5); }
void IfcUShapeProfileDef::setWebThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcUShapeProfileDef::FlangeThickness() { return *entity->getArgument(6); }
void IfcUShapeProfileDef::setFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcUShapeProfileDef::hasFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcUShapeProfileDef::FilletRadius() { return *entity->getArgument(7); }
void IfcUShapeProfileDef::setFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcUShapeProfileDef::hasEdgeRadius() { return !entity->getArgument(8)->isNull(); }
IfcNonNegativeLengthMeasure IfcUShapeProfileDef::EdgeRadius() { return *entity->getArgument(8); }
void IfcUShapeProfileDef::setEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcUShapeProfileDef::hasFlangeSlope() { return !entity->getArgument(9)->isNull(); }
IfcPlaneAngleMeasure IfcUShapeProfileDef::FlangeSlope() { return *entity->getArgument(9); }
void IfcUShapeProfileDef::setFlangeSlope(IfcPlaneAngleMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcUShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcUShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcUShapeProfileDef::type() const { return Type::IfcUShapeProfileDef; }
Type::Enum IfcUShapeProfileDef::Class() { return Type::IfcUShapeProfileDef; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcUShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUShapeProfileDef::IfcUShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Depth, IfcPositiveLengthMeasure v5_FlangeWidth, IfcPositiveLengthMeasure v6_WebThickness, IfcPositiveLengthMeasure v7_FlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_FilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v9_EdgeRadius, boost::optional< IfcPlaneAngleMeasure > v10_FlangeSlope) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Depth)); e->setArgument(4,(v5_FlangeWidth)); e->setArgument(5,(v6_WebThickness)); e->setArgument(6,(v7_FlangeThickness)); if (v8_FilletRadius) { e->setArgument(7,(*v8_FilletRadius)); } else { e->setArgument(7); } if (v9_EdgeRadius) { e->setArgument(8,(*v9_EdgeRadius)); } else { e->setArgument(8); } if (v10_FlangeSlope) { e->setArgument(9,(*v10_FlangeSlope)); } else { e->setArgument(9); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUnitAssignment
SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > IfcUnitAssignment::Units() { RETURN_AS_LIST(IfcUtil::IfcAbstractSelect,0) }
void IfcUnitAssignment::setUnits(SHARED_PTR< IfcTemplatedEntityList< IfcUtil::IfcAbstractSelect > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
bool IfcUnitAssignment::is(Type::Enum v) const { return v == Type::IfcUnitAssignment; }
Type::Enum IfcUnitAssignment::type() const { return Type::IfcUnitAssignment; }
Type::Enum IfcUnitAssignment::Class() { return Type::IfcUnitAssignment; }
IfcUnitAssignment::IfcUnitAssignment(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcUnitAssignment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitAssignment::IfcUnitAssignment(IfcEntities v1_Units) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Units)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUnitaryControlElement
bool IfcUnitaryControlElement::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElement::PredefinedType() { return IfcUnitaryControlElementTypeEnum::FromString(*entity->getArgument(8)); }
void IfcUnitaryControlElement::setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcUnitaryControlElementTypeEnum::ToString(v)); }
bool IfcUnitaryControlElement::is(Type::Enum v) const { return v == Type::IfcUnitaryControlElement || IfcDistributionControlElement::is(v); }
Type::Enum IfcUnitaryControlElement::type() const { return Type::IfcUnitaryControlElement; }
Type::Enum IfcUnitaryControlElement::Class() { return Type::IfcUnitaryControlElement; }
IfcUnitaryControlElement::IfcUnitaryControlElement(IfcAbstractEntityPtr e) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcUnitaryControlElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitaryControlElement::IfcUnitaryControlElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum > v9_PredefinedType) : IfcDistributionControlElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcUnitaryControlElementTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUnitaryControlElementType
IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum IfcUnitaryControlElementType::PredefinedType() { return IfcUnitaryControlElementTypeEnum::FromString(*entity->getArgument(9)); }
void IfcUnitaryControlElementType::setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcUnitaryControlElementTypeEnum::ToString(v)); }
bool IfcUnitaryControlElementType::is(Type::Enum v) const { return v == Type::IfcUnitaryControlElementType || IfcDistributionControlElementType::is(v); }
Type::Enum IfcUnitaryControlElementType::type() const { return Type::IfcUnitaryControlElementType; }
Type::Enum IfcUnitaryControlElementType::Class() { return Type::IfcUnitaryControlElementType; }
IfcUnitaryControlElementType::IfcUnitaryControlElementType(IfcAbstractEntityPtr e) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcUnitaryControlElementType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitaryControlElementType::IfcUnitaryControlElementType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v10_PredefinedType) : IfcDistributionControlElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcUnitaryControlElementTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUnitaryEquipment
bool IfcUnitaryEquipment::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipment::PredefinedType() { return IfcUnitaryEquipmentTypeEnum::FromString(*entity->getArgument(8)); }
void IfcUnitaryEquipment::setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcUnitaryEquipmentTypeEnum::ToString(v)); }
bool IfcUnitaryEquipment::is(Type::Enum v) const { return v == Type::IfcUnitaryEquipment || IfcEnergyConversionDevice::is(v); }
Type::Enum IfcUnitaryEquipment::type() const { return Type::IfcUnitaryEquipment; }
Type::Enum IfcUnitaryEquipment::Class() { return Type::IfcUnitaryEquipment; }
IfcUnitaryEquipment::IfcUnitaryEquipment(IfcAbstractEntityPtr e) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcUnitaryEquipment)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitaryEquipment::IfcUnitaryEquipment(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum > v9_PredefinedType) : IfcEnergyConversionDevice((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcUnitaryEquipmentTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcUnitaryEquipmentType
IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum IfcUnitaryEquipmentType::PredefinedType() { return IfcUnitaryEquipmentTypeEnum::FromString(*entity->getArgument(9)); }
void IfcUnitaryEquipmentType::setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcUnitaryEquipmentTypeEnum::ToString(v)); }
bool IfcUnitaryEquipmentType::is(Type::Enum v) const { return v == Type::IfcUnitaryEquipmentType || IfcEnergyConversionDeviceType::is(v); }
Type::Enum IfcUnitaryEquipmentType::type() const { return Type::IfcUnitaryEquipmentType; }
Type::Enum IfcUnitaryEquipmentType::Class() { return Type::IfcUnitaryEquipmentType; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(IfcAbstractEntityPtr e) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcUnitaryEquipmentType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcUnitaryEquipmentType::IfcUnitaryEquipmentType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v10_PredefinedType) : IfcEnergyConversionDeviceType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcUnitaryEquipmentTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcValve
bool IfcValve::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcValveTypeEnum::IfcValveTypeEnum IfcValve::PredefinedType() { return IfcValveTypeEnum::FromString(*entity->getArgument(8)); }
void IfcValve::setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcValveTypeEnum::ToString(v)); }
bool IfcValve::is(Type::Enum v) const { return v == Type::IfcValve || IfcFlowController::is(v); }
Type::Enum IfcValve::type() const { return Type::IfcValve; }
Type::Enum IfcValve::Class() { return Type::IfcValve; }
IfcValve::IfcValve(IfcAbstractEntityPtr e) : IfcFlowController((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcValve)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcValve::IfcValve(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcValveTypeEnum::IfcValveTypeEnum > v9_PredefinedType) : IfcFlowController((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcValveTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcValveType
IfcValveTypeEnum::IfcValveTypeEnum IfcValveType::PredefinedType() { return IfcValveTypeEnum::FromString(*entity->getArgument(9)); }
void IfcValveType::setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcValveTypeEnum::ToString(v)); }
bool IfcValveType::is(Type::Enum v) const { return v == Type::IfcValveType || IfcFlowControllerType::is(v); }
Type::Enum IfcValveType::type() const { return Type::IfcValveType; }
Type::Enum IfcValveType::Class() { return Type::IfcValveType; }
IfcValveType::IfcValveType(IfcAbstractEntityPtr e) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcValveType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcValveType::IfcValveType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcValveTypeEnum::IfcValveTypeEnum v10_PredefinedType) : IfcFlowControllerType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcValveTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVector
IfcDirection* IfcVector::Orientation() { return (IfcDirection*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcVector::setOrientation(IfcDirection* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
IfcLengthMeasure IfcVector::Magnitude() { return *entity->getArgument(1); }
void IfcVector::setMagnitude(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcVector::is(Type::Enum v) const { return v == Type::IfcVector || IfcGeometricRepresentationItem::is(v); }
Type::Enum IfcVector::type() const { return Type::IfcVector; }
Type::Enum IfcVector::Class() { return Type::IfcVector; }
IfcVector::IfcVector(IfcAbstractEntityPtr e) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVector)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVector::IfcVector(IfcDirection* v1_Orientation, IfcLengthMeasure v2_Magnitude) : IfcGeometricRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_Orientation)); e->setArgument(1,(v2_Magnitude)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVertex
bool IfcVertex::is(Type::Enum v) const { return v == Type::IfcVertex || IfcTopologicalRepresentationItem::is(v); }
Type::Enum IfcVertex::type() const { return Type::IfcVertex; }
Type::Enum IfcVertex::Class() { return Type::IfcVertex; }
IfcVertex::IfcVertex(IfcAbstractEntityPtr e) : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVertex)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertex::IfcVertex() : IfcTopologicalRepresentationItem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVertexLoop
IfcVertex* IfcVertexLoop::LoopVertex() { return (IfcVertex*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcVertexLoop::setLoopVertex(IfcVertex* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcVertexLoop::is(Type::Enum v) const { return v == Type::IfcVertexLoop || IfcLoop::is(v); }
Type::Enum IfcVertexLoop::type() const { return Type::IfcVertexLoop; }
Type::Enum IfcVertexLoop::Class() { return Type::IfcVertexLoop; }
IfcVertexLoop::IfcVertexLoop(IfcAbstractEntityPtr e) : IfcLoop((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVertexLoop)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertexLoop::IfcVertexLoop(IfcVertex* v1_LoopVertex) : IfcLoop((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_LoopVertex)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVertexPoint
IfcPoint* IfcVertexPoint::VertexGeometry() { return (IfcPoint*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(0))); }
void IfcVertexPoint::setVertexGeometry(IfcPoint* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v); }
bool IfcVertexPoint::is(Type::Enum v) const { return v == Type::IfcVertexPoint || IfcVertex::is(v); }
Type::Enum IfcVertexPoint::type() const { return Type::IfcVertexPoint; }
Type::Enum IfcVertexPoint::Class() { return Type::IfcVertexPoint; }
IfcVertexPoint::IfcVertexPoint(IfcAbstractEntityPtr e) : IfcVertex((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVertexPoint)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVertexPoint::IfcVertexPoint(IfcPoint* v1_VertexGeometry) : IfcVertex((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_VertexGeometry)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVibrationIsolator
bool IfcVibrationIsolator::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolator::PredefinedType() { return IfcVibrationIsolatorTypeEnum::FromString(*entity->getArgument(8)); }
void IfcVibrationIsolator::setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcVibrationIsolatorTypeEnum::ToString(v)); }
bool IfcVibrationIsolator::is(Type::Enum v) const { return v == Type::IfcVibrationIsolator || IfcElementComponent::is(v); }
Type::Enum IfcVibrationIsolator::type() const { return Type::IfcVibrationIsolator; }
Type::Enum IfcVibrationIsolator::Class() { return Type::IfcVibrationIsolator; }
IfcVibrationIsolator::IfcVibrationIsolator(IfcAbstractEntityPtr e) : IfcElementComponent((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVibrationIsolator)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVibrationIsolator::IfcVibrationIsolator(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum > v9_PredefinedType) : IfcElementComponent((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcVibrationIsolatorTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVibrationIsolatorType
IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum IfcVibrationIsolatorType::PredefinedType() { return IfcVibrationIsolatorTypeEnum::FromString(*entity->getArgument(9)); }
void IfcVibrationIsolatorType::setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcVibrationIsolatorTypeEnum::ToString(v)); }
bool IfcVibrationIsolatorType::is(Type::Enum v) const { return v == Type::IfcVibrationIsolatorType || IfcElementComponentType::is(v); }
Type::Enum IfcVibrationIsolatorType::type() const { return Type::IfcVibrationIsolatorType; }
Type::Enum IfcVibrationIsolatorType::Class() { return Type::IfcVibrationIsolatorType; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(IfcAbstractEntityPtr e) : IfcElementComponentType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVibrationIsolatorType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVibrationIsolatorType::IfcVibrationIsolatorType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v10_PredefinedType) : IfcElementComponentType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcVibrationIsolatorTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVirtualElement
bool IfcVirtualElement::is(Type::Enum v) const { return v == Type::IfcVirtualElement || IfcElement::is(v); }
Type::Enum IfcVirtualElement::type() const { return Type::IfcVirtualElement; }
Type::Enum IfcVirtualElement::Class() { return Type::IfcVirtualElement; }
IfcVirtualElement::IfcVirtualElement(IfcAbstractEntityPtr e) : IfcElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVirtualElement)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVirtualElement::IfcVirtualElement(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag) : IfcElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVirtualGridIntersection
SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > IfcVirtualGridIntersection::IntersectingAxes() { RETURN_AS_LIST(IfcGridAxis,0) }
void IfcVirtualGridIntersection::setIntersectingAxes(SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(0,v->generalize()); }
std::vector< IfcLengthMeasure > /*[2:3]*/ IfcVirtualGridIntersection::OffsetDistances() { return *entity->getArgument(1); }
void IfcVirtualGridIntersection::setOffsetDistances(std::vector< IfcLengthMeasure > /*[2:3]*/ v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(1,v); }
bool IfcVirtualGridIntersection::is(Type::Enum v) const { return v == Type::IfcVirtualGridIntersection; }
Type::Enum IfcVirtualGridIntersection::type() const { return Type::IfcVirtualGridIntersection; }
Type::Enum IfcVirtualGridIntersection::Class() { return Type::IfcVirtualGridIntersection; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(IfcAbstractEntityPtr e) : IfcUtil::IfcBaseEntity() { if (!e) return; if (!e->is(Type::IfcVirtualGridIntersection)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVirtualGridIntersection::IfcVirtualGridIntersection(SHARED_PTR< IfcTemplatedEntityList< IfcGridAxis > > v1_IntersectingAxes, std::vector< IfcLengthMeasure > /*[2:3]*/ v2_OffsetDistances) : IfcUtil::IfcBaseEntity() { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_IntersectingAxes)->generalize()); e->setArgument(1,(v2_OffsetDistances)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcVoidingFeature
bool IfcVoidingFeature::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum IfcVoidingFeature::PredefinedType() { return IfcVoidingFeatureTypeEnum::FromString(*entity->getArgument(8)); }
void IfcVoidingFeature::setPredefinedType(IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcVoidingFeatureTypeEnum::ToString(v)); }
bool IfcVoidingFeature::is(Type::Enum v) const { return v == Type::IfcVoidingFeature || IfcFeatureElementSubtraction::is(v); }
Type::Enum IfcVoidingFeature::type() const { return Type::IfcVoidingFeature; }
Type::Enum IfcVoidingFeature::Class() { return Type::IfcVoidingFeature; }
IfcVoidingFeature::IfcVoidingFeature(IfcAbstractEntityPtr e) : IfcFeatureElementSubtraction((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcVoidingFeature)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcVoidingFeature::IfcVoidingFeature(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum > v9_PredefinedType) : IfcFeatureElementSubtraction((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcVoidingFeatureTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWall
bool IfcWall::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcWallTypeEnum::IfcWallTypeEnum IfcWall::PredefinedType() { return IfcWallTypeEnum::FromString(*entity->getArgument(8)); }
void IfcWall::setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcWallTypeEnum::ToString(v)); }
bool IfcWall::is(Type::Enum v) const { return v == Type::IfcWall || IfcBuildingElement::is(v); }
Type::Enum IfcWall::type() const { return Type::IfcWall; }
Type::Enum IfcWall::Class() { return Type::IfcWall; }
IfcWall::IfcWall(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWall)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWall::IfcWall(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWallElementedCase
bool IfcWallElementedCase::is(Type::Enum v) const { return v == Type::IfcWallElementedCase || IfcWall::is(v); }
Type::Enum IfcWallElementedCase::type() const { return Type::IfcWallElementedCase; }
Type::Enum IfcWallElementedCase::Class() { return Type::IfcWallElementedCase; }
IfcWallElementedCase::IfcWallElementedCase(IfcAbstractEntityPtr e) : IfcWall((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWallElementedCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWallElementedCase::IfcWallElementedCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcWall((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWallStandardCase
bool IfcWallStandardCase::is(Type::Enum v) const { return v == Type::IfcWallStandardCase || IfcWall::is(v); }
Type::Enum IfcWallStandardCase::type() const { return Type::IfcWallStandardCase; }
Type::Enum IfcWallStandardCase::Class() { return Type::IfcWallStandardCase; }
IfcWallStandardCase::IfcWallStandardCase(IfcAbstractEntityPtr e) : IfcWall((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWallStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWallStandardCase::IfcWallStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType) : IfcWall((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcWallTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWallType
IfcWallTypeEnum::IfcWallTypeEnum IfcWallType::PredefinedType() { return IfcWallTypeEnum::FromString(*entity->getArgument(9)); }
void IfcWallType::setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcWallTypeEnum::ToString(v)); }
bool IfcWallType::is(Type::Enum v) const { return v == Type::IfcWallType || IfcBuildingElementType::is(v); }
Type::Enum IfcWallType::type() const { return Type::IfcWallType; }
Type::Enum IfcWallType::Class() { return Type::IfcWallType; }
IfcWallType::IfcWallType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWallType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWallType::IfcWallType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcWallTypeEnum::IfcWallTypeEnum v10_PredefinedType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcWallTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWasteTerminal
bool IfcWasteTerminal::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminal::PredefinedType() { return IfcWasteTerminalTypeEnum::FromString(*entity->getArgument(8)); }
void IfcWasteTerminal::setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcWasteTerminalTypeEnum::ToString(v)); }
bool IfcWasteTerminal::is(Type::Enum v) const { return v == Type::IfcWasteTerminal || IfcFlowTerminal::is(v); }
Type::Enum IfcWasteTerminal::type() const { return Type::IfcWasteTerminal; }
Type::Enum IfcWasteTerminal::Class() { return Type::IfcWasteTerminal; }
IfcWasteTerminal::IfcWasteTerminal(IfcAbstractEntityPtr e) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWasteTerminal)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWasteTerminal::IfcWasteTerminal(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum > v9_PredefinedType) : IfcFlowTerminal((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcWasteTerminalTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWasteTerminalType
IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum IfcWasteTerminalType::PredefinedType() { return IfcWasteTerminalTypeEnum::FromString(*entity->getArgument(9)); }
void IfcWasteTerminalType::setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcWasteTerminalTypeEnum::ToString(v)); }
bool IfcWasteTerminalType::is(Type::Enum v) const { return v == Type::IfcWasteTerminalType || IfcFlowTerminalType::is(v); }
Type::Enum IfcWasteTerminalType::type() const { return Type::IfcWasteTerminalType; }
Type::Enum IfcWasteTerminalType::Class() { return Type::IfcWasteTerminalType; }
IfcWasteTerminalType::IfcWasteTerminalType(IfcAbstractEntityPtr e) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWasteTerminalType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWasteTerminalType::IfcWasteTerminalType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v10_PredefinedType) : IfcFlowTerminalType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcWasteTerminalTypeEnum::ToString(v10_PredefinedType)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindow
bool IfcWindow::hasOverallHeight() { return !entity->getArgument(8)->isNull(); }
IfcPositiveLengthMeasure IfcWindow::OverallHeight() { return *entity->getArgument(8); }
void IfcWindow::setOverallHeight(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcWindow::hasOverallWidth() { return !entity->getArgument(9)->isNull(); }
IfcPositiveLengthMeasure IfcWindow::OverallWidth() { return *entity->getArgument(9); }
void IfcWindow::setOverallWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcWindow::hasPredefinedType() { return !entity->getArgument(10)->isNull(); }
IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindow::PredefinedType() { return IfcWindowTypeEnum::FromString(*entity->getArgument(10)); }
void IfcWindow::setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcWindowTypeEnum::ToString(v)); }
bool IfcWindow::hasPartitioningType() { return !entity->getArgument(11)->isNull(); }
IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindow::PartitioningType() { return IfcWindowTypePartitioningEnum::FromString(*entity->getArgument(11)); }
void IfcWindow::setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v,IfcWindowTypePartitioningEnum::ToString(v)); }
bool IfcWindow::hasUserDefinedPartitioningType() { return !entity->getArgument(12)->isNull(); }
IfcLabel IfcWindow::UserDefinedPartitioningType() { return *entity->getArgument(12); }
void IfcWindow::setUserDefinedPartitioningType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcWindow::is(Type::Enum v) const { return v == Type::IfcWindow || IfcBuildingElement::is(v); }
Type::Enum IfcWindow::type() const { return Type::IfcWindow; }
Type::Enum IfcWindow::Class() { return Type::IfcWindow; }
IfcWindow::IfcWindow(IfcAbstractEntityPtr e) : IfcBuildingElement((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindow)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindow::IfcWindow(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPositiveLengthMeasure > v9_OverallHeight, boost::optional< IfcPositiveLengthMeasure > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< IfcLabel > v13_UserDefinedPartitioningType) : IfcBuildingElement((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_OverallHeight) { e->setArgument(8,(*v9_OverallHeight)); } else { e->setArgument(8); } if (v10_OverallWidth) { e->setArgument(9,(*v10_OverallWidth)); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcWindowTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } if (v12_PartitioningType) { e->setArgument(11,*v12_PartitioningType,IfcWindowTypePartitioningEnum::ToString(*v12_PartitioningType)); } else { e->setArgument(11); } if (v13_UserDefinedPartitioningType) { e->setArgument(12,(*v13_UserDefinedPartitioningType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindowLiningProperties
bool IfcWindowLiningProperties::hasLiningDepth() { return !entity->getArgument(4)->isNull(); }
IfcPositiveLengthMeasure IfcWindowLiningProperties::LiningDepth() { return *entity->getArgument(4); }
void IfcWindowLiningProperties::setLiningDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcWindowLiningProperties::hasLiningThickness() { return !entity->getArgument(5)->isNull(); }
IfcNonNegativeLengthMeasure IfcWindowLiningProperties::LiningThickness() { return *entity->getArgument(5); }
void IfcWindowLiningProperties::setLiningThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcWindowLiningProperties::hasTransomThickness() { return !entity->getArgument(6)->isNull(); }
IfcNonNegativeLengthMeasure IfcWindowLiningProperties::TransomThickness() { return *entity->getArgument(6); }
void IfcWindowLiningProperties::setTransomThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcWindowLiningProperties::hasMullionThickness() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcWindowLiningProperties::MullionThickness() { return *entity->getArgument(7); }
void IfcWindowLiningProperties::setMullionThickness(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcWindowLiningProperties::hasFirstTransomOffset() { return !entity->getArgument(8)->isNull(); }
IfcNormalisedRatioMeasure IfcWindowLiningProperties::FirstTransomOffset() { return *entity->getArgument(8); }
void IfcWindowLiningProperties::setFirstTransomOffset(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcWindowLiningProperties::hasSecondTransomOffset() { return !entity->getArgument(9)->isNull(); }
IfcNormalisedRatioMeasure IfcWindowLiningProperties::SecondTransomOffset() { return *entity->getArgument(9); }
void IfcWindowLiningProperties::setSecondTransomOffset(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcWindowLiningProperties::hasFirstMullionOffset() { return !entity->getArgument(10)->isNull(); }
IfcNormalisedRatioMeasure IfcWindowLiningProperties::FirstMullionOffset() { return *entity->getArgument(10); }
void IfcWindowLiningProperties::setFirstMullionOffset(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcWindowLiningProperties::hasSecondMullionOffset() { return !entity->getArgument(11)->isNull(); }
IfcNormalisedRatioMeasure IfcWindowLiningProperties::SecondMullionOffset() { return *entity->getArgument(11); }
void IfcWindowLiningProperties::setSecondMullionOffset(IfcNormalisedRatioMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcWindowLiningProperties::hasShapeAspectStyle() { return !entity->getArgument(12)->isNull(); }
IfcShapeAspect* IfcWindowLiningProperties::ShapeAspectStyle() { return (IfcShapeAspect*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(12))); }
void IfcWindowLiningProperties::setShapeAspectStyle(IfcShapeAspect* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcWindowLiningProperties::hasLiningOffset() { return !entity->getArgument(13)->isNull(); }
IfcLengthMeasure IfcWindowLiningProperties::LiningOffset() { return *entity->getArgument(13); }
void IfcWindowLiningProperties::setLiningOffset(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v); }
bool IfcWindowLiningProperties::hasLiningToPanelOffsetX() { return !entity->getArgument(14)->isNull(); }
IfcLengthMeasure IfcWindowLiningProperties::LiningToPanelOffsetX() { return *entity->getArgument(14); }
void IfcWindowLiningProperties::setLiningToPanelOffsetX(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(14,v); }
bool IfcWindowLiningProperties::hasLiningToPanelOffsetY() { return !entity->getArgument(15)->isNull(); }
IfcLengthMeasure IfcWindowLiningProperties::LiningToPanelOffsetY() { return *entity->getArgument(15); }
void IfcWindowLiningProperties::setLiningToPanelOffsetY(IfcLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(15,v); }
bool IfcWindowLiningProperties::is(Type::Enum v) const { return v == Type::IfcWindowLiningProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcWindowLiningProperties::type() const { return Type::IfcWindowLiningProperties; }
Type::Enum IfcWindowLiningProperties::Class() { return Type::IfcWindowLiningProperties; }
IfcWindowLiningProperties::IfcWindowLiningProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindowLiningProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowLiningProperties::IfcWindowLiningProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcPositiveLengthMeasure > v5_LiningDepth, boost::optional< IfcNonNegativeLengthMeasure > v6_LiningThickness, boost::optional< IfcNonNegativeLengthMeasure > v7_TransomThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_MullionThickness, boost::optional< IfcNormalisedRatioMeasure > v9_FirstTransomOffset, boost::optional< IfcNormalisedRatioMeasure > v10_SecondTransomOffset, boost::optional< IfcNormalisedRatioMeasure > v11_FirstMullionOffset, boost::optional< IfcNormalisedRatioMeasure > v12_SecondMullionOffset, IfcShapeAspect* v13_ShapeAspectStyle, boost::optional< IfcLengthMeasure > v14_LiningOffset, boost::optional< IfcLengthMeasure > v15_LiningToPanelOffsetX, boost::optional< IfcLengthMeasure > v16_LiningToPanelOffsetY) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_LiningDepth) { e->setArgument(4,(*v5_LiningDepth)); } else { e->setArgument(4); } if (v6_LiningThickness) { e->setArgument(5,(*v6_LiningThickness)); } else { e->setArgument(5); } if (v7_TransomThickness) { e->setArgument(6,(*v7_TransomThickness)); } else { e->setArgument(6); } if (v8_MullionThickness) { e->setArgument(7,(*v8_MullionThickness)); } else { e->setArgument(7); } if (v9_FirstTransomOffset) { e->setArgument(8,(*v9_FirstTransomOffset)); } else { e->setArgument(8); } if (v10_SecondTransomOffset) { e->setArgument(9,(*v10_SecondTransomOffset)); } else { e->setArgument(9); } if (v11_FirstMullionOffset) { e->setArgument(10,(*v11_FirstMullionOffset)); } else { e->setArgument(10); } if (v12_SecondMullionOffset) { e->setArgument(11,(*v12_SecondMullionOffset)); } else { e->setArgument(11); } e->setArgument(12,(v13_ShapeAspectStyle)); if (v14_LiningOffset) { e->setArgument(13,(*v14_LiningOffset)); } else { e->setArgument(13); } if (v15_LiningToPanelOffsetX) { e->setArgument(14,(*v15_LiningToPanelOffsetX)); } else { e->setArgument(14); } if (v16_LiningToPanelOffsetY) { e->setArgument(15,(*v16_LiningToPanelOffsetY)); } else { e->setArgument(15); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindowPanelProperties
IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum IfcWindowPanelProperties::OperationType() { return IfcWindowPanelOperationEnum::FromString(*entity->getArgument(4)); }
void IfcWindowPanelProperties::setOperationType(IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v,IfcWindowPanelOperationEnum::ToString(v)); }
IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum IfcWindowPanelProperties::PanelPosition() { return IfcWindowPanelPositionEnum::FromString(*entity->getArgument(5)); }
void IfcWindowPanelProperties::setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v,IfcWindowPanelPositionEnum::ToString(v)); }
bool IfcWindowPanelProperties::hasFrameDepth() { return !entity->getArgument(6)->isNull(); }
IfcPositiveLengthMeasure IfcWindowPanelProperties::FrameDepth() { return *entity->getArgument(6); }
void IfcWindowPanelProperties::setFrameDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcWindowPanelProperties::hasFrameThickness() { return !entity->getArgument(7)->isNull(); }
IfcPositiveLengthMeasure IfcWindowPanelProperties::FrameThickness() { return *entity->getArgument(7); }
void IfcWindowPanelProperties::setFrameThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcWindowPanelProperties::hasShapeAspectStyle() { return !entity->getArgument(8)->isNull(); }
IfcShapeAspect* IfcWindowPanelProperties::ShapeAspectStyle() { return (IfcShapeAspect*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(8))); }
void IfcWindowPanelProperties::setShapeAspectStyle(IfcShapeAspect* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcWindowPanelProperties::is(Type::Enum v) const { return v == Type::IfcWindowPanelProperties || IfcPreDefinedPropertySet::is(v); }
Type::Enum IfcWindowPanelProperties::type() const { return Type::IfcWindowPanelProperties; }
Type::Enum IfcWindowPanelProperties::Class() { return Type::IfcWindowPanelProperties; }
IfcWindowPanelProperties::IfcWindowPanelProperties(IfcAbstractEntityPtr e) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindowPanelProperties)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowPanelProperties::IfcWindowPanelProperties(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< IfcPositiveLengthMeasure > v7_FrameDepth, boost::optional< IfcPositiveLengthMeasure > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle) : IfcPreDefinedPropertySet((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } e->setArgument(4,v5_OperationType,IfcWindowPanelOperationEnum::ToString(v5_OperationType)); e->setArgument(5,v6_PanelPosition,IfcWindowPanelPositionEnum::ToString(v6_PanelPosition)); if (v7_FrameDepth) { e->setArgument(6,(*v7_FrameDepth)); } else { e->setArgument(6); } if (v8_FrameThickness) { e->setArgument(7,(*v8_FrameThickness)); } else { e->setArgument(7); } e->setArgument(8,(v9_ShapeAspectStyle)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindowStandardCase
bool IfcWindowStandardCase::is(Type::Enum v) const { return v == Type::IfcWindowStandardCase || IfcWindow::is(v); }
Type::Enum IfcWindowStandardCase::type() const { return Type::IfcWindowStandardCase; }
Type::Enum IfcWindowStandardCase::Class() { return Type::IfcWindowStandardCase; }
IfcWindowStandardCase::IfcWindowStandardCase(IfcAbstractEntityPtr e) : IfcWindow((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindowStandardCase)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowStandardCase::IfcWindowStandardCase(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcIdentifier > v8_Tag, boost::optional< IfcPositiveLengthMeasure > v9_OverallHeight, boost::optional< IfcPositiveLengthMeasure > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< IfcLabel > v13_UserDefinedPartitioningType) : IfcWindow((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } e->setArgument(5,(v6_ObjectPlacement)); e->setArgument(6,(v7_Representation)); if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_OverallHeight) { e->setArgument(8,(*v9_OverallHeight)); } else { e->setArgument(8); } if (v10_OverallWidth) { e->setArgument(9,(*v10_OverallWidth)); } else { e->setArgument(9); } if (v11_PredefinedType) { e->setArgument(10,*v11_PredefinedType,IfcWindowTypeEnum::ToString(*v11_PredefinedType)); } else { e->setArgument(10); } if (v12_PartitioningType) { e->setArgument(11,*v12_PartitioningType,IfcWindowTypePartitioningEnum::ToString(*v12_PartitioningType)); } else { e->setArgument(11); } if (v13_UserDefinedPartitioningType) { e->setArgument(12,(*v13_UserDefinedPartitioningType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindowStyle
IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum IfcWindowStyle::ConstructionType() { return IfcWindowStyleConstructionEnum::FromString(*entity->getArgument(8)); }
void IfcWindowStyle::setConstructionType(IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcWindowStyleConstructionEnum::ToString(v)); }
IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum IfcWindowStyle::OperationType() { return IfcWindowStyleOperationEnum::FromString(*entity->getArgument(9)); }
void IfcWindowStyle::setOperationType(IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcWindowStyleOperationEnum::ToString(v)); }
bool IfcWindowStyle::ParameterTakesPrecedence() { return *entity->getArgument(10); }
void IfcWindowStyle::setParameterTakesPrecedence(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
bool IfcWindowStyle::Sizeable() { return *entity->getArgument(11); }
void IfcWindowStyle::setSizeable(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcWindowStyle::is(Type::Enum v) const { return v == Type::IfcWindowStyle || IfcTypeProduct::is(v); }
Type::Enum IfcWindowStyle::type() const { return Type::IfcWindowStyle; }
Type::Enum IfcWindowStyle::Class() { return Type::IfcWindowStyle; }
IfcWindowStyle::IfcWindowStyle(IfcAbstractEntityPtr e) : IfcTypeProduct((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindowStyle)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowStyle::IfcWindowStyle(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v9_ConstructionType, IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable) : IfcTypeProduct((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } e->setArgument(8,v9_ConstructionType,IfcWindowStyleConstructionEnum::ToString(v9_ConstructionType)); e->setArgument(9,v10_OperationType,IfcWindowStyleOperationEnum::ToString(v10_OperationType)); e->setArgument(10,(v11_ParameterTakesPrecedence)); e->setArgument(11,(v12_Sizeable)); entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWindowType
IfcWindowTypeEnum::IfcWindowTypeEnum IfcWindowType::PredefinedType() { return IfcWindowTypeEnum::FromString(*entity->getArgument(9)); }
void IfcWindowType::setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v,IfcWindowTypeEnum::ToString(v)); }
IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum IfcWindowType::PartitioningType() { return IfcWindowTypePartitioningEnum::FromString(*entity->getArgument(10)); }
void IfcWindowType::setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v,IfcWindowTypePartitioningEnum::ToString(v)); }
bool IfcWindowType::hasParameterTakesPrecedence() { return !entity->getArgument(11)->isNull(); }
bool IfcWindowType::ParameterTakesPrecedence() { return *entity->getArgument(11); }
void IfcWindowType::setParameterTakesPrecedence(bool v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcWindowType::hasUserDefinedPartitioningType() { return !entity->getArgument(12)->isNull(); }
IfcLabel IfcWindowType::UserDefinedPartitioningType() { return *entity->getArgument(12); }
void IfcWindowType::setUserDefinedPartitioningType(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcWindowType::is(Type::Enum v) const { return v == Type::IfcWindowType || IfcBuildingElementType::is(v); }
Type::Enum IfcWindowType::type() const { return Type::IfcWindowType; }
Type::Enum IfcWindowType::Class() { return Type::IfcWindowType; }
IfcWindowType::IfcWindowType(IfcAbstractEntityPtr e) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWindowType)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWindowType::IfcWindowType(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcIdentifier > v5_ApplicableOccurrence, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPropertySetDefinition > > > v6_HasPropertySets, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcRepresentationMap > > > v7_RepresentationMaps, boost::optional< IfcLabel > v8_Tag, boost::optional< IfcLabel > v9_ElementType, IfcWindowTypeEnum::IfcWindowTypeEnum v10_PredefinedType, IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v11_PartitioningType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< IfcLabel > v13_UserDefinedPartitioningType) : IfcBuildingElementType((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ApplicableOccurrence) { e->setArgument(4,(*v5_ApplicableOccurrence)); } else { e->setArgument(4); } if (v6_HasPropertySets) { e->setArgument(5,(*v6_HasPropertySets)->generalize()); } else { e->setArgument(5); } if (v7_RepresentationMaps) { e->setArgument(6,(*v7_RepresentationMaps)->generalize()); } else { e->setArgument(6); } if (v8_Tag) { e->setArgument(7,(*v8_Tag)); } else { e->setArgument(7); } if (v9_ElementType) { e->setArgument(8,(*v9_ElementType)); } else { e->setArgument(8); } e->setArgument(9,v10_PredefinedType,IfcWindowTypeEnum::ToString(v10_PredefinedType)); e->setArgument(10,v11_PartitioningType,IfcWindowTypePartitioningEnum::ToString(v11_PartitioningType)); if (v12_ParameterTakesPrecedence) { e->setArgument(11,(*v12_ParameterTakesPrecedence)); } else { e->setArgument(11); } if (v13_UserDefinedPartitioningType) { e->setArgument(12,(*v13_UserDefinedPartitioningType)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWorkCalendar
bool IfcWorkCalendar::hasWorkingTimes() { return !entity->getArgument(6)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > IfcWorkCalendar::WorkingTimes() { RETURN_AS_LIST(IfcWorkTime,6) }
void IfcWorkCalendar::setWorkingTimes(SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v->generalize()); }
bool IfcWorkCalendar::hasExceptionTimes() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > IfcWorkCalendar::ExceptionTimes() { RETURN_AS_LIST(IfcWorkTime,7) }
void IfcWorkCalendar::setExceptionTimes(SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcWorkCalendar::hasPredefinedType() { return !entity->getArgument(8)->isNull(); }
IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum IfcWorkCalendar::PredefinedType() { return IfcWorkCalendarTypeEnum::FromString(*entity->getArgument(8)); }
void IfcWorkCalendar::setPredefinedType(IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v,IfcWorkCalendarTypeEnum::ToString(v)); }
bool IfcWorkCalendar::is(Type::Enum v) const { return v == Type::IfcWorkCalendar || IfcControl::is(v); }
Type::Enum IfcWorkCalendar::type() const { return Type::IfcWorkCalendar; }
Type::Enum IfcWorkCalendar::Class() { return Type::IfcWorkCalendar; }
IfcWorkCalendar::IfcWorkCalendar(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWorkCalendar)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkCalendar::IfcWorkCalendar(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > > v7_WorkingTimes, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcWorkTime > > > v8_ExceptionTimes, boost::optional< IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum > v9_PredefinedType) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } if (v7_WorkingTimes) { e->setArgument(6,(*v7_WorkingTimes)->generalize()); } else { e->setArgument(6); } if (v8_ExceptionTimes) { e->setArgument(7,(*v8_ExceptionTimes)->generalize()); } else { e->setArgument(7); } if (v9_PredefinedType) { e->setArgument(8,*v9_PredefinedType,IfcWorkCalendarTypeEnum::ToString(*v9_PredefinedType)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWorkControl
IfcDateTime IfcWorkControl::CreationDate() { return *entity->getArgument(6); }
void IfcWorkControl::setCreationDate(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcWorkControl::hasCreators() { return !entity->getArgument(7)->isNull(); }
SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > IfcWorkControl::Creators() { RETURN_AS_LIST(IfcPerson,7) }
void IfcWorkControl::setCreators(SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v->generalize()); }
bool IfcWorkControl::hasPurpose() { return !entity->getArgument(8)->isNull(); }
IfcLabel IfcWorkControl::Purpose() { return *entity->getArgument(8); }
void IfcWorkControl::setPurpose(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcWorkControl::hasDuration() { return !entity->getArgument(9)->isNull(); }
IfcDuration IfcWorkControl::Duration() { return *entity->getArgument(9); }
void IfcWorkControl::setDuration(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(9,v); }
bool IfcWorkControl::hasTotalFloat() { return !entity->getArgument(10)->isNull(); }
IfcDuration IfcWorkControl::TotalFloat() { return *entity->getArgument(10); }
void IfcWorkControl::setTotalFloat(IfcDuration v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(10,v); }
IfcDateTime IfcWorkControl::StartTime() { return *entity->getArgument(11); }
void IfcWorkControl::setStartTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(11,v); }
bool IfcWorkControl::hasFinishTime() { return !entity->getArgument(12)->isNull(); }
IfcDateTime IfcWorkControl::FinishTime() { return *entity->getArgument(12); }
void IfcWorkControl::setFinishTime(IfcDateTime v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(12,v); }
bool IfcWorkControl::is(Type::Enum v) const { return v == Type::IfcWorkControl || IfcControl::is(v); }
Type::Enum IfcWorkControl::type() const { return Type::IfcWorkControl; }
Type::Enum IfcWorkControl::Class() { return Type::IfcWorkControl; }
IfcWorkControl::IfcWorkControl(IfcAbstractEntityPtr e) : IfcControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWorkControl)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkControl::IfcWorkControl(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, IfcDateTime v7_CreationDate, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > > v8_Creators, boost::optional< IfcLabel > v9_Purpose, boost::optional< IfcDuration > v10_Duration, boost::optional< IfcDuration > v11_TotalFloat, IfcDateTime v12_StartTime, boost::optional< IfcDateTime > v13_FinishTime) : IfcControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } e->setArgument(6,(v7_CreationDate)); if (v8_Creators) { e->setArgument(7,(*v8_Creators)->generalize()); } else { e->setArgument(7); } if (v9_Purpose) { e->setArgument(8,(*v9_Purpose)); } else { e->setArgument(8); } if (v10_Duration) { e->setArgument(9,(*v10_Duration)); } else { e->setArgument(9); } if (v11_TotalFloat) { e->setArgument(10,(*v11_TotalFloat)); } else { e->setArgument(10); } e->setArgument(11,(v12_StartTime)); if (v13_FinishTime) { e->setArgument(12,(*v13_FinishTime)); } else { e->setArgument(12); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWorkPlan
bool IfcWorkPlan::hasPredefinedType() { return !entity->getArgument(13)->isNull(); }
IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum IfcWorkPlan::PredefinedType() { return IfcWorkPlanTypeEnum::FromString(*entity->getArgument(13)); }
void IfcWorkPlan::setPredefinedType(IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v,IfcWorkPlanTypeEnum::ToString(v)); }
bool IfcWorkPlan::is(Type::Enum v) const { return v == Type::IfcWorkPlan || IfcWorkControl::is(v); }
Type::Enum IfcWorkPlan::type() const { return Type::IfcWorkPlan; }
Type::Enum IfcWorkPlan::Class() { return Type::IfcWorkPlan; }
IfcWorkPlan::IfcWorkPlan(IfcAbstractEntityPtr e) : IfcWorkControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWorkPlan)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkPlan::IfcWorkPlan(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, IfcDateTime v7_CreationDate, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > > v8_Creators, boost::optional< IfcLabel > v9_Purpose, boost::optional< IfcDuration > v10_Duration, boost::optional< IfcDuration > v11_TotalFloat, IfcDateTime v12_StartTime, boost::optional< IfcDateTime > v13_FinishTime, boost::optional< IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum > v14_PredefinedType) : IfcWorkControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } e->setArgument(6,(v7_CreationDate)); if (v8_Creators) { e->setArgument(7,(*v8_Creators)->generalize()); } else { e->setArgument(7); } if (v9_Purpose) { e->setArgument(8,(*v9_Purpose)); } else { e->setArgument(8); } if (v10_Duration) { e->setArgument(9,(*v10_Duration)); } else { e->setArgument(9); } if (v11_TotalFloat) { e->setArgument(10,(*v11_TotalFloat)); } else { e->setArgument(10); } e->setArgument(11,(v12_StartTime)); if (v13_FinishTime) { e->setArgument(12,(*v13_FinishTime)); } else { e->setArgument(12); } if (v14_PredefinedType) { e->setArgument(13,*v14_PredefinedType,IfcWorkPlanTypeEnum::ToString(*v14_PredefinedType)); } else { e->setArgument(13); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWorkSchedule
bool IfcWorkSchedule::hasPredefinedType() { return !entity->getArgument(13)->isNull(); }
IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum IfcWorkSchedule::PredefinedType() { return IfcWorkScheduleTypeEnum::FromString(*entity->getArgument(13)); }
void IfcWorkSchedule::setPredefinedType(IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(13,v,IfcWorkScheduleTypeEnum::ToString(v)); }
bool IfcWorkSchedule::is(Type::Enum v) const { return v == Type::IfcWorkSchedule || IfcWorkControl::is(v); }
Type::Enum IfcWorkSchedule::type() const { return Type::IfcWorkSchedule; }
Type::Enum IfcWorkSchedule::Class() { return Type::IfcWorkSchedule; }
IfcWorkSchedule::IfcWorkSchedule(IfcAbstractEntityPtr e) : IfcWorkControl((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWorkSchedule)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkSchedule::IfcWorkSchedule(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcIdentifier > v6_Identification, IfcDateTime v7_CreationDate, boost::optional< SHARED_PTR< IfcTemplatedEntityList< IfcPerson > > > v8_Creators, boost::optional< IfcLabel > v9_Purpose, boost::optional< IfcDuration > v10_Duration, boost::optional< IfcDuration > v11_TotalFloat, IfcDateTime v12_StartTime, boost::optional< IfcDateTime > v13_FinishTime, boost::optional< IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum > v14_PredefinedType) : IfcWorkControl((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_Identification) { e->setArgument(5,(*v6_Identification)); } else { e->setArgument(5); } e->setArgument(6,(v7_CreationDate)); if (v8_Creators) { e->setArgument(7,(*v8_Creators)->generalize()); } else { e->setArgument(7); } if (v9_Purpose) { e->setArgument(8,(*v9_Purpose)); } else { e->setArgument(8); } if (v10_Duration) { e->setArgument(9,(*v10_Duration)); } else { e->setArgument(9); } if (v11_TotalFloat) { e->setArgument(10,(*v11_TotalFloat)); } else { e->setArgument(10); } e->setArgument(11,(v12_StartTime)); if (v13_FinishTime) { e->setArgument(12,(*v13_FinishTime)); } else { e->setArgument(12); } if (v14_PredefinedType) { e->setArgument(13,*v14_PredefinedType,IfcWorkScheduleTypeEnum::ToString(*v14_PredefinedType)); } else { e->setArgument(13); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcWorkTime
bool IfcWorkTime::hasRecurrencePattern() { return !entity->getArgument(3)->isNull(); }
IfcRecurrencePattern* IfcWorkTime::RecurrencePattern() { return (IfcRecurrencePattern*)((IfcUtil::IfcSchemaEntity)(*entity->getArgument(3))); }
void IfcWorkTime::setRecurrencePattern(IfcRecurrencePattern* v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
bool IfcWorkTime::hasStart() { return !entity->getArgument(4)->isNull(); }
IfcDate IfcWorkTime::Start() { return *entity->getArgument(4); }
void IfcWorkTime::setStart(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
bool IfcWorkTime::hasFinish() { return !entity->getArgument(5)->isNull(); }
IfcDate IfcWorkTime::Finish() { return *entity->getArgument(5); }
void IfcWorkTime::setFinish(IfcDate v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcWorkTime::is(Type::Enum v) const { return v == Type::IfcWorkTime || IfcSchedulingTime::is(v); }
Type::Enum IfcWorkTime::type() const { return Type::IfcWorkTime; }
Type::Enum IfcWorkTime::Class() { return Type::IfcWorkTime; }
IfcWorkTime::IfcWorkTime(IfcAbstractEntityPtr e) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcWorkTime)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcWorkTime::IfcWorkTime(boost::optional< IfcLabel > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< IfcLabel > v3_UserDefinedDataOrigin, IfcRecurrencePattern* v4_RecurrencePattern, boost::optional< IfcDate > v5_Start, boost::optional< IfcDate > v6_Finish) : IfcSchedulingTime((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); if (v1_Name) { e->setArgument(0,(*v1_Name)); } else { e->setArgument(0); } if (v2_DataOrigin) { e->setArgument(1,*v2_DataOrigin,IfcDataOriginEnum::ToString(*v2_DataOrigin)); } else { e->setArgument(1); } if (v3_UserDefinedDataOrigin) { e->setArgument(2,(*v3_UserDefinedDataOrigin)); } else { e->setArgument(2); } e->setArgument(3,(v4_RecurrencePattern)); if (v5_Start) { e->setArgument(4,(*v5_Start)); } else { e->setArgument(4); } if (v6_Finish) { e->setArgument(5,(*v6_Finish)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcZShapeProfileDef
IfcPositiveLengthMeasure IfcZShapeProfileDef::Depth() { return *entity->getArgument(3); }
void IfcZShapeProfileDef::setDepth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(3,v); }
IfcPositiveLengthMeasure IfcZShapeProfileDef::FlangeWidth() { return *entity->getArgument(4); }
void IfcZShapeProfileDef::setFlangeWidth(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(4,v); }
IfcPositiveLengthMeasure IfcZShapeProfileDef::WebThickness() { return *entity->getArgument(5); }
void IfcZShapeProfileDef::setWebThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
IfcPositiveLengthMeasure IfcZShapeProfileDef::FlangeThickness() { return *entity->getArgument(6); }
void IfcZShapeProfileDef::setFlangeThickness(IfcPositiveLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(6,v); }
bool IfcZShapeProfileDef::hasFilletRadius() { return !entity->getArgument(7)->isNull(); }
IfcNonNegativeLengthMeasure IfcZShapeProfileDef::FilletRadius() { return *entity->getArgument(7); }
void IfcZShapeProfileDef::setFilletRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(7,v); }
bool IfcZShapeProfileDef::hasEdgeRadius() { return !entity->getArgument(8)->isNull(); }
IfcNonNegativeLengthMeasure IfcZShapeProfileDef::EdgeRadius() { return *entity->getArgument(8); }
void IfcZShapeProfileDef::setEdgeRadius(IfcNonNegativeLengthMeasure v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(8,v); }
bool IfcZShapeProfileDef::is(Type::Enum v) const { return v == Type::IfcZShapeProfileDef || IfcParameterizedProfileDef::is(v); }
Type::Enum IfcZShapeProfileDef::type() const { return Type::IfcZShapeProfileDef; }
Type::Enum IfcZShapeProfileDef::Class() { return Type::IfcZShapeProfileDef; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcAbstractEntityPtr e) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcZShapeProfileDef)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcZShapeProfileDef::IfcZShapeProfileDef(IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< IfcLabel > v2_ProfileName, IfcAxis2Placement2D* v3_Position, IfcPositiveLengthMeasure v4_Depth, IfcPositiveLengthMeasure v5_FlangeWidth, IfcPositiveLengthMeasure v6_WebThickness, IfcPositiveLengthMeasure v7_FlangeThickness, boost::optional< IfcNonNegativeLengthMeasure > v8_FilletRadius, boost::optional< IfcNonNegativeLengthMeasure > v9_EdgeRadius) : IfcParameterizedProfileDef((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,v1_ProfileType,IfcProfileTypeEnum::ToString(v1_ProfileType)); if (v2_ProfileName) { e->setArgument(1,(*v2_ProfileName)); } else { e->setArgument(1); } e->setArgument(2,(v3_Position)); e->setArgument(3,(v4_Depth)); e->setArgument(4,(v5_FlangeWidth)); e->setArgument(5,(v6_WebThickness)); e->setArgument(6,(v7_FlangeThickness)); if (v8_FilletRadius) { e->setArgument(7,(*v8_FilletRadius)); } else { e->setArgument(7); } if (v9_EdgeRadius) { e->setArgument(8,(*v9_EdgeRadius)); } else { e->setArgument(8); } entity = e; EntityBuffer::Add(this); }

// Function implementations for IfcZone
bool IfcZone::hasLongName() { return !entity->getArgument(5)->isNull(); }
IfcLabel IfcZone::LongName() { return *entity->getArgument(5); }
void IfcZone::setLongName(IfcLabel v) { if ( ! entity->isWritable() ) { entity = new IfcWritableEntity(entity); } ((IfcWritableEntity*)entity)->setArgument(5,v); }
bool IfcZone::is(Type::Enum v) const { return v == Type::IfcZone || IfcSystem::is(v); }
Type::Enum IfcZone::type() const { return Type::IfcZone; }
Type::Enum IfcZone::Class() { return Type::IfcZone; }
IfcZone::IfcZone(IfcAbstractEntityPtr e) : IfcSystem((IfcAbstractEntityPtr)0) { if (!e) return; if (!e->is(Type::IfcZone)) throw IfcException("Unable to find find keyword in schema"); entity = e; }
IfcZone::IfcZone(IfcGloballyUniqueId v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< IfcLabel > v3_Name, boost::optional< IfcText > v4_Description, boost::optional< IfcLabel > v5_ObjectType, boost::optional< IfcLabel > v6_LongName) : IfcSystem((IfcAbstractEntityPtr)0) { IfcWritableEntity* e = new IfcWritableEntity(Class()); e->setArgument(0,(v1_GlobalId)); e->setArgument(1,(v2_OwnerHistory)); if (v3_Name) { e->setArgument(2,(*v3_Name)); } else { e->setArgument(2); } if (v4_Description) { e->setArgument(3,(*v4_Description)); } else { e->setArgument(3); } if (v5_ObjectType) { e->setArgument(4,(*v5_ObjectType)); } else { e->setArgument(4); } if (v6_LongName) { e->setArgument(5,(*v6_LongName)); } else { e->setArgument(5); } entity = e; EntityBuffer::Add(this); }

#endif